<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xander&#39;s Wiki</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xander.wiki/"/>
  <updated>2024-12-02T15:20:24.935Z</updated>
  <id>https://xander.wiki/</id>
  
  <author>
    <name>xander.liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0开始学习velox源码（二）</title>
    <link href="https://xander.wiki/2024/12/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0velox%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://xander.wiki/2024/12/02/从0开始学习velox源码（二）/</id>
    <published>2024-12-02T14:26:00.000Z</published>
    <updated>2024-12-02T15:20:24.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习velox orderby算子，其排序存在一个列转行的过程，其中行数据的表现形式是<code>RowContainer</code>。<br>本节主要描述<code>RowContainer</code>的layout和基础api。<br>笔者当前仅关注<code>SortBuffer</code>所需要关注的部分，对于<code>RowContainer</code>的其他部分（aggregate、join等），将在后续补充。</p><a id="more"></a><h1 id="RowContainer"><a href="#RowContainer" class="headerlink" title="RowContainer"></a>RowContainer</h1><p><code>RowContainer</code>是velox用于存储行数据的数据结构，当前用于<code>agg</code>、<code>hash join</code>、<code>orderby</code>三种场景。</p><p>相关源码位置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">velox/exec/RowContainer.h</span><br><span class="line">velox/exec/RowContainer.cpp</span><br></pre></td></tr></table></figure></p><h1 id="Ctor"><a href="#Ctor" class="headerlink" title="Ctor"></a>Ctor</h1><p>在<code>SortBuffer</code>中，<code>RowContainer</code>的构造函数调用如下：<br>也就是只需要传入<code>keyTypes</code>，<code>dependentTypes</code>，<code>pool</code>三个参数即可。<br>其中<code>keyTypes</code>是key列（用于排序的列）类型，<code>dependentTypes</code>是非排序列类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RowContainer(</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt;&amp; keyTypes,</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt;&amp; dependentTypes,</span><br><span class="line">      memory::MemoryPool* pool)</span><br><span class="line">      : RowContainer(</span><br><span class="line">            keyTypes,</span><br><span class="line">            <span class="literal">true</span>, <span class="comment">// nullableKeys，列数据是否支持null</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Accumulator&gt;&#123;&#125;,</span><br><span class="line">            dependentTypes,</span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// hasNext</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// isJoinBuild</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// hasProbedFlag</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// hasNormalizedKey</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// collectColumnStats</span></span><br><span class="line">            pool) &#123;&#125;</span><br></pre></td></tr></table></figure><p>精简版构造函数与所需要关注的数据结构如下(去除了<code>agg</code>、<code>hash join</code>相关的部分)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">RowContainer::RowContainer(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt;&amp; keyTypes,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt;&amp; dependentTypes,</span><br><span class="line">    memory::MemoryPool* pool)</span><br><span class="line">    : keyTypes_(keyTypes),</span><br><span class="line">      stringAllocator_(<span class="built_in">std</span>::make_unique&lt;HashStringAllocator&gt;(pool)),</span><br><span class="line">      rows_(pool) &#123;</span><br><span class="line">  <span class="keyword">int32_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int32_t</span> nullOffset = <span class="number">0</span>; <span class="comment">// bit维度</span></span><br><span class="line">  <span class="keyword">bool</span> isVariableWidth = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; type : keyTypes_) &#123; <span class="comment">// 排序列排在前面，对缓存友好</span></span><br><span class="line">    typeKinds_.push_back(type-&gt;kind());</span><br><span class="line">    types_.push_back(type);</span><br><span class="line">    offsets_.push_back(offset);</span><br><span class="line">    offset += typeKindSize(type-&gt;kind());</span><br><span class="line">    nullOffsets_.push_back(nullOffset); <span class="comment">// bit维度</span></span><br><span class="line">    isVariableWidth |= !type-&gt;isFixedWidth(); <span class="comment">// 当前行是否存在可变长字段</span></span><br><span class="line">    ++nullOffset;</span><br><span class="line">    columnHasNulls_.push_back(<span class="literal">false</span>); <span class="comment">// 某一列是否存在null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已记录完所有key列offset，修正offset，使其至少和一个指针大小相等</span></span><br><span class="line">  offset = <span class="built_in">std</span>::max&lt;<span class="keyword">int32_t</span>&gt;(offset, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int32_t</span> firstAggregateOffset = offset;<span class="comment">// 此offset紧贴key列最后一个数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; type : dependentTypes) &#123;</span><br><span class="line">    types_.push_back(type);</span><br><span class="line">    typeKinds_.push_back(type-&gt;kind());</span><br><span class="line">    nullOffsets_.push_back(nullOffset);</span><br><span class="line">    ++nullOffset;</span><br><span class="line">    isVariableWidth |= !type-&gt;isFixedWidth();</span><br><span class="line">    columnHasNulls_.push_back(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Free flag.</span></span><br><span class="line">  nullOffsets_.push_back(nullOffset); <span class="comment">// free flag offset，表示这一行是否已被删除</span></span><br><span class="line">  freeFlagOffset_ = nullOffset + firstAggregateOffset * <span class="number">8</span>; <span class="comment">// 修正为bit维度</span></span><br><span class="line">  ++nullOffset;</span><br><span class="line">  flagBytes_ = bits::nbytes(nullOffsets_.back() + <span class="number">1</span>); <span class="comment">// flag占据了多少个字节，对于orderby来说，就是(列数 + 1(free flag))/8向上取整</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; nullOffsets_.size(); ++i) &#123; <span class="comment">// 修正flag offset为bit维度</span></span><br><span class="line">    nullOffsets_[i] += firstAggregateOffset * <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  offset += flagBytes_; <span class="comment">// 将flag占据的字节加入offset，由此看出，flag贴在key列后面</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; type : dependentTypes) &#123; <span class="comment">// 追加dependent offset</span></span><br><span class="line">    offsets_.push_back(offset);</span><br><span class="line">    offset += typeKindSize(type-&gt;kind());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isVariableWidth) &#123; <span class="comment">// 若当前行中存在可变长字段</span></span><br><span class="line">    rowSizeOffset_ = offset; <span class="comment">// 当前行 定长数据offset</span></span><br><span class="line">    offset += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>); <span class="comment">// 大概是变长数据地址？</span></span><br><span class="line">  &#125;</span><br><span class="line">  fixedRowSize_ = bits::roundUp(offset, alignment_); <span class="comment">// 对齐之后的行长度， 默认按1对齐，最终将按此值申请行内存</span></span><br><span class="line">  <span class="keyword">if</span> (!nullOffsets_.empty()) &#123;</span><br><span class="line">    initialNulls_.resize(flagBytes_, <span class="number">0x0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; offsets_.size(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 将data offset和null offset绑定，编码为一个uint64_t, 用于快速访问</span></span><br><span class="line">    <span class="comment">// 其中高32位为data offset，低32位为null offset</span></span><br><span class="line">    rowColumns_.emplace_back( </span><br><span class="line">        offsets_[i],</span><br><span class="line">        (nullableKeys_ || i &gt;= keyTypes_.size()) ? nullOffsets_[i]</span><br><span class="line">                                                 : RowColumn::kNotNullOffset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><p>根据上述构造函数，用于<code>orderby</code>的<code>RowContainer</code>的layout大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[key1][key2]...[keyN][padding](if needed)[flag][dependent1][dependent2]...[dependentN][variable length data](if needed)</span><br></pre></td></tr></table></figure></p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>假设当前行结构如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key1: INT(4 bytes)</span><br><span class="line">dependent1: BIGINT(8 bytes)</span><br><span class="line">dependent2: SMALL(2 bytes)</span><br><span class="line">dependent3: REAL(4 bytes)</span><br><span class="line">dependent4: DOUBLE(8 bytes)</span><br><span class="line">dependent5: VARCHAR(16 bytes)</span><br></pre></td></tr></table></figure></p><p>则有offsets数组如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offsets_: [0, 9, 17, 19, 23, 31]</span><br><span class="line">nullOffsets_: [64, 65, 66, 67, 68, 69, 70]</span><br></pre></td></tr></table></figure></p><p>数据布局图大致如下：<br><img src="/images/RowContainer-memory-layout.jpg" alt="RowContainer-layout"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在学习velox orderby算子，其排序存在一个列转行的过程，其中行数据的表现形式是&lt;code&gt;RowContainer&lt;/code&gt;。&lt;br&gt;本节主要描述&lt;code&gt;RowContainer&lt;/code&gt;的layout和基础api。&lt;br&gt;笔者当前仅关注&lt;code&gt;SortBuffer&lt;/code&gt;所需要关注的部分，对于&lt;code&gt;RowContainer&lt;/code&gt;的其他部分（aggregate、join等），将在后续补充。&lt;/p&gt;
    
    </summary>
    
      <category term="velox" scheme="https://xander.wiki/categories/velox/"/>
    
    
      <category term="velox container" scheme="https://xander.wiki/tags/velox-container/"/>
    
      <category term="RowContainer" scheme="https://xander.wiki/tags/RowContainer/"/>
    
  </entry>
  
  <entry>
    <title>从0开始学习velox源码（一）</title>
    <link href="https://xander.wiki/2024/12/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0velox%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://xander.wiki/2024/12/02/从0开始学习velox源码（一）/</id>
    <published>2024-12-02T12:32:00.000Z</published>
    <updated>2024-12-02T15:19:02.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本系列是笔者学习velox源码的笔记，主要记录了我在学习velox源码时遇到的问题和解决方案。<br>本节是最基础也是最磨人的一节————搭建开发环境。</p><a id="more"></a><h1 id="git-clone-velox"><a href="#git-clone-velox" class="headerlink" title="git clone velox"></a>git clone velox</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:facebookincubator/velox.git</span><br></pre></td></tr></table></figure><p>本系列当前基于commit <code>ac5c15eb7627b42f8d41023215d1d4a7e69d45aa</code>。</p><h1 id="setup-macos-sh"><a href="#setup-macos-sh" class="headerlink" title="setup-macos.sh"></a>setup-macos.sh</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/setup-macos.sh</span><br></pre></td></tr></table></figure><p>执行该脚本会安装velox的依赖，包括<code>cmake</code>、<code>glog</code>、<code>gflags</code>、<code>fmt</code>、<code>folly</code>等。<br>笔者在安装时遇到了一些问题，解决方案可参考此isuue：<a href="https://github.com/facebookincubator/velox/issues/11701" target="_blank" rel="noopener">build issue</a></p><p>大致来看，分别是<code>ccache</code>安装失败和<code>folly</code>编译失败。</p><h1 id="use-clion-to-open-velox"><a href="#use-clion-to-open-velox" class="headerlink" title="use clion to open velox"></a>use clion to open velox</h1><p>本地ide使用的是<code>clion</code>，打开velox的根目录即可。<br>本地环境主要用于debug unit test, 因此cmake参数直接参考make unitest命令得到的cmake命令即可。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DTREAT_WARNINGS_AS_ERRORS=1 -DENABLE_ALL_WARNINGS=1 -DVELOX_BUILD_MINIMAL="OFF" -DVELOX_BUILD_TESTING="ON" -DCMAKE_BUILD_TYPE=Debug -GNinja -DMAX_LINK_JOBS= -DMAX_HIGH_MEM_JOBS= -DVELOX_FORCE_COLORED_OUTPUT=ON</span><br></pre></td></tr></table></figure><br>Build dir也参考make unitest命令得到的build dir，即<code>_build/debug</code>。<br>此外，还需要额外关注环境变量<code>INSTALL_PREFIX</code>，这将制定velox优先从下载的依赖项中查找库文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTALL_PREFIX=&#123;Your-velox-code-repo&#125;/deps-install</span><br></pre></td></tr></table></figure></p><p>cmake设置大致如图：<img src="/images/clion-velox-debug-env-cmake.png" alt="clion-velox-debug-env-cmake"></p><p>此后，愉快地debug即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本系列是笔者学习velox源码的笔记，主要记录了我在学习velox源码时遇到的问题和解决方案。&lt;br&gt;本节是最基础也是最磨人的一节————搭建开发环境。&lt;/p&gt;
    
    </summary>
    
      <category term="velox" scheme="https://xander.wiki/categories/velox/"/>
    
    
      <category term="velox debug" scheme="https://xander.wiki/tags/velox-debug/"/>
    
      <category term="环境搭建" scheme="https://xander.wiki/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>clang-tidy customized checker example</title>
    <link href="https://xander.wiki/2024/01/21/clang-tidy%20customized%20checker%20example/"/>
    <id>https://xander.wiki/2024/01/21/clang-tidy customized checker example/</id>
    <published>2024-01-21T03:04:00.000Z</published>
    <updated>2024-01-21T08:04:22.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本文给出了一个自定义clang-tidy checker的实例，并介绍了引入该实例的背景和原因，旨在帮助读者以此为蓝本快速开发own clang-tidy checker。<br>本文并不对clang-tidy的基本使用做过多介绍，不熟悉的读者可以阅读<a href="https://clang.llvm.org/extra/clang-tidy/" target="_blank" rel="noopener">官方文档</a>。<br>此外，本文同样可以视作对<a href="https://xander.wiki/2023/12/18/c++%20dev%20tools%20&amp;&amp;%20clang%20tools/#write-our-own-checkers">write our own checkers</a>的补充说明。</p><a id="more"></a><hr><h1 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在近期工作中，我们的c++研发偶遇了一个问题：common code在某些编译条件下匹配到了不符预期的函数重载，因而引入了较难排查的运行期错误。</p><p>具体而言，有demo code如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_WIDE_STRINGS</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> MyString;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MY_TEXT(str) L##str</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> MyString;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MY_TEXT(str) str</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdPartyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ThirdPartyClass(<span class="keyword">bool</span> value) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bool constructor called with value: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ThirdPartyClass(<span class="keyword">const</span> <span class="keyword">char</span> *value) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Const char* constructor called with value: "</span> &lt;&lt; value</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// should have a ctor with const wchar_t* parameter but not</span></span><br><span class="line">  <span class="comment">// ThirdPartyClass(const wchar_t *value) &#123;</span></span><br><span class="line">  <span class="comment">//   std::cout &lt;&lt; "const wchar_t* constructor called with value: " &lt;&lt; value &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thirdPartyFunction</span><span class="params">(<span class="keyword">bool</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bool function called with value: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thirdPartyFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Const char* function called with value: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// should have a function with const wchar_t* parameter but not</span></span><br><span class="line"><span class="comment">// void thirdPartyFunction(const wchar_t *value) &#123;</span></span><br><span class="line"><span class="comment">//   std::cout &lt;&lt; "const wchar_t* function called with value: " &lt;&lt; value &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ThirdPartyClass <span class="title">instance1</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="function">ThirdPartyClass <span class="title">instance2</span><span class="params">(<span class="string">"Hello, World"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  MyString str = MY_TEXT(<span class="string">"Hello, World"</span>);</span><br><span class="line">  <span class="function">ThirdPartyClass <span class="title">instance3</span><span class="params">(str.c_str())</span></span>; <span class="comment">// call ThirdPartyClass(bool value) when use wide strings</span></span><br><span class="line"></span><br><span class="line">  thirdPartyFunction(<span class="literal">true</span>);</span><br><span class="line">  thirdPartyFunction(<span class="string">"Hello, World"</span>);</span><br><span class="line">  thirdPartyFunction(str.c_str());<span class="comment">// call thirdPartyFunction(bool value) when use wide strings</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在上述代码中，我们使用了一个第三方库中的类<code>ThirdPartyClass</code>，该类有多个构造函数。<br>类似的，我们使用了一个第三方库中函数<code>thirdPartyFunction</code>，该函数有多个重载。   </p><p>除此之外，我们还定义了一个<code>MyString</code>类型，该类型在不同编译条件下分别是<code>std::string</code>和<code>std::wstring</code>的别名。  </p><p>我们预期，在使用<code>MyString str.c_str()</code>作为实参时，<code>ThirdPartyClass</code>的构造函数和<code>thirdPartyFunction</code>的函数<strong>总是</strong>调用形参是<code>const char*</code>的重载版本。<br>如果传入的是<code>const wchar_t*</code>，则<strong>应当抛出一个build error，以显式地提示开发当前需要对字符串执行编码转换</strong>。</p><p>遗憾的是，当我们使用<code>std::wstring</code>作为<code>MyString</code>并传入<code>c_str()</code>时，<strong><code>ThirdPartyClass</code>的构造函数和<code>thirdPartyFunction</code>的函数将会调用形参是<code>bool</code>的重载版本</strong>，原因很简单：任何指针类型都可以隐式转换为<code>bool</code>类型。<br>在没有任何重载版本匹配<code>const wchar_t*</code>的情况下，编译器会选择<code>bool</code>的重载版本，并且导致后续触发运行期错误（构造了错误的对象或者调用了错误的函数）。由于编译器往往认为这种转换是合理的，因此也不会有任何警告信息。</p><p>以下分别为使用<code>std::string</code>和<code>std::wstring</code>作为<code>MyString</code>时的运行输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> use std::string</span></span><br><span class="line">clang++ ./demo.cpp &amp;&amp; ./a.out </span><br><span class="line">Bool constructor called with value: 1</span><br><span class="line">Const char* constructor called with value: Hello, World</span><br><span class="line">Const char* constructor called with value: Hello, World # meet our expectation</span><br><span class="line">Bool function called with value: 1</span><br><span class="line">Const char* function called with value: Hello, World</span><br><span class="line">Const char* function called with value: Hello, World # meet our expectation</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> use std::wstring</span></span><br><span class="line">clang++ ./demo.cpp -DUSE_WIDE_STRINGS &amp;&amp; ./a.out</span><br><span class="line">Bool constructor called with value: 1</span><br><span class="line">Const char* constructor called with value: Hello, World</span><br><span class="line">Bool constructor called with value: 1 # unexpected, with no warning</span><br><span class="line">Bool function called with value: 1</span><br><span class="line">Const char* function called with value: Hello, World</span><br><span class="line">Bool function called with value: 1 # unexpected, with no warning</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们可以通过 <code>加强培训</code> + <code>code review</code> + <code>高覆盖度单元测试</code> 来避免这种问题，但以上方式需要付出巨大的成本和心智负担。<br>因此，我们希望简单轻松地解决此问题，至少我们期待可以<strong>将错误从运行期提前到编译期</strong>。</p><p>以下为一些可能的解决方案：</p><ol><li>修改第三方库<br>针对这个case，我们可以考虑修改第三方库，为<code>ThirdPartyClass</code>添加一个<code>const wchar_t*</code>的构造函数，为<code>thirdPartyFunction</code>添加一个<code>const wchar_t*</code>的重载版本。<br>如此，当我们使用<code>std::wstring</code>作为<code>MyString</code>时，编译器将会选择形参为<code>const wchar_t*</code>的最优重载，从而避免运行期错误。</li><li>自定义clang-tidy checker<br>我们可以考虑自定义一个clang-tidy checker，用于检查所有<strong>存在<code>const wchar_t*</code>在函数调用或对象构造过程中转为<code>bool</code>的场景</strong>，并且在检测到相关场景后抛出build warning（或者更进一步地，视作build error）。</li></ol><p>方案1的优点无需赘述，但其缺点也显而易见：</p><ul><li>大多数场景下，第三方库无法直接修改</li><li>后续引入新的第三方库时，需要重复这个过程以避免再次出现类似问题</li></ul><p>因此本文将关注于更加通用化的方案2，即使用自定义clang-tidy checker。</p><hr><h1 id="自定义clang-tidy-checker"><a href="#自定义clang-tidy-checker" class="headerlink" title="自定义clang-tidy checker"></a>自定义clang-tidy checker</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><a href="https://clang.llvm.org/extra/clang-tidy/Contributing.html" target="_blank" rel="noopener">clang-tidy-extra</a><br><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html" target="_blank" rel="noopener">AST Matchers</a></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>clang-tidy新增checker有2种方式</p><ol><li>新建checkers，并将其编译成动态链接库，然后通过令clang-tidy以<code>-load</code>参数加载plugin</li><li>新建checkers，并将checkers编译进clang-tidy二进制文件中</li></ol><p>方案1也就是所谓的<code>Out-of-tree check plugins</code>。<br>显然，相较于方案2需要rebuild clang-tidy，方案1更加灵活。<br>此外，由于中文互联网社区对方案1的描述较少，因此本文将仅关注方案1，并给出方案1的demo级具体实现。<br>方案2可参考<a href="https://zhuanlan.zhihu.com/p/518339529" target="_blank" rel="noopener">为clang-tidy添加自定义check</a>。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 目录结构</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── WCharToBoolConversionCheck.cpp</span><br><span class="line">├── WCharToBoolConversionCheck.h</span><br><span class="line">└── build_and_test.sh # for test</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(WCharToBoolConversionCheckPlugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(LLVM REQUIRED CONFIG)</span><br><span class="line"><span class="keyword">find_package</span>(Clang REQUIRED CONFIG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CLANG_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;LLVM_DEFINITIONS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(WCharToBoolConversionCheck SHARED WCharToBoolConversionCheck.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(WCharToBoolConversionCheck PRIVATE clangASTMatchers clangTidy)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WCharToBoolConversionCheck.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WCHAR_TO_BOOL_CONVERSION_CHECK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WCHAR_TO_BOOL_CONVERSION_CHECK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidyCheck.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> clang &#123;</span><br><span class="line"><span class="keyword">namespace</span> tidy &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WCharToBoolConversionCheck</span> :</span> <span class="keyword">public</span> ClangTidyCheck &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  WCharToBoolConversionCheck(StringRef Name, ClangTidyContext *Context)</span><br><span class="line">      : ClangTidyCheck(Name, Context) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerMatchers</span><span class="params">(ast_matchers::MatchFinder *Finder)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> ast_matchers::MatchFinder::MatchResult &amp;Result)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace tidy</span></span><br><span class="line">&#125; <span class="comment">// namespace clang</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WCharToBoolConversionCheck.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidy.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidyCheck.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidyModule.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidyModuleRegistry.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> clang &#123;</span><br><span class="line"><span class="keyword">namespace</span> tidy &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WCharToBoolConversionCheck</span> :</span> <span class="keyword">public</span> ClangTidyCheck &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  WCharToBoolConversionCheck(StringRef Name, ClangTidyContext *Context)</span><br><span class="line">      : ClangTidyCheck(Name, Context) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerMatchers</span><span class="params">(ast_matchers::MatchFinder *Finder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> clang::ast_matchers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Match function calls and constructor calls with a boolean parameter.</span></span><br><span class="line">    Finder-&gt;addMatcher(</span><br><span class="line">        callExpr(forEachArgumentWithParam(expr().bind(<span class="string">"arg"</span>),</span><br><span class="line">                                          parmVarDecl(hasType(booleanType()))))</span><br><span class="line">            .bind(<span class="string">"call"</span>),</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Finder-&gt;addMatcher(</span><br><span class="line">        cxxConstructExpr(</span><br><span class="line">            forEachArgumentWithParam(expr().bind(<span class="string">"arg"</span>),</span><br><span class="line">                                     parmVarDecl(hasType(booleanType()))))</span><br><span class="line">            .bind(<span class="string">"construct"</span>),</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> ast_matchers::MatchFinder::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> *ArgExpr = Result.Nodes.getNodeAs&lt;Expr&gt;(<span class="string">"arg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ArgExpr) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QualType ArgType = ArgExpr-&gt;getType().getCanonicalType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *PT = dyn_cast&lt;PointerType&gt;(ArgType)) &#123;</span><br><span class="line">      QualType PointeeType = PT-&gt;getPointeeType().getCanonicalType();</span><br><span class="line">      <span class="comment">// If the pointee type is wchar_t || const wchar_t, emit a warning.</span></span><br><span class="line">      <span class="keyword">if</span> (PointeeType-&gt;isWideCharType() ||</span><br><span class="line">          (PointeeType.isConstQualified() &amp;&amp;</span><br><span class="line">           PointeeType.getUnqualifiedType()-&gt;isWideCharType())) &#123;</span><br><span class="line">        diag(ArgExpr-&gt;getBeginLoc(),</span><br><span class="line">             <span class="string">"passing 'wchar_t*' to a boolean parameter, which may lead to "</span></span><br><span class="line">             <span class="string">"unexpected behavior"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WCharToBoolConversionModule</span> :</span> <span class="keyword">public</span> ClangTidyModule &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addCheckFactories</span><span class="params">(ClangTidyCheckFactories &amp;CheckFactories)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    CheckFactories.registerCheck&lt;WCharToBoolConversionCheck&gt;(</span><br><span class="line">        <span class="string">"wchar-to-bool-conversion-check"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> ClangTidyModuleRegistry::Add&lt;WCharToBoolConversionModule&gt;</span><br><span class="line">    X(<span class="string">"wchar-to-bool-conversion-module"</span>,</span><br><span class="line">      <span class="string">"Adds checks for wchar_t* to bool conversions."</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace tidy</span></span><br><span class="line">&#125; <span class="comment">// namespace clang</span></span><br></pre></td></tr></table></figure><hr><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><h2 id="test-script"><a href="#test-script" class="headerlink" title="test script"></a>test script</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> build_and_test.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -eu</span><br><span class="line"></span><br><span class="line">SCRIPT_DIR=$(cd "$(dirname "$&#123;BASH_SOURCE[0]&#125;")" &amp;&gt;/dev/null &amp;&amp; pwd)</span><br><span class="line">BUILD_DIR="$SCRIPT_DIR/build"</span><br><span class="line"></span><br><span class="line">rm -rf "$&#123;BUILD_DIR&#125;"</span><br><span class="line">mkdir "$&#123;BUILD_DIR&#125;"</span><br><span class="line">cd "$&#123;BUILD_DIR&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> build checker plugin</span></span><br><span class="line"></span><br><span class="line">cmake "$SCRIPT_DIR"</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">cd "$SCRIPT_DIR"</span><br><span class="line"></span><br><span class="line">LIB_FILE="$BUILD_DIR/libWCharToBoolConversionCheck.dylib"</span><br><span class="line">DEMO_FILE="$SCRIPT_DIR/demo.cpp"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> start <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">echo "clang-tidy demo.cpp use std::string"</span><br><span class="line">clang-tidy --checks='-*,wchar-to-bool-conversion-check' -load "$LIB_FILE" "$DEMO_FILE" -- </span><br><span class="line"></span><br><span class="line">echo "clang-tidy demo.cpp use std::wstring"</span><br><span class="line">clang-tidy --checks='-*,wchar-to-bool-conversion-check' -load "$LIB_FILE" "$DEMO_FILE" -- -DUSE_WIDE_STRINGS</span><br></pre></td></tr></table></figure><h2 id="test-result"><a href="#test-result" class="headerlink" title="test result"></a>test result</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./build_and_test.sh</span></span><br><span class="line">clang-tidy demo.cpp use std::string # no warning</span><br><span class="line">clang-tidy demo.cpp use std::wstring # report 2 warnings</span><br><span class="line">2 warnings generated.</span><br><span class="line">/Users/XanderLiu/myclang/demo.cpp:55:29: warning: passing 'wchar_t*' to a boolean parameter, which may lead to unexpected behavior [wchar-to-bool-conversion-check]</span><br><span class="line">   55 |   ThirdPartyClass instance3(str.c_str());</span><br><span class="line">      |                             ^</span><br><span class="line">/Users/XanderLiu/myclang/demo.cpp:59:22: warning: passing 'wchar_t*' to a boolean parameter, which may lead to unexpected behavior [wchar-to-bool-conversion-check]</span><br><span class="line">   59 |   thirdPartyFunction(str.c_str());</span><br><span class="line">      |                      ^</span><br></pre></td></tr></table></figure><hr><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>Target: arm64-apple-darwin22.6.0<br>Homebrew clang version: 17.0.5<br>cmake version: 3.27.0  </p><h2 id="src获取与运行"><a href="#src获取与运行" class="headerlink" title="src获取与运行"></a>src获取与运行</h2><ol><li>installed llvm &amp;&amp; clang</li><li>git clone git@github.com:zsmj2017/ClangTidyCustomizedCheckersExample.git</li><li>cd ClangTidyCustomizedCheckersExample</li><li>run ./build_and_test.sh or write your own test script</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;本文给出了一个自定义clang-tidy checker的实例，并介绍了引入该实例的背景和原因，旨在帮助读者以此为蓝本快速开发own clang-tidy checker。&lt;br&gt;本文并不对clang-tidy的基本使用做过多介绍，不熟悉的读者可以阅读&lt;a href=&quot;https://clang.llvm.org/extra/clang-tidy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;。&lt;br&gt;此外，本文同样可以视作对&lt;a href=&quot;https://xander.wiki/2023/12/18/c++%20dev%20tools%20&amp;amp;&amp;amp;%20clang%20tools/#write-our-own-checkers&quot;&gt;write our own checkers&lt;/a&gt;的补充说明。&lt;/p&gt;
    
    </summary>
    
      <category term="杂项" scheme="https://xander.wiki/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="tools" scheme="https://xander.wiki/tags/tools/"/>
    
      <category term="clang" scheme="https://xander.wiki/tags/clang/"/>
    
  </entry>
  
  <entry>
    <title>cpp dev tools &amp;&amp; clang tools</title>
    <link href="https://xander.wiki/2023/12/18/c++%20dev%20tools%20&amp;&amp;%20clang%20tools/"/>
    <id>https://xander.wiki/2023/12/18/c++ dev tools &amp;&amp; clang tools/</id>
    <published>2023-12-18T10:07:00.000Z</published>
    <updated>2024-01-20T19:25:42.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><ol><li>C++ dev tools</li><li>clang tools</li></ol><a id="more"></a><hr><h1 id="C-dev-tools"><a href="#C-dev-tools" class="headerlink" title="C++ dev tools"></a>C++ dev tools</h1><h2 id="why-we-need-tools"><a href="#why-we-need-tools" class="headerlink" title="why we need tools"></a>why we need tools</h2><p>C makes it easy to shoot yourself in the foot;<br>C++ makes it harder, but when you do it blows your whole leg off.                             </p><p align="right">-- Bjarne Stroustrup</p>                 <p>C++ is a powerful language, but it is also a complex language, so it is easy to import bad smell code into cur project.<br>We can keep our code high quality by code review, but it is not efficient and not enough.<br>CR is a human work, it cost too many time and energy to find some simple or hide bugs.<br>So we need some tools to help us to find the simple bugs automatically and bring our attention to the important &amp;&amp; interesting things.</p><h3 id="what-is-good-code"><a href="#what-is-good-code" class="headerlink" title="what is good code"></a>what is good code</h3><ul><li>easy to read</li><li>easy to maintain</li><li>easy to use</li><li>work as expected</li><li>work fast</li></ul><h2 id="tools-help-us-write-good-code"><a href="#tools-help-us-write-good-code" class="headerlink" title="tools help us write good code"></a>tools help us write good code</h2><ol><li>formatter</li><li>code generator</li><li>code analyzer</li><li>code refactor tools</li><li>test framework</li><li>benchmark (test) framework</li></ol><hr><h3 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h3><h4 id="why-we-need-formatter"><a href="#why-we-need-formatter" class="headerlink" title="why we need formatter"></a>why we need formatter</h4><ul><li>ensure consistent code style accross the code data base</li><li>reduce time on code style discussions</li><li>keep CR reviewer focus on logic</li><li>automatically format code to save time</li></ul><h4 id="when-we-format-code"><a href="#when-we-format-code" class="headerlink" title="when we format code"></a>when we format code</h4><ul><li>save file</li><li>pre-commit hook</li><li>CI</li></ul><h4 id="formatter-tools-list"><a href="#formatter-tools-list" class="headerlink" title="formatter tools list"></a>formatter tools list</h4><ul><li>clang-format</li><li>astyle</li><li>…</li></ul><hr><h3 id="code-generator"><a href="#code-generator" class="headerlink" title="code generator"></a>code generator</h3><h4 id="why-we-need-code-generator"><a href="#why-we-need-code-generator" class="headerlink" title="why we need code generator"></a>why we need code generator</h4><ul><li>reduce time on boring work</li><li>keep code style guidelines</li><li>use common design patterns</li><li>avoid human error</li></ul><h4 id="when-we-use-code-generator"><a href="#when-we-use-code-generator" class="headerlink" title="when we use code generator"></a>when we use code generator</h4><ul><li>generate implementation codesnippet from a interface</li><li>generate ctor &amp;&amp; dtor &amp;&amp; copy ctor &amp;&amp; move ctor &amp;&amp; copy assignment &amp;&amp; move assignment </li><li>generate getter &amp;&amp; setter member function</li><li>generate implementation codesnippet from a proto</li><li>…</li></ul><h4 id="code-generator-tools-list"><a href="#code-generator-tools-list" class="headerlink" title="code generator tools list"></a>code generator tools list</h4><ul><li>IDES(Visual Studio, CLion, …)</li><li>protoc</li><li>…</li></ul><hr><h3 id="code-analyzer"><a href="#code-analyzer" class="headerlink" title="code analyzer"></a>code analyzer</h3><h4 id="why-we-need-code-analyzer-linter"><a href="#why-we-need-code-analyzer-linter" class="headerlink" title="why we need code analyzer (linter)"></a>why we need code analyzer (linter)</h4><ul><li>find undefined behavior &amp;&amp; potential bugs automatically</li><li>find bad smell code automatically</li><li>keep code style guidelines (modernize, readability, performance, …)</li><li>…</li></ul><h4 id="static-analyzer"><a href="#static-analyzer" class="headerlink" title="static analyzer"></a>static analyzer</h4><ul><li>Build warnings</li><li>Other tools<ul><li>clang-tidy</li><li>coverity</li><li>cppcheck</li><li>…</li></ul></li></ul><h4 id="dynamic-analyzer"><a href="#dynamic-analyzer" class="headerlink" title="dynamic analyzer"></a>dynamic analyzer</h4><ul><li>valgrind</li><li>address sanitizer</li><li>…</li></ul><hr><h3 id="code-refactor-tools"><a href="#code-refactor-tools" class="headerlink" title="code refactor tools"></a>code refactor tools</h3><h4 id="what-is-refactor"><a href="#what-is-refactor" class="headerlink" title="what is refactor"></a>what is refactor</h4><ul><li>Basic set<ul><li>rename</li><li>extract function</li><li>…</li></ul></li><li>Profound set<ul><li>change function signature</li><li>push/pull data member up/down in class hierarchy</li><li>modernize</li><li>…</li></ul></li></ul><h4 id="why-we-need-refactor-tools"><a href="#why-we-need-refactor-tools" class="headerlink" title="why we need refactor tools"></a>why we need refactor tools</h4><p>Maybe you will say, we can do refactor by hand or use regex, why we need tools to do it?</p><p>Just think about rename:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example for confusing names</span></span><br><span class="line">Struct stat stat; <span class="comment">// stat is a struct name, but also a variable name</span></span><br><span class="line">stat(<span class="string">"file"</span>, &amp;stat); <span class="comment">// stat is a function name</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, stat.<span class="built_in">size</span>);</span><br></pre></td></tr></table></figure><p>If we want to rename struct name ‘stat’ to ‘Mystat’, how can we do it?<br>We can use refactor tools such like clang-rename to do it, thanks clangParse, clangSema, clangAST and many other tools did the hard work.</p><h4 id="code-refactor-tools-list"><a href="#code-refactor-tools-list" class="headerlink" title="code refactor tools list"></a>code refactor tools list</h4><ul><li>IDES(Visual Studio, CLion, …)</li><li>clangRefactor</li><li>clangMR(MapReduce)</li><li>…</li></ul><hr><h3 id="test-framework"><a href="#test-framework" class="headerlink" title="test framework"></a>test framework</h3><p>Every one know test is important, so I will not talk about why we need test.</p><h4 id="test-framework-list"><a href="#test-framework-list" class="headerlink" title="test framework list"></a>test framework list</h4><ul><li>Google Test</li><li>Boost.Test</li><li>…</li></ul><hr><h3 id="benchmark-test-framework"><a href="#benchmark-test-framework" class="headerlink" title="benchmark (test) framework"></a>benchmark (test) framework</h3><h4 id="what-is-benchmark"><a href="#what-is-benchmark" class="headerlink" title="what is benchmark"></a>what is benchmark</h4><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h5><p>For example, we want to compare the performance of two implements.<br>First one use <code>std::unordered_map</code> to store the data, and second one use <code>std::map</code> to store the data.<br>We know <code>std::unordered_map</code> is faster than <code>std::map</code>, but we don’t know how much find faster when we use them store 10000 int and with a O2 optimization.<br>So we write benchmark code to compare them.  </p><p><a href="https://quick-bench.com/q/JMw0rZ4-Ucaytj2j0uduX8kAHbA" target="_blank" rel="noopener">benchmark_result</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomNumber</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="title">dis</span><span class="params">(<span class="number">1</span>, <span class="number">1000000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dis(gen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for std::unordered_map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_UnorderedMap_Read</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">unordered_map</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = RandomNumber();</span><br><span class="line">        <span class="built_in">unordered_map</span>[num] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            benchmark::DoNotOptimize(<span class="built_in">unordered_map</span>.<span class="built_in">find</span>(RandomNumber()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_UnorderedMap_Read);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for std::map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_Map_Read</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = RandomNumber();</span><br><span class="line">        <span class="built_in">map</span>[num] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            benchmark::DoNotOptimize(<span class="built_in">map</span>.<span class="built_in">find</span>(RandomNumber()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_Map_Read);</span><br><span class="line"></span><br><span class="line">BENCHMARK_MAIN();</span><br></pre></td></tr></table></figure><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h5><p>We want to use <code>std::string_view</code> instead of <code>const std::string&amp;</code> to pass string parameter to a function.<br>But how much performance improvement we can get?<br>Suppose we use both const char* and std::string to pass a string parameter to a function.<br>We write benchmark code to compare them.  </p><p><a href="https://quick-bench.com/q/qoswOAQLY-J5ve2dgwHYNDM_HO8" target="_blank" rel="noopener">benchmark_result</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function that generates random strings</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GenerateRandomString</span><span class="params">(<span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> chars = <span class="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">    <span class="built_in">std</span>::random_device random_device;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">generator</span><span class="params">(random_device())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="title">distribution</span><span class="params">(<span class="number">0</span>, chars.<span class="built_in">size</span>() - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> random_string;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        random_string += chars[distribution(generator)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random_string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function that takes std::string_view</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FunctionWithStringView</span><span class="params">(<span class="built_in">std</span>::string_view str)</span> </span>&#123;</span><br><span class="line">    benchmark::DoNotOptimize(str.data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function that takes const std::string&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FunctionWithStringRef</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">    benchmark::DoNotOptimize(str.data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for std::string_view with const char*</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_StringViewWithChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = GenerateRandomString(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        FunctionWithStringView(cstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_StringViewWithChar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for const std::string&amp; with const char*</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_StringRefWithChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = GenerateRandomString(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        FunctionWithStringRef(cstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_StringRefWithChar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for std::string_view with std::string</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_StringViewWithString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = GenerateRandomString(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        FunctionWithStringView(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_StringViewWithString);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for const std::string&amp; with std::string</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_StringRefWithString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = GenerateRandomString(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        FunctionWithStringRef(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_StringRefWithString);</span><br><span class="line"></span><br><span class="line">BENCHMARK_MAIN();</span><br></pre></td></tr></table></figure><h4 id="why-we-need-benchmark"><a href="#why-we-need-benchmark" class="headerlink" title="why we need benchmark"></a>why we need benchmark</h4><ul><li>performance compare: compare the performance of algorithms || data structures || implementations</li><li>performance optimization: identify the bottleneck</li><li>performance regression: ensure the performance is not worse than before</li></ul><h4 id="benchmark-framework-tools"><a href="#benchmark-framework-tools" class="headerlink" title="benchmark framework tools"></a>benchmark framework tools</h4><ul><li>Google Benchmark</li><li>Boost.Test</li><li><a href="https://quick-bench.com/" target="_blank" rel="noopener">https://quick-bench.com/</a></li><li>…</li></ul><hr><h1 id="clang-tools"><a href="#clang-tools" class="headerlink" title="clang tools"></a>clang tools</h1><h2 id="clang-family"><a href="#clang-family" class="headerlink" title="clang family"></a>clang family</h2><ul><li>clang: C, C++, Objective-C and Objective-C++ compiler</li><li>clang-format: code formatter</li><li>clang-tidy: code analyzer &amp;&amp; code refactor tools</li><li>clang-refactor: code refactor tools</li><li>clangd: language server, support code completion, go to definition, find references, rename, …</li><li>…</li></ul><h2 id="precondition-when-we-use-clang-tools"><a href="#precondition-when-we-use-clang-tools" class="headerlink" title="precondition when we use clang tools"></a>precondition when we use clang tools</h2><p>Compile your source code with clang, make sure they can be compiled successfully to a object file.<br>And then we can use clang tools to analyze &amp;&amp; refactor our code.<br>Plz take care: only need compile with clang :-), no need to use or deploy the outputs.</p><h2 id="what-can-we-do-with-clang-tools"><a href="#what-can-we-do-with-clang-tools" class="headerlink" title="what can we do with clang tools"></a>what can we do with clang tools</h2><h3 id="write-our-own-checkers"><a href="#write-our-own-checkers" class="headerlink" title="write our own checkers"></a>write our own checkers</h3><p>For example, our code data base was fulled with some bad smell code, but they can pass all the clang-tidy checkers and compiled successfully without any warnings.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slowloop.cc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = GetSomeData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// If compiler dont optimize strlen(str) to a const value, this loop will run as O(n^2)</span></span><br><span class="line"><span class="comment">// But dont generate any warnings</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can use clang-AST to make sure what happened when clang compile this code.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -Xclang -ast-dump -fsyntax-only slowloop.cc</span><br></pre></td></tr></table></figure><br>And We can get a output AST such like this:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|   `-ForStmt <span class="number">0x9759b40</span> &lt;<span class="built_in">line</span>:<span class="number">6</span>:<span class="number">3</span>, <span class="built_in">line</span>:<span class="number">8</span>:<span class="number">3</span>&gt;                                                                           <span class="comment">// for(</span></span><br><span class="line">|     |-DeclStmt <span class="number">0x97599a8</span> &lt;<span class="built_in">line</span>:<span class="number">6</span>:<span class="number">8</span>, col:<span class="number">24</span>&gt;</span><br><span class="line">|     | `-VarDecl 0x9759930 &lt;col:8, col:23&gt; col:15 used index 'size_t':'unsigned int' cinit                            // size_t index = 0;</span><br><span class="line">|     |   `-ImplicitCastExpr 0x9759998 &lt;col:23&gt; 'size_t':'unsigned int' &lt;IntegralCast&gt;</span><br><span class="line">|     |     `-IntegerLiteral 0x9759970 &lt;col:23&gt; 'int' 0</span><br><span class="line">|     |-&lt;&lt;&lt;<span class="literal">NULL</span>&gt;&gt;&gt;                                                                                                     <span class="comment">// i &lt; strlen(str);</span></span><br><span class="line">|     |-BinaryOperator 0x9759ae8 &lt;col:26, col:44&gt; 'bool' '&lt;'</span><br><span class="line">|     | |-ImplicitCastExpr 0x9759ad8 &lt;col:26&gt; 'size_t':'unsigned int' &lt;LValueToRValue&gt;</span><br><span class="line">|     | | `-DeclRefExpr 0x97599c0 &lt;col:26&gt; 'size_t':'unsigned int' lvalue Var 0x9759930 'index' 'size_t':'unsigned int'</span><br><span class="line">|     | `-CallExpr 0x9759aa8 &lt;col:34, col:44&gt; 'size_t':'unsigned int'</span><br><span class="line">|     |   |-ImplicitCastExpr 0x9759a98 &lt;col:34&gt; 'size_t (*)(const char *) __attribute__((cdecl))' &lt;FunctionToPointerDecay&gt;</span><br><span class="line">|     |   | `-DeclRefExpr 0x9759a38 &lt;col:34&gt; 'size_t (const char *) __attribute__((cdecl))':'size_t (const char *)' lvalue Function 0x92edfb8 'strlen' 'size_t (const char *) __attribute__((cdecl))':'size_t (const char *)'</span><br><span class="line">|     |   `-ImplicitCastExpr 0x9759ac8 &lt;col:41&gt; 'const char *' &lt;LValueToRValue&gt;</span><br><span class="line">|     |     `-DeclRefExpr 0x9759a18 &lt;col:41&gt; 'const char *' lvalue Var 0x9759890 'str' 'const char *'</span><br><span class="line">|     |-UnaryOperator 0x9759b20 &lt;col:47, col:49&gt; 'size_t':'unsigned int' lvalue prefix '++'                             // ++i</span><br><span class="line">|     | `-DeclRefExpr 0x9759b00 &lt;col:49&gt; 'size_t':'unsigned int' lvalue Var 0x9759930 'index' 'size_t':'unsigned int'</span><br><span class="line">|     `-CompoundStmt <span class="number">0x9759b30</span> &lt;col:<span class="number">56</span>, <span class="built_in">line</span>:<span class="number">8</span>:<span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure><br>Finally, we can write our own checkers(patterns) to find this kind of bad smell code.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forStmt(hasCondition(hasDescendant(callExpr(callee(functionDecl(hasName(<span class="string">"strlen"</span>)))))))</span><br></pre></td></tr></table></figure></p><p>For more info, u can see </p><ul><li><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html" target="_blank" rel="noopener">LibASTMatchersReference</a></li><li><a href="https://llvm.org/devmtg/2020-09/slides/Clang-tidy_for_Customized_Checkers_and_Large_Scale.pdf" target="_blank" rel="noopener">Clang-tidy CustomizedCheckers</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;abstract&quot;&gt;&lt;a href=&quot;#abstract&quot; class=&quot;headerlink&quot; title=&quot;abstract&quot;&gt;&lt;/a&gt;abstract&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;C++ dev tools&lt;/li&gt;
&lt;li&gt;clang tools&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="杂项" scheme="https://xander.wiki/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="tools" scheme="https://xander.wiki/tags/tools/"/>
    
      <category term="clang" scheme="https://xander.wiki/tags/clang/"/>
    
  </entry>
  
  <entry>
    <title>C++模板元编程入门</title>
    <link href="https://xander.wiki/2022/08/05/C++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://xander.wiki/2022/08/05/C++模板元编程入门/</id>
    <published>2022-08-05T02:41:00.000Z</published>
    <updated>2024-01-21T07:40:22.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本文只是针对TMP(Template Metaprogramming)的简单说明，并不涉及模板元编程中的各种黑魔法诸如编译期堆排序，实现反射特性等等。<br>旨在对TMP做一个入门科普，以及简单介绍TMP在实际业务中存在哪些应用。</p><a id="more"></a><hr><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>&nbsp;<br>C++模板特化，偏特化的一些匹配原则。（参考C++ Primer相关章节即可）<br>C++模板类型推导的基本原理，以及模板类型推导的一些常见问题。<br>具体可见<a href="https://xander.wiki/2018/06/20/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%A1%8D/">Effective Modern C++ Item1</a>。</p><hr><h1 id="模板元编程的基本概念"><a href="#模板元编程的基本概念" class="headerlink" title="模板元编程的基本概念"></a>模板元编程的基本概念</h1><p>&nbsp;<br>顾名思义，模板元编程就是用模板来实现元编程，它工作于<strong>编译期</strong>，而非运行期。<br>开发者尝试使用模板实例化的一些特性和约束来完成一些计算任务，或者实现一些在运行期很难完成的功能。</p><h2 id="TMP的简单应用（编译期求值）"><a href="#TMP的简单应用（编译期求值）" class="headerlink" title="TMP的简单应用（编译期求值）"></a>TMP的简单应用（编译期求值）</h2><h3 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h3><p>abs相当于是TMP内的”hello,world”, 我们通过它来了解最基础的模板元编程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt; <span class="comment">// use template parameter as a function parameter</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_abs</span>&#123;</span></span><br><span class="line">    <span class="keyword">static_assert</span>(N != INT_MIN, <span class="string">"N must not be INT_MIN"</span>);</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = N &lt; <span class="number">0</span> ? -N : N; <span class="comment">// use static data member as return value</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_my_abs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;<span class="number">-1</span>&gt;::value == <span class="number">1</span>, <span class="string">"my_abs&lt;-1&gt;::value == 1"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;<span class="number">1</span>&gt;::value == <span class="number">1</span>, <span class="string">"my_abs&lt;1&gt;::value == 1"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;<span class="number">0</span>&gt;::value == <span class="number">0</span>, <span class="string">"my_abs&lt;0&gt;::value == 0"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;<span class="number">-6</span>&gt;::value == <span class="number">6</span>, <span class="string">"my_abs&lt;-6&gt;::value == 6"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;INT_MAX&gt;::value == INT_MAX, <span class="string">"my_abs&lt;INT_MAX&gt;::value == INT_MAX"</span>);</span><br><span class="line">    <span class="comment">// cannot compile</span></span><br><span class="line">    <span class="comment">// static_assert(my_abs&lt;INT_MIN&gt;::value == -INT_MIN, "my_abs&lt;INT_MIN&gt;::value == -INT_MIN");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fibonacci"><a href="#fibonacci" class="headerlink" title="fibonacci"></a>fibonacci</h3><p>为了展现tmp并非只能完成简单计算求值，有fibonacci的TMP递归实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span> &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;0&gt; &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;1&gt; &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bad impl!!!</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Fibonacci&lt;45&gt;::value = "</span> &lt;&lt; Fibonacci&lt;<span class="number">45</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// calculates fibonacci(45) at compile time</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"fibonacci(45) = "</span> &lt;&lt; fibonacci(<span class="number">45</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// cost too much run time</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Fibonacci&lt;10000&gt;::value = "</span> &lt;&lt; Fibonacci&lt;<span class="number">10000</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过编译期递归并不能为所欲为，其递归深度取决于编译器允许的模板实例化的最大深度，不过可以通过<code>-ftemplate-depth=N</code>进行调整。<br>（constexpr函数同样存在编译期递归深度限制问题）</p><hr><h2 id="TMP的简单应用（操作类型）"><a href="#TMP的简单应用（操作类型）" class="headerlink" title="TMP的简单应用（操作类型）"></a>TMP的简单应用（操作类型）</h2><p>到目前为止，给出的2个示例并不能真正体现TMP的优势，毕竟我们完全可以用constexpr函数取代abs&lt;&gt;和fibonacci&lt;&gt;。 TMP的优势在于，它的参数可以是一个类型，而非一个值。实际上，c++内早就有这种函数，例如sizeof。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">4</span>, <span class="string">"int is not 4 bytes"</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span> ll == <span class="number">8</span>, <span class="string">"long long is not 8 bytes"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) == <span class="number">8</span>, <span class="string">"long long is not 8 bytes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入类型，输出值"><a href="#输入类型，输出值" class="headerlink" title="输入类型，输出值"></a>输入类型，输出值</h3><p>假设存在一个场景，我们需要根据指定类型返回一个值，例如根据指定类型，返回该类型的最大值或者最小值(也就是<code>std::numeric_limits</code>)。 那么可以有简单实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">max_value</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">max_value</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = INT_MAX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">max_value</span>&lt;long&gt; &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">long</span> value = LONG_MAX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MY_CLASS</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max_value&lt;<span class="keyword">int</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max_value&lt;<span class="keyword">long</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// cannot compile</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; Max_value&lt;MY_CLASS&gt;::value &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，对于已经完成特化的部分类型，max_value运行地很好，但对于其他类型，将会直接导致编译报错。<br>这种技法被称之为SFINAE（Substitution Failure Is Not An Error）。SFINAE是元编程基础组件<code>std::enable_if</code>的重要基础，后续会继续提到。</p><h3 id="输入类型，输出类型"><a href="#输入类型，输出类型" class="headerlink" title="输入类型，输出类型"></a>输入类型，输出类型</h3><p>也许我们不应该仅仅将目光停留在输出数值上，更进一步地，TMP可以输出一个类型，而不仅仅是数值。</p><h4 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h4><p>模板函数可以根据输入类型的一些特性，返回特定类型。在某些场景下这种名叫type traits的技法非常有用，例如stl中的大部分泛型算法都基于这种技法。</p><h5 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h5><p>举一个最简单的例子，让某个迭代器移动指定的步长, <code>advance</code>函数声明大致类似于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">  ... <span class="comment">// impl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>众所周知，stl内各容器的迭代器均为具体的类型，并且具备不同的特性，以vector举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">simpleAlloc</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:<span class="comment">// alias declarartions</span></span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> pointer = value_type *;</span><br><span class="line">  <span class="keyword">using</span> iterator = value_type *;<span class="comment">// iterator is raw pointer</span></span><br><span class="line">  <span class="keyword">using</span> const_iterator = <span class="keyword">const</span> value_type *;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">const</span> value_type &amp;;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">size_t</span>;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:<span class="comment">// data member</span></span><br><span class="line">  <span class="comment">// iterator to indicate the vector's memory location</span></span><br><span class="line">  iterator start;</span><br><span class="line">  iterator finish;</span><br><span class="line">  iterator end_of_storage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于vector而言，它的迭代器类型为<code>value_type *</code>，单纯的指针类型，支持随机访问。<br>而<code>list</code>则不然，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">list_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> self = list_iterator&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> link_type = list_node&lt;T&gt; *;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> iterator_category = bidirectional_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> pointer = T *;</span><br><span class="line">  <span class="keyword">using</span> reference = T &amp;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data member</span></span><br><span class="line">  link_type node;<span class="comment">// raw pointer link to list_node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// increasement</span></span><br><span class="line">  self &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    self temp = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// decreasement</span></span><br><span class="line">  self &amp;<span class="keyword">operator</span>--() &#123;</span><br><span class="line">    node = node-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    self temp = *<span class="keyword">this</span>;</span><br><span class="line">    --(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>list的迭代器显然仅仅支持双向递增递减，并不支持随机访问。<br>slist（单链表)的迭代器具体实现此处略过不再赘述，不过它的迭代器仅支持前向递增。<br>显然，枚举出所有迭代器并一一重载是不现实的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(slist&lt;T&gt;::iterator &amp;i, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(<span class="built_in">list</span>&lt;T&gt;::iterator &amp;i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;::iterator &amp;i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>stl将迭代器分为以下5种类型，并存在以下继承关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;; <span class="comment">// 前向迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;; <span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;; <span class="comment">// 随机访问迭代器</span></span><br></pre></td></tr></table></figure><p>并且定义迭代器type traits为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> Iterator::iterator_category;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> Iterator::difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T *&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in c++14 style</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">iterator_category_t</span> =</span></span><br><span class="line"><span class="class">    <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:iterator_category;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">difference_type_t</span> = <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:difference_type;</span><br></pre></td></tr></table></figure><p>因此，自定义迭代器只需要在内部声明<code>iterator_category</code>和<code>difference_type</code>（为了避免忘记声明，stl提供了一个模板以供继承），即可使用type_traits。 因此，<code>advance</code>函数具体实现为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  i += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">  _advance(i, n, <span class="keyword">iterator_category_t</span>&lt;InputIterator&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>事实上，type traits在stl泛型算法中的应用随处可见（这也与stl的设计理念有关），例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span> *<span class="title">p</span>) &#123;</span></span><br><span class="line">  p-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">beg</span>, <span class="title">ForwardIterator</span> <span class="title">end</span>) &#123;</span></span><br><span class="line">  <span class="keyword">using</span> is_POD_type = <span class="keyword">typename</span> type_traits&lt;ForwardIterator&gt;::is_POD_type;</span><br><span class="line">  destroy_aux(beg, <span class="built_in">end</span>, is_POD_type());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的value_type不存在non—trivial destructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">beg</span>, <span class="title">ForwardIterator</span> <span class="title">end</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">false_type</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (; beg != <span class="built_in">end</span>; ++beg) destroy(&amp;*beg);<span class="comment">// 毕竟迭代器不是真正的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在trivial destructor</span></span><br><span class="line"><span class="comment">// 如果对象的析构函数无关痛痒，那么反复调用它是一种效率上的巨大浪费</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>, <span class="title">ForwardIterator</span>, <span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对char*、wchar_t*的特化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span> *)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">wchar_t</span> *, <span class="keyword">wchar_t</span> *)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>不胜枚举。</p><hr><h2 id="构建模板元编程的基础组件"><a href="#构建模板元编程的基础组件" class="headerlink" title="构建模板元编程的基础组件"></a>构建模板元编程的基础组件</h2><h3 id="模板元编程中的代码复用"><a href="#模板元编程中的代码复用" class="headerlink" title="模板元编程中的代码复用"></a>模板元编程中的代码复用</h3><h4 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h4><p>假设存在一个场景，开发者需要对输入的类型添加或删除某种属性。<br>先从最简单的例子开始———擦除某种类型的<code>const</code>属性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>&lt;const T&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure><br>移除<code>volatile</code>也是类似的，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span>&lt;volatile T&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>擦除<code>reference</code>也是类似的，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，<code>add_lreference</code>，<code>add_rrefernce</code>的实现也并不复杂，此处不再赘述。</p><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>前文所提及的所有模板元案例，要么基于<code>xxx::value</code>，要么基于<code>xxx::type</code>（表示TMP的返回是一个类型还是一个值）。<br>每一次模板元编程都写一次<code>using type = xxx</code>是一次非常磨人的行为，类似的代码理论上应该被复用。因此，我们有必要实现一些基础组件，并根据这些基础组件来完成模板元编程的开发工作。</p><h3 id="TMP基础组件"><a href="#TMP基础组件" class="headerlink" title="TMP基础组件"></a>TMP基础组件</h3><h4 id="证同的实现与应用"><a href="#证同的实现与应用" class="headerlink" title="证同的实现与应用"></a>证同的实现与应用</h4><p>证同操作是一个单纯的投射，输入一个T类型，返回一个T类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>通过<code>identity</code>，<code>remove_xxx</code>的实现可以更加优雅：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>:</span> identity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>&lt;const T&gt;:</span> identity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> :</span> identity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt;:</span> identity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt;:</span> identity&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="编译期数值的实现与应用"><a href="#编译期数值的实现与应用" class="headerlink" title="编译期数值的实现与应用"></a>编译期数值的实现与应用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T val&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_constant</span> &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> T value = val;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> type = integral_constant;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据<code>integral_constant</code>，开发者可以使用<code>integral_constant&lt;T, val&gt;</code>来创建和使用编译期数值，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> val&gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="keyword">bool</span>, val&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = bool_constant&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = bool_constant&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure></p><h4 id="how-to-impl-is-same"><a href="#how-to-impl-is-same" class="headerlink" title="how to impl is_same?"></a>how to impl is_same?</h4><p><code>is_same</code>，顾名思义，返回两个类型是否相同，其具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_same</span> :</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_same</span>&lt;T, T&gt; :</span> true_type &#123;&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="how-to-impl-is-void"><a href="#how-to-impl-is-void" class="headerlink" title="how to impl is_void ?"></a>how to impl is_void ?</h4><p>操作类型的基础是了解当前传入的类型，在泛型编程中，我们时常需要类似于<code>is_int</code>,<code>is_float</code>,<code>is_pointer</code>等等诸如此类的类型判断。<br>本文并不关注描述如何实现以上工具，只是试图表明以上工具均可以通过前文已有所涉及的基础组件加以实现。<br>还是从最简单的例子开始，尝试通过几种方法来实现 <code>is_void</code>。</p><h5 id="通过特化穷举所有可能"><a href="#通过特化穷举所有可能" class="headerlink" title="通过特化穷举所有可能"></a>通过特化穷举所有可能</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>:</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void&gt;:</span> true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void const&gt;:</span> true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void volatile&gt;:</span> true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void const volatile&gt;:</span> true_type &#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="use-is-same-amp-amp-remove-cv"><a href="#use-is-same-amp-amp-remove-cv" class="headerlink" title="use is_same &amp;&amp; remove_cv"></a>use is_same &amp;&amp; remove_cv</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span> :</span> is_same&lt;<span class="keyword">remove_cv_t</span>&lt;T&gt;::type, <span class="keyword">void</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="use-is-one-of"><a href="#use-is-one-of" class="headerlink" title="use is_one_of"></a>use is_one_of</h5><p><code>is_one_of</code>，顾名思义，返回一个类型是否存在于类型列表中（not in std)，其具体实现如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>  ...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_one_of</span>;</span> <span class="comment">// only a declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_one_of</span>&lt;T&gt; :</span> false_type &#123;&#125;; <span class="comment">// 递归基</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_one_of</span>&lt;T, U, Args...&gt; :</span> bool_constant&lt;is_same&lt;T, U&gt;::value || is_one_of&lt;T, Args...&gt;::value&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><br>如何使用<code>is_one_of</code>来实现<code>is_void</code>是非常显然的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>:</span> is_one_of&lt;T,<span class="keyword">void</span>, <span class="keyword">const</span> <span class="keyword">void</span>, <span class="keyword">volatile</span> <span class="keyword">void</span>, <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>以上关于<code>is_void</code>的实现充分说明，类似于普通函数，模板元编程在实现过程中同样存在多种方案可供选择，并非仅有单一实践。</p><h4 id="编译期判断"><a href="#编译期判断" class="headerlink" title="编译期判断"></a>编译期判断</h4><h5 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h5><p>编译期同样存在if判断的需求与使用场景，例如某个模板类需要根据泛型参数<code>T</code>的具体属性来决定继承基类<code>B1</code>或<code>B2</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span></span><br><span class="line">  ...<span class="comment">// sth</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> &#123;</span></span><br><span class="line">  ...<span class="comment">// sth</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> val, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = xxx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> conditional&lt;<span class="built_in">std</span>::is_void&lt;T&gt;::value, B1, B2&gt;::type &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中<code>conditional</code>是一个标准的元编程实现，其作用为:val为true，则type == T，否则type == U。<br>显然，<code>conditional</code>的实现并无特别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> val, <span class="keyword">typename</span> T, <span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span>&lt;true, T, U&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span>&lt;false, T, U&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = U;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h5><p><code>enable_if</code>的实现基础来自于SFINAE，在TMP中使用非常广泛。<br>在实际开发工作中经常存在某种场景，即当前泛型函数仅应该支持符合条件的某些类型，其余类型应当在编译期触发报错，例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该模板函数接受参数：整形，浮点，string_view， xxx库提供的数组与字典结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;</span><br><span class="line">              <span class="built_in">std</span>::is_same&lt;T, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::value ||</span><br><span class="line">              <span class="built_in">std</span>::is_same&lt;T, xxx::string_view&gt;::value || <span class="built_in">std</span>::is_integral&lt;T&gt;::value ||</span><br><span class="line">              <span class="built_in">std</span>::is_floating_point&lt;T&gt;::value || <span class="built_in">std</span>::is_same&lt;T, xxx::Values&gt;::value ||</span><br><span class="line">              <span class="built_in">std</span>::is_same&lt;T, xxx::Dictionary&gt;::value&gt;::type * = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">process</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t, <span class="keyword">const</span> T &amp;val) &#123;</span><br><span class="line">  ... <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>enable_if</code>有实现如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> val&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">enable_if</span> &#123;</span>&#125;; <span class="comment">// nothing in struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">enable_if</span>&lt;true&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">void</span>; <span class="comment">// dont need use this type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="模板元编程的实际应用"><a href="#模板元编程的实际应用" class="headerlink" title="模板元编程的实际应用"></a>模板元编程的实际应用</h1><p>&nbsp;</p><h2 id="判断类型是否存在某个对外暴露的符号"><a href="#判断类型是否存在某个对外暴露的符号" class="headerlink" title="判断类型是否存在某个对外暴露的符号"></a>判断类型是否存在某个对外暴露的符号</h2><p>简单介绍一下TMP在实际工程中的应用情况，例如：判断当前类型是否内含有某public member function或者pulic data member，思路和<code>enable_if</code>思路大致类似。<br>这里仅以如何判断当前类型存在拷贝赋值函数举例。   </p><h2 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h2><p>decltype 与 declval<br><a href="https://xander.wiki/2018/06/25/%E4%BA%86%E8%A7%A3decltype%E6%8A%80%E6%9C%AF/">https://xander.wiki/2018/06/25/%E4%BA%86%E8%A7%A3decltype%E6%8A%80%E6%9C%AF/</a><br><a href="https://stdrc.cc/post/2020/09/12/std-declval/" target="_blank" rel="noopener">https://stdrc.cc/post/2020/09/12/std-declval/</a><br>void_t<br><a href="https://blog.csdn.net/ding_yingzi/article/details/79983042" target="_blank" rel="noopener">https://blog.csdn.net/ding_yingzi/article/details/79983042</a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">copy_assignment_t</span> = <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;T &amp;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct has_copy_assignment : <span class="built_in">std</span>::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in c++17 style</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_copy_assignment</span>&lt;T, std::void_t&lt;copy_assignment_t&lt;T&gt;&gt;&gt; :</span> <span class="built_in">std</span>::is_same&lt;<span class="keyword">copy_assignment_t</span>&lt;T&gt;, T &amp;&gt; &#123;&#125;; <span class="comment">// 特化最优匹配</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    B &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> B &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(has_copy_assignment&lt;A&gt;::value, <span class="string">"A has copy assignment"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(!has_copy_assignment&lt;B&gt;::value, <span class="string">"B has no copy assignment"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，如需检验某个类是否具备public data member，只需要更改<code>decltype</code>内的判断条件即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;本文只是针对TMP(Template Metaprogramming)的简单说明，并不涉及模板元编程中的各种黑魔法诸如编译期堆排序，实现反射特性等等。&lt;br&gt;旨在对TMP做一个入门科普，以及简单介绍TMP在实际业务中存在哪些应用。&lt;/p&gt;
    
    </summary>
    
      <category term="杂项" scheme="https://xander.wiki/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="模板元编程" scheme="https://xander.wiki/tags/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记一次懵懂的源码阅读经历————static_cast，priavte继承与friend杂烩</title>
    <link href="https://xander.wiki/2022/07/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%87%B5%E6%87%82%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%BB%8F%E5%8E%86%E2%80%94%E2%80%94static_cast%E4%B8%8Efriend%E7%9B%B8%E5%85%B3/"/>
    <id>https://xander.wiki/2022/07/29/记一次懵懂的源码阅读经历——static_cast与friend相关/</id>
    <published>2022-07-29T04:01:00.000Z</published>
    <updated>2022-08-01T14:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>由于工作需要，最近在读folly库src，在阅读源码过程中产生了一些关于private继承，static_cast，friend之间的疑问。   </p><a id="more"></a><hr><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="private继承"><a href="#private继承" class="headerlink" title="private继承"></a>private继承</h2><p>C++在业务逻辑中很少涉及private继承，实际上private继承仅仅是一种实现技术，如果class d以private形式继承class b，这说明d仅仅为了采用某些b中已经存在的特性，而不是b和d有任何观念上的交集。<br>一般来说，private继承主要用于EBO（Empty Base Optimization）。<br>更多信息可以参考Effective C++中关于private继承的说明。</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>四种类型转换之一，相较于<code>dynamic_cast</code>，<code>static_cast</code>在做向下类型转换时（Base class to Derived class)，不验证正确性。<br>当用作向下转换时，<code>static_cast</code>需要保证待转换对象间存在public继承关系，否则无法通过编译。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">private</span> B &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> B();</span><br><span class="line">    D1 *d1 = <span class="keyword">static_cast</span>&lt;D1*&gt;(b); <span class="comment">// ok</span></span><br><span class="line">    D2 *d2 = <span class="keyword">static_cast</span>&lt;D2*&gt;(b); <span class="comment">// error, cannot cast private base class 'B' to 'D2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="case"><a href="#case" class="headerlink" title="case"></a>case</h1><p>&nbsp;<br>根据前置知识，下文内的代码无疑是无法通过编译的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> d = *(<span class="keyword">static_cast</span>&lt;Derived&lt;T&gt; *&gt;(<span class="keyword">this</span>)); <span class="comment">// error, cannot cast private base class 'Base&lt;T&gt;' to 'Derived&lt;T&gt;'</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="title">final</span> :</span> <span class="keyword">private</span> Base&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    b.dosth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，如果在<code>Derived</code>内添加<code>friend base class</code>，则可正常通过编译<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> d = *(<span class="keyword">static_cast</span>&lt;Derived&lt;T&gt; *&gt;(<span class="keyword">this</span>)); <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="title">final</span> :</span> <span class="keyword">private</span> Base&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;T&gt;;</span> <span class="comment">// add friend</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    b.dosth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>&nbsp;<br>我对<code>friend</code>的了解仅仅是改变了class之间的符号访问关系，为什么通过增加friend修饰，可以做到cast private base to derived?  </p><hr><h1 id="一些猜想与结论"><a href="#一些猜想与结论" class="headerlink" title="一些猜想与结论"></a>一些猜想与结论</h1><p>&nbsp;<br>根据 <a href="https://stackoverflow.com/questions/56673706/inaccessible-base-class-despite-friendship" target="_blank" rel="noopener">https://stackoverflow.com/questions/56673706/inaccessible-base-class-despite-friendship</a><br>得到了一些初步的结论：<br>简单来说，private继承令d无法访问b的内部具体实现（这也是private的特性），从而<code>d*</code>与<code>b*</code>不具备相互转换的能力（inaccessible-base-class）。<br>但加上friend后，在<strong>指定的上下文内</strong>d可以<strong>访问</strong>b的内部实现，因此static_cast是合法的。示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="title">final</span> :</span> <span class="keyword">private</span> Base&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;T&gt;;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    Derived&lt;<span class="keyword">int</span>&gt; * d1 = <span class="keyword">static_cast</span>&lt;Derived&lt;<span class="keyword">int</span>&gt; *&gt;(&amp;b); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    Derived&lt;<span class="keyword">int</span>&gt; * d1 = <span class="keyword">static_cast</span>&lt;Derived&lt;<span class="keyword">int</span>&gt; *&gt;(&amp;b); <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;由于工作需要，最近在读folly库src，在阅读源码过程中产生了一些关于private继承，static_cast，friend之间的疑问。   &lt;/p&gt;
    
    </summary>
    
      <category term="杂项" scheme="https://xander.wiki/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>设计无锁并发数据结构——无锁结构实例</title>
    <link href="https://xander.wiki/2021/08/04/%E8%AE%BE%E8%AE%A1%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%97%A0%E9%94%81%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/"/>
    <id>https://xander.wiki/2021/08/04/设计无锁并发结构——无锁结构实例/</id>
    <published>2021-08-04T07:17:00.000Z</published>
    <updated>2021-10-26T07:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>为了演示一些在设计无锁数据结构中用到的技术，本节将给出一系列简单数据结构的无锁实现。<br>如前文所述，无锁结构依赖原子操作和相关的内存顺序保证来确保数据以正确的顺序对其他线程可见。在本节之初，所有的原子操作将使用默认的<code>memory_order_seq_cst</code>内存顺序，因为它最好理解(所有的<code>memory_order_seq_cst</code>操作构成一个全序)，但后续将逐渐减少约束至<code>memory_order_acquire</code>，<code>memory_order_release</code>，甚至<code>memory_order_relaxed</code>。<br>虽然实例中没有直接使用互斥锁，但需要注意，仅有<code>std::atomic_flag</code>保证无锁实现。如<code>C++内存模型与原子类型操作</code>一章所述，在某些平台上C++标准库内的原子类型可能是基于锁实现的，此时倒不如选择直接使用基于锁的数据结构。<br><a id="more"></a></p><hr><h1 id="无锁线程安全栈"><a href="#无锁线程安全栈" class="headerlink" title="无锁线程安全栈"></a>无锁线程安全栈</h1><p>&nbsp;<br>栈的最简底层结构是链表，其内部维持一个<code>head</code>节点指向当前栈顶。</p><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>在上述方案下，添加一个节点有步骤如下：</p><ol><li>创建一个新节点。</li><li>设置它的next指针指向当前的head节点。 </li><li>设置head节点指向新节点。</li></ol><h3 id="条件竞争分析与解决"><a href="#条件竞争分析与解决" class="headerlink" title="条件竞争分析与解决"></a>条件竞争分析与解决</h3><p>单线程下上述步骤没有问题，但当有两个线程同时添加节点时，第2步与第3步之间会产生竞争条件:在线程1执行第2步读取<code>head</code>的值和第3步更新<code>head</code>的值之间，线程2可能会修改<code>head</code>的值——这会导致其他线程的修改被丢弃，或造成更加严重的后果。在解决这个竞争条件之前，还需要注意一点:一旦<code>head</code>更新并指向了新节点，另一个线程就能读到这个节点。因此，在<code>head</code>设置为指向新节点前，新节点必须准备就绪——此后将无法修改此节点。</p><p>如何解决该条件竞争？答案是在第3步时使用原子的比较/交换操作，来确保步骤2读取到<code>head</code>以来，不会对<code>head</code>进行修改;若有修改，则循环后重试。有<code>push</code>代码实例如下。</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    node *next;</span><br><span class="line">    node(T <span class="keyword">const</span> &amp;data_) : data(data_) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;node *&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;data)</span> </span>&#123;</span><br><span class="line">    node *<span class="keyword">const</span> new_node = <span class="keyword">new</span> node(data);</span><br><span class="line">    new_node-&gt;next = head.load();</span><br><span class="line">    <span class="keyword">while</span> (!head.compare_exchange_weak(new_node-&gt;next, new_node));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>在本实例中，使用<code>compare_exchange_weak</code>以规避条件竞争：</p><ul><li>若被存储到<code>new_node-&gt;next</code>的<code>head</code>指针和之前load到的一样，<code>head</code>将被设置为<code>new_node</code>。</li><li>若返回false，意味着比较失败(<code>head</code>已被另一个线程修改)，此时参数1(<code>new_node-&gt;next</code>)将更新为<code>head</code>的最新值，并试图再次执行该循环。</li></ul><p>由于本次失败后将直接进行循环，因此我们使用比较/交换的weak版本而非strong版本，在某些架构上，前者效率优于后者（详见<code>C++内存模型与原子类型操作——原子操作与原子类型</code>一节）。</p><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>pop的步骤在单线程下并不复杂：</p><ol><li>读取head的当前值保存到node。 </li><li>读取head-&gt;next。</li><li>设置head为head-&gt;next。</li><li>返回node中的数据。</li><li>删除node节点。</li></ol><h3 id="条件竞争分析与解决-1"><a href="#条件竞争分析与解决-1" class="headerlink" title="条件竞争分析与解决"></a>条件竞争分析与解决</h3><p>但在多线程场景下，两个线程可能在步骤1中读取到相同的<code>head</code>值。存在一种场景：线程1处理到步骤5时，线程2还在处理步骤2，这将导致线程2试图解引用空悬指针——为了规避此问题，只能跳过步骤5，泄漏该节点，但问题并没有解决——这两个线程将返回同一个节点，这不符合栈语义。<br>解决问题的思路类似于push操作:在步骤3处使用比较/交换操作更新head。当比较/交换操作失败时，不是一个新节点已被推入，就是另一个线程弹出了节点。无论是哪种情况，都得返回步骤1(比较/交换操作会重新读取head)。一旦比较/交换成功，则当前线程是从栈上弹出指定节点的唯一线程，此后即可执行步骤4。</p><h3 id="代码实例1"><a href="#代码实例1" class="headerlink" title="代码实例1"></a>代码实例1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; result)</span> </span>&#123;</span><br><span class="line">    node* old_head = head.load(); </span><br><span class="line">    <span class="keyword">while</span>(!head.compare_exchange_weak(old_head,old_head-&gt;next)); </span><br><span class="line">    result=old_head-&gt;data;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实例1分析"><a href="#实例1分析" class="headerlink" title="实例1分析"></a>实例1分析</h3><p>实例1虽然仅有3行代码，但是问题却不少，以下将一一分析。<br>首先，这段代码在链表为空时将触发UB——当<code>head</code>是空指针时，尝试访问其next指针的行为未定义。解决方案很简单:在while循环内判空，并在空栈上抛出一个异常，或者pop函数返回一个bool 值来表明成功与否。<br>其次，这段代码存在异常安全问题。在前文中读者已经了解到拷贝对象作为返回值可能存在问题——若在拷贝返回值时如果抛出异常，该值将丢失（栈内没有，返回值也没有）。传入引用能解决该问题——至少异常发生时栈没有发生变更。但pop操作需要从栈上移除元素，因此通过引用获取返回值的方式并不可取——开发者依旧需要按值返回，那只能使用智能指针。智能指针意味着需要在堆上分配内存，但分配内存同样可能造成异常（此时又造成了数据丢失或pop失败），因此开发者可以在<code>push</code>内分配内存。</p><h3 id="代码实例2"><a href="#代码实例2" class="headerlink" title="代码实例2"></a>代码实例2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">    node *next;</span><br><span class="line"></span><br><span class="line">    node(T <span class="keyword">const</span> &amp;data_) : data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;node *&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;data)</span> </span>&#123;</span><br><span class="line">    node *<span class="keyword">const</span> new_node = <span class="keyword">new</span> node(data);</span><br><span class="line">    new_node-&gt;next = head.load();</span><br><span class="line">    <span class="keyword">while</span> (!head.compare_exchange_weak(new_node-&gt;next, new_node));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node *old_head = head.load();</span><br><span class="line">    <span class="keyword">while</span> (old_head &amp;&amp; !head.compare_exchange_weak(old_head, old_head-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> old_head ? old_head-&gt;data : <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实例2分析"><a href="#实例2分析" class="headerlink" title="实例2分析"></a>实例2分析</h3><p>需要注意一点，尽管该栈结构是无锁的，但并非无等待。因为只要<code>compare_exchange_weak</code>保持失败，push和pop函数中的while循环理论上可以无限循环下去。</p><hr><h1 id="在无锁数据结构中管理内存"><a href="#在无锁数据结构中管理内存" class="headerlink" title="在无锁数据结构中管理内存"></a>在无锁数据结构中管理内存</h1><p>&nbsp;<br>在上一小节中，为了避免当线程A删除某节点的同时，线程B还持有指向该节点的指针并需要解引用导致竞争条件，我们选择了泄漏节点。对于C++开发者而言，内存泄漏是不可接受的，本小节将致力于解决该问题。</p><p>该问题的核心在于如何保证释放节点时没有其他线程持有该节点。可能访问指定节点的线程只有2种：</p><ol><li>把节点添加到栈中的线程</li><li>调用<code>pop</code>的线程</li></ol><p>所有节点均在<code>push</code>内创建，一旦节点入栈，<code>push</code>将不再触碰该节点，此时仅剩下调用<code>pop</code>的线程——如果只有一个这样的线程，那么删除该节点是安全的。</p><p>当然，并发场景下往往是同一个栈实例上存在多个线程调用<code>pop</code>，此时我们需要为节点写一个专用GC，虽然听起来很麻烦，但实际上也还算凑活：只需要检查哪些被<code>pop</code>访问到的节点即可。该GC的任务如下:将所有待删除节点推入队列，若当前无任何进程执行<code>pop</code>，则安全清除队列内所有节点。GC内部持有一个原子变量，用以统计当前进入pop的线程。根据以上需求，有<code>pop</code>修订版如下。</p><h2 id="pop实例"><a href="#pop实例" class="headerlink" title="pop实例"></a>pop实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span>&gt; threads_in_pop;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">try_reclaim</span><span class="params">(node *old_head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++threads_in_pop; <span class="comment">// 增加计数</span></span><br><span class="line">    node *old_head = head.load();</span><br><span class="line">    <span class="keyword">while</span> (old_head &amp;&amp; !head.compare_exchange_weak(old_head, old_head-&gt;next));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">      res.swap(old_head-&gt;data); <span class="comment">// 交换而非拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">    try_reclaim(old_head); <span class="comment">// 尝试回收删除的节点，递减计数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要关注的点在于：数据的传出使用了<code>swap</code>而非单纯拷贝，原因很简单——旧节点已经无需再持有数据，如果拷贝的话，数据的引用计数+1，从而致使即使<code>pop</code>调用方已经完成数据使用，数据仍未能立即释放（压入待删除队列的节点依然持有数据）—— 本质上是分离了节点与数据的生命周期。</p><h2 id="try-reclaim实例"><a href="#try-reclaim实例" class="headerlink" title="try_reclaim实例"></a>try_reclaim实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;node *&gt; to_be_deleted;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_nodes</span><span class="params">(node *nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nodes) &#123;</span><br><span class="line">      node *next = nodes-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> nodes;</span><br><span class="line">      nodes = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">try_reclaim</span><span class="params">(node *old_head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threads_in_pop == <span class="number">1</span>) &#123;</span><br><span class="line">      node *nodes_to_delete = to_be_deleted.exchange(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == --threads_in_pop) &#123; <span class="comment">// 3</span></span><br><span class="line">        delete_nodes(nodes_to_delete);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodes_to_delete) &#123;</span><br><span class="line">        chain_pending_nodes(nodes_to_delete); <span class="comment">// 2</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> old_head; <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      chain_pending_node(old_head);</span><br><span class="line">      --threads_in_pop;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node *nodes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取链表尾部</span></span><br><span class="line">    node *last = nodes;</span><br><span class="line">    <span class="keyword">while</span> (node * <span class="keyword">const</span> next = last-&gt;next) &#123;</span><br><span class="line">      last = next;</span><br><span class="line">    &#125;</span><br><span class="line">    chain_pending_nodes(nodes, last);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新待删除列表</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node *first, node *last)</span> </span>&#123;</span><br><span class="line">    last-&gt;next = to_be_deleted;</span><br><span class="line">    <span class="keyword">while</span> (!to_be_deleted.compare_exchange_weak(last-&gt;next, first));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">chain_pending_node</span><span class="params">(node *n)</span> </span>&#123;</span><br><span class="line">    chain_pending_nodes(n, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h2><p>若当前仅有一个线程在<code>pop</code>内，则此时可安全删除待移出节点（步骤1）。若当前存在多个线程在<code>pop</code>内，删除任何节点均不安全，因此将当前节点添加至未决（pending）链表。</p><p>若当前仅有一个线程在<code>pop</code>内，需要尝试回收所有的未决节点（如前文所说，当前节点必然被回收）。首先通过原子<code>exchange</code>操作获取未决链表，并递减计数，若此时计数为0，则意味着可安全删除链表内所有内容（虽然删除时可能会出现新的未决节点）。若计数递减后不为0(此时存在其他线程在获取<code>threads_in_pop</code>和获取链表之间调用<code>pop</code>），则需要将未决节点加入未决链表内(步骤2），具体情形可见下图。</p><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>如图，线程C添加节点Y到<code>to_be_deleted</code>链表，而此时线程B仍在通过old_head引用它，并且尝试读其next指针。因此线程A必须再次效验<code>threads_in_pop</code>，否则将误删节点。<br><img src="http://static.zybuluo.com/zsmj2017/0mf5wmeqjpva3wl6p82gzoke/image.png" alt="sth"><br><img src="http://static.zybuluo.com/zsmj2017/znsinrqgczs44hfrs1pdn84b/image.png" alt="image.png-589.8kB"></p><h2 id="方案优劣"><a href="#方案优劣" class="headerlink" title="方案优劣"></a>方案优劣</h2><p>在低负载场景下，这一方案运行良好，因为总有时间点没有线程运行<code>pop</code>。但这些时间点稍纵即逝，这直接导致了：</p><ol><li>回收前，需要效验<code>threads_in_pop</code>计数为0</li><li>在delete（步骤1）前执行效验</li></ol><p>删除节点是一个耗时的操作，因此线程修改链表的时间窗口越小越好。从第一次发现<code>threads_in_pop == 1</code>到尝试删除节点耗费的时间越长，就越有可能有另一个线程会调用<code>pop</code>，导致此线程看见的<code>threads_in_pop</code>不再等于1，从而无法直接删除节点。</p><p>在高负载场景下，可能永远不会存在能回收节点的时间点，此时链表将会无限增长，导致再次泄漏内存。</p><hr><h1 id="使用风险指针检测不可回收的节点"><a href="#使用风险指针检测不可回收的节点" class="headerlink" title="使用风险指针检测不可回收的节点"></a>使用风险指针检测不可回收的节点</h1><p>&nbsp;<br>“风险指针”这个术语引自Maged Michael发现的一项技术。其基本思想为，如果线程A准备访问线程B想要删除的对象，A将设置风险指针来引用此对象，然后通知其他线程使用这个指针是危险的。一旦不再需要此对象，则可清除风险指针。以划船比赛机制举例——比赛开始（删除对象）前，每个船上的舵手可以举手示意他们还没有准备好。只要有舵手举手，裁判就不能开始比赛。当所有舵手把手放下后，比赛才能开始，舵手可以在比赛开始前随意举手，无次数限制。</p><h2 id="pop实例-1"><a href="#pop实例-1" class="headerlink" title="pop实例"></a>pop实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;T&gt; pop() &#123;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span> *&gt; &amp;hp = get_hazard_pointer_for_current_thread();</span><br><span class="line">    node *old_head = head.load();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node *temp;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            temp = old_head;</span><br><span class="line">            hp.store(old_head);</span><br><span class="line">            old_head = head.load();</span><br><span class="line">        &#125; <span class="keyword">while</span> (old_head != temp); <span class="comment">// 一直循环，直到将风险指针设为head</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (old_head &amp;&amp; !head.compare_exchange_strong(old_head, old_head-&gt;next)); <span class="comment">// 1 重新设置head</span></span><br><span class="line">    hp.store(<span class="literal">nullptr</span>); <span class="comment">// 取出头结点后，清除风险指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">        res.swap(old_head-&gt;data);</span><br><span class="line">        <span class="comment">// 在删除之前检查是否有风险指针引用该节点(因为在上面那个内部循环中可能多个线程都把某个head设置为自己线程的风险指针)</span></span><br><span class="line">        <span class="keyword">if</span> (outstanding_hazard_pointers_for(old_head))</span><br><span class="line">        &#123;</span><br><span class="line">            reclaim_later(old_head); <span class="comment">// 加入链表内，稍后删除</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_head;</span><br><span class="line">        &#125;</span><br><span class="line">        delete_nodes_with_no_hazards();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h2><p>首先，设置风险指针的循环置于外部循环1内，该外部循环会在“比较/交换”操作失败的时候重新加载old_head，需要注意这里使用了<code>compare_exchange_strong</code>，因为在while循环内部有事可做(若使用<code>compare_exchange_weak</code>伪失败后，会导致不必要地重新设置风险指针）。若已成功取出节点，此时即可清除风险指针，并检查当前节点是否为其他线程的风险指针。若是，则置于链表内，留待后续回收;否则立刻删除节点。最后<code>delete_nodes_with_no_hazards</code>将检测所有由<code>reclaim_later</code>收集的节点，若当前没有任何风险指针引用这些节点，则可安全删除这些节点，否则留待下一个调用pop的线程继续检测。</p><h2 id="get-hazard-pointer-for-current-thread的简单实现"><a href="#get-hazard-pointer-for-current-thread的简单实现" class="headerlink" title="get_hazard_pointer_for_current_thread的简单实现"></a>get_hazard_pointer_for_current_thread的简单实现</h2><p><code>get_hazard_pointer_for_current_thread</code>的具体实现方案对程序逻辑影响不大。目前可以先设计一个简单（但不高效）的结构:一个定长数组，其元素类型是一个KV对——K是线程ID，V为风险指针。通过搜索这个数组来找到空闲槽位，并设置KV对。当线程退出时，重置ID为默认值，表征该槽位已空闲。具体实例如下。</p><h3 id="get-hazard-pointer-for-current-thread实例"><a href="#get-hazard-pointer-for-current-thread实例" class="headerlink" title="get_hazard_pointer_for_current_thread实例"></a>get_hazard_pointer_for_current_thread实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">const</span> max_hazard_pointers = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hazard_pointer</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::atomic &lt;<span class="built_in">std</span>::thread::id&gt; id&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span> *&gt; pointer&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">hazard_pointer hazard_pointers[max_hazard_pointers];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hp_owner</span> &#123;</span></span><br><span class="line">    hazard_pointer *hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    hp_owner(hp_owner <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    hp_owner <span class="keyword">operator</span>=(hp_owner <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    hp_owner() :</span><br><span class="line">            hp(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; hazard_pointer : hazard_pointers) &#123;</span><br><span class="line">            <span class="built_in">std</span>::thread::id old_id;</span><br><span class="line">             <span class="comment">// 找到第一个空闲槽位</span></span><br><span class="line">            <span class="keyword">if</span> (hazard_pointer.id.compare_exchange_strong(old_id, <span class="built_in">std</span>::this_thread::get_id())) &#123;</span><br><span class="line">                hp = &amp;hazard_pointer;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"No hazard pointers available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span> *&gt; &amp;<span class="title">get_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hp-&gt;pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~hp_owner() &#123;</span><br><span class="line">        hp-&gt;pointer.store(<span class="literal">nullptr</span>);</span><br><span class="line">        hp-&gt;id.store(<span class="built_in">std</span>::thread::id());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span> *&gt; &amp;<span class="title">get_hazard_pointer_for_current_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">static</span> hp_owner hazard;</span><br><span class="line">    <span class="keyword">return</span> hazard.get_pointer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前指针是否为风险指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">outstanding_hazard_pointers_for</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; max_hazard_pointers; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hazard_pointers[i].pointer.load() == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例分析-3"><a href="#实例分析-3" class="headerlink" title="实例分析"></a>实例分析</h3><p><code>get_hazard_pointer_for_current_thread</code>的实现如下:它有一个hp_owner类型的thread_local变量，用来存储当前线程的风险指针。每个线程第一次调用这个函数时，一个新的<code>hp_owner</code>实例被创建，该实例将通过<code>compare_exchange_strong</code>获取空闲槽位，停止搜索，若遍历完毕尚未找到空闲槽位，则抛出异常。显然，这种遍历对工作线程只需要一次，<code>hp_owner</code>承载了缓存的作用。当线程退出时其专属的<code>hp_owner</code>实例将被销毁，数组内将新增一个空闲槽位。</p><h2 id="回收实例"><a href="#回收实例" class="headerlink" title="回收实例"></a>回收实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;T *&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_to_reclaim</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span> *)&gt; deleter;</span><br><span class="line">    data_to_reclaim *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    data_to_reclaim(T *p): data(p), deleter(&amp;do_delete&lt;T&gt;), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~data_to_reclaim() &#123; deleter(data); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;data_to_reclaim *&gt; nodes_to_reclaim; <span class="comment">// 回收链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_reclaim_list</span><span class="params">(data_to_reclaim *node)</span> </span>&#123;</span><br><span class="line">    node-&gt;next = nodes_to_reclaim.load();</span><br><span class="line">    <span class="keyword">while</span> (!nodes_to_reclaim.compare_exchange_weak(node-&gt;next, node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reclaim_later</span><span class="params">(T *data)</span> </span>&#123;</span><br><span class="line">    add_to_reclaim_list(<span class="keyword">new</span> data_to_reclaim(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_nodes_with_no_hazards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data_to_reclaim *current = nodes_to_reclaim.exchange(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        data_to_reclaim *<span class="keyword">const</span> next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!outstanding_hazard_pointers_for(current-&gt;data)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add_to_reclaim_list(current);</span><br><span class="line">        &#125;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例分析-4"><a href="#实例分析-4" class="headerlink" title="实例分析"></a>实例分析</h3><p>首先，以<code>data_to_reclaim</code>作为链表内的元素类型，其构造函数是一个函数模板（主要是为了支持各类型的deleter）。<code>reclaim_later</code>的职责很简单——将该指针构建为<code>data_to_reclaim</code>类型后添加至链表内。</p><p><code>delete_nodes_with_no_hazards</code>使用<code>exchange</code>函数获取需要回收的整个链表。这个简单但很关键的步骤确保了只有一个线程回收该链表。其他线程现在自由地将其他节点添加到新回收链表中，甚至尝试对节点进行回收，而不影响本回收线程。当获取到链表头后，遍历该链表内节点，若该节点为非风险指针，则可安全删除，否则将该节点重新置于回收链表内（已不再是本链表）。</p><p>虽然这个简单的实现确实安全地回收了被删除的节点，不过开销极大。每次<code>pop</code>调用都需要扫描一次风险指针数组，这意味着检查max_hazard_pointers个原子变量。原子操作本来就慢(在台式CPU上，原子操作比非原子操作慢100倍)。每一次调用<code>outstanding_hazard_pointers_for</code>时开发者需要意识到：可能会有max_hazard_pointers个节点在链表中，并且它们需要和max_hazard_pointers个存储的风险指针做比较。是时候做性能优化了。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>上文只是描述了一个简单的风险指针实现，用以辅助解释该技术。以下将简单介绍一些优化点。<br>首先可以用内存换性能。不同于每次调用<code>pop</code>都检查回收链表上的每个节点，如果一直等到2&times;max_hazard_pointers个节点在链表中时，由于最多有max_hazard_pointers个节点是活跃的，即可保证至少有max_hazard_pointers个节点可以被回收，并且再次尝试回收任意节点前，至少会对<code>pop</code>有 max_hazard_pointer次调用。比起每次<code>pop</code>调用检查大约max_hazard_pointers个节点(不一定能回收到节点)，每max_hazard_pointers次<code>pop</code>调用，检查2&times;max_hazard_pointers个节点，就会有max_hazard_pointers个节点可回收。这等价于<code>pop</code>调用检查两个节点，其中有一个被回收。<br>不过，这个方案不仅使得回收链表增加了内存使用，同时还增加了计数需求，这意味着需要使用原子计数器，并且有多线程争竞争访问回收链表本身。当然，如果内存充裕，可以考虑令每个线程通过线程局部变量，持有自己的回收链表，如果一个线程在它的所有节点被回收前退出，它的本地链表可以像之前一样存储到全局链表中，然后添加到下一个线程的本地回收链表内，令该线程执行回收操作。</p><hr><h1 id="使用引用计数检测节点是否在使用"><a href="#使用引用计数检测节点是否在使用" class="headerlink" title="使用引用计数检测节点是否在使用"></a>使用引用计数检测节点是否在使用</h1><p>&nbsp;<br>区别于风险指针通过把使用中的节点存储到链表中，引用计数通过统计每个节点上访问的线程数量来判断当前节点是否正在被使用。</p><h2 id="使用std-shared-ptr"><a href="#使用std-shared-ptr" class="headerlink" title="使用std::shared_ptr"></a>使用std::shared_ptr</h2><p>理论上我们可以直接使用<code>std::shared_ptr&lt;&gt;</code>完成引用计数，但需要注意一点，在部分平台上，<code>std::shared_ptr&lt;&gt;</code>并不保证无锁，尽管其部分操作能够保证原子性。毕竟标准库中的<code>std::shared_ptr&lt;&gt;</code>旨在广泛用于多种上下文内，令其原子操作无锁可能会带来额外的开销。</p><p>若我们运气足够好，本平台<code>std::atomic_is_lock_free(&amp;some_shared_ ptr)</code>返回true，那实现就简单多了，具体实例如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt; next;</span><br><span class="line"></span><br><span class="line">        node(T <span class="keyword">const</span> &amp;data_) :</span><br><span class="line">                data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt; <span class="keyword">const</span> new_node = <span class="built_in">std</span>::make_shared&lt;node&gt;(data);</span><br><span class="line">        new_node-&gt;next = <span class="built_in">std</span>::atomic_load(&amp;head);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">std</span>::atomic_compare_exchange_weak(&amp;head,</span><br><span class="line">                                                  &amp;new_node-&gt;next, new_node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt; old_head = <span class="built_in">std</span>::atomic_load(&amp;head);</span><br><span class="line">        <span class="keyword">while</span> (old_head &amp;&amp; !<span class="built_in">std</span>::atomic_compare_exchange_weak(&amp;head,</span><br><span class="line">                                                              &amp;old_head, old_head-&gt;next));</span><br><span class="line">        <span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">            <span class="built_in">std</span>::atomic_store(&amp;old_head-&gt;next, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt;()); <span class="comment">// 避免当最后一个std::shared_ptr引用的给定节点被销毁时，删除后续数据，因此需要清空next指针</span></span><br><span class="line">            <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~lock_free_stack() &#123;</span><br><span class="line">        <span class="keyword">while</span> (pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="手动管理引用计数"><a href="#手动管理引用计数" class="headerlink" title="手动管理引用计数"></a>手动管理引用计数</h2><p>一种技术是对每个节点使用两个而不是一个引用计数:一个内部计数和一个外部计数，两个值的和就是对这个节点的引用总数。<br>外部计数与指向节点的指针一起保存，并且每次读取指针的时候外部计数增加。当读线程使用完节点后，递减内部计数。一个读指针操作完成后，外部计数将加1，内部计数会减1。<br>当不再需要外部计数&amp;&amp;指针时(该节点不再位于可以被多个线程访问的位置)，内部计数将加上外部计数-1的值，并丢弃外部计数。若此时内部计数等于0，则认为没有对该节点的引用，可以将该节点安全的删除。</p><h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">counted_node_ptr</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> external_count;</span><br><span class="line">        node *ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">        <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; internal_count;</span><br><span class="line">        counted_node_ptr next;</span><br><span class="line"></span><br><span class="line">        node(T <span class="keyword">const</span> &amp;data_) : data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_)), internal_count(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;counted_node_ptr&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~lock_free_stack() &#123;</span><br><span class="line">        <span class="keyword">while</span> (pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;data)</span> </span>&#123;</span><br><span class="line">        counted_node_ptr new_node;</span><br><span class="line">        new_node.ptr = <span class="keyword">new</span> node(data);</span><br><span class="line">        new_node.external_count = <span class="number">1</span>;</span><br><span class="line">        new_node.ptr-&gt;next = head.load();</span><br><span class="line">        <span class="keyword">while</span> (!head.compare_exchange_weak(new_node.ptr-&gt;next, new_node));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase_head_count</span><span class="params">(counted_node_ptr &amp;old_counter)</span> </span>&#123;</span><br><span class="line">        counted_node_ptr new_counter;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            new_counter = old_counter;</span><br><span class="line">            ++new_counter.external_count;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.compare_exchange_strong(old_counter, new_counter));</span><br><span class="line">        old_counter.external_count = new_counter.external_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counted_node_ptr old_head = head.load();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            increase_head_count(old_head);</span><br><span class="line">            node *<span class="keyword">const</span> ptr = old_head.ptr;</span><br><span class="line">            <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">                <span class="comment">// 理论上需要减少该节点的外部计数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.compare_exchange_strong(old_head, ptr-&gt;next)) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res;</span><br><span class="line">                res.swap(ptr-&gt;data);</span><br><span class="line">                <span class="keyword">int</span> <span class="keyword">const</span> count_increase = old_head.external_count - <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;internal_count.fetch_add(count_increase) == -count_increase) &#123; <span class="comment">// 引用计数和为0</span></span><br><span class="line">                    <span class="keyword">delete</span> ptr;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该节点已不再是head节点，需要重新读取，此时令该节点内部计数-1</span></span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;internal_count.fetch_sub(<span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 节点已被删除</span></span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p>首先，外部计数和节点指针一起包装在<code>counted_node_ptr</code>结构中，并作为<code>node</code>结构的next指针，同时<code>node</code>内持有内部计数。因为counted_node_ptr是一个简单的结构体，因此可以和std::atomic&lt;&gt;模板一起用作链表的head。在支持“双字比较和交换”（double-word-compare-and-swap）操作的平台上，由于这个结构体足够小，因此std::atomic<counted_node_ptr>支持无锁。若当前平台不支持的话，则只能使用<code>std::shared_ptr</code>作为引用计数工具。当类型的体积对平台的原子指令来讲太大的话，std::atomic&lt;&gt;将使用互斥锁来保证其操作的原子性(使“无锁”算法退化为“基于锁”的算法)。又或者，限制计数器大小，将其填充至指针内空余的bit位(比如，地址空间只有48位，而一个指针占64位。例如intel平台)，这样就可以塞进一个机器字当中。</p><p><code>push</code>很简单——构造了一个counted_node_ptr实例，引用新分配出来带有相关数据的node，并将node的next指针设置为当前head。此时internal_count为0，external_count为1（这是一个新节点，当前只有一个外部引用指向它，也就是head指针本身)。</p><p><code>pop</code>操作相对复杂一些。一旦加载了head的值，首先必须增加对head节点的外部引用计数，以表明正在引用这个节点并且确保解引用是安全的。如果在引用计数增加前解引用指针，另一个线程可能在你访问这个节点之前释放它，从而使你持有一个空悬指针。这就是使用内外引用计数的主要原因:通过增加外部引用计数，保证了指针在访问期间是有效的。递增操作通过compare_exchange_strong循环完成，该循环保证了指针不会在同一时间内被另一个线程修改。<br>一旦计数增加，则可安全地解引用head值的ptr字段，以便访问指向的节点。如果指针为空，说明此时链表为空，否则尝试对head调用compare_exchange_strong以移除该节点。</p><ol><li>若compare_exchange_strong成功，则意味着此时该线程掌握了节点所有权，可置换出data数据。此后使用原子操作fetch_add将外部计数加到内部计数。若此时引用计数为0，那么之前的值(fetch_add返回值)则为增加值的负数，此时可安全删除节点。需要注意的是，增加的值要比外部引用计数少2——节点已经从链表中删除，需要将外部计数-1，并且由于不再从这个线程访问节点，因此内部计数-1。无论是否删除节点，操作都已经完成，因此直接返回数据。</li><li>若compare_exchange_strong失败，则说明另一个线程已移除了该节点，或者另一个线程添加了一个新的节点到栈中。无论是何种情况，都需要用compare_exchange_strong返回的新的head值再次启动操作。不过，首先需要递减尝试移除的节点上的引用计数，因为该线程不会再访问此节点。如果当前线程是最后一个持有引用(另一个线程已经将这个节点从栈上移除了)的线程，此时内部引用为1，减1后为0，此时判定节点可安全删除。</li></ol><hr><h1 id="应用内存模型顺序至无锁栈"><a href="#应用内存模型顺序至无锁栈" class="headerlink" title="应用内存模型顺序至无锁栈"></a>应用内存模型顺序至无锁栈</h1><p>&nbsp;<br>目前为止，本文实例一直使用默认的<code>std::memory_order_seq_cst</code>内存顺序。在大多数系统上，<code>std::memory_order_seq_cst</code>在执行时间和同步开销方面比其他内存顺序更为昂贵，也许是时候做进一步优化了~</p><p>在对内存顺序做优化之前，首先需要明确数据结构的使用场景，<br>在修改内存顺序之前，定提供所需关系的最小内存顺序。为了做到这一点，需要在几种不同的场景中从线程的视 角查看相关情况。最简单的场景是一个线程将数据项推入栈，然后另一个线程在一段时间 过后弹出数据项，因此我们将从这开始。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;为了演示一些在设计无锁数据结构中用到的技术，本节将给出一系列简单数据结构的无锁实现。&lt;br&gt;如前文所述，无锁结构依赖原子操作和相关的内存顺序保证来确保数据以正确的顺序对其他线程可见。在本节之初，所有的原子操作将使用默认的&lt;code&gt;memory_order_seq_cst&lt;/code&gt;内存顺序，因为它最好理解(所有的&lt;code&gt;memory_order_seq_cst&lt;/code&gt;操作构成一个全序)，但后续将逐渐减少约束至&lt;code&gt;memory_order_acquire&lt;/code&gt;，&lt;code&gt;memory_order_release&lt;/code&gt;，甚至&lt;code&gt;memory_order_relaxed&lt;/code&gt;。&lt;br&gt;虽然实例中没有直接使用互斥锁，但需要注意，仅有&lt;code&gt;std::atomic_flag&lt;/code&gt;保证无锁实现。如&lt;code&gt;C++内存模型与原子类型操作&lt;/code&gt;一章所述，在某些平台上C++标准库内的原子类型可能是基于锁实现的，此时倒不如选择直接使用基于锁的数据结构。&lt;br&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计无锁并发数据结构——概述</title>
    <link href="https://xander.wiki/2021/07/31/%E8%AE%BE%E8%AE%A1%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
    <id>https://xander.wiki/2021/07/31/设计无锁并发数据结构——概述/</id>
    <published>2021-07-31T03:17:00.000Z</published>
    <updated>2021-08-04T06:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>互斥锁的理解成本很低，带来的收益却很高——可以保证在多线程情况下安全地访问数据结构，而不会产生竞争条件或破坏不变量。<br>但互斥锁并非完美无缺，不正确地使用可能带来死锁，粗粒度地上锁将影响并发性。<br>如果能写出一个不使用锁的并发数据结构，则可避免上述互斥锁引入的问题，这样的数据结构被被称为无锁(lock-free)数据结构。<br>无锁结构的核心是前文提及的内存顺序属性，设计无锁结构时需要万分小心——它不仅很难正确实现，同时其内部bug很难稳定复现与定位原因。<br><a id="more"></a></p><hr><h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>&nbsp;<br>使用互斥锁、条件变量，以及期望来同步数据的算法和数据结构被称为阻塞式 (blocking)数据结构和算法——线程在block消失前无法跨越。一般情况下，操作系统会完全挂起一个阻塞的线程(并将其时间片分配给其他线程)，直到另一个线程排除障碍（解锁一个互斥锁、通知一个条件变量，或令期望就绪）。</p><h2 id="非阻塞数据结构的3种类型"><a href="#非阻塞数据结构的3种类型" class="headerlink" title="非阻塞数据结构的3种类型"></a>非阻塞数据结构的3种类型</h2><p>前文曾用<code>std::atomic_flag</code>实现了一个简单的自旋锁，其代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic_flag flag; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  spinlock_mutex(): flag(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.test_and_set(<span class="built_in">std</span>::memory_order_acquire)); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该实例内没有调用任何阻塞函数，<code>lock</code>不断循环，直到<code>test_and_set</code>返回false，这就是自旋锁（spin lock）名字的由来——代码在循环中“旋转”。<br>因为不存在阻塞调用，所以使用这个互斥锁来保护共享数据的代码均为非阻塞式，不过并非无锁，毕竟这还是一个只能被一个线程锁住的互斥锁。显然，仅仅定义“阻塞”，“非阻塞”是不够用的，因此为了后续展开详细叙述，这里引入以下定义：</p><ul><li>无障碍——若其他线程均处于暂停状态，唯一操作线程都将在有限的步骤内完成其操作。</li><li>无锁——若存在多个线程同时对该数据结构进行操作，其中某个线程将在有限的步骤内完成其操作。</li><li>无等待——若存在多个线程同时对该数据结构进行操作，每个线程都将在有限步骤内完成其操作。</li></ul><p>显然，无障碍算法在实际场景中使用性很低（很少存在其他线程都暂停的场景），因此它主要用于刻画一个失败的无锁实现。</p><hr><h1 id="无锁数据结构"><a href="#无锁数据结构" class="headerlink" title="无锁数据结构"></a>无锁数据结构</h1><p>&nbsp;<br>无锁数据结构性质：支持多个线程并发访问，这些线程的操作无需相同（例如无锁队列支持一个线程push数据时另一个线程pop数据）。此外，当其中一个正在访问数据的线程被调度器中途挂起时，其他线程必须仍然能够继续完成工作，而无需等待挂起线程。</p><p>使用“比较-交换”原子操作的算法，通常都包含一个循环，之所以需要使用“比较-交换”操作，是因为与此同时另一个线程可能已经修改了数据，此时在再次尝试“比较-交换”之前，代码需要重新执行部分操作。若此时其他线程均被挂起，该算法可被称为“无锁”，否则的话等价于持有自旋锁，仅能称之为“非阻塞算法”。</p><p>带有循环的无锁算法可能导致某线程处于饥饿状态：若存在某一线程在“错误”时机执行操作，其他线程可能运行良好，但某倒霉线程则可能此时需要不断重复试错。</p><hr><h1 id="无等待数据结构"><a href="#无等待数据结构" class="headerlink" title="无等待数据结构"></a>无等待数据结构</h1><p>&nbsp;<br>根据前文定义，无等待数据结构是无锁数据结构的子集，其特征在于每个线程都都将在有限步骤内完成其操作（不管其他线程行为如何）。因此，由于与其他线程发生冲突而可能陷入无限次重试的算法并不是无等待的（本章的大多数实例都都具备这一特性——存在一个在<code>compare_exchange_weak</code>或<code>compare_exchange_strong</code>操作上的循环，并且循环次数没有上限）。</p><p>显然，正确实现一个“无等待”数据结构极其困难。为了保证每个线程都能在有限的步骤内完成操作，开发者必须保证线程内的所有操作均能一次执行完毕，并且不会给其他线程带来负面影响。这些要求无疑增加了数据结构与算法的复杂程度。</p><hr><h1 id="无锁结构的优缺点"><a href="#无锁结构的优缺点" class="headerlink" title="无锁结构的优缺点"></a>无锁结构的优缺点</h1><p>&nbsp;<br>在学习无锁结构前我们已经充分强调了其实现复杂性，因此开发者在撰写前必须充分审度开发成本与性能收益。下文将简单叙述无锁结构的优缺点，以供权衡。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>归根结底，使用无锁结构的主要原因在于并发最大化。在使用基于锁的数据结构时，一个线程总会阻塞某个节点并等待另一个线程完成操作（此即为互斥）。无锁结构可以保证某些线程持续性向前推进，而无等待结构则能保证所有线程均能有效向前推进（尽管很难实现）。</p><h3 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h3><p>若一个线程在持有锁时死亡，那么数据结构将会遭到永久性破坏。但无锁结构可以规避这一点，仅有当前死亡的线程数据被丢失。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="开发成本"><a href="#开发成本" class="headerlink" title="开发成本"></a>开发成本</h3><p>如果不能让线程互斥地访问数据结构，那开发者必须严格地关注与维持不变量。为了避免和数据竞争相关的未定义行为，开发者必须在修改时使用原子操作，并且确保修改以正确的顺序对其他线程可见。上述要求意味着极大的开发成本与心智投入。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>无锁编程不会导致死锁，但可能造成活锁（live lock）——多个线程试图同时修改数据结构，此时线程不断循环与重试，导致性能降低。无等待算法不存在活锁问题，但必然其算法复杂性更高（可能需要更多步骤来完成相应操作）。</p><p>无锁结构虽然提高了操作并发的潜力，减少了单个线程的等待时间，但其可能会导致整体性能下降，理由如下：</p><ol><li>无锁代码中的原子操作比非原子操作要慢得多，并且很可能无锁数据结构中原子操作大大多于基于锁的数据结构中互斥锁锁住的代码。</li><li>访问相同原子变量的硬件必须在线程间同步，这会导致严重的性能损耗。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;互斥锁的理解成本很低，带来的收益却很高——可以保证在多线程情况下安全地访问数据结构，而不会产生竞争条件或破坏不变量。&lt;br&gt;但互斥锁并非完美无缺，不正确地使用可能带来死锁，粗粒度地上锁将影响并发性。&lt;br&gt;如果能写出一个不使用锁的并发数据结构，则可避免上述互斥锁引入的问题，这样的数据结构被被称为无锁(lock-free)数据结构。&lt;br&gt;无锁结构的核心是前文提及的内存顺序属性，设计无锁结构时需要万分小心——它不仅很难正确实现，同时其内部bug很难稳定复现与定位原因。&lt;br&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计基于锁的并发数据结构——更复杂的数据结构</title>
    <link href="https://xander.wiki/2021/07/22/%E8%AE%BE%E8%AE%A1%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://xander.wiki/2021/07/22/设计基于锁的并发数据结构——更复杂的数据结构/</id>
    <published>2021-07-22T07:00:00.000Z</published>
    <updated>2021-07-31T03:00:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>上一节所提及的栈和队列均是非常简单的数据结构，使用场景有限。本节将针对【查找表】，【链表】两种使用场景较丰富的数据结构，提供设计实例。<br><a id="more"></a></p><hr><h1 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h1><h2 id="设计前提与使用场景"><a href="#设计前提与使用场景" class="headerlink" title="设计前提与使用场景"></a>设计前提与使用场景</h2><p><code>std::map</code>是STL提供的现成查找表，其接口重度基于迭代器。从并发视角看，迭代器的线程安全性很难（并非不可能）保证，比如另一个线程可能正在删除本线程迭代器所引用的元素，此时很难验证迭代器是否已经失效。因此本次数据结构接口设计并不基于STL传统思想。</p><p>不同于栈和队列，查找表的主要使用场景是查找指定元素，而非修改表内数据（例如前文提及的DNS缓存）。本次设计的查找表具备几个基本操作：</p><ul><li>添加一个新的键/值对</li><li>修改给定键对应的值</li><li>删除一个键及其关联的值</li><li>通过给定键，获取对应的值（如有）</li></ul><p>除此以外还可以考虑增加一些全容器范围的操作，例如检查容器是否为空，提供当前完整键的快照，提供当前完整键值对的快照等。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>查找表接口的固有条件竞争在于：若两个线程同时试图添加key相同的KV对，则只有一个线程能够添加成功，因此必须修改接口，合并<strong>添加</strong>与<strong>修改</strong>为同一个成员函数。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>为了提高并发性，可以使用<code>std::shared_mutex</code>，保证支持多线程读取，单线程写入。</p><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>实现查找表的底层数据结构一般有三种；</p><ol><li>二叉树（AVL或红黑树）</li><li>有序数组</li><li>哈希表</li></ol><p>二叉树并没有为扩展并发提供太多可能，每一个查找或者修改操作都需要从访问根节点开始，因此，根节点需要上锁。虽然随着访问线程沿着树向下移动，这个锁可以释放，但相比横跨整个数据结构的单一锁，提升并不大。有序数组则更不适合，每一次修改或查找都必须锁住整个数组，毫无并发性可言。</p><p>对于哈希表而言，一个键属于哪个桶纯粹由键的属性以及哈希函数决定，每个桶都可以有一个独立的锁。若桶的数量为N，则并发访问的可能性约为数组的N倍（虽然需要挑选一个好的哈希函数）。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash=<span class="built_in">std</span>::hash&lt;Key&gt; &gt;</span><br><span class="line">class threadsafe_lookup_table &#123;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// member class</span></span><br><span class="line">  class bucket_type &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> bucket_value = <span class="built_in">std</span>::pair&lt;Key, Value&gt;;</span><br><span class="line">    <span class="keyword">using</span> bucket_data = <span class="built_in">std</span>::<span class="built_in">list</span>&lt;bucket_value&gt;;</span><br><span class="line">    <span class="keyword">using</span> bucket_iterator = <span class="keyword">typename</span> bucket_data::iterator;</span><br><span class="line">    <span class="keyword">using</span> bucket_const_iterator = <span class="keyword">typename</span> bucket_data::const_iterator;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    bucket_data data;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex mutex; <span class="comment">// C++17</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">bucket_const_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::find_if(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [&amp;](bucket_value <span class="keyword">const</span> &amp;item) &#123; <span class="keyword">return</span> item.first == key; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::find_if(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [&amp;](bucket_value <span class="keyword">const</span> &amp;item) &#123; <span class="keyword">return</span> item.first == key; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="keyword">const</span> &amp;key, Value <span class="keyword">const</span> &amp;default_value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">      bucket_const_iterator <span class="keyword">const</span> found_entry = find_entry_for(key);</span><br><span class="line">      <span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? default_value : found_entry-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="keyword">const</span> &amp;key, Value <span class="keyword">const</span> &amp;value)</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">      bucket_iterator found_entry = find_entry_for(key);</span><br><span class="line">      <span class="keyword">if</span> (found_entry == data.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        data.push_back(bucket_value(key, value));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        found_entry-&gt;second = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">      bucket_iterator found_entry = find_entry_for(key);</span><br><span class="line">      <span class="keyword">if</span> (found_entry != data.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        data.erase(found_entry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;bucket_type&gt;&gt; buckets;</span><br><span class="line">  Hash hasher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">bucket_type &amp;<span class="title">get_bucket</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="keyword">const</span> bucket_index = hasher(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">threadsafe_lookup_table</span><span class="params">(<span class="keyword">unsigned</span> num_buckets = <span class="number">19</span>, Hash <span class="keyword">const</span> &amp;hasher_ = Hash())</span> :</span></span><br><span class="line">      buckets(num_buckets), hasher(hasher_) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; num_buckets; ++i) &#123;</span><br><span class="line">      buckets[i].reset(<span class="keyword">new</span> bucket_type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_lookup_table(threadsafe_lookup_table <span class="keyword">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  threadsafe_lookup_table &amp;<span class="keyword">operator</span>=(threadsafe_lookup_table <span class="keyword">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="keyword">const</span> &amp;key, Value <span class="keyword">const</span> &amp;default_value = Value())</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get_bucket(key).value_for(key, default_value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="keyword">const</span> &amp;key, Value <span class="keyword">const</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    get_bucket(key).add_or_update_mapping(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> </span>&#123;</span><br><span class="line">    get_bucket(key).remove_mapping(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取快照</span></span><br><span class="line">  std::map&lt;Key, Value&gt; get_map() const &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt;&gt; locks;</span><br><span class="line">    <span class="comment">// 以相同顺序加锁，确保不会死锁</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      locks.push_back(<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt;(buckets[i]-&gt;mutex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;Key, Value&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> it = buckets[i]-&gt;data.cbegin(); it != buckets[i]-&gt;data.cend(); ++it) &#123;</span><br><span class="line">        res.insert(*it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="设计前提与使用场景-1"><a href="#设计前提与使用场景-1" class="headerlink" title="设计前提与使用场景"></a>设计前提与使用场景</h2><p>如前文所述，本次接口设计依然避免基于迭代器（STL风格迭代器生命周期不受容器控制，很难确保线程安全性）。</p><p>链表的常用场景有以下几点：</p><ul><li>添加一个项到链表</li><li>从链表中删除满足某个条件的项</li><li>从链表中查找满足某个条件的项</li><li>更新链表中满足某个条件的项</li><li>拷贝链表中的每一项到另一个容器中</li></ul><h2 id="基本设计思想"><a href="#基本设计思想" class="headerlink" title="基本设计思想"></a>基本设计思想</h2><p>令链表的每一个节点持有一个互斥锁，即可最大程度实现并发性（尽管互斥锁个数将随着链表长度增长而增长），每个操作仅需要锁住它需要的节点，并在关注点转向其他节点时释放该锁。</p><h2 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_list</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// member class</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;T&gt; data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span> &lt;node&gt; next;</span><br><span class="line"></span><br><span class="line">    node() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">node</span><span class="params">(T <span class="keyword">const</span> &amp;value)</span> : <span class="title">data</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(value))</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  node head; <span class="comment">// 哨兵节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_list() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~threadsafe_list() &#123; remove_if([](node <span class="keyword">const</span> &amp;) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;); &#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_list(threadsafe_list <span class="keyword">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  threadsafe_list &amp;<span class="keyword">operator</span>=(threadsafe_list <span class="keyword">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(T <span class="keyword">const</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span> &lt;node&gt; new_node(<span class="keyword">new</span> node(value));</span><br><span class="line">    <span class="built_in">std</span>::lock_guard &lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">    new_node-&gt;next = <span class="built_in">std</span>::<span class="built_in">move</span>(head.next);</span><br><span class="line">    head.next = <span class="built_in">std</span>::<span class="built_in">move</span>(new_node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">for_each</span><span class="params">(Function f)</span> </span>&#123;</span><br><span class="line">    node *current = &amp;head;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">    <span class="keyword">while</span> (node *<span class="keyword">const</span> next = current-&gt;next.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">      lk.unlock();</span><br><span class="line">      f(*next-&gt;data);</span><br><span class="line">      current = next;</span><br><span class="line">      lk = <span class="built_in">std</span>::<span class="built_in">move</span>(next_lk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;T&gt; find_first_if(Predicate p) &#123;</span><br><span class="line">    node *current = &amp;head;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">    <span class="keyword">while</span> (node *<span class="keyword">const</span> next = current-&gt;next.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">      lk.unlock();</span><br><span class="line">      <span class="keyword">if</span> (p(*next-&gt;data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">      &#125;</span><br><span class="line">      current = next;</span><br><span class="line">      lk = <span class="built_in">std</span>::<span class="built_in">move</span>(next_lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_if</span><span class="params">(Predicate p)</span> </span>&#123;</span><br><span class="line">    node *current = &amp;head;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">    <span class="keyword">while</span> (node *<span class="keyword">const</span> next = current-&gt;next.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">      <span class="keyword">if</span> (p(*next-&gt;data)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span> &lt;node&gt; old_next = <span class="built_in">std</span>::<span class="built_in">move</span>(current-&gt;next);</span><br><span class="line">        current-&gt;next = <span class="built_in">std</span>::<span class="built_in">move</span>(next-&gt;next);</span><br><span class="line">        next_lk.unlock(); <span class="comment">// 若无此语句，则将导致销毁已上锁的互斥锁——未定义行为</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lk.unlock();</span><br><span class="line">        current = next;</span><br><span class="line">        lk = <span class="built_in">std</span>::<span class="built_in">move</span>(next_lk);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><p>首先在锁外构建新节点，并默认初始化其next节点为nullptr。此后，在锁内获取当前头部节点，完成节点链接。由于只需要锁住一个互斥锁，因此死锁发生率为0。性能开销较大的内存分配位于锁外，无性能问题。</p><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><p>与大多数标准库算法类似，for_each将对Function对象执行值传递（确保无论是函数还是函数对象都能正常工作）。需要关注的点在于交叉(hand-over-hand)上锁。首先，锁住cur节点的互斥锁以安全访问其next节点。若该节点不为nullptr，则锁住该节点互斥锁，同时释放cur节点互斥锁，此后待函数执行完毕后，更新cur节点，并重新上锁cur。</p><h3 id="find-first-if"><a href="#find-first-if" class="headerlink" title="find_first_if"></a>find_first_if</h3><p>与for_each类似，区别在于一旦符合谓词则直接返回。</p><h3 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h3><p>交叉上锁的步骤与for_each类似。<br>若谓词返回true，此时更新cur-&gt;next断开链接，释放next对应的互斥锁，std::unique_ptr<node>将负责删除节点，cur无需更新（仍需检查后续节点）。<br>若谓词返回false，正常迭代。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;上一节所提及的栈和队列均是非常简单的数据结构，使用场景有限。本节将针对【查找表】，【链表】两种使用场景较丰富的数据结构，提供设计实例。&lt;br&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计基于锁的并发数据结构——并发数据结构实例</title>
    <link href="https://xander.wiki/2021/07/13/%E8%AE%BE%E8%AE%A1%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/"/>
    <id>https://xander.wiki/2021/07/13/设计基于锁的并发数据结构——并发数据结构实例/</id>
    <published>2021-07-13T07:00:00.000Z</published>
    <updated>2021-07-22T06:14:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>设计基于锁的数据结构的核心要旨：在持有锁时间最短的前提下，访问数据时锁住<strong>正确的</strong>互斥锁。若使用不同的互斥锁来保护数据结构中不同的部分，操作不当可能会导致死锁，因此更需小心。</p><a id="more"></a><hr><h1 id="使用锁的线程安全栈"><a href="#使用锁的线程安全栈" class="headerlink" title="使用锁的线程安全栈"></a>使用锁的线程安全栈</h1><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> <span class="built_in">std</span>::exception &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data; </span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_stack()&#123;&#125;</span><br><span class="line">  threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other) &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>; </span><br><span class="line">    data=other.data;</span><br><span class="line">  &#125;</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    data.push(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data.empty()) </span><br><span class="line">      <span class="keyword">throw</span> empty_stack();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(data.top())))</span></span>;</span><br><span class="line">    data.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack(); </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(data.top());</span><br><span class="line">    data.pop(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data.empty(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><ol><li>线程安全<br>通过使用互斥锁保护每个成员函数，确保任一时刻均只有一个线程在访问数据。</li><li><p>条件竞争<br>2.1 在<code>empty</code>和<code>pop</code>成员函数间有潜在的竞争条件(调用<code>empty</code>时是正确的，但其结果并不可靠：其返回后可能其他线程执行了<code>pop</code>操作），但<code>pop</code>在持有锁时将显式地判空，因此条件竞争无影响。<br>2.2 <code>pop</code>函数将直接返回栈顶数据，避免操作分离后<code>top</code>与<code>pop</code>潜在的竞争条件（具体可见<code>线程间共享数据——使用互斥量保护共享数据</code>一章）。</p></li><li><p>异常<br>3.1 对互斥锁上锁可能会抛出异常，但这种情况不仅极其罕见(互斥锁存在问题，或缺乏系统资源)，并且上锁是每个成员函数的第一个操作。由于没有数据被修改，因此异常安全。<br>3.2 解锁互斥锁不会失败，所以总是安全的，并且<code>std::lock_guard&lt;&gt;</code>确保了互斥锁不会一直处于上锁的状态。<br>3.3 在第一个重载的<code>pop</code>中，程序可能抛出一个<code>empty_stack</code>异常，由于没有数据被修改，所以是安全的。创建<code>res</code>可能会抛出一个异常，原因可能为：<code>std::make_shared</code>可能因为无法为新对象以及引用计数需要的数据分配出足够的内存而抛出异常，亦或在拷贝/移动数据到新分配内存时构造函数抛出异常。C++运行库与标准库将保证上述两种情况没有内存泄露，同时正确销毁新创建的对象（如有），由于没有数据被修改，因此异常安全。调用<code>data.pop</code>保证不会抛出异常。综上，该<code>pop</code>函数异常安全。<br>3.4 第二个重载的<code>pop</code>在拷贝赋值或移动赋值时可能抛出异常,但依旧没有数据修改，异常安全。<br>3.5 <code>empty</code>不会修改数据，异常安全。</p></li><li><p>死锁<br>由于持有锁时调用了用户代码——数据的拷贝/移动构造或拷贝/移动赋值运算符，亦或是自定义的new操作运算符，因此可能出现死锁，例如：<br>4.1 这些函数调用了栈上的成员函数(而栈正在插入或移除数据项)<br>4.2 这些函数内部持有一种锁，而在调用栈成员函数时又lock了内部的互斥锁，二者可能存在关联<br>因此必须令用户保证上述情况不会发生。</p></li><li><p>构造与析构<br>构造函数与析构函数没有上锁保护，因此可能存在安全问题。但不管并发与否，调用一个不完全构造的对象或是部分销毁的对象的成员函数永远都不可取。因此，用户必须确保2点：<br>5.1 其他线程直到栈完全构造才能访问它<br>5.2 在栈对象销毁前，所有线程都已经停止访问栈</p></li></ol><h2 id="实例缺陷"><a href="#实例缺陷" class="headerlink" title="实例缺陷"></a>实例缺陷</h2><p>尽管该数据结构安全性很高，但其性能非常差——每次只有一个线程能够操作栈内数据，而其他线程在等待锁时什么也干不了，过度的串行化抑制了性能。<br>同时，栈也未能提供等待添加一个数据项的方法——因此线程必须周期性地调用<code>empty</code>或<code>pop</code>，并捕获<code>empty_stack</code>异常。这逼迫用户要么浪费宝贵的计算资源来检查数据，要么编写等待——通知机制（如条件变量），这使得内部上锁没有必要。</p><hr><h1 id="使用锁的线程安全队列"><a href="#使用锁的线程安全队列" class="headerlink" title="使用锁的线程安全队列"></a>使用锁的线程安全队列</h1><h2 id="代码实例1"><a href="#代码实例1" class="headerlink" title="代码实例1"></a>代码实例1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue; </span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_queue.push(<span class="built_in">std</span>::<span class="built_in">move</span>(data)); </span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(data_queue.front())))</span></span>;</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(data_queue.front()); </span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(data_queue.front())))</span></span>; </span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.empty(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实例1分析"><a href="#实例1分析" class="headerlink" title="实例1分析"></a>实例1分析</h2><p>相对栈的实现，主要差别有2点：</p><ol><li>新增了条件变量，不再需要线程持续调用<code>empty</code></li><li><code>try_pop</code>不再抛出异常，转为返回bool量</li></ol><p>在异常安全性方面存在一个细微变化：由于使用的是<code>notify_one</code>，因此在多线程等待时，只会有一个线程被唤醒。但如果该线程在<code>wait_and_pop</code>中抛出一个异常(如构造<code>std::shared_ptr&lt;&gt;</code>对象时），此时队列不为空，但不会有其他线程被唤醒。若当前使用环境无法接受这种情况，存在三种修改方案：</p><ol><li>将<code>notify_one</code>调用可以替换成<code>notify_all</code>，它将唤醒所有的工作线程，代价是大多数线程发现队列依旧是空时将重新进入休眠状态。</li><li>有异常抛出时令<code>wait_and_pop</code>调用<code>notify_one</code>，从而让另一个线程尝试检索队列内数据。</li><li>将<code>std::shared_ptr&lt;&gt;</code>的初始化过程移到<code>push</code>中，队列由存储数据实例转为存储<code>std::shared_ptr&lt;&gt;</code>实例，由于<code>std::shared_ptr&lt;&gt;</code>拷贝不会抛出异常，由此即可保证异常安全性。</li></ol><h2 id="代码实例2"><a href="#代码实例2" class="headerlink" title="代码实例2"></a>代码实例2</h2><p>根据方案3，有代码实例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; &gt; data_queue; </span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(*data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(*data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">data</span><span class="params">( <span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_queue.push(data);</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.empty(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="实例2分析"><a href="#实例2分析" class="headerlink" title="实例2分析"></a>实例2分析</h2><p>除去解决前文所述的问题外，使用<code>std::shared_ptr&lt;&gt;</code>还有一大优点：<code>push</code>内数据实例的构造可以在锁外完成。一般来说，内存分配的性能开销较大，若将其置于锁内将增加持有锁的时间，不利于数据结构的性能。</p><hr><h1 id="使用细粒度锁和条件变量的线程安全队列"><a href="#使用细粒度锁和条件变量的线程安全队列" class="headerlink" title="使用细粒度锁和条件变量的线程安全队列"></a>使用细粒度锁和条件变量的线程安全队列</h1><p>&nbsp;<br>上文所提及的两种线程安全数据结构，本质上均为使用互斥锁保护<code>STL</code>容器，尽管易于实现，但其并发程度较低。通过精心设计底层数据结构，开发者可以提供更细粒度的锁定，从而进一步提高并发程度。</p><h2 id="基于单链表实现的队列"><a href="#基于单链表实现的队列" class="headerlink" title="基于单链表实现的队列"></a>基于单链表实现的队列</h2><p>最简单的队列是单链表，如下图所示。<br><img src="http://static.zybuluo.com/zsmj2017/p0pm8bxn760i6if798hii7mj/image.png" alt="image.png-84.7kB"><br>队列维护着一个头指针和一个尾指针，分别指向链表的首项数据与末项数据。<code>push</code>操作为添加新数据为tail的next，并更新tail，<code>pop</code>操作即为更新head为其next，此后切断联系。<br>当<code>head==tail==nullptr</code>时，链表为空。具体实例如下。</p><h3 id="代码实例（单线程版）"><a href="#代码实例（单线程版）" class="headerlink" title="代码实例（单线程版）"></a>代码实例（单线程版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    T data; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">    node(T data_): data(<span class="built_in">std</span>::<span class="built_in">move</span>(data_)) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">  node* tail; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">queue</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(head-&gt;data)))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head=<span class="built_in">std</span>::<span class="built_in">move</span>(head); </span><br><span class="line">    head=<span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>; </span><br><span class="line">    node* <span class="keyword">const</span> new_tail=p.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span>(tail) &#123;</span><br><span class="line">      tail-&gt;next=<span class="built_in">std</span>::<span class="built_in">move</span>(p); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      head=<span class="built_in">std</span>::<span class="built_in">move</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    tail=new_tail;<span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p>该队列使用了<code>std::unique_ptr&lt;node&gt;</code>来管理节点，从而保证了节点和其引用数据将在不需要时自动删除，tail是指向最后一个节点的裸指针，因为它需要引用<code>std::unique_ptr&lt;node&gt;</code>已经拥有的节点(代码1处p已经被move)。</p><p>在多线程下使用细粒度锁时，开发者可能会倾向于使用2个互斥锁分别保护两个数据项<code>head</code>与<code>tail</code>，但存在以下问题：</p><ol><li><code>push</code>可能同时修改head与tail，因此它必须锁住两个互斥锁——虽然很少见，但同时锁住两个互斥锁还不算太诡异。</li><li><code>push</code>和<code>try_pop</code>都能访问next指针指向的节点:<code>push</code>更新tail-&gt;next，然后<code>try_pop</code>读取head-&gt;next。若队列中只有一个元素（head==tail），此时head-&gt;next和tail-&gt;next是同一个需要保护的对象。若不同时读取head和tail，开发者无法区分它们是否是同一个对象，因此必须在<code>push</code>与<code>try_pop</code>内锁住同一个锁（用来保护next数据）。</li></ol><hr><h3 id="实例改进（增加尾部哨兵）"><a href="#实例改进（增加尾部哨兵）" class="headerlink" title="实例改进（增加尾部哨兵）"></a>实例改进（增加尾部哨兵）</h3><p>开发者可以通过分配尾哨兵来解决问题，此时tail将不再指向具体数据，而是承担哨兵角色。为了允许哨兵的存在（没有数据），需要增加额外的一层间接性——通过指针来存储数据，具体代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next; </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">  node* tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">queue</span>():head(<span class="keyword">new</span> node),tail(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>()==tail) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(head-&gt;data)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head=<span class="built_in">std</span>::<span class="built_in">move</span>(head); </span><br><span class="line">    head=<span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    tail-&gt;data=new_data; <span class="comment">// 若tail==head,此时head亦被赋值</span></span><br><span class="line">    node* <span class="keyword">const</span> new_tail=p.<span class="built_in">get</span>(); </span><br><span class="line">    tail-&gt;next=<span class="built_in">std</span>::<span class="built_in">move</span>(p);</span><br><span class="line">    tail=new_tail; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="实例比较"><a href="#实例比较" class="headerlink" title="实例比较"></a>实例比较</h4><ol><li><p>构造函数中新增了对虚拟节点的创建</p></li><li><p><code>try_pop</code>的改动为：<br>2.1 将检查head是否为nullptr替换为比较head与tail，因为引入虚拟节点后head将不可能为nullptr。<br>2.2 直接返回指针，不再需要创建新一个新实例。</p></li><li><p><code>push</code>的改动为:<br>3.1 必须先在堆上创建一个T类型的实例，并让一个<code>std::shared_ptr&lt;&gt;</code>拥有该实例。<br>3.2 将原有哨兵节点数据替换为新实例，连接至新哨兵，并更新哨兵节点。</p></li></ol><h4 id="改进收益"><a href="#改进收益" class="headerlink" title="改进收益"></a>改进收益</h4><ol><li><code>push</code>只需访问tail，不再访问head，这意味着不需要持有2个互斥锁。</li><li><code>try_pop</code>与<code>push</code>将永远不可能对同一节点做操作（head-&gt;next与tail-&gt;next一致时，队列为空，此时直接返回），因此不再需要一个总的互斥锁。</li></ol><hr><h3 id="代码实例（加锁）"><a href="#代码实例（加锁）" class="headerlink" title="代码实例（加锁）"></a>代码实例（加锁）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next; </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::mutex head_mutex; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head; </span><br><span class="line">  <span class="built_in">std</span>::mutex tail_mutex; </span><br><span class="line">  node* tail;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">node* <span class="title">get_tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>() == get_tail()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head=<span class="built_in">std</span>::<span class="built_in">move</span>(head); </span><br><span class="line">    head = <span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue(): head(<span class="keyword">new</span> node),tail(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp; other)=<span class="keyword">delete</span>; </span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = pop_head();</span><br><span class="line">    <span class="keyword">return</span> old_head ? old_head-&gt;data : <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    node* <span class="keyword">const</span> new_tail = p.<span class="built_in">get</span>(); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>; </span><br><span class="line">    tail-&gt;data = new_data;</span><br><span class="line">    tail-&gt;next = <span class="built_in">std</span>::<span class="built_in">move</span>(p);</span><br><span class="line">    tail=new_tail;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实例分析-3"><a href="#实例分析-3" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>为了实现最大程度的并发，上锁的时间越少越好。因此<code>push</code>与<code>try_pop</code>有设计思路如下：</p><ol><li>push<br>访问tail期间均必须完成上锁，因此分配完成性哨兵节点后上锁开始，直至函数完成。</li><li>try_pop<br>首先必须锁住head，直至head完成改变（该操作决定了哪一个线程执行pop操作）。其次，由于判空需要获取tail，因此在此期间必须完成对tail的锁定。<br>将<code>pop_head</code>与<code>get_tail</code>封装为函数不仅提高了代码可读性，同时也使得互斥区更加明确。</li></ol><h4 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h4><h5 id="不变量"><a href="#不变量" class="headerlink" title="不变量"></a>不变量</h5><p>针对该基于单链表实现的队列，有不变量如下:</p><ul><li>tail-&gt;next==nullptr</li><li>tail-&gt;data==nullptr</li><li>head==tail意味着空链表</li><li>单元素链表有head-&gt;next==tail</li><li>x-&gt;next==tail意味着x是链表中最后一个节点</li><li>以head为起点迭代，必将访问至tail</li></ul><h5 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h5><ol><li>push<br>如前文所述，数据被正确保护，不变量未遭到破坏。</li><li>try_pop<br>2.1 该函数需要在读取head，tail时加锁以避免数据竞争。如果tail不加锁，则可能出现数据竞争或UB：一个线程调用try_pop的同时，另一个线程调用push，此时可能两个线程在访问同一个tail对象（尽管每个成员函数都加锁了，但<code>pop</code>与<code>try_pop</code>持有的是不同的锁）。加锁后<code>get_tail</code>将会锁住和<code>push</code>相同的锁，因此调用将存在明确顺序：要么<code>get_tail</code>将在<code>push</code>前被调用，线程看到的是tail旧值；要么在<code>push</code>后被调用，线程将观察到tail新值。<br>2.2 <code>get_tail</code>的调用必须发生于<code>head_mutex</code>互斥区内<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error version</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node* <span class="keyword">const</span> old_tail = get_tail();</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>(head.<span class="built_in">get</span>() == old_tail) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = <span class="built_in">std</span>::<span class="built_in">move</span>(head); </span><br><span class="line">  head=<span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">  <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当进入<code>head_mutex</code>的互斥区后，很有可能tail与head的值已经发生了改变（另一个线程完成了push或者正在调用pop_head修改head），此后的判空无意义。若<code>get_tail</code>在<code>head_mutex</code>保护范围内，即可保证没有其他线程对head进行修改，判空符合预期。</li></ol><h5 id="异常安全分析"><a href="#异常安全分析" class="headerlink" title="异常安全分析"></a>异常安全分析</h5><ol><li><code>try_pop</code>锁住互斥锁时可能产生异常，但由于在获得锁前数据不会被修改，因此<code>try_pop</code>异常安全。</li><li><code>push</code>在堆上分配数据实例和node实例时（new语句）可能会产生异常，但智能指针保证了异常安全性。获得锁后，<code>push</code>内操作不会产生异常，因此<code>push</code>异常安全。</li></ol><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p><code>pop_head</code>获取锁的顺序永远是先head_mutex再tail_mutex，因此永远不会死锁。</p><h4 id="并发性分析"><a href="#并发性分析" class="headerlink" title="并发性分析"></a>并发性分析</h4><p>细粒度锁的引入带来了更高的并发性，并且本实例已尽可能将操作置于锁外。举例而言，<code>push</code>中新节点和新数据项的分配都未曾持有锁，这保证了多个线程可以并发地分配新节点新数据项。在<code>try_pop</code>中较为耗时的<code>delete</code>同样置于锁外，这增加了并发调用<code>try_pop</code>的次数。</p><hr><h3 id="实例完善（增加wait-and-pop）"><a href="#实例完善（增加wait-and-pop）" class="headerlink" title="实例完善（增加wait_and_pop）"></a>实例完善（增加wait_and_pop）</h3><p>本节将针对上述实例做进一步完善，新增<code>wait_and_pop</code>接口，并补充<code>pop</code>接口重载版本。</p><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><ol><li>push<br>简单来看，只需要在函数末尾添加<code>data_cond.notify_one()</code>调用即可，但此时处于tail_mutex被锁住的状态，若被通知的线程在tail_mutex解锁前醒来，则需要等待该互斥锁解锁，因此可以考虑在调用<code>notify_one</code>前解锁互斥锁以获得最大并发性。</li><li>wait_and_pop<br>首先，仅有在队列非空时（head != tail）需要等待，因此似乎需要同时锁住两个互斥锁，但正如前文所述（只有在读取时需要持有互斥锁），因此谓词可设定为<code>head!=get_tail()</code>即可，然后使用head_mutex对data_cond.wait()调用进行保护。</li><li>重载pop<br>若将从old_head检索得到的数据项拷贝赋值至value，若拷贝赋值操作抛出异常，则数据量将彻底丢失（队列中已不存在数据）。因此必须新增一个重载的<code>pop_head</code>函数，在改动链表前检索数据。</li></ol><h4 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next; </span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex head_mutex; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head; </span><br><span class="line">  <span class="built_in">std</span>::mutex tail_mutex;</span><br><span class="line">  node* tail; </span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue(): head(<span class="keyword">new</span> node),tail(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp; other)=<span class="keyword">delete</span>; </span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = try_pop_head();</span><br><span class="line">    <span class="keyword">return</span> old_head?old_head-&gt;data:<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head = try_pop_head(value);</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head = wait_pop_head();</span><br><span class="line">    <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head = wait_pop_head(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>; </span><br><span class="line">      tail-&gt;data=new_data;</span><br><span class="line">      node* <span class="keyword">const</span> new_tail=p.<span class="built_in">get</span>(); </span><br><span class="line">      tail-&gt;next=<span class="built_in">std</span>::<span class="built_in">move</span>(p);</span><br><span class="line">      tail=new_tail; </span><br><span class="line">    &#125;</span><br><span class="line">    data_cond.notify_one(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (head.<span class="built_in">get</span>()==get_tail());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">node* <span class="title">get_tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head=<span class="built_in">std</span>::<span class="built_in">move</span>(head);</span><br><span class="line">    head=<span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> old_head; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    data_cond.wait(head_lock,[&amp;]&#123;<span class="keyword">return</span> head.<span class="built_in">get</span>()!=get_tail();&#125;); </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">move</span>(head_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保数据被修改时持有同一把锁</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> pop_head(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> pop_head();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">try_pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>()==get_tail()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pop_head(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">try_pop_head</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>()==get_tail()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> pop_head(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;设计基于锁的数据结构的核心要旨：在持有锁时间最短的前提下，访问数据时锁住&lt;strong&gt;正确的&lt;/strong&gt;互斥锁。若使用不同的互斥锁来保护数据结构中不同的部分，操作不当可能会导致死锁，因此更需小心。&lt;/p&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计基于锁的并发数据结构——并发设计纲要</title>
    <link href="https://xander.wiki/2021/07/08/%E8%AE%BE%E8%AE%A1%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E7%BA%B2%E8%A6%81/"/>
    <id>https://xander.wiki/2021/07/08/设计基于锁的并发数据结构——并发设计纲要/</id>
    <published>2021-07-08T07:00:00.000Z</published>
    <updated>2021-07-08T09:09:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>选择与设计正确的数据结构是解决方案设计的重中之重，并发编程亦不例外。若某种数据结构存在被多线程访问的可能性，除非其具备只读属性，否则必然需要保证数据变化在线程间被正确同步，对于此，一般有两种设计方案：</p><ol><li>使用独立的互斥锁以及外部加锁来保护数据</li><li>设计自身支持并发访问的数据结构</li></ol><p>本章将重点论述第二点。<br><a id="more"></a></p><hr><h1 id="何谓并发设计"><a href="#何谓并发设计" class="headerlink" title="何谓并发设计"></a>何谓并发设计</h1><p>&nbsp;<br>线程安全(thread-safe)：若存在某种数据结构，支持多线程并发访问，所有线程均可观察到该结构<strong>前后一致</strong>的视图，施加于该数据结构的任意操作均保证不会造成数据丢失或损坏，且不会造成数据竞争，则称该数据结构线程安全。通常场景下，数据结构可能仅需要保证特定的并发访问“安全”即可，例如“保证在多线程读与单线程写的情景下安全”，或者“多线程执行不同操作时安全”。</p><p>前文曾提及的互斥锁可以为数据结构提供保护(一次仅能有一个线程获得互斥锁)，究其本质，即显式阻止对被保护数据的真正并发访问。这被称为串行化(serialization)——各线程轮流，以串行而非并行的方式访问保护数据。</p><p>使用互斥锁包裹<strong>全部</strong>数据显然不是并发设计——真正的设计意味着需要为多线程提供并发访问保护数据的机会。尽管不同场景，不同数据结构所需要的并发范围大小各有差异，但基本设计思想是一致的：保护区越小，串行化操作就越少，并发的潜力就越大。</p><hr><h1 id="并发设计纲要"><a href="#并发设计纲要" class="headerlink" title="并发设计纲要"></a>并发设计纲要</h1><p>&nbsp;</p><p>如上文所说，并发设计主要需要考虑2点：</p><ol><li>确保访问安全</li><li>允许真正的并发访问</li></ol><h2 id="访问安全"><a href="#访问安全" class="headerlink" title="访问安全"></a>访问安全</h2><p>在<code>线程间共享数据</code>一章中曾对保证数据结构线程安全的基础要点有所介绍：</p><ul><li>除修改线程外，没有线程能看到数据被修改时的中间状态。</li><li>提供完整操作（而非一个个操作步骤）的函数以避免接口固有的竞争条件。</li><li>避免异常行为暴露数据的中间状态。</li><li>限制锁的范围，避免嵌套锁，尽力避免死锁。</li></ul><p>同时，我们也需要考虑对数据结构的使用者施加何种约束：若当前存在线程A通过一个特定函数对数据结构进行访问，那么其他线程能安全使用哪些函数？<br>通常，构造函数和析构函数需要互斥地访问数据结构，但需要用户保证不会在构造函数完成前/析构函数完成后访问数据结构。若该数据结构支持<code>copy assignment</code>，<code>swap</code>或<code>copy ctor</code>，则我们必须决定这些操作与其他操作并发调用时使用安全，或者它们是否必须要求用户保证互斥访问。</p><h2 id="并发访问"><a href="#并发访问" class="headerlink" title="并发访问"></a>并发访问</h2><p>在设计数据结构之前，我们必须扪心自问</p><ul><li>是否可以限制锁的作用范围，以允许操作的某些部分在锁外执行？</li><li>数据结构不同部分能否被不同的互斥锁保护?</li><li>所有的操作需要同一级别的保护吗?</li><li>是否可以在不影响操作语义的前提下修改数据结构，增加其得以被并发访问的可能？</li></ul><p>上述问题的核心是——如何最小化必须的串行操作，使真实的并发最大化?<br>就实际使用场景而言，只读线程并发访问，修改线程互斥访问的案例较为常见（可以通过使用<code>std::shared_thread</code>实现）。后文将提及另一种常见场景:串行执行执行同一操作，并发执行不同操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;选择与设计正确的数据结构是解决方案设计的重中之重，并发编程亦不例外。若某种数据结构存在被多线程访问的可能性，除非其具备只读属性，否则必然需要保证数据变化在线程间被正确同步，对于此，一般有两种设计方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用独立的互斥锁以及外部加锁来保护数据&lt;/li&gt;
&lt;li&gt;设计自身支持并发访问的数据结构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章将重点论述第二点。&lt;br&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++内存模型与原子类型操作——同步操作与强制顺序</title>
    <link href="https://xander.wiki/2021/06/24/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%BC%BA%E5%88%B6%E9%A1%BA%E5%BA%8F/"/>
    <id>https://xander.wiki/2021/06/24/C++内存模型与原子类型操作——同步操作与强制顺序/</id>
    <published>2021-06-24T07:00:00.000Z</published>
    <updated>2021-07-07T10:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>一段经典的生产-消费场景代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!data_ready.load()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep(<span class="built_in">std</span>::milliseconds(<span class="number">1</span>)); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"The answer="</span>&lt;&lt;data[<span class="number">0</span>]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data.push_back(<span class="number">42</span>);</span><br><span class="line">  data_ready=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我们利用原子操作，保证了写入操作必然“先发生于”读取操作。不过，原子操作对顺序要求还有其他选项，它们构成了原子操作间的各种关系，下文将一一说明。<br><a id="more"></a></p><hr><h1 id="“同步于”"><a href="#“同步于”" class="headerlink" title="“同步于”"></a>“同步于”</h1><p>&nbsp;<br>“同步于”关系只能在原子类型的操作间获得。如果UDT（user-defined-type）包含原子类型，并且施加于UDT实例的行为内包含有原子操作(例如锁住互斥锁) 亦可提供这种关系。但本质上，该关系仅与原子操作绑定。</p><p>其基本概念为：对于变量x，若当前存在两种操作：一个适当标记（suitably-tagged）的原子写操作W，与一个适当标记的原子读操作R，W “同步于” R。在这种同步关系下，R要么读取到的是W操作写入的内容，要么读取到的是执行W操作的线程内，W操作后续的写操作所写入的值。</p><p>由于所有对原子操作类型的操作默认均为适当标记（suitably-tagged），因此我们可以简化“同步于”关系为：如果线程A存储了一个值，并且线程B读取了这个值，则在默认情况下，线程A的存储操作与线程B的加载操作之间有一个“同步于”关系，如图所示：<br><img src="http://static.zybuluo.com/zsmj2017/ydyg15n8mt9ozb48owqrfbf0/image.png" alt="image.png-234.1kB"></p><p>原子操作内的细微差别都来自于“适当标记”部分，C++内存模型允许对原子类型的操作应用各种顺序约束，这就是所谓的标记。</p><hr><h1 id="“先发生于”"><a href="#“先发生于”" class="headerlink" title="“先发生于”"></a>“先发生于”</h1><p>&nbsp;<br>“先发生于”(happens-before)关系是程序中操作顺序的基础构件——它指定了哪些操作能看见另一些操作的影响。</p><p>对于单线程而言，确保“先发生于”关系很简单——只需要在源码中确保操作A先于操作B出现，则存在操作A必在操作B前发生。如果操作A与操作B发生于同一个语句，则不能确保存在“先发生于”关系，例如下述程序可能输出“1，2”或“2，1”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;”,”&lt;&lt;b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ++i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  foo(get_num(),get_num()); <span class="comment">//无序调用get_num()，未定义行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了避免混淆，我们将单线程内操作A必然发生于操作B之前的关系称为“先序于”（sequenced-before），而将线程间的操作A必然发生另一个线程内操作B之前的关系称为“线程间先发生于”（inter-thread happens-before）。</p><p>对于“线程间先发生于”而言，若一个线程内的操作A与另一个线程内的操作B同步，则有A“线程间先发生于”B。该关系具备传递性，即若A“线程间先发生于”B，且B“线程间先发生于”C，则A“线程间先发生于” C。</p><p>“线程间先发生于”亦可和“先序于”相结合:若操作A“先序于”操作B，且操作B“线程间先发生于”操作C，则有A“线程间先发生于”C。类似地，如果 A“同步于”B，且B“先序于”C，则A“线程间先发生于”C。</p><hr><h1 id="原子操作的内存顺序"><a href="#原子操作的内存顺序" class="headerlink" title="原子操作的内存顺序"></a>原子操作的内存顺序</h1><p>&nbsp;<br>正如前文已经提及到的，原子操作共计可以指定六种内存顺序，默认使用memory_order_seq_cst（最严格）：</p><ol><li>memory_order_relaxed</li><li>memory_order_consume</li><li>memory_order_acquire</li><li>memory_order_release</li><li>memory_order_acq_rel</li><li>memory_order_seq_cst</li></ol><p>尽管内存顺序存在六种，但它们仅代表三种内存顺序模型：</p><ol><li>序列一致 (sequentially consistent) </li><li>获得-释放 (acquire-release)：memory_order_consume, memory_order_acquire, memory_order_release，memory_order_acq_rel</li><li>宽松 (relaxed)：memory_order_relaxed</li></ol><p>不同的内存顺序模型在不同的CPU架构下成本不同。举例而言，在基于通过处理器精细控制操作可见性的架构(而非更改可见性的架构)的系统上，“序列一致”顺序相较于“获得-释放”或者“宽松”需要额外的同步指令，“获得-释放”顺序相较于“宽松”也是如此。如果这些系统有很多处理器，额外的同步指将会花费大量的时间，从而降低系统整体性能。另一方面，使用x86或x86-64架构的CPU(比如使用Intel或AMD处理器的台式电脑) 除了执行确保原子性所必须的指令之外，不需要为“获得-释放”执行额外指令，甚至“序列一致”对于加载操作也不需要任何特殊处理，尽管在数据存储层面增加了些许成本。</p><p>不同内存顺序模型保证了开发者得以使用更细粒度的顺序关系对程序性能做出提升，下文将依介绍它们的特点及应用范围。</p><hr><h2 id="序列一致"><a href="#序列一致" class="headerlink" title="序列一致"></a>序列一致</h2><p>序列一致是最容易被理解的内存顺序，因此C++将其定义为默认内存顺序。若原子类型实例上的所有操作均遵循“序列一致”的，则多线程程序的行为将类似于所有操作都是由单个线程按照某种特定的序列执行的——所有线程必须看到相同的操作顺序，不允许存在重新排序的操作。这种约束不适用于使用“宽松”内存顺序原子操作的线程——它们仍然可以看到不同顺序的操作，因此必须在所有线程上使用“序列一致”的操作，才能受益。</p><p>下述代码演示了这种顺序约束的作用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(y.load(<span class="built_in">std</span>::memory_order_seq_cst))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_seq_cst))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(write_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join();</span><br><span class="line">  c.join();</span><br><span class="line">  d.join(); </span><br><span class="line">  assert(z.load()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>assert语句将永远无法触发，因为必将发生存储x或存储y（虽然未指定哪一个）。若在<code>read_x_then_y</code>中加载y返回false（存储x的操作发生在存储y的操作之前），则<code>read_y_then_x</code>中加载x必定会返回true（while循环将保证此刻y已为true）。因为memory_order_seq_cst语义需要在所有标记为memory_order_seq_cst的操作上有一个单一全序，因此在“加载y返回 false”与“存储y”的操作之间存在一个隐含的顺序关系。由于单个全序，当一个线程看到x==true，随后又看到y==false，即意味着在此全序中存储x的操作发生在存储y的操作之前。当然，这个假设是对称的，亦可能存在完全相反的情况，此时先存储y后存储x。</p><p>从同步的角度来看，一个“序列一致”的存储操作“同步于”相同变量的加载操作，这个加载操作读取存储的值，这为两个(或更多)线程的操作提供了一个顺序约束，但“序列一致”的约束性比上述描述的更强。对系统中使用“序列一致”原子操作的其他线程，任何加载操作之后执行的“序列一致”的原子操作也必须出现在存储操作之后。</p><p>针对read_x_then_y看x为true，且y为false的情况，有图例如下。虚线展示了为了保持“序列一致”而隐含的必须的顺序关系——在 memory_order_seq_cst操作的全局顺序中，为了获得这里给出的结果，加载操作必须在存储操作之前发生。<br><img src="http://static.zybuluo.com/zsmj2017/0ab1ct7dl4ju0kc1sypp3ukd/image.png" alt="image.png-287.1kB"></p><p>“序列一致”是最简单直观的顺序，也是最昂贵的内存顺序，因为它需要所有线程间进行全局同步。在一个多处理器系统上，这可能需要在处理器之间进行大量并且耗时的通信。</p><hr><h2 id="非序列一致"><a href="#非序列一致" class="headerlink" title="非序列一致"></a>非序列一致</h2><h3 id="宽松"><a href="#宽松" class="headerlink" title="宽松"></a>宽松</h3><p>原子类型上的操作以宽松顺序执行时，不会参与任何“同步于”关系。在同一线程内，对于同一变量的操作服从“先序于”关系。而线程间几乎没有任何顺序要求，唯一特例是线程访问单个的原子变量不能重排——当线程看到一个原子变量的特定值后，该线程随后的读操作将无法检索到这个变量更早的值。以下代码实例将展示宽松顺序的影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join(); </span><br><span class="line">  assert(z.load()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次assert可能会触发，因为加载x的操作可能读取到false，即使加载y的操作读取到true，并且存储x的操作“先发生于”存储y的操作。由于x，y是不同的变量，因此各操作对其数据可见性并不做顺序性保证。</p><p>宽松顺序对于不同变量可以自由重排，只需遵守约束“先发生于”关系即可(例如读取到y为true后，仅能保证接下来该线程不会读取到y为true之前的值)，它不会引入“同步于”关系。尽管在存储与存储，加载与加载操作间存在着“先发生于”关系，但存储和加载间并不存在这种关系，因此载入操作可以看到次序颠倒的存储操作，下图展示了这种关系。<br><img src="http://static.zybuluo.com/zsmj2017/87l6exoj7ney3p024g9qdwe2/image.png" alt="image.png-106.4kB"></p><h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>接下来关注一个略微复杂点的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">std::atomic&lt;int&gt; x(0),y(0),z(0);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">go</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">const</span> loop_count=<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_values</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y,z; </span><br><span class="line">&#125;;</span><br><span class="line">read_values values1[loop_count]; </span><br><span class="line">read_values values2[loop_count]; </span><br><span class="line">read_values values3[loop_count]; </span><br><span class="line">read_values values4[loop_count]; </span><br><span class="line">read_values values5[loop_count];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;* var_to_inc,read_values* values)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!go)</span><br><span class="line">    <span class="built_in">std</span>::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 自旋，等待信号</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i) &#123;</span><br><span class="line">    values[i].x=x.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    values[i].y=y.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    values[i].z=z.load(<span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">    var_to_inc-&gt;store(i+<span class="number">1</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">std</span>::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_vals</span><span class="params">(read_values* values)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!go)</span><br><span class="line">    <span class="built_in">std</span>::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 自旋，等待信号</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i) &#123;</span><br><span class="line">    values[i].x=x.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    values[i].y=y.load(<span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">    values[i].z=z.load(<span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">    <span class="built_in">std</span>::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(read_values* v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i) </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;v[i].x&lt;&lt;<span class="string">","</span>&lt;&lt;v[i].y&lt;&lt;<span class="string">","</span>&lt;&lt;v[i].z&lt;&lt;<span class="string">")"</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(increment,&amp;x,values1)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(increment,&amp;y,values2)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(increment,&amp;z,values3)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(read_vals,values4)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t5</span><span class="params">(read_vals,values5)</span></span>;</span><br><span class="line">  go=<span class="literal">true</span>; <span class="comment">// 开始执行主循环的信号</span></span><br><span class="line">  t5.join();</span><br><span class="line">  t4.join();</span><br><span class="line">  t3.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  t1.join();</span><br><span class="line">  <span class="built_in">print</span>(values1);</span><br><span class="line">  <span class="built_in">print</span>(values2);</span><br><span class="line">  <span class="built_in">print</span>(values3);</span><br><span class="line">  <span class="built_in">print</span>(values4);</span><br><span class="line">  <span class="built_in">print</span>(values5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序内有三个全局原子变量和五个线程。每一个线程循环10次，使用memory_order_relaxed读取三个原子变量的值，并且将它们存储在一个数组上。其中三个线程每次通过循环来更新其中一个原子变量，而剩下的两个线程负责读取。当线程都被joined了，则打印出每个线程存到数组上的值。如果没有明确的延迟，第一个线程可能在最后一个线程开始前结束，因此使用原子变量go来确保线程尽可能接近同一时间开始循环。一旦go被设定为true，则所有线程均将开始执行。</p><p>该程序一种可能的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,7,0),(6,7,8),(7,9,8),(8,9,8), (9,9,10) &#x2F;&#x2F; increment</span><br><span class="line">(0,0,0),(0,1,0),(0,2,0),(1,3,5),(8,4,5),(8,5,5),(8,6,6),(8,7,9),(10,8,9), (10,9,10) &#x2F;&#x2F; increment</span><br><span class="line">(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,0,4),(0,0,5),(0,0,6),(0,0,7),(0,0,8), (0,0,9) &#x2F;&#x2F; increment</span><br><span class="line">(1,3,0),(2,3,0),(2,4,1),(3,6,4),(3,9,5),(5,10,6),(5,10,8),(5,10,10), (9,10,10),(10,10,10) &#x2F;&#x2F; read</span><br><span class="line">(0,0,0),(0,0,0),(0,0,0),(6,3,7),(6,5,7),(7,7,7),(7,8,7),(8,8,7),(8,8,9), (8,8,9) &#x2F;&#x2F; read</span><br></pre></td></tr></table></figure></p><p>我们可以关注到几点：</p><ol><li>线程1中x每次增1，线程2中y每次增1，线程3中z每次增1。</li><li>在给定输出集合中，x，y，z均为不均匀增序，且相对顺序在各线程中不同。</li><li>线程3只关注到了z的更新，无视x与y的更新，但不影响其他线程可以关注到z的更新。</li></ol><h3 id="类比分析"><a href="#类比分析" class="headerlink" title="类比分析"></a>类比分析</h3><p>想象每个原子变量是一个小隔间里的办事员，它拿着小本子记录着一个列表（变量值的历史版本）。当你要一个值的时候，它就从列表中取出一个值给你（load），如果你想写入一个值，那它就把这个新值写在列表的最后（store）。</p><p>当然，读取值是有一定规则的。当你第一次向它获取值时，它可能会给你列表中的任意值。此后如果你继续要，它可能会给你同一个值，或者出现在该值后的任意值。如果你写入一个值后再向它要一个值，则要么给你你写入的值，要么给你出现在该值后的任意值。（先发生于）</p><p>举个例子，若它的列表上开始有5，10，23，3，1，2这几个值。如果你问他要一个值， 你可能获取这几个数中的任意一个。假设它给你10，那么下次再问它要值的时候可能会再给你10，或者10 后面的数，但绝对不会是5。如果连续要5次，它可能回复“10，10，1，2，2”。如果你要它写下42，则它会将列表更新为“5，10，23，3，1，2，42”，此后将只会向你提供42这个值，直到有新值被写入后它才有可能给你新值。</p><p>现在让情况复杂一些——假设当前存在多个人对这个可怜的办事员发号施令，但它一次只能处理一个人的请求，为了确保能保证每个人拿到的新值都符合上述规则，它选择使用一个便利贴指向各个值，用以标识当前各人的所了解到的列表状态，具体如下图所示：<br><img src="http://static.zybuluo.com/zsmj2017/w9yacv1ey7kt32ipevwpenko/image.png" alt="image.png-223.3kB"></p><p>那么上一个实例的输出就很容易理解了——<code>write_x_then_y</code>函数就类似于A通知x办事员写下 true，之后又通知y办事员写下true。线程反复运行<code>read_y_then_x</code>就类似于B反复向y要值，直到它说true，然后再向x要值。x没必要告诉B最新值true，它完全有可能告诉B false。</p><p>除此之外，该办事员也支持一些其他操作，例如“写下这个数字，并且告诉我现在列表中的最后一个数字”(exchange)，或“当列表的最后一个数字为某值则写下这个数字;否则的话，告诉我我试图去猜的值（此时已经未必是列表最后一个）是多少”(compare_exchange_strong)。</p><hr><h2 id="获取—释放"><a href="#获取—释放" class="headerlink" title="获取—释放"></a>获取—释放</h2><p>“获得-释放”是“宽松”的增强版——在不存在全序操作的前提下引入了同步。在这种顺序模型中，原子加载是获得(acquire)操作(memory_order_acquire)，原子存储是释放(memory_order_release)操作，原子读-改-写操作(如<code>fetch_add</code>或<code>exchange</code>可以是“获得”/“释放”中的任意一个，或者两者兼备 (memory_order_acq_rel)，一个“释放”操作同步于一个“获取”操作。</p><h3 id="代码实例1"><a href="#代码实例1" class="headerlink" title="代码实例1"></a>代码实例1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">  <span class="keyword">if</span>(y.load(<span class="built_in">std</span>::memory_order_acquire))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_acquire))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(write_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join();</span><br><span class="line">  c.join();</span><br><span class="line">  d.join(); </span><br><span class="line">  assert(z.load()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里assert可能会触发，因为可能加载x和y的时候都读取到的是false。下图展示了程序的一种可能运行流程：<br><img src="http://static.zybuluo.com/zsmj2017/ky9ttwheysxdkh241sxnq327/image.png" alt="image.png-174.3kB"></p><h3 id="代码实例2"><a href="#代码实例2" class="headerlink" title="代码实例2"></a>代码实例2</h3><p>获取-释放的正确使用实例如下文所示——将两次存储由一个线程来完成，存储y时使用<code>std::memory_order_release</code>，读取y时使用<code>std::memory_order_acquire</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_acquire)); <span class="comment">// 自旋，等待y被设置为true</span></span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed)) </span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join();</span><br><span class="line">  assert(z.load()!=<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于y的存储/读取操作存在“同步于关系”，而x，y的存储操作又在一个线程，存在”先序于”关系，因此，当<code>read_y_then_x</code>中的y被读取为true时，x必然为true，此时将导致z自增，此时assert将不会触发。为了提供同步，<code>std::memory_order_acquire</code>与<code>std::memory_order_release</code>必须成对进行。</p><h3 id="类比分析-1"><a href="#类比分析-1" class="headerlink" title="类比分析"></a>类比分析</h3><p>同样以办事员举例，获取-释放操作需要在此前的建模中引入“批次”的概念。具体而言，每个已经完成的存储都是某一批次更新的一部分，因此，你在告诉办事员数值时，必须提及“请记下99，作为第423批的一部分”，一个批次中的末尾存储需要说明为“请记下127，作为第423批的最后存储”。此后的存储将变为424批次。</p><p>获取值则分为2种情况：</p><ol><li>简单请求一个值（宽松），此时办事员给你提供一个值</li><li>请求一个值，并且希望了解它是否是某批次中的最后一个（获取-释放）。若该值不是批次中的最后一个，办事员会说它是个普通值，否则它将提供如下信息：“数字为987，该值是956批次的最后一个，来源于Anne”。这即是获取-释放的核心操作：当你向办事员提供了你所了解的批次后，它会在其列表中查找该批次的最后一个值，然后要么给你该值，要么给予更靠后的值。</li></ol><p>那么我们将根据上述原则分析代码实例——首先，线程a运行<code>write_x_then_y</code>，告知办事员x“请写下true作为来自线程a的批次1的一部分”，然后，线程a告诉办事员y，“请写下true，这是来自线程a的批次1的最后一个写”。与此同时，线程b正在运行<code>read_y_then_x</code>，线程b持续向办事员y请求一个带批次信息的值(<code>std::memory_order_acquire</code>)，直到获取true，此时办事员y将告诉线程b，该值为来自线程a批次1的最后一次写。线程b继续向办事员x请求一个值，但这次他会说“请给我一个值，并且我从线程a了解到了批次1”。 此时办事员x将不得不查看它的记事本，从中找到批次1的最后一个写入操作——true。</p><h3 id="用“获得-释放”传递同步"><a href="#用“获得-释放”传递同步" class="headerlink" title="用“获得-释放”传递同步"></a>用“获得-释放”传递同步</h3><p>正如前文所述，若A“线程间先发生于”B，且B“线程间先发生于”C，则有A“线程间先发生于”C。这意味着“获得-释放”可用于在若干线程间同步数据，即使“中间”线程没有接触到数据。</p><p>具体而言，若当前存在三个线程:线程A修改一些共享变量，并对同步变量a执行“存储-释放”(store-release)。线程B使用“加载-获得”(load-acquire)读取“存储-释放”的同步变量a，并对第中同步变量b执行“存储-释放”。线程C对变量b执行“加载-获得”，若线程C确保自己读取到了b“存储-释放”后的值，则线程C此时对共享变量的读取必然也是“存储-释放”后的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">3</span>];</span><br><span class="line">std::atomic&lt;bool&gt; sync1(false),sync2(false);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data[<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line">  data[<span class="number">1</span>] = <span class="number">97</span>;</span><br><span class="line">  data[<span class="number">2</span>] = <span class="number">17</span>;</span><br><span class="line">  sync1.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!sync1.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">  sync2.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!sync2.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">  assert(data[<span class="number">0</span>]==<span class="number">42</span>);</span><br><span class="line">  assert(data[<span class="number">1</span>]==<span class="number">97</span>);</span><br><span class="line">  assert(data[<span class="number">2</span>]==<span class="number">17</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span> ,<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">3</span>);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.join();</span><br><span class="line">    b.join();</span><br><span class="line">    c.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实际上，我们可以对上述实例做进一步的改进，利用<code>std::memory_order_acq_rel</code>特性使得同步变量仅需要一个即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">sync</span><span class="params">(<span class="number">0</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  sync.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> expected=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 反复查看sync是否为1，否则以其值更新expected，是则存入2</span></span><br><span class="line">  <span class="keyword">while</span>(!sync.compare_exchange_strong(expected, <span class="number">2</span>, <span class="built_in">std</span>::memory_order_acq_rel)) </span><br><span class="line">    expected=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(sync.load(<span class="built_in">std</span>::memory_order_acquire) &lt; <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="“获得-释放”与memory-order-consume的数据相关性"><a href="#“获得-释放”与memory-order-consume的数据相关性" class="headerlink" title="“获得-释放”与memory_order_consume的数据相关性"></a>“获得-释放”与memory_order_consume的数据相关性</h3><p>（C++17明确建议不要使用memory_order_consume, 若有兴趣，可直接查阅原文）</p><hr><h2 id="“释放序列”与“同步于”"><a href="#“释放序列”与“同步于”" class="headerlink" title="“释放序列”与“同步于”"></a>“释放序列”与“同步于”</h2><p>释放序列定义：若存储操作被标记为<code>memory_order_release</code>，<code>memory_order_acq_rel</code>或<code>memory_order_seq_cst</code>，加载操作被标记为<code>memory_order_consum</code>， <code>memory_order_acquire</code>或<code>memory_order_sqy_cst</code>，并且操作链上的每个操作加载的值是由前面的操作写入的，那么操作链就构成了一个释放序列(release sequence)。</p><p>释放序列性质：最初的存储“同步于”最终的加载操作，操作链上的任何原子“读-改-写”操作可以拥有任意的内存顺序(memory_order_relaxed)。</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p>考虑以<code>atomic&lt;int&gt;</code>对象作为对共享队列内条目数的计数器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queue_data; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_queue</span><span class="params">()</span> </span>&#123; <span class="comment">// init</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">const</span> number_of_items=<span class="number">20</span>;</span><br><span class="line">  queue_data.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_items; ++i) &#123;</span><br><span class="line">    queue_data.push_back(i); </span><br><span class="line">  &#125;</span><br><span class="line">  count.store(number_of_items, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_queue_items</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> item_index;</span><br><span class="line">    <span class="comment">// fetch返回操作前的值</span></span><br><span class="line">    <span class="keyword">if</span>((item_index = count.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acquire)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      wait_for_more_items();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">process</span>(queue_data[item_index - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(populate_queue)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(consume_queue_items)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join();</span><br><span class="line">  c.join(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重点关注<code>fetch_sub</code>的内存顺序是<code>std::memory_order_acquire</code>，这意味着该加载操作与之前的存储操作构成了同步关系, 显然，若仅有一个消费者线程时不会发生任何问题。若存在两个消费线程，第二个<code>fetch_sub</code>操作将看到第一个线程写入的值，而不是<code>store</code>写入的值。若没有释放序列的性质，第二个线程与第一个线程不会存在“先发生于”关系，因此可能读到错误的count值，除非第一个<code>fetch_sub</code>具备<code>memory_order_release</code>语义，但这为两个消费者线程引入了不必要的同步关系。不过，第一个<code>fetch_sub()</code>存在于“释放序列”中，所以<code>store</code>能同步于第二个<code>fetch_sub</code>操作，两个消费者线程间仍然不存在“同步于”关系。下图虚线展示了“释放序列”，实线展示了“先发生于”关系：<br><img src="http://static.zybuluo.com/zsmj2017/x6l8hb72r6u91c7c4qfpnhr4/image.png" alt="image.png-478.1kB"></p><hr><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>栅栏通常也被称为“内存屏障”(memory barriers)，可以在不修改任何数据的情况下强制执行内存顺序约束，通常配合<code>std::memory_order_relax</code>使用。正如前文所述，不同变量上的宽松操作通常可以被编译器或者硬件自由地重排，栅栏限制了这种自由度并引入了“先发生于”和“同步于”关系。</p><h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release); <span class="comment">// 1</span></span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_relaxed));</span><br><span class="line">  <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire); <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join(); </span><br><span class="line">  assert(z.load()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码1“同步于”代码2，因此当y为true时，x已经存储为true，此时assert将不会触发。在栅栏上施加“获取-释放”将在代码内引入“同步于”关系。</p><hr><h2 id="使用原子操作对非原子操作排序"><a href="#使用原子操作对非原子操作排序" class="headerlink" title="使用原子操作对非原子操作排序"></a>使用原子操作对非原子操作排序</h2><p>（本节的主题是通过“获取-释放”引入“同步于”关系，从而保证非原子操作得以排序，实际上，本节大部分relax操作可以直接被替换为非原子操作）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">false</span>;</span><br><span class="line">  y = <span class="literal">false</span>;</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">std</span>::atomic_signal_fence(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">  y = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_write_z</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y) &#123; <span class="comment">// 自旋</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y is false"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">std</span>::atomic_signal_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">      ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_write_z)</span></span>;</span><br><span class="line">    a.join();</span><br><span class="line">    b.join();</span><br><span class="line">    assert(z != <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(以上是我本人写的示例代码，但是对<code>while(!y)</code>存疑，是否可能由于编译器优化造成死循环？clang下未发生死循环情况，运行符合预期)</p><h3 id="互斥锁实现解析"><a href="#互斥锁实现解析" class="headerlink" title="互斥锁实现解析"></a>互斥锁实现解析</h3><p>非原子操作同样遵循“先发生于”传递关系——如果一个非原子操作“先序于”一个原子操作，并且这个原子操作“先发生于”另一个线程中的操作，那么这个非原子操作也会“先发生于”另一个线程中的那个操作，以下述代码实现的简单自旋锁为例（上一篇介绍原子类型时曾经提及）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::atomic_flag flag; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  spinlock_mutex(): flag(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.test_and_set(<span class="built_in">std</span>::memory_order_acquire)); <span class="comment">// 忙-等待</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，该自旋锁在内部构成了“释放-获取”顺序，从而可以保证在非原子操作间引入“同步于”关系。当持有锁的线程完成对保护数据的修改后调用<code>unlock</code>——即调用带有 <code>std::memory_order_release</code>语义的<code>flag.clear()</code>，该操作“同步于”随后对<code>flag.test_and_set()</code>的调用——即另一个线程调用<code>lock</code>。对保护数据的修改必然“先序于”<code>unlock</code>，因此将“先发生于”随后第二个线程对<code>lock</code>的调用。值得注意的是，第二个线程获得锁同样“先序于”该线程对保护数据的任何访问。</p><p>尽管其他互斥锁的实现各有差异，但基本原理是一样的:<code>lock</code>是一个内部内存位置上的获得操作，<code>unlock</code>是同样的内存位置上的一个释放操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;一段经典的生产-消费场景代码如下：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;atomic&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; data; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&amp;gt; &lt;span class=&quot;title&quot;&gt;data_ready&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reader_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!data_ready.load()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::this_thread::sleep(&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::milliseconds(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;The answer=&quot;&lt;/span&gt;&amp;lt;&amp;lt;data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;writer_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  data.push_back(&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  data_ready=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;这里我们利用原子操作，保证了写入操作必然“先发生于”读取操作。不过，原子操作对顺序要求还有其他选项，它们构成了原子操作间的各种关系，下文将一一说明。&lt;br&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++内存模型与原子类型操作——原子操作与原子类型</title>
    <link href="https://xander.wiki/2020/06/02/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xander.wiki/2020/06/02/C++内存模型与原子类型操作——原子操作与原子类型/</id>
    <published>2020-06-02T09:00:00.000Z</published>
    <updated>2021-06-24T07:00:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>原子类型操作(atomic operation)具备不可分割性，其仅存在执行完成与未执行两种状态。</p><p>如若某线程正在以原子操作load一个对象的值（对该对象的所有修改都由原子操作完成），那么它仅能读取到该对象在修改前，亦或某一次修改后的值（无法获取中间状态）。非原子类型操作不具备此性质，因此线程很可能读取到某个对象的中间状态，从而造成数据竞争。</p><a id="more"></a><hr><h1 id="标准原子类型"><a href="#标准原子类型" class="headerlink" title="标准原子类型"></a>标准原子类型</h1><p>&nbsp;<br>所有标准原子类型都可以在<code>&lt;atomic&gt;</code>头文件中找到。尽管从理论角度出发，开发者可以使用互斥锁保证任何数据类型均对外展现出原子性，但从C++语言定义而言，仅有这些类型是真正的原子类型。</p><p>事实上，可能标准原子类型也是通过使用锁实现了原子性。为了探究这一点，几乎所有标准原子类型（特例为<code>std::atomic_flag</code>）都具备这样一个接口<code>is_lock_free()</code>，开发者可以通过调用此接口来判断，当前行为究竟是语义上的原子行为（此时该接口返回true）还是编译器或者函数库内部在执行加锁操作模拟原子性（此时该接口返回false）。了解原子类型是否具备语义上的原子性在性能优化领域较为重要：如果某类型内部同样使用了mutex，那么可能将无法带来期望的性能收益。</p><p>除了直接使用<code>std::atomic</code>类模板外，标准库也提供了一系列名称来引用原子类型。但由于历史原因，在较老的编译器上，这些替代类型名称可能引用对应 std::atomic&lt;&gt;的特化类或这个特化类的一个基类，支持C++17的编译器则不存在此问题。因此，如果混合使用类型名与<code>std::atomic&lt;&gt;</code>特化类，可能导致代码不可移植。</p><p>类型名与<code>std::atomic&lt;&gt;</code>特化类映射表如下：<br><img src="http://static.zybuluo.com/zsmj2017/ulsub2apkxgv7hlabpfxrdxv/WechatIMG13.png" alt="WechatIMG13.png-417kB"></p><p>除此以外，C++标准库还针对<code>std::size_t</code>等非基本原子类型提供typedef，其映射表如下：<br><img src="http://static.zybuluo.com/zsmj2017/jut87ru9vyn16t0qv66fsr0w/image-20210610152408616.png" alt="image-20210610152408616.png-298.2kB"></p><p>标准原子类型理论上不可复制或赋值，因为它们没有<code>copy ctor</code>或<code>copy assignment operator</code>。但它们支持通过诸如<code>load()</code>,<code>store</code>，<code>exchange</code>等被相应的内置类型赋值或隐式转换。此外，它们也支持相应的相关计算符，例如<code>+=</code>,<code>-=</code>等等。整形与指针的原子类型还支持<code>++</code>，<code>--</code>。这些计算符同样具备实现同样功能的成员函数，如<code>fetch_add()</code>、<code>fetch_or()</code>等等。<br>一般而言，对象的赋值运算符往往返回引用，如果将该惯例应用于原子类型，则获取存储数据时程序中势必存在一个特殊的读操作，这可能导致数据竞争（在assign和read之间可能存在一个线程正在修改数据）。因此，对于赋值运算符而言，其返回值是被存储的数据，而对于命名成员函数而言，返回值是操作前的数据。</p><p><code>std::atomic&lt;&gt;</code>类模板不仅仅是一组特化。它确实存在一个主模板，可用于创建用户自定义类型的原子变体。其操作被限定为<code>load()</code>、<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。</p><p>每个原子类型上操作都有一个可选的内存顺序参数，它是<code>std::memory_order</code>枚举类型的某个值，可以用来指定所需的内存顺序语义。<code>std::memory_order</code>枚举值分别为：<br>1.std::memory_order_relaxed<br>2.std::memory_order_acquire<br>3.std::memory_order_consume<br>4.std::memory_order_acq_rel<br>5.std::memory_order_release<br>6.std::memory_order_seq_cst</p><p>该内存顺序参数依赖于操作的类别，在不指定的情况下，默认使用<code>std::memory_order_seq_cst</code>。</p><hr><h1 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a>std::atomic_flag</h1><p>&nbsp;<br><code>std::atomic_flag</code>是最简单的标准原子类型，表征布尔量，此类型的对象仅有两种状态:set或clear。实际上，它被设计为一种基础构建模块，很少应用于实际工程。以下将简称<code>std::atomic_flag</code>类型对象为flag对象。</p><p>flag对象必须用<code>ATOMIC_FLAG_INIT</code>初始化，即初始化为clear状态，这也意味着它无法被初始化为set状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic_flag f = ATOMIC_FLAG_INIT;</span><br></pre></td></tr></table></figure><br>它是唯一在初始化时需要这种特殊处理的原子类型，也是唯一保证无锁的原子类型。此外，static flag对象保证其具备静态初始化特性，即该对象总在首次使用前完成初始化。</p><p>flag对象在完成初始化后，仅能对其施加三种操作：destroy，clear，test_and_set（读取值后set），分别对应着析构函数，<code>clear()</code>成员函数以及<code>test_and_set()</code>成员函数。<code>clear()</code>和<code>test_and_set()</code>都可以指定内存顺序。</p><p>所有原子类型均不支持copy ctor &amp;&amp; copy assignment，flag对象也不例外。原因很简单：应用于原子类型的所有操作均应具备原子性，但赋值和拷贝构造涉及到两个独立对象。在执行拷贝构造或拷贝赋值操作时，必须先从一个对象读取值，然后将其写入另一个对象，这一组合行为不可能具备原子性。</p><p><code>std::atomic_flag</code>所具备的特性使其非常适合实现自旋互斥锁，具体实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::atomic_flag flag; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  spinlock_mutex(): flag(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.test_and_set(<span class="built_in">std</span>::memory_order_acquire)); <span class="comment">// 忙-等待</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>flag对象类似于bool，但其未提供标准get接口（C++20引入<code>test()</code>成员函数），因此如存在相关需求，请使用<code>std::atomic&lt;bool&gt;</code>。</p><hr><h1 id="std-atomic-lt-bool-gt"><a href="#std-atomic-lt-bool-gt" class="headerlink" title="std::atomic&lt;bool&gt;"></a>std::atomic&lt;bool&gt;</h1><p>&nbsp;<br>相较于flag对象，<code>std::atomic&lt;bool&gt;</code>的灵活程度大为提高。尽管不支持copy ctor与copy assign，但可以使用内置的bool类型构造它——这意味着它可以被初始化为true或false。此外，<code>std::atomic&lt;bool&gt;</code>对象亦可接受来自内置bool类型的赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这里需要注意一点：不同于常规赋值操作，原子类型的赋值操作返回的并非引用，而是被赋予的值。原因很简单，返回引用可能会导致另一个线程修改当前存储数据，这将导致数据竞争。</p><p><code>std::atomic&lt;bool&gt;</code>使用<code>strore()</code>成员函数写入true或false值，使用<code>exchange()</code>成员函数完成对原始值的检索与替换，读取操作使用的是成员函数<code>load()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> x=b.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">b.store(<span class="literal">true</span>);</span><br><span class="line">x=b.exchange(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br></pre></td></tr></table></figure></p><p>除<code>exchange</code>外，<code>std::atomic&lt;bool&gt;</code>还有两个”read-change-write”操作，分别是<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。</p><p>compare-exchange操作是使用原子类型进行编程的基石——它将原子变量的值与提供的预期值进行比较，若相等，则存储提供的值。如果值不相等，则预期值将被更新为原子变量存储的值。该操作返回布尔量，若执行了存储操作（值相等）且存储成功则为true，否则为false。</p><p><code>compare_exchange_weak()</code>的weak之处在于，即使原始值与预期值一致时，存储也可能会不成功，此时原始值不变，<code>compare_exchange_weak()</code>返回false。这种情况多见于当前机器不支持compare-exchange指令（意味着无法保证操作原子性），若此时执行操作的线程在必要的指令序列中被切换出去，而操作系统在其位置调度了另一个线程，将导致数据存储失败。因此<code>compare_exchange_weak()</code>通常应用于循环内：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="keyword">bool</span>&gt; b; <span class="comment">// 在其他某个地方设置</span></span><br><span class="line"><span class="comment">// b内部数据为存储值</span></span><br><span class="line"><span class="comment">// expected为期待值</span></span><br><span class="line"><span class="comment">// true为提供值</span></span><br><span class="line"><span class="keyword">while</span>(!b.compare_exchange_weak(expected,<span class="literal">true</span>) &amp;&amp; !expected); <span class="comment">// 若存储失败，将持续执行</span></span><br></pre></td></tr></table></figure><br><code>compare_exchange_strong()</code>的strong之处在于，当存储值等于期待值时，该函数返回ture（即使存储失败），否则返回false。</p><p>若当前提供值依赖于存储值，则开发者可以利用期待值被更新为存储值的特性，利用期待值计算提供值。这里需要注意，若这种计算过程非常耗时，则使用strong优于weak，因为weak所在的循环将导致提供值被反复计算，即使期待值未发生变更。</p><p>除flag外，原子类型并不保证无锁性，若有需要，<code>std::atomic&lt;bool&gt;</code>可以通过<code>is_lock_free()</code>成员函数检查其操作是否具备无锁性。</p><hr><h1 id="std-atomic-lt-T-gt"><a href="#std-atomic-lt-T-gt" class="headerlink" title="std::atomic&lt;T*&gt;"></a>std::atomic&lt;T*&gt;</h1><p>&nbsp;<br>std::atomic&lt;T*&gt;具备所有std::atomic<bool>的接口与性质，本节主要描述其特性。</p><p>std::atomic<T*>支持指针运算，类似于普通指针，其行为是在存储的地址上做原子加法与减法，其接口也类似与普通指针类型，有+=，-=，++(前置&amp;&amp;后置)， —(前置&amp;&amp;后置)，它们的返回值是一个普通的T*，指向增加/减少后的内存地址。</p><p>除上述接口外，std::atomic<T*>还提供了接口<code>fetch_add()</code>与<code>fetch_sub()</code>，其返回值与上述接口不同，返回执行加/减操作前的原始值。</p><p>std::atomic<T*>具体使用示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span>&#125;;</span><br><span class="line">Foo some_array[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;Foo*&gt; <span class="title">p</span><span class="params">(some_array)</span></span>; </span><br><span class="line">Foo*x=p.fetch_add(<span class="number">2</span>); <span class="comment">//p加2，并返回老的值 </span></span><br><span class="line">assert(x==some_array); </span><br><span class="line">assert(p.load()==&amp;some_array[<span class="number">2</span>]);</span><br><span class="line">x=(p-=<span class="number">1</span>); <span class="comment">//p减1，并返回新的值 </span></span><br><span class="line">assert(x==&amp;some_array[<span class="number">1</span>]); </span><br><span class="line">assert(p.load()==&amp;some_array[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p><hr><h1 id="标准整形原子类型"><a href="#标准整形原子类型" class="headerlink" title="标准整形原子类型"></a>标准整形原子类型</h1><p>&nbsp;<br>除load(), store(), exchange(), compare_exchange_weak(),compare_exchange_strong()接口外，原子整形类型如std::atomic<int>和 std::atomic<unsigned long long>有相当全面的一整套运算接口:fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor()，以及复合赋值形式的操作((+=, -=, &amp;=, |=和^=)，++和—(前置&amp;&amp;后置)。因为原子整数值通常用作计数器或位掩码，因此缺失乘法，除法，移位操作符也许并不能算作遗憾。如有需要，在循环内反复调用compare_exchange_weak()即可。</p><p>类似于指针操作，<code>fetch()</code>接口均返回修改前的旧值，前置操作符返回修改后的新值，后置操作符返回修改前的旧值。</p><hr><h1 id="std-atomic-lt-T-gt-1"><a href="#std-atomic-lt-T-gt-1" class="headerlink" title="std::atomic&lt;T&gt;"></a>std::atomic&lt;T&gt;</h1><p>&nbsp;<br>给定用户自定义的类型UDT，std::atomic&lt;UDT&gt;提供了与std::atomic&lt;bool&gt;相同的接口，当然，与存储值相关的返回类型为UDT，而非bool。</p><p>并非任意UDT均可与std::atomic&lt;&gt;搭配使用：UDT必须具备一个trivial拷贝赋值操作符，这意味着该类型必须没有虚函数和虚基类，并且必须使用编译器生成的拷贝赋值操作符——这一要求对其基类和非静态数据成员同样生效。这保证了编译器可以使用memcpy（或一个等价操作）来完成赋值。此外，compare_exchange使用的是memcmp式的比较操作，因此不支持bitwise相等的UDT实例在执行compare_exchange操作时将会不符合预期，即使比较值满足自定义operator==（顺带提一嘴，std::atomic&lt;double&gt;与std::atomic&lt;float&gt;尽管是标准类型，使用<code>compare_exchange_strong</code>时也存在同样的坑，原因在于数据的存储形式不同）。</p><p>这些限制背后的原因前文已经提及——不要将指针和引用作为参数传递给用户提供的函数，从而在锁范围外传递受保护数据。一般来说，编译器无法为std::atomic&lt;UDT生成无锁代码，因此它必须生成和使用一个内部锁。如果允许用户提供自定义拷贝赋值或比较操作符，则需要将对受保护数据的引用作为参数传递给用户提供的函数，这可能导致数据竞争。此外，这些限制增加了编译器直接为 std::atomic&lt;UDT&gt;使用原子指令的机会，因为它可以直接将UDT实例视为一组原始字节。</p><p>这些限制意味着开发者不能创建一些较为复杂的原子数据类型，例如<code>std::atomic&lt;std::vector&lt;int&gt;&gt;</code>(它有一个特殊的拷贝构造和拷贝赋值操作符)。但这并不算大问题——数据结构越复杂，对其进行复杂操作的可能性越高，而不只是原子操作里简单的赋值和比较，此类数据最好使用<code>std::mutex</code>，以确保为所需操作适当地保护数据。</p><p>如果UDT的大小 &lt;= int或void*，那么大多数平台都能够对std::atomic&lt;UDT&gt;使用原子指令。一些平台还能对两倍于int或void*大小的用户自定义类型使用原子指令。这些平台通常支持所谓的双字比较-交换(double-word-compare-and-swap)指令，该指令对应于compare_exchange_xxx函数。</p><p>综上，下表展示了std::atomic&lt;T&gt;上可使用的各项操作：<br><img src="http://static.zybuluo.com/zsmj2017/l5jxrrnhm2mvnxa1cda7vzhj/image.png" alt="image.png-224.6kB"></p><hr><h1 id="应用于原子操作的自由函数"><a href="#应用于原子操作的自由函数" class="headerlink" title="应用于原子操作的自由函数"></a>应用于原子操作的自由函数</h1><p>TODO::不甚重要，日后补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;原子类型操作(atomic operation)具备不可分割性，其仅存在执行完成与未执行两种状态。&lt;/p&gt;
&lt;p&gt;如若某线程正在以原子操作load一个对象的值（对该对象的所有修改都由原子操作完成），那么它仅能读取到该对象在修改前，亦或某一次修改后的值（无法获取中间状态）。非原子类型操作不具备此性质，因此线程很可能读取到某个对象的中间状态，从而造成数据竞争。&lt;/p&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>VimTutor小结</title>
    <link href="https://xander.wiki/2020/05/05/VimTutor/"/>
    <id>https://xander.wiki/2020/05/05/VimTutor/</id>
    <published>2020-05-05T07:02:00.000Z</published>
    <updated>2021-07-06T06:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为vimtutor总结，仅摘录部分常用vim语句以供复习。<br><a id="more"></a></p><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>i   输入欲插入文本 &lt;ESC&gt;            在光标前插入文本<br>A   输入欲添加文本&lt;ESC&gt;             在一行后添加文本</p><hr><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><ol><li>欲从当前光标删除至下一个单词，请输入：dw</li><li>欲从当前光标删除至当前行末尾，请输入：d$</li><li>欲删除整行，请输入：dd</li><li>在正常模式下修改命令的格式是：<code>operator   [number]   motion</code><br>其中：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator - 操作符，代表要做的事情，比如 d 代表删除</span><br><span class="line">[number] - 可以附加的数字，代表动作重复的次数</span><br><span class="line">motion   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，$ 代表行末等等。</span><br></pre></td></tr></table></figure></li><li>欲移动光标到行首，请按数字0键：0</li><li>欲撤消以前的操作，请输入：u<br>欲撤消在一行中所做的改动，请输入：U<br>欲撤消以前的撤消命令，恢复以前的操作结果，请输入：<code>CTRL-R</code></li></ol><hr><h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><ol><li>要重新置入已经删除的文本内容，请输入 p。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。(被删除文本存入缓存，个人认为类似于剪切)。</li><li>要替换光标所在位置的字符，请输入r和要替换掉原位置字符的新字符即可。</li><li>更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入ce可以替换当前光标到单词的末尾的内容；输入c$可以替换当前光标到行末的内容。</li><li>更改类命令的格式是：<code>c   [number]   motion</code></li></ol><hr><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><ol><li><code>CTRL-g</code> 用于显示当前光标所在位置和文件状态信息。<br>G用于将光标跳转至文件最后一行。<br>gg用于将光标跳转至文件第一行。<br>先敲入一个行号然后输入G则是将光标移动至该行号代表的行。</li><li>输入/然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。<br>输入?然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。<br>完成一次查找之后按n键是重复上一次的命令，可在同一方向上查找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。<br><code>CTRL-O</code>带您跳转回较旧的位置，<code>CTRL-I</code>则带您到较新的位置。</li><li>如果光标当前位置是括号(、)、[、]、{、}，按%会将光标移动到配对的括号上。</li><li>在一行内替换<strong>头一个</strong>字符串 old 为新的字符串 new，请输入  <code>:s/old/new</code><br>在一行内替换<strong>所有的</strong>字符串 old 为新的字符串 new，请输入  <code>:s/old/new/g</code><br>在<strong>两行内</strong>替换所有的字符串 old 为新的字符串 new，请输入  <code>:#,#s/old/new/g</code><br>进行<strong>全文替换时询问用户</strong>确认每个替换<strong>需添加 c 标志</strong>      <code>:%s/old/new/gc</code></li></ol><hr><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><ol><li><code>:!command</code>用于执行一个外部命令 command。如<code>:!ls :rm sth</code>  </li><li><code>:w FILENAME</code>  可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。</li><li><code>v motion :w FILENAME</code> 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。</li><li><code>:r FILENAME</code>可提取磁盘文件FILENAME并将其插入到当前文件的光标位置后面。</li><li><code>:r !dir</code>可以读取dir命令的输出并将其放置到当前文件的光标位置后面。</li></ol><hr><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><ol><li>输入o可以在光标下方打开新的一行并进入插入模式。<br>输入O可以在光标上方打开新的一行。</li><li>输入a可以在光标所在位置之后插入文本 。<br>输入A可以在光标所在行的行末之后插入文本。</li><li>e命令可以使光标移动到单词末尾，因此在单词后插入为ea。</li><li>操作符y复制文本，p粘贴先前复制的文本。</li><li>输入R将进入替换模式，直至按&lt;ESC&gt;键回到正常模式。</li><li>输入 <code>:set xxx</code> 可以设置 xxx 选项。一些有用的选项如下：<br> ‘ic’ ‘ignorecase’       查找时忽略字母大小写<br> ‘is’ ‘incsearch’        查找短语时显示部分匹配<br> ‘hls’ ‘hlsearch’        高亮显示所有的匹配短语<br> 选项名可以用完整版本，也可以用缩略版本。</li><li>在选项前加上 no 可以关闭选项：<code>:set noic</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为vimtutor总结，仅摘录部分常用vim语句以供复习。&lt;br&gt;
    
    </summary>
    
      <category term="杂项" scheme="https://xander.wiki/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="Vim" scheme="https://xander.wiki/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络与互联网</title>
    <link href="https://xander.wiki/2020/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91/"/>
    <id>https://xander.wiki/2020/05/04/计算机网络与互联网/</id>
    <published>2020-05-04T05:29:00.000Z</published>
    <updated>2021-06-23T07:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为《Computer Network-A Top-Down Approach》第一章读书笔记。</p><a id="more"></a><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>连接至计算机网络的计算设备被称为<strong>主机（hosts）</strong>或<strong>终端（end system）</strong>。<ul><li>终端间通过<strong>通信链路（communication link）</strong>与<strong>分组交换机（packet switch）</strong>相连。<ul><li>通信链路由同轴电缆，光纤，双绞线等物理媒介构成，其传输速率被定义为bits/second。</li><li>路由器（router）与链路层交换机（link-layer switch）均属于分组交换机。</li></ul></li></ul></li><li>终端通过<strong>ISP（Internet Service Provider）</strong>提供的服务连接至互联网。</li><li>计算机网络中信息的收发均遵从<strong>协议（protocols）</strong>, <strong>TCP（Transmission Control Protocol ）与 Internet Protocol (IP)</strong> 是其中最重要的两个。</li><li>为了保证所有人都遵从协议，IETF（Internet Engineering Task Force）制定了互联网标准（Internet standard）。</li><li>分布式应用程序（distributed application）——包含多个彼此交换数据的终端。</li><li>连接至互联网的终端，通<strong>过套接字接口（Socket Interface）</strong>指定数据如何传递至另一个终端上的特定应用程序。</li><li>协议是实体间为完成通信所必须遵从的规则，它包含了信息格式，信息顺序，以及发送/接受信息所必须执行的操作。</li></ul><hr><h1 id="网络边沿"><a href="#网络边沿" class="headerlink" title="网络边沿"></a>网络边沿</h1><ul><li>接入网络（access network）——将终端系统以物理方式连接到首个路由器的网络。<ul><li>原书对诸如DSL,FTTH及各物理媒介的介绍与对比不再赘述。</li><li>接入网络在网络体系中的位置如图中蓝色高亮所示。<br><img src="http://static.zybuluo.com/zsmj2019/de8blil0iqur1lod8pehp0il/WX20200504-143411@2x.png" alt="WX20200504-143411@2x.png-696.6kB"></li></ul></li></ul><hr><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><p>本节所研究内容如下图蓝色高亮位置所示。<br><img src="http://static.zybuluo.com/zsmj2019/ojdknbtilpd7n5c0zhr7aeup/WX20200504-144038@2x.png" alt="WX20200504-144038@2x.png-712.9kB"></p><ul><li>分组交换（packet switch）：终端间通过<strong>报文（message）</strong>通信，较长的报文将被切割为<strong>分组/包（packet）</strong><ul><li>存储-转发（store-and-forward transmission）机制：交换机仅在接收完<strong>整个</strong>包后才开始向外发送数据，这造成了一定的时延。</li><li>排队时延（Queuing Delay）与丢包（Packet Loss）：每一个交换机均持有一个<strong>输出队列</strong>（output queue），所有待发送包均需在此队列中排队（当前通信链路正忙于发送数据），若<strong>队列已满</strong>时到达了新包，新包将被<strong>丢弃</strong>。</li><li>在因特网中，IP地址的多级结构信息和路由器的<strong>转发表（forwarding table）</strong>，决定了路由器拿到包后送往哪条链路，转发表是由路由选择协议自动设置的。</li></ul></li><li>电路交换（Circuit Switch）：另一种端与端通信手段，特点是源和目标点建立起名副其实的连接，称为电路，这条路上的带宽全部为这个连接空出来，所以电路交换的速度非常可靠（电话就采用了这种通信方式）。<ul><li>频分复用，时分复用等不再赘述。 </li></ul></li><li>分组交换 VS 电路交换：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">电路交换</th><th style="text-align:center">分组交换</th></tr></thead><tbody><tr><td style="text-align:center">实现</td><td style="text-align:center">复杂，成本高</td><td style="text-align:center">简单,成本低</td></tr><tr><td style="text-align:center">可靠性</td><td style="text-align:center">可靠</td><td style="text-align:center">延时不可预测</td></tr><tr><td style="text-align:center">利用率</td><td style="text-align:center">低，有空闲浪费</td><td style="text-align:center">高，可共享空闲资源</td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">专线专用</td><td style="text-align:center">共享路由</td></tr></tbody></table></div><ul><li>ISP架构图：<br>其中IXP （Internet Exchange Point）用以令各ISP相互peer。<br><img src="http://static.zybuluo.com/zsmj2019/7nwbcb17m4o0j3c5ez2pt7q4/WX20200504-184743@2x.png" alt="WX20200504-184743@2x.png-244.8kB"></li></ul><hr><h1 id="时延，丢包与吞吐量"><a href="#时延，丢包与吞吐量" class="headerlink" title="时延，丢包与吞吐量"></a>时延，丢包与吞吐量</h1><ul><li>分组交换中时延的分类<ul><li>处理时延（Processing Delay）：<strong>检查分组首部和决定将该分组导向何处</strong>，是节点处理时延（nodal processing delay）的一部分，其他部分有包括检查比特级差错处理（通常是微秒级以下）等。在这之后，路由器将包引向通往路由器B链路之前的队列。</li><li>排队时延（Queuing Delay）：在队列中，当分组在链路缓存中<strong>等待传输</strong>时，它经受排队时延。 到达组的分组数量是到达该队列的流量强度的函数。实际的排队时延通常在毫秒到微秒级。 </li><li>传输时延（Transmission Delay）：假定包长度为L，从路由器A到路由器B的链路传输速率为R （b/s），则有传输时延L/R。这是<strong>将所有比特推向链路所需要的时间</strong>。实际的传输时延通常在毫秒到微秒级。传输时延与包体长度正相关，与路由间距无关。 </li><li>传播时延（Propagation Delay）：一旦一个比特被A推向链路向路由器B传播，从该链路的<strong>起点到路由器B的传播所需要的时间</strong>为传播时延，其速率范围等于或略小于光速，时延范围在毫秒级。传播时延等于两台路由器之间的距离d除以传播速率s。 </li><li><strong>传输时延与传播时延的区别</strong>：传输时延可以看做是车队（包）过收费站（路由器）的时间（车队头需要等待车队尾通过），而传播时延可看作在高速上花费的时间。</li><li>节点总时延 = 处理时延（可忽略） + 排队时延 + 传输时延 + 传播时延。</li></ul></li><li>排队时延与丢包<ul><li>流量强度（ traffic intensity）：假定包（packet）进入队列的速率为a（packets/sec）,当前所有包总长度为L（bits）,链路传输速度为R，则有流量强度=La/R。<ul><li>如果La/R &gt; 1，则意味着队列进入端速度大于流出端速度，此时排队时延将趋向无穷大。因此，流量工程中设计系统时流量强度不能大于1。在因特网中，接近1时将容易发生丢包。</li><li>若La/R &lt;= 1，此时排序时延取决于流量本身的特点（即突发还是平稳）。</li><li>排序时延与流量强度的关系大致如下图所示：<br><img src="http://static.zybuluo.com/zsmj2019/2a6s7phknrnuq9bdh6hdp4af/WX20200504-192241@2x.png" alt="WX20200504-192241@2x.png-84.8kB"></li></ul></li><li>丢包：在理想状态下丢包不会发生（将队列容量视作无穷大），实际上队列容量有限。若新包到达时队列已满，此时将发生丢包，在后续章节中我们将了解到丢失的包将会被再次传递至目的地，以保证数据的完整性。</li></ul></li><li>端到端时延（End-to-End Delay）<ul><li>假定源主机和目的主机之间有N-1台路由器，并且该网络是无拥塞的（此时可无视排队时延）。那么端到端时延为：<script type="math/tex">d_{end-end} = N (d_{proc} + d_{trans} + d_{prop})</script></li></ul></li><li>吞吐量（Throughput）<ul><li>在如以太网路及封包无线电之类的电信网络之中，吞吐量或网络吞吐量是指于一通讯通道上单位时间能成功传递的平均资料量，资料可以于实体或逻辑链接上传递，或通过某个网络节点。吞吐量的单位通常表示为bit/s或bp。</li><li>在因特网内表现为网速。</li><li>整个通信网络的吞吐量由所有通信链路中的最低吞吐量决定（短板效应）。</li></ul></li></ul><hr><h1 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h1><ul><li><p>五层模型与七层模型：<br><img src="http://static.zybuluo.com/zsmj2019/3wjcflxrm66esvgwvwdors7c/WX20200504-195027@2x.png" alt="WX20200504-195027@2x.png-195kB"></p></li><li><p>五层协议栈</p><ul><li>应用层：应用程序的协议。<ul><li>我们把应用层的信息称为<strong>报文（message）</strong>。</li><li>典型协议如<code>HTTP</code>、<code>FTP</code>、<code>SMTP(电邮)</code>、<code>DNS</code>。</li></ul></li><li>运输层：在应用程序端点之间传输应用层报文的协议。<ul><li>因特网中常用的有两个，即<code>TCP</code>和<code>UDP</code>。</li><li>TCP：面向连接，提供分割长报文，拥塞控制机制。</li><li>UDP：无连接，无特殊功能。</li><li>处于运输层的分组叫做<strong>报文段（segement）</strong></li></ul></li><li>网络层：负责将<strong>数据报(datagram)</strong>从主机移动到另一主机，使两端能够互连且决定最佳路径。<ul><li>从运输层拿到报文段和目标地址。然后进行<code>路由</code>。</li><li>网络层的典型协议是<code>IP</code>协议，用来识别目标地址。</li><li>另一典型协议是<code>网络控制消息协定（ICMP）</code>，它是IP的主要部分，一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了<code>ping</code>和<code>traceroute</code>这两个特例。</li></ul></li><li>链路层：在两个网络实体之间提供数据链路连接的创建、维持和释放管理。<ul><li>传输<strong>数据帧（frame）</strong>，并对帧定界、同步、收发顺序的控制。</li><li>负责传输过程中的流量控制,差错检测和差错控制等方面。</li><li>数据链路层中的数据封装是指：封装的数据信息中，包含了地址段和数据段等。地址段含有点对点发送节点和接收节点的地址（如<code>MAC</code>），控制段用来表示数格连接帧的类型，数据段包含实际要传输的数据。</li><li>网络层将数据报下发给链路层，链路层传输后，上报给目标结点的网络层。</li><li>典型协议：<code>异步传输模式（ATM）</code>、<code>帧中继（frame relay）</code>、<code>高级数据链路控制（HDLC）</code>。</li><li>交换机、桥接器是本层设备。而集线器是物理层设备。</li></ul></li><li>物理层：移动比特。<ul><li>典型协议如：<code>蓝牙协议</code>、<code>数字用户线路（DSL）</code>等等。</li><li>常见物理层设备：网卡、光纤、集线器 。</li></ul></li></ul></li><li>封装：<ul><li>因特网协议栈自顶向下传输时，各层会将上层信息包装，上层信息包装为<code>负载字段（payload field）</code>，本层信息包装为<code>首部字段（header field）</code>。</li><li>应用层报文 -&gt; 运输层报文段 -&gt; 网络层数据报 -&gt; 链路层帧</li><li><img src="http://static.zybuluo.com/zsmj2019/ludlhii7p63so2srpbkaxw50/WX20200504-200252@2x.png" alt="WX20200504-200252@2x.png-261.9kB"></li></ul></li></ul><hr><h1 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h1><ul><li>因特网攻击举例<ol><li>利用病毒和木马形成僵尸网络（botnet），即肉鸡。</li><li>弱点攻击（攻击bug）、带宽洪泛（较为常见，多采用分布式攻击）、连接洪泛（伪造大量TCP连接）。</li><li>分组嗅探（packet sniffer）：抓包，窃取隐私。</li><li>伪造分组：IP哄骗等。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为《Computer Network-A Top-Down Approach》第一章读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Networking A Top-Down Approach" scheme="https://xander.wiki/categories/Computer-Networking-A-Top-Down-Approach/"/>
    
    
      <category term="Computer Network" scheme="https://xander.wiki/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>C++内存模型与原子类型操作——内存模型基础</title>
    <link href="https://xander.wiki/2020/03/14/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://xander.wiki/2020/03/14/C++内存模型与原子类型操作——内存模型基础/</id>
    <published>2020-03-14T04:00:00.000Z</published>
    <updated>2021-06-23T07:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;</p><p>C++11标准引入了全新的多线程内存模型，如果没有它准确地定义基本构建块（building blocks）的工作方式，那么前文所提到的一切并发工具都将成为空谈。</p><p>C++内存模型基本可以分为2部分：内存结构（structs，与对象在内存中的布局有关）与并发性，一般认为前者比后者重要，尤其是需要深入了解底层原子操作时。</p><a id="more"></a><hr><h1 id="object-amp-amp-memory-location"><a href="#object-amp-amp-memory-location" class="headerlink" title="object &amp;&amp; memory location"></a>object &amp;&amp; memory location</h1><p>&nbsp;<br>C++中任何数据均由object构成（并非是狭义上的“对象”）。C++标准对object的定义是“一块内存区域”。当然，object并不能一概而论，有些object较为简单，例如POD类型，而另一些则以用户自定义类型的形式出现。有些object存在子object（例如数组，派生类的实例，以及具有non-static data member的类实例），有些则并不具备。</p><p>无论object是何种类型，其必然被存储于一个或多个内存位置（memory location）上。内存位置要么是标量类型的对象(如<code>unsigned int</code>或<code>my class*</code>)或子对象，要么是一块连续的位域（bit fields）。需要注意，在位域中，即使相邻的位域内存储着不同的对象，他们依旧被视作具有相同的内存位置。下图清晰地展示了一个struct的objects 与 memory locations。<br><img src="http://static.zybuluo.com/zsmj2019/u4xaaorysd8xs1u8b97gddpo/WX20200313-194502@2x.png" alt="WX20200313-194502@2x.png-133.9kB"></p><p>首先，整个struct是一个由几个子对象组成的对象，每个子对象对应一个数据成员。bf1和bf2位字段共享一个内存位置，std::string对象s内部由几个内存位置组成。除此之外，每个成员都有自己的内存位置。注意零长度位字段 bf3(bf3这个名字是用来注释的，C++中零长度位字段必须未命名)如何将bf4分隔到它自己的内存位置，但它本身没有内存位置。(C++中零长度的未命名位域有特殊含义:让下一个位域从分配单元的边界开始。C++中位域的内存布局是与机器相关的，取地址操作符&amp;不能作用于位域)。</p><p>抛开细节，从上图中可以得出四点结论：</p><ol><li>任何变量都是一个对象，即使它本身是其他对象的data member。</li><li>每一个对象至少占据一个内存位置。</li><li>基本类型（如int或char）无论大小必然占据一个内存位置，即使他们毗邻或是是数组的一部分。</li><li>相邻的位域共享同一个内存位置。</li></ol><hr><h1 id="object-amp-amp-memory-location-amp-amp-concurrency"><a href="#object-amp-amp-memory-location-amp-amp-concurrency" class="headerlink" title="object &amp;&amp; memory location &amp;&amp; concurrency"></a>object &amp;&amp; memory location &amp;&amp; concurrency</h1><p>&nbsp;<br>首先需要阐明：在C++中，一切事物均与其内存位置挂钩。如果两个线程各自访问不同的内存位置，那么岁月静好，反之，若两个线程访问同一个内存位置，则必须提高警惕。此外，如果不存在线程更新内存位置，此时同样无需担忧——只读数据不需要保护与同步，但如果某个线程需要修正数据，则意味着引入数据竞争的可能性。</p><p>为了规避数据竞争，我们必须强制指定线程访问数据的先后顺序。方案一已经在第三章提过：使用互斥锁。如果在两次访问前锁定了相同的mutex，则可以确保同一时刻仅有一个线程访问数据，因此线程访问数据的顺序必然是有序的（尽管无法知道线程们谁先谁后）。另一种方案是在内存位置上使用原子操作（定义具体可见下一节）的同步属性，强制定义线程访问数据的顺序。若在多线程下试图对同一内存位置写入数据而不使用原子操作，则将引起数据竞争，从而导致未定义行为。</p><p>这里需要明确指出的是，使用原子操作并不能规避数据竞争（仍未指定各原子操作访问内存位置的先后性），但原子操作可以规避未定义行为。</p><hr><h1 id="modification-orders"><a href="#modification-orders" class="headerlink" title="modification orders"></a>modification orders</h1><p>&nbsp;<br>C++程序中的任意对象从都具备明确的修改顺序（modification order），由所有线程对该对象的写入操作组成，其开端为对象初始化。在大多数情况下，每一次程序时的修改顺序并不完全相同，但系统中所有线程都必须对该顺序达成一致。使用原子操作后，编译器将采取必要的同步措施保证线程按照修改顺序写入数据。如果对象类型并非原子类型，开发者应当保证采取足够的同步措施以确保每一个线程严格遵守修改顺序。</p><p>这一要求意味着某些投机执行（speculative execution）将不再被允许（禁止优化部分数据的读写顺序）。使用原子操作后，线程已经明确了解对象的修改顺序，那么读操作后的写操作必须等待读操作完成后执行，而写操作后的读操作也是同理，不可提前读取或写入。相关细节我们将在后续章节进一步讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;C++11标准引入了全新的多线程内存模型，如果没有它准确地定义基本构建块（building blocks）的工作方式，那么前文所提到的一切并发工具都将成为空谈。&lt;/p&gt;
&lt;p&gt;C++内存模型基本可以分为2部分：内存结构（structs，与对象在内存中的布局有关）与并发性，一般认为前者比后者重要，尤其是需要深入了解底层原子操作时。&lt;/p&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>同步并发操作——使用同步操作简化代码</title>
    <link href="https://xander.wiki/2020/03/13/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/"/>
    <id>https://xander.wiki/2020/03/13/同步并发操作——使用同步操作简化代码/</id>
    <published>2020-03-13T04:50:00.000Z</published>
    <updated>2023-06-05T14:09:04.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>使用本节描述的技巧编码，开发者可以更多地将注意力集中至同步操作本身——使用函数式编程技法实现并发编程。</p><p>相较于在多个线程间直接共享数据，每个任务均拥有自己的数据似乎更为优雅，并且可将任务结果广播至其它线程——这需要使用future实现。</p><a id="more"></a><hr><h1 id="使用future的函数式编程"><a href="#使用future的函数式编程" class="headerlink" title="使用future的函数式编程"></a>使用future的函数式编程</h1><p>&nbsp;<br>函数式编程(functional programming)指的是一种编程范式，在该范式下，函数结果仅依赖于传入参数，并不依赖外部状态，其命名与数学概念相关。简而言之，若函数输入相同，则函数输出相同。C++标准库中很多与数学相关的函数都有这个特性，例如sin,cos,sqrt以及简单算术运算。</p><p>如果不存在任何试图修改共享数据的行为，数据竞争也就不复存在，那么诸如mutex之类的数据保护机制也无需使用。因此，HasKell这类函数式语言日益流行于并发编程。由于大多数操作都仅具备只读性，因此开发者仅需要关心存在写入的操作。</p><p>future是我们攻克函数式并发编程的最后一个难点。我们可以在线程间传递future，以此来保证某一次计算结果取决于另一次计算结果，并且无需任何对共享数据的显式访问。</p><hr><h2 id="快排实例"><a href="#快排实例" class="headerlink" title="快排实例"></a>快排实例</h2><h3 id="函数式快排"><a href="#函数式快排" class="headerlink" title="函数式快排"></a>函数式快排</h3><p>下图是一张快排实例图。<br><img src="http://static.zybuluo.com/zsmj2019/e5r8d5ks0f6byo41atcomapj/WX20200311-123528@2x.png" alt="WX20200311-123528@2x.png-186.3kB"><br>快排的函数式编程实例如下文所示，需要注意的是，其返回值是一个<code>list</code>，而非像<code>std::sort</code>一样就地排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(input.empty())&#123;</span><br><span class="line">    <span class="keyword">return</span> input;     </span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; result;</span><br><span class="line">  result.splice(result.<span class="built_in">begin</span>(),input,input.<span class="built_in">begin</span>());</span><br><span class="line">  T <span class="keyword">const</span>&amp; pivot=*result.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">auto</span> divide_point=<span class="built_in">std</span>::partition(input.<span class="built_in">begin</span>(),input.<span class="built_in">end</span>(),[&amp;](T <span class="keyword">const</span>&amp; t)&#123;<span class="keyword">return</span> t&lt;pivot;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lower_part;</span><br><span class="line">  lower_part.splice(lower_part.<span class="built_in">end</span>(),input,input.<span class="built_in">begin</span>(),divide_point);</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(sequential_quick_sort(<span class="built_in">std</span>::<span class="built_in">move</span>(lower_part)))</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(sequential_quick_sort(<span class="built_in">std</span>::<span class="built_in">move</span>(input)))</span></span>;</span><br><span class="line">  result.splice(result.<span class="built_in">end</span>(),new_higher);<span class="comment">// end is the pivot</span></span><br><span class="line">  result.splice(result.<span class="built_in">begin</span>(),new_lower);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们通过splice操作指定input的首个元素为基准点（由于并非选取了最优基准点，因此比较次数与交换次数相有所提升，但为了选取最优基准点引入的list遍历操作也同样耗时）。由于我们知道基准点必然出现在res中，因此使用splice将其添加进来是合理的。在lambda（比较函数）中，我们采取引用捕获的方式以避免不必要的拷贝。接着使用<code>partition</code>确保了list被按照大小分为2部分，并同样通过splice将其拆分为两个list，接着递归执行排序。最终，我们通过splice操作将排序完成的两个区间拼接在一起，至此快排完成。</p><hr><h3 id="并发函数式快排"><a href="#并发函数式快排" class="headerlink" title="并发函数式快排"></a>并发函数式快排</h3><p>以下是使用了<code>future</code>的并发函数式快排实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; <span class="title">parallel_quick_sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; input)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(input.empty())&#123;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; result;</span><br><span class="line">  result.splice(result.<span class="built_in">begin</span>(),input,input.<span class="built_in">begin</span>());</span><br><span class="line">  T <span class="keyword">const</span>&amp; pivot=*result.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">auto</span> divide_point=<span class="built_in">std</span>::partition(input.<span class="built_in">begin</span>(),input.<span class="built_in">end</span>(),[&amp;](T <span class="keyword">const</span>&amp; t)&#123;<span class="keyword">return</span> t&lt;pivot;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lower_part;</span><br><span class="line">  lower_part.splice(lower_part.<span class="built_in">end</span>(),input,input.<span class="built_in">begin</span>(),divide_point);</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &gt; <span class="title">new_lower</span><span class="params">(<span class="built_in">std</span>::async(&amp;parallel_quick_sort&lt;T&gt;,<span class="built_in">std</span>::<span class="built_in">move</span>(lower_part)))</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(parallel_quick_sort(<span class="built_in">std</span>::<span class="built_in">move</span>(input)))</span></span>;</span><br><span class="line">  result.splice(result.<span class="built_in">end</span>(),new_higher);</span><br><span class="line">  result.splice(result.<span class="built_in">begin</span>(),new_lower.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和上个实例相比，二者最大的区别是本例使用<code>std::async</code>在另一个线程排序lower_part，upper_part则与原来一致。使用<code>std::async</code>的一大优势在于充分利用了硬件并发性，举例而言，如果向下执行3次递归，则将启动八个线程执行计算任务，如果执行10次递归（当list规模在1000左右时），将启动1024个线程执行计算。如果当前待执行的任务已经超出了硬件并发资源，则子任务（spawn_task）将被同步执行。这些子任务将在调用get()的线程中运行，从而避免于事无补地将任务传递至另一个线程。需要注意的是，若无std::launch::async的显式指定，std::async将为每一个任务启动一个新线程（即使当前已经超出了硬件最大并发量），有关std::async的启动机制，具体可见<a href="https://xander.wiki/post/61b11a8d.html">https://xander.wiki/post/61b11a8d.html</a> 。此外，由于new_lower是一个future，因此我们必须通过get来等待后台任务运行完成，接着执行splice。get的返回值是一个右值，可以直接move。最后，在此实例中<code>std::partition</code>依然是同步的，因此可以继续改进。</p><p>除了使用<code>std::async</code>自动生成<code>spawn_task</code>,开发者也可以通过简单封装<code>std::packaged_task</code>与<code>std::thread</code>,撰写自己的<code>spawn_task()</code>（如下述代码所示）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span> A&gt; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::result_of&lt;<span class="title">F</span><span class="params">(A&amp;&amp;)</span>&gt;::type&gt; <span class="title">spawn_task</span><span class="params">(F&amp;&amp; f,A&amp;&amp; a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::result_of&lt;F(A&amp;&amp;)&gt;::type result_type;</span><br><span class="line">  std::packaged_task&lt;result_type(A&amp;&amp;)&gt;  task(std::move(f)));     </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;     </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(task),<span class="built_in">std</span>::<span class="built_in">move</span>(a))</span></span>;     </span><br><span class="line">  t.<span class="built_in">detach</span>();     </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法相较于<code>std::async</code>并无优势可言（并且会导致大量的<code>massive oversubcription</code>），但却为“将精密事务迁移入由线程池维护的队列”——这一任务铺平了康庄大道（我们将在第九章详细论述）。</p><h1 id="CSP编程范式"><a href="#CSP编程范式" class="headerlink" title="CSP编程范式"></a>CSP编程范式</h1><p>&nbsp;</p><p>函数式编程并非是规避共享数据竞争的唯一途径，CSP(Communicating Sequential Processes)范式具备同样的能力。在此编程范式中，线程完全独立的，不再共享数据，但依旧支持线程间通信。</p><h2 id="通过信息传递机制实现同步"><a href="#通过信息传递机制实现同步" class="headerlink" title="通过信息传递机制实现同步"></a>通过信息传递机制实现同步</h2><p>CSP范式的理念很简单：如果不再存在共享数据，那么开发者可以通过[某一线程]对传入信息的响应方式来推断线程状态。在此情形下，每一个线程实际上都是一个状态机：线程将根据接受到的信息更新自身状态，并将一条或多条信息发送至别的线程，这些行为完全取决于线程自身的初始状态。</p><p>由于C++ thread共享地址空间，因此无法从语言层面保证不存在共享数据，开发者必须从实现层面上保证这一点。当然，消息队列必须为各线程所共享，但细节可以被封装至库内。</p><h3 id="设计实例"><a href="#设计实例" class="headerlink" title="设计实例"></a>设计实例</h3><p>设想现在正在为一台ATM机撰写程序，我们不仅需要处理与使用者的交互，还需要处理与银行后台系统的交互，同样，我们还需要操作物理设备以便让使用者能够自如地完成插卡，取钱，拔卡等操作。</p><p>该系统的一种实现方式是拆分任务，使其在三个独立的线程上运行：一个操作物理设备，一个处理ATM逻辑，一个与银行后台通信。这些线程完全可以仅通过信息传递完成通信，根本不需要共享数据。举例而言，当使用者按下按键后，操作物理设备的线程将发送信息至处理ATM逻辑的线程，后者又将发送信息至前者，指示应该吐出多少钱。</p><p>ATM 逻辑可以抽象为一个状态机，该线程内部维护一个状态，并根据下一次传入的信息更新自身状态，并反复循环，下图即为一次简单的状态流转。<br><img src="http://static.zybuluo.com/zsmj2019/xmg1nmjyq6q4v07r1pefkq0g/WX20200311-204143@2x.png" alt="WX20200311-204143@2x.png-288.2kB"><br>表征ATM逻辑的类具备一些展现自身状态的成员函数。每一个成员函数都与特定的传入信息相关，并根据传入信息更新内部状态，与此同时，每一种信息类型都表现为一种特定的结构体。具体而言，ATM机等待插卡的逻辑可以简化为下述代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card_inserted</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> account; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">atm</span> &#123;</span></span><br><span class="line">  messaging::receiver incoming;</span><br><span class="line">  messaging::sender bank;</span><br><span class="line">  messaging::sender interface_hardware;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (atm::*state)();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> account; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> pin;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">waiting_for_card</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interface_hardware.send(display_enter_card()); </span><br><span class="line">    incoming.wait().</span><br><span class="line">      handle&lt;card_inserted&gt;([&amp;](card_inserted <span class="keyword">const</span>&amp; msg)&#123;</span><br><span class="line">        <span class="comment">// handle仅接受类型为card_inserted的信息</span></span><br><span class="line">        <span class="comment">// 别的信息传入将导致丢弃</span></span><br><span class="line">        account=msg.account; </span><br><span class="line">        pin=<span class="string">""</span>;</span><br><span class="line">        interface_hardware.send(display_enter_pin()); </span><br><span class="line">        state=&amp;atm::getting_pin;</span><br><span class="line">        <span class="comment">// 执行结束后更新状态</span></span><br><span class="line">        <span class="comment">// run()内将执行新状态函数</span></span><br><span class="line">      &#125; </span><br><span class="line">    );</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getting_pin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    state=&amp;atm::waiting_for_card; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;*state)(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span>(messaging::close_queue <span class="keyword">const</span>&amp;) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><code>getting_pin</code>的设计要较为复杂一些，有简化版实例如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atm::getting_pin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  incoming.wait()</span><br><span class="line">  <span class="comment">// 存在三种可传入信息</span></span><br><span class="line">  <span class="comment">// 因此handle呈链状</span></span><br><span class="line">  <span class="comment">// 每一次对handle的调用都会将消息类型特化为模板参数</span></span><br><span class="line">  .handle&lt;digit_pressed&gt;([&amp;](digit_pressed <span class="keyword">const</span>&amp; msg)&#123; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">const</span> pin_length=<span class="number">4</span>;</span><br><span class="line">    pin+=msg.digit;</span><br><span class="line">    <span class="comment">// 密码尚未输入完时不会改变状态，因此可以持续输入</span></span><br><span class="line">    <span class="keyword">if</span>(pin.length()==pin_length) &#123;</span><br><span class="line">      bank.send(verify_pin(account,pin,incoming));</span><br><span class="line">      state=&amp;atm::verifying_pin; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  )</span><br><span class="line">  .handle&lt;clear_last_pressed&gt;([&amp;](clear_last_pressed <span class="keyword">const</span>&amp; msg)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pin.empty()) &#123;</span><br><span class="line">      pin.resize(pin.length()<span class="number">-1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  )</span><br><span class="line">  .handle&lt;cancel_pressed&gt;([&amp;](cancel_pressed <span class="keyword">const</span>&amp; msg)&#123; </span><br><span class="line">    state=&amp;atm::done_processing; </span><br><span class="line">  &#125; </span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上文可见，代码中根本不存在同步和并发，ATM logic和系统的其他组件分别运行在独立的线程上。这种设计手法被称为Actor model——系统内存在多个运行于独立线程上的actor，每一个都通过发送和接受消息来处理当前任务，除了直接通过信息传入的状态外，彼此没有任何共享状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;使用本节描述的技巧编码，开发者可以更多地将注意力集中至同步操作本身——使用函数式编程技法实现并发编程。&lt;/p&gt;
&lt;p&gt;相较于在多个线程间直接共享数据，每个任务均拥有自己的数据似乎更为优雅，并且可将任务结果广播至其它线程——这需要使用future实现。&lt;/p&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>同步并发操作——限制等待时间</title>
    <link href="https://xander.wiki/2019/05/07/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E9%99%90%E5%88%B6%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4/"/>
    <id>https://xander.wiki/2019/05/07/同步并发操作——限制等待时间/</id>
    <published>2019-05-07T04:50:00.000Z</published>
    <updated>2021-06-23T07:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在本章前文所述的各项等待操作中，线程阻塞的时间并不确定，但在实际应用中存在这样的需求：限制线程等待时间——在线程等待特定的一段时间后，开发者既可以向用户发出“该事件仍未完成”的提示，也可以接受由于用户放弃等待从而关闭线程的命令。</p><p>判断程序运行超时有两种方式：</p><ol><li>duration-based<br>该方式需要用户指定一段时间，例如30ms。</li><li>absolute<br>该方式需要用户提供一个时间点，例如17:30:15.045987023 UTC on November 30, 2011。</li></ol><p>大多数等待函数均支持这两种方式，处理<code>duration-based</code>的后缀为<code>_for</code>，处理<code>absolute</code>的后缀为<code>_until</code>。举例而言，<code>std::condition_variable</code>的成员函数<code>wait_for()</code>和<code>wait_until()</code>。此外，这些函数具备2种重载，第一种重载形式等待着信号触发或虚假唤醒，另一种则在唤醒时检查谓词，并仅在结果为<code>true</code>的情况下返回，或直接超时返回。更多相关信息可见本节末尾的图表。</p><a id="more"></a><h1 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h1><p>&nbsp;<br>在探讨超时之前，有必要先了解一下时间在C++中的表现形式，首先从<code>clock</code>开始。<br>对C++标准库而言，<code>clock</code>意味着时间信息源，具体来说，<code>clock</code>是一个类，提供了4种不同的信息：</p><ol><li>当前时间</li><li>时间类型</li><li>时钟节拍</li><li>时钟是否稳定（由时钟节拍确定）</li></ol><h2 id="当前时间"><a href="#当前时间" class="headerlink" title="当前时间"></a>当前时间</h2><p>当前时间可通过调用该类的静态成员函数<code>now</code>获得，如<code>std::chrono::system_clock::now()</code>将返回系统时钟当前时间。</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p>时间类型由<code>time_point</code>中的<code>typedef</code>指定，因此<code>some_clock::now()</code>的类型为<code>some_clock::time_point</code>。</p><h2 id="时钟节拍"><a href="#时钟节拍" class="headerlink" title="时钟节拍"></a>时钟节拍</h2><p>时钟节拍被指定为1/x(x取决于硬件)秒。若当前时钟一秒有25个节拍，则其一个时钟周期为<code>std::ratio&lt;1, 25&gt;</code>。若时钟的时钟节拍每2.5秒一次，则时钟周期则可表示为<code>std::ratio&lt;5, 2&gt;</code>。时钟周期通常会在数据手册中给出，但如果当前并不知悉，则可以通过多次运行特定程序的方法求解平均值（这种方法并不保证精确性）。</p><h2 id="时钟稳定性"><a href="#时钟稳定性" class="headerlink" title="时钟稳定性"></a>时钟稳定性</h2><p>若时钟节拍均匀分布（无论该速率与时钟周期匹配与否）且无法调整，则称该时钟为稳定时钟，在此类情况下，时钟类中的<code>is_steady</code>静态数据成员为<code>true</code>，否则为<code>false</code>。通常情况下我们可以认为<code>std::chrono::system_clock</code>不稳定，因为该时钟可被调整（即使这种调整是为了抑制本地时钟漂移而自发进行的）。</p><p>对时钟的调整行为可能导致一个问题：当前调用<code>now</code>返回的时间要早于之前调用<code>now</code>返回的时间。（举例而言，做手机app的耗时监控，在app启动后用户调整了时间，从而导致计算错误，此时应当使用绝对时间）。</p><p>时钟的稳定性对于超时计算而言非常重要，因此C++标准库提供了<code>std::chrono::steady_clock</code>。<code>std::chrono::system_clock</code>代表了系统时钟的“实际时间”，并且提供了可将时间点转化为<code>time_t</code>类型的接口；<code>std::chrono::high_resolution_clock</code>提供了具备最高分辨率（即最小的时钟周期）的时钟。上述时钟及其相关工具均位于头文件<code>&lt;chrono&gt;</code>中。</p><hr><h1 id="Durations"><a href="#Durations" class="headerlink" title="Durations"></a>Durations</h1><p>&nbsp;<br>时延是本节最简单的内容：它们由<code>std::chrono::duration&lt;&gt;</code>函数模板进行处理(位于<code>std::chrono</code>命名空间内)。第一个模板参数是一个时延外在表现的类型(如int，long或double)，第二个模板参数是制定部分，表示每一个单元所用秒数。举例而言，当存在分钟级时延需要存储于<code>short</code>类型中时，可以写成<code>std::chrono::duration&lt;short,std::ratio&lt;60,1&gt;&gt;</code>，因为一分钟包含60秒。若需要将毫秒级时延存储于<code>double</code>类型中时，则写作<code>std::chrono::duration&lt;short,std::ratio&lt;1,1000&gt;&gt;</code>，原因在于一秒包含1000毫秒。</p><p>在隐式转换下，时延转换不存在截断（即可由时转为秒，但不可由秒转为时）。我们可以通过显式操作<code>std::chrono::duration_cast&lt;&gt;</code>来完成转换(具备截断）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>; </span><br><span class="line"><span class="built_in">std</span>::chrono::seconds s= <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(ms); <span class="comment">// s = 54</span></span><br></pre></td></tr></table></figure></p><p>时延支持算术操作，因此开发者可以对它进行加减乘除操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>*seconds(<span class="number">1</span>) == seconds(<span class="number">5</span>) == minutes(<span class="number">1</span>) - seconds(<span class="number">55</span>)</span><br></pre></td></tr></table></figure><br>此外，可以通过成员函数<code>count</code>获取时延中的单元数量，如<code>std::chrono::milliseconds(1234).count()</code>是1234。</p><p>为了方便起见，在C++1 中引入的<code>std::chrono_literals</code>命名空间内有许多预定义字面值后缀操作符，因此后续可以直接写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals; </span><br><span class="line"><span class="keyword">auto</span> one_day=<span class="number">24</span>h;</span><br><span class="line"><span class="keyword">auto</span> half_an_hour=<span class="number">30</span><span class="built_in">min</span>;</span><br><span class="line"><span class="keyword">auto</span> max_time_between_messages=<span class="number">15</span>ns; <span class="comment">// ==  std::chrono::nanoseconds(15)</span></span><br></pre></td></tr></table></figure><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>假设开发者期待在35ms内一个<code>future</code>对象状态就绪，以便于执行相关操作，那么该需求可被写为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f=<span class="built_in">std</span>::async(some_task); </span><br><span class="line"><span class="keyword">if</span>(f.wait_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">35</span>)) == <span class="built_in">std</span>::future_status::<span class="built_in">ready</span>) </span><br><span class="line">  do_something_with(f.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><br>所有的<code>wait</code>函数均返回一个状态，用以指示当前时间已经耗尽或者说等待事件已经发生。在刚才的代码实例中，由于我们调用的是<code>future</code>的程序函数<code>wait_for</code>，因此它存在三种返回状态：</p><ol><li>std::future_status::timeout 时延耗尽</li><li>std::future_status::ready future 已就绪</li><li>std::future_status::deferred future 任务被延迟</li></ol><p>计算时延所使用的是系统内部提供的稳定时钟，因此无论系统时钟<code>system_clock</code>发生怎样的调整，线程耗时总是35毫秒。当然，由于难以预料的系统调度和操作系统间不同的时钟精度，从调用该线程到返回该线程的时间可能要远长于35毫秒。</p><hr><h1 id="time-point"><a href="#time-point" class="headerlink" title="time_point"></a>time_point</h1><p>&nbsp;<br>时钟的时间点可以用<code>std::chrono::time_point&lt;&gt;</code>类模板实例来表示。模板的第一个参数用来指定所要使用的时钟，第二个参数表示时延的计量单位(<code>std::chrono::duration&lt;&gt;</code>的特例化 )。一个时间点的值就是以一个时间戳(epoch)作为起点的时间的长度(其必然为指定时延的倍数)。时间戳是时钟的基本属性，但它既不可直接查询也不并非由C++标准指定。通常采用的时间戳为1970年1月1日00:00，或运行应用程序的计算机启动时。不同的时钟实例可能共享一个时间戳，也可能具备各自独立的时间戳。虽然我们并不了解当前使用的是何种时间戳，但开发者可通过对指定<code>time_point</code>类型使用<code>time_since_epoch()</code>来获取时延值，该时延值即为当前时间距离时间戳的距离。</p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>举例而言，<code>std::chrono::time_point&lt;std:: chrono::system_clock, std::chrono::minutes&gt;</code>表示当前时间点与系统时钟相关联，且其时延计量单位为分钟。我们可以自由地通过对一个时间点执行算术运算，从而获取另一个时间点，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::high_resolution_clock:: now() + <span class="built_in">std</span>::chrono::nanoseconds(<span class="number">500</span>)</span><br></pre></td></tr></table></figure><br>我们也可以在两个时间点之间执行算术运算（二者需要共享一个时钟），从而获取时间差。这常见于代码块的计时需求：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=<span class="built_in">std</span>::chrono::high_resolution_clock::now(); </span><br><span class="line">do_something(); </span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">stop</span>=<span class="built_in">std</span>::chrono::high_resolution_clock::now(); </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;”do_something() took “&lt;&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>,<span class="built_in">std</span>::chrono::seconds&gt;(<span class="built_in">stop</span>-start).count()&lt;&lt;” seconds”&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><br>应当尽量避免在计时代码块中调整<code>std::chrono::time_point</code>所指定的时钟，因为这将导致计时错误。</p><p>假设当前存在一个事件，而我们至多等待该事件500毫秒，则有程序如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> done; </span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> timeout = <span class="built_in">std</span>::chrono::steady_clock::now() + <span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>); </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; </span><br><span class="line">  <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.wait_until(lk,timeout) == <span class="built_in">std</span>::cv_status::timeout)</span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="Functions-that-accept-timeouts"><a href="#Functions-that-accept-timeouts" class="headerlink" title="Functions that accept timeouts"></a>Functions that accept timeouts</h1><p>&nbsp;<br>开发者经常需要为特定的线程添加延迟，让它们休眠一段指定时间或休眠至特定时间点，而这两个需求的实现依赖于函数<code>std::this_thread::sleep_for()</code>与<code>std::this_thread::sleep_until()</code>。</p><p>显然，休眠只是超时（timeout）处理的一种形式，在上文中，超时配合条件变量与期望一起使用。超时甚至可以在尝试获取一个互斥锁时(前提是该互斥锁支持timeout)使用，传统的<code>std::mutex</code>与<code>std::recursive_mutex</code>并不支持超时，但<code>std::timed_mutex</code>与<code>std::recursive_timed_mutex</code>则可以。它们具备了名为<code>try_lock_for</code>与<code>try_lock_until</code>的成员函数。下表则更具体地展示了支持timeout的函数，并给出了它们所需参数与返回值。</p><p><img src="http://static.zybuluo.com/zsmj2019/0gqjv6v3rep0hvrwgvxkzawj/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-23%20%E4%B8%8B%E5%8D%8811.09.46.png" alt="屏幕快照 2019-06-23 下午11.09.46.png-457.7kB"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;在本章前文所述的各项等待操作中，线程阻塞的时间并不确定，但在实际应用中存在这样的需求：限制线程等待时间——在线程等待特定的一段时间后，开发者既可以向用户发出“该事件仍未完成”的提示，也可以接受由于用户放弃等待从而关闭线程的命令。&lt;/p&gt;
&lt;p&gt;判断程序运行超时有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;duration-based&lt;br&gt;该方式需要用户指定一段时间，例如30ms。&lt;/li&gt;
&lt;li&gt;absolute&lt;br&gt;该方式需要用户提供一个时间点，例如17:30:15.045987023 UTC on November 30, 2011。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大多数等待函数均支持这两种方式，处理&lt;code&gt;duration-based&lt;/code&gt;的后缀为&lt;code&gt;_for&lt;/code&gt;，处理&lt;code&gt;absolute&lt;/code&gt;的后缀为&lt;code&gt;_until&lt;/code&gt;。举例而言，&lt;code&gt;std::condition_variable&lt;/code&gt;的成员函数&lt;code&gt;wait_for()&lt;/code&gt;和&lt;code&gt;wait_until()&lt;/code&gt;。此外，这些函数具备2种重载，第一种重载形式等待着信号触发或虚假唤醒，另一种则在唤醒时检查谓词，并仅在结果为&lt;code&gt;true&lt;/code&gt;的情况下返回，或直接超时返回。更多相关信息可见本节末尾的图表。&lt;/p&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>同步并发操作——使用future等待一次性事件</title>
    <link href="https://xander.wiki/2019/04/21/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%9C%9F%E6%9C%9B%E7%AD%89%E5%BE%85%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BA%8B%E4%BB%B6/"/>
    <id>https://xander.wiki/2019/04/21/同步并发操作——使用期望等待一次性事件/</id>
    <published>2019-04-21T02:50:00.000Z</published>
    <updated>2021-06-23T07:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本节我们将讨论线程应当以何种方式处理一次性事件，即线程仅需要被notice一次。</p><a id="more"></a><h1 id="future"><a href="#future" class="headerlink" title="future"></a>future</h1><p>&nbsp;<br>C++标准库将这种一次性事件建模为<code>future</code>。当线程需要等待某个特定的一次性事件时，它将持有表征该事件的future。随后，线程将以一个较短的时间周期检查事件是否触发。当然，检查期间也会执行其他任务。又或者，线程可以在等待任务期间可以先执行一些别的任务，直到对应的任务触发(此时future的状态变为ready)，此后，future将无法被重置。</p><p>C++标准库提供了两种future：unique_future<code>std::future&lt;&gt;</code>与shared future<code>std::shared_future&lt;&gt;</code>，它们都位于头文件<code>&lt;future&gt;</code>内。一个<code>std::future</code>实例与一个指定事件相关联，而多个<code>std::shared_future</code>可以共享共一个事件，并在事件完成后同时ready，共享与事件相关的任何数据。如果事件不存在关联数据，则可以使用<code>std::future&lt;void&gt;</code>与<code>std::shared_future&lt;void&gt;</code>。</p><p>尽管future被广泛应用于线程间通信，但future对象本身并不提供同步访问。若当前存在多个线程需要访问同一个future对象，那么必须使用互斥量或类似的同步机制对数据访问进行保护。但<code>std::shared_future</code>存在一个特例：多个线程可以访问自己的<code>std :: shared_future</code>副本而无需同步。</p><p>最基础的一次性事件是获取线程函数返回值，由于std::thread`并没有提供一个简单的返回任务结果的接口，因此我们将使用future来实现。</p><hr><h1 id="带有返回值的后台任务"><a href="#带有返回值的后台任务" class="headerlink" title="带有返回值的后台任务"></a>带有返回值的后台任务</h1><p>&nbsp;<br>假设当前存在一个耗时颇久的计算任务，其结果并不需要立即获得，显然，该任务应当作为后台进程。</p><p>开发者可以使用<code>std::async</code>来启动当前无需立即得到结果的异步任务，<code>std::async</code>返回一个持有函数返回值的<code>std::future</code>对象，调用<code>get()</code>成员函数可以得到返回结果(调用后，当前线程将阻塞至future状态变为ready)。标准使用案例如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; the_answer=<span class="built_in">std</span>::async(find_the_answer_to_ltuae);</span><br><span class="line">  do_other_stuff();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"The answer is "</span>&lt;&lt;the_answer.<span class="built_in">get</span>()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类似于<code>std::thread</code>，future也支持调用者通过添加额外的参数向其内置任务传递参数。</p><ol><li>若第一个参数是指向一个成员函数的指针，第二个参数提供有该类的具体对象(无论是直接传入，通过指针还是包装于<code>std::ref</code>中)，剩余的参数将视作成员函数参数。</li><li>若不满足条件1，第二个及其之后的参数将视作传入函数或可调用对象的参数。<br>若传入参数为右值，异步任务中的拷贝将直接通过移动构造函数完成创建，因此<code>std::async</code>支持将<code>move only</code>对象作为参数传入。具体使用如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">X x; </span><br><span class="line"><span class="keyword">auto</span> f1 = <span class="built_in">std</span>::async(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">"hello"</span>);<span class="comment">// 调用p-&gt;foo(42,"hello") p为成员函数指针</span></span><br><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">std</span>::async(&amp;X::bar,x,<span class="string">"goodbye"</span>);<span class="comment">// tmpx.bar("goodbye") tmpx是x的拷贝副本 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span>)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">Y y; </span><br><span class="line"><span class="keyword">auto</span> f3=<span class="built_in">std</span>::async(Y(),<span class="number">3.141</span>);<span class="comment">// tempy(3.141) tempy由y移动构造函数生成</span></span><br><span class="line"><span class="keyword">auto</span> f4=<span class="built_in">std</span>::async(<span class="built_in">std</span>::ref(y),<span class="number">2.718</span>);<span class="comment">// y(2.718)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>; </span><br><span class="line"><span class="built_in">std</span>::async(baz,<span class="built_in">std</span>::ref(x)); <span class="comment">// 调用baz(x) </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">move_only</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  move_only();</span><br><span class="line">  move_only(move_only&amp;&amp;)</span><br><span class="line">  move_only(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;);</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">auto</span> f5=<span class="built_in">std</span>::async(move_only()); <span class="comment">// 调用tempm，tempm由std::move(move_only())移动构造生成</span></span><br></pre></td></tr></table></figure>值得注意的是，<code>std::async</code>并不保证任务被异步执行，更进一步地说，<code>std::async</code>的默认启动策略既可能启动一个新线程运行任务，但该任务也可能仅在future被调用<code>get()</code>或<code>wait()</code>时才会运行。为了明确任务启动策略，开发者可向<code>std::async</code>传入一个额外参数类型<code>std::lunch</code>，它是一个<code>enum class</code>，所含枚举量如下：</li><li><code>std::launch::async</code>，意味着函数必然将运行于另一个线程之上（即异步运行）</li><li><code>std::launch::defered</code>，函数的执行被推迟至调用<code>get</code>或<code>wait</code>时。当调用<code>get</code>或<code>wait</code>时，函数将同步执行（即阻塞调用程序，直到函数完成运行）。如果一直不调用<code>get</code>或<code>wait</code>，f将永不执行。</li></ol><p>其使用如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f6=<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,Y(),<span class="number">1.2</span>); <span class="comment">// 在新线程上执行 </span></span><br><span class="line"><span class="keyword">auto</span> f7=<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred,baz,<span class="built_in">std</span>::ref(x)); <span class="comment">// 在 wait()或get()调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f8=<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred | <span class="built_in">std</span>::launch::async, baz,<span class="built_in">std</span>::ref(x)); <span class="comment">// 默认启动策略</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="任务与期望"><a href="#任务与期望" class="headerlink" title="任务与期望"></a>任务与期望</h1><p>&nbsp;<br><code>std::async</code>并非是future与任务关联的唯一方式，开发者也可以将task包装至<code>std::packaged_task</code>或<code>std::promise</code>。前者的抽象级别更高。</p><h2 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h2><p><code>std::packaged_task</code>将一个future绑定至函数或可调用对象。当<code>std::packaged_task</code>对象被调用时，它将调用相关函数或可调用对象，将future状态置为就绪，并将返回值存储于其中。</p><p><code>std::packaged_task</code>常用于构建线程池的结构单元或管理其他任务，如在任务所在线程运行任务(同步)，或在某后台线程中按顺序运行所有任务。如果当前存在一个粒度较大的操作，并且该操作可分解为独立的子任务时，则可将各子任务包装于<code>std::packaged_task</code>中，并将该实例传递给任务调度器或线程池。这种操作对任务的细节进行了抽象，调度器仅处理<code>std::packaged_task</code>实例，而非处理单独的函数。</p><p><code>std::packaged_task</code>的模板参数是一个函数签名，如<code>void()</code>或<code>int(string&amp;,double)</code>。<code>std::packaged_task</code>的构造函数必须传入一个函数或可调用对象，它们的形参与返回值必须能够隐式转为模板参数，即不需要严格地一致。</p><p>以下是一个<code>std::packaged_task</code>的模板偏特化实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">packaged_task</span>&lt;std::string(std::vector&lt;char&gt;*,int)&gt; &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable&amp;&amp; f)</span></span>; <span class="comment">// f的形参必须能隐式转为std::vector&lt;char&gt;*,int</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">get_future</span><span class="params">()</span></span>;<span class="comment">// f的返回值必须能隐式转为std::string</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;*,<span class="keyword">int</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::packaged_task</code>是一个可调用对象，它可以被封装至<code>std::function</code>中，可以作为线程函数传递给<code>std::thread</code>，可以作为另一个函数的实参(该函数接受一个可调用对象)，甚至可以被直接调用。当<code>std::packaged_task</code>作为函数对象被调用时，提供至其<code>operator()</code>的参数被传递至其内部包含的函数，返回值将作为异步运行结果存储于<code>get_future</code>提供的<code>std::future</code>中。</p><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>许多GUI框架都利用某个特定的更新线程完成界面更新，因此当某个线程需要更新当前界面时，它将发送信息至更新线程，敦促后者完成界面更新操作。通过<code>std::packaged_task</code>我们可以实现该需求，并且杜绝了发送自定义信息的需要。具体实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex m; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gui_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!gui_shutdown_message_received()) &#123; </span><br><span class="line">    get_and_process_gui_message(); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">void</span>()&gt; task; </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; </span><br><span class="line">      <span class="keyword">if</span>(tasks.empty()) </span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      task = <span class="built_in">std</span>::<span class="built_in">move</span>(tasks.front());</span><br><span class="line">      tasks.pop_front();</span><br><span class="line">    &#125; <span class="comment">// 此处互斥量的锁被释放</span></span><br><span class="line">    task();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将任务置入队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; res = task.get_future();</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  tasks.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(task));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段程序十分易懂：GUI线程将反复循环，直至收到一条关闭图形界面的命令。在循环过程中，该线程将轮询界面消息(时间点1)，处理诸如用户点击或当前存在于队列内的任务，当前队列内不存在任务时则继续循环。若当前队列内存在任务，则使用<code>std::move</code>提取该任务，随后释放锁并执行任务。此时future与任务相关，当任务执行完毕后其状态将被置为ready。</p><p>将任务置入队列也很简单：首先利用传入参数f创建一个task，并通过该task的成员函数<code>get_future</code>获取future对象，在将task推入队列后返回该future。若当前明确需要了解任务是否完成，函数调用方可等待future，否则直接丢弃。</p><p>在该实例中我们使用了<code>std::packaged_task&lt;void()&gt;</code>，这表明我们期待传入参数是一个无参数无返回值函数或可调用对象(若其存在返回值，则该返回值将被丢弃)。</p><hr><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>对于一些packaged_task不能解决的问题，如任务为非简单调用或存在多个不同来源的任务，我们可以通过<code>std::promise</code>来显式地设定future。</p><h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>若当前存在一个需要处理大量网络连接的应用程序，一个线程对应一个连接的设计非常易于实现。但是该方案仅适用于网络连接较少的情况，随着连接数的增加(亦即线程数的增加)，操作系统资源被大量消耗，并且可能引发较多的上下文切换(线程数目超过硬件核心数)，最终导致程序性能下降。为了避免上述问题，在网络连接较多时，通常一个线程会处理多个网络连接。</p><p>对于需要处理多个网络连接的线程而言，来自不同网络连接的数据包将会被乱序处理，同样地，需要被发送的数据包也将被乱序发送。在大多数情况下，应用程序的其他线程不是在等待数据发送成功，就是在等待数据接收成功。</p><p><code>std::promise&lt;T&gt;</code>与<code>std::future&lt;T&gt;</code>相关联，它将为上述疑难杂症提供如下机制：数据等待线程可以由futur阻塞，而数据发送线程可通过<code>promise</code>设定相关值，并将future状态置为ready。类似于<code>packaged_task</code>，future对象可通过<code>get_future</code>成员函数显式获得。当<code>std::promise</code>调用<code>set_value</code>成员函数设定相关值完毕后，future对象状态将被置为<code>ready</code>，并可用于检索存储值。若你在调用<code>set_value</code>前析构<code>std::promise</code>，将会存储一个异常。</p><p>下述代码展示了如何利用<code>std::promise</code>与<code>std::future</code>完成单线程处理多网络连接。在此实例中，开发者使用<code>std::promise&lt;bool&gt;</code>与<code>std::future&lt;bool&gt;</code>表征数据块的成功传输，与future相关的数据是简单的bool量：成功/失败。对于数据传入，该量则为数据包的有效负载。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_connections</span><span class="params">(connection_set&amp; connections)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!done(connections))&#123; </span><br><span class="line">    <span class="keyword">for</span>(connection_iterator connection=connections.<span class="built_in">begin</span>(),<span class="built_in">end</span>=connections.<span class="built_in">end</span>(); connection!=<span class="built_in">end</span>; ++connection) &#123; </span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;has_incoming_data())&#123; </span><br><span class="line">        data_packet data=connection-&gt;incoming();   </span><br><span class="line">        <span class="built_in">std</span>::promise&lt;payload_type&gt;&amp; p = connection-&gt;get_promise(data.id); </span><br><span class="line">        p.set_value(data.payload); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;has_outgoing_data())&#123; </span><br><span class="line">        outgoing_packet data= connection-&gt;top_of_outgoing_queue(); </span><br><span class="line">        connection-&gt;send(data.payload); </span><br><span class="line">        data.promise.set_value(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>process_connections</code>将持续循环至处理完毕，每一次循环都将遍历当前所有连接，检索传入数据或发送当前队列顶端数据。在本实例中，我们假设所有传入数据均具备属性<code>ID</code>与<code>payload</code>。</p><hr><h1 id="利用future存储异常"><a href="#利用future存储异常" class="headerlink" title="利用future存储异常"></a>利用future存储异常</h1><p>&nbsp;<br>当-1作为实参被传入下述程序时将发生异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square_root</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;<span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(“x&lt;<span class="number">0</span>”); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若当前该函数被异步调用，将会导致什么结果？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">double</span>&gt; f=<span class="built_in">std</span>::async(square_root,<span class="number">-1</span>); </span><br><span class="line"><span class="keyword">double</span> y=f.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><br>该问题的答案是：异常将代替返回值，被存储至future中（此时future被置位为ready）。当future对象调用<code>get</code>成员函数时，该异常将被重新抛出（C++标准并没有明确规定抛出原始异常还是其副本，具体实现由各编译器决定）。被封装至<code>std::packaged_task</code>内的函数或可调用对象抛出异常也是如此。</p><p><code>std::promise</code>同样会将异常存储于future中，但除此之外，它还提供有显式接口。若开发者明确当前需要存储异常，则可以直接通过<code>set_exception</code>成员函数完成需求。显然，<code>set_exception</code>一般出现在catch语句中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::promise&lt;<span class="keyword">double</span>&gt; some_promise; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  some_promise.set_value(calculate_value()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(...) &#123; </span><br><span class="line">  some_promise.set_exception(<span class="built_in">std</span>::current_exception()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里使用了<code>std::current_exception</code>来检索当前异常，存在一种替代方案：使用<code>std::copy_exception()</code>直接存储新的异常而不抛出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_promise.set_exception(<span class="built_in">std</span>::copy_exception(<span class="built_in">std</span>::logic_error(<span class="string">"foo "</span>)));</span><br></pre></td></tr></table></figure><br>显然，在明确异常类型的前提下，这种写法不仅使得try catch代码块更加直观，也给了编译器更大的优化空间。</p><p>另一种存储异常的方法是：在调用<code>std::promise</code>的set成员函数之前析构<code>std::promise</code>对象，亦或在调用<code>std::packaged_task</code>中的任务之前析构<code>std::packaged_task</code>。在future状态为ready之前析构<code>std::promise</code>将导致析构函数存储一个<code>std::future_error</code>异常，其错误码为<code>std::future_errc::broken_promise</code>。</p><hr><h1 id="shared-future"><a href="#shared-future" class="headerlink" title="shared_future"></a>shared_future</h1><p>&nbsp;<br>尽管<code>std::future</code>可以处理所有在线程间数据转移的必要同步，但对<code>std::future</code>成员函数的调用并不彼此同步，也就是说在多线程下没有保护措施地访问一个future对象将导致数据竞争和未定义行为。这由<code>std::future</code>的特性决定：<code>std::future</code>独享同步结果的所有权，在<code>get</code>成员函数调用后将不会存在任何可获取的值。</p><p>如果当前存在多个线程等待同一个事件，那么我们应当使用<code>std::shared_future</code>。顾名思义，<code>std::future</code>是一个<code>move only object</code>，而<code>std::shared_future</code>可被拷贝。但<code>std::shared_future</code>也不具备调用成员函数时的同步性，因此在使用时必须以锁保护。</p><p>使用<code>std::shared_future</code>的首选方案是将其副本传递给每一个需要使用的线程，如此则可保证所有线程均可在其内部通过<code>std::shared_future</code>安全访问结果，使用实例如下图所示。<br><img src="http://static.zybuluo.com/zsmj2019/nld57wa0ysra9ccrvjky2yot/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-28%20%E4%B8%8A%E5%8D%889.12.54.png" alt="屏幕快照 2019-04-28 上午9.12.54.png-302.9kB"></p><p><code>std::shared_future</code>的一大潜在用途是实现复杂表格中的并行运行。每个单元个均具备计算结果，并且该值可被其他单元格引用，因此公式内部可使用<code>std::shared_future</code>对象表征单元格计算结果。在堆所有单元格公式执行并行计算后，所有可被计算的结果将直接计算，而尚存在依赖的单元格计算线程将被阻塞，直到相关数据准备就绪。这种方案最大程度地利用了当前可用的硬件并发。</p><p>某些<code>std::shared_future</code>由<code>std::future</code>构造而来，由于后者不具备拷贝属性，因此在构造时我们应当使用<code>std::move</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(p.get_future())</span></span>; </span><br><span class="line">assert(f.valid()); <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">sf</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(f))</span></span>; </span><br><span class="line">assert(!f.valid()); <span class="comment">// true</span></span><br><span class="line">assert(sf.valid()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br>由于右值具备隐式的移动操作，因此我们可以直接使用<code>get_future</code>返回值构造<code>std::shared_future</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">sf</span><span class="params">(p.get_future())</span></span>;</span><br></pre></td></tr></table></figure><br>当然了，也可以不必这么麻烦，<code>std::future</code>的成员函数<code>share</code>可以直接创建一个<code>std::shared_future</code>，并将所有权直接传递给它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;SomeIndexType, SomeDataType, SomeComparator, SomeAllocator&gt;::iterator&gt; p; </span><br><span class="line"><span class="keyword">auto</span> sf = p.get_future().share();</span><br></pre></td></tr></table></figure><br><code>share</code>的存在使得<code>auto</code>成为可能，从而避免打出大量错综复杂的类型名。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;本节我们将讨论线程应当以何种方式处理一次性事件，即线程仅需要被notice一次。&lt;/p&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>同步并发操作——等待事件或条件</title>
    <link href="https://xander.wiki/2019/04/20/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6%E6%88%96%E6%9D%A1%E4%BB%B6/"/>
    <id>https://xander.wiki/2019/04/20/同步并发操作——等待事件或条件/</id>
    <published>2019-04-20T04:27:00.000Z</published>
    <updated>2021-06-23T07:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在线程运行过程中经常发生如下场景：线程A需要等待线程B完成某操作。有三种方案可以解决这一需求：</p><ol><li><p>反复检查共享标志位(例如mutex)，直到某线程完成操作后将其置位。<br>这将造成两点浪费：首先，线程不得不耗费宝贵的运行时间循环检查数据；其次，如果mutex被线程A上锁（它需要锁住互斥量以查看被其保护的标志位），那么其他线程将无法获得该锁，甚至连已完成任务的线程B也无法锁住互斥量以重置该标志位。</p></li><li><p>使用<code>std::this_thread::sleep_for()</code>令线程在等待间隙短暂休眠</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag; </span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_flag</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; </span><br><span class="line">  <span class="keyword">while</span>(!flag) &#123; </span><br><span class="line">    lk.unlock();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>)); <span class="comment">// 休眠100ms </span></span><br><span class="line">    <span class="comment">//....此时可以保证其他线程获取该锁，重置flag</span></span><br><span class="line">    lk.lock();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案2优于方案1，但缺憾在于开发者无法确定休眠时间取多少合适。过少的休眠时间等于没有，过多的休眠时间又会造成任务必须等待线程苏醒。尽管休眠时间过长很少会对程序运行产生直接影响，但在对实时性较高的场景中（例如游戏画面绘制），这意味着一场灾难。</p></li><li><p>使用C++标准库提供的工具<br>最基本的处理等待事件机制为条件变量(condition variable)。从本质而言，条件变量的存在与事件或条件相关联，并且必须存在一些等待该变量被满足的线程。若当前执行线程确定条件已被满足，那么它将通知一个或多个等待该条件变量被满足的线程，以便唤醒它们接着执行任务。</p></li></ol><a id="more"></a><h1 id="等待条件达成"><a href="#等待条件达成" class="headerlink" title="等待条件达成"></a>等待条件达成</h1><p>&nbsp;<br>C++标准库提供了了两种条件变量的实现：<code>std::condition_variable</code>与<code>std::condition_variable_any</code>,它们都位于头文件<code>&lt;condition_variable&gt;</code>内。</p><p>二者均需要与互斥量配合，不同之处在于<code>std::condition_variable</code>仅限于与<code>std::mutex</code>搭配使用，而<code>std::condition_variable_any</code>则可以与任何满足最低标准的互斥量一起工作，这也是<code>_any</code>后缀的由来。当然，灵活性会带来性能上的损耗，因此除非必要，我们应当尽可能使用<code>std::condition_variable</code>。以下将展示如何使用<code>std::condition_variable</code>实现条件唤醒：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue; </span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(more_data_to_prepare()) &#123; </span><br><span class="line">    data_chunk <span class="keyword">const</span> data = prepare_data(); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_queue.push(data);</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    data_chunk data=data_queue.front(); </span><br><span class="line">    data_queue.pop(); </span><br><span class="line">    lk.unlock();<span class="comment">// 时间点1</span></span><br><span class="line">    <span class="built_in">process</span>(data); </span><br><span class="line">    <span class="keyword">if</span>(is_last_chunk(data)) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先存在一个用于在两个线程间传递数据的队列。当数据准备就绪时，准备数据的线程调用<code>std ::lock_guard</code>锁定保护队列的互斥锁，并将数据推送到队列中。接着该线程调用<code>std:: condition_variable</code>的成员函数<code>notify_one()</code>来通知可能存在的等待线程。</p><p>接下来我们将目光移至<code>data_processing_thread</code>。该线程首先执行对互斥量的锁定(使用的是unique_lock而非lock_gurad,具体原因将在下文提及)。接着线程调用<code>condition_variable</code>的成员函数<code>wait</code>。该函数接收一个lock对象与一个lambda表达式，当lambda表达式返回false时，<code>wait</code>将解锁互斥量，并将当前线程置于阻塞或等待状态。当其他线程调用<code>notify_one()</code>通知条件变量时，执行线程从睡眠中苏醒，重新获取互斥锁并检查执行条件(lambda表达式)。若当前条件满足，从<code>wait()</code>返回（互斥量保持锁定）。若不满足，则线程将解锁互斥量并继续等待。这也就是我们使用<code>unique_lock</code>的原因——我们需要随时加锁解锁的灵活性。如果线程处于休眠状态时互斥锁保持锁定，则数据准备线程将无法锁定互斥锁并把数据添加到队列中，此时等待线程的条件也将永远不会被满足。</p><p><code>unique_lock</code>的存在不仅为了满足<code>wait</code>内频繁加锁与解锁的需要，若当前存在待处理数据，但此时处理操作尚未开始(如代码中时间点1)，开发者同样需要调用<code>unlock</code>，原因在于处理数据可能非常耗时。在前文中我们曾经提及，持有锁的时间过长将造成种种负面影响。</p><hr><h1 id="使用条件变量构建线程安全队列"><a href="#使用条件变量构建线程安全队列" class="headerlink" title="使用条件变量构建线程安全队列"></a>使用条件变量构建线程安全队列</h1><p>&nbsp;<br>使用队列在线程之间传输数据是一种常见行为，既然如此，我们完全可以在队列内部实现同步，从而降低触发条件竞争的可能性。因此，本节将致力于使用条件变量构建通用型线程安全队列。</p><p>首先观察一下C++标准库中<code>queue</code>的对外接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">deque</span>&lt;T&gt; &gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(<span class="keyword">const</span> Container&amp;)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(Container&amp;&amp; = Container())</span></span>; </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">explicit</span> <span class="title">queue</span>(<span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">queue</span>(<span class="title">const</span> <span class="title">Container</span>&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">queue</span>(<span class="title">Container</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">queue</span>(<span class="title">queue</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">queue</span>&amp; q)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; x)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace</span>(<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>忽略构造、赋值、交换后，值得注意的接口有以下三种：</p><ol><li>查询接口(<code>empty()</code>，<code>size()</code>)</li><li>数据接口(<code>front()</code>，<code>back()</code>)</li><li>修改接口(<code>push()</code>，<code>pop()</code>，<code>emplace()</code>)</li></ol><p>类似于stack，queue的接口同样存在固有条件竞争，因此需要将<code>front()</code>与<code>pop()</code>合并至一个接口内。在前文queue的使用场景中，我们注意到接收线程常常需要等待数据，因此我们将<code>pop()</code>接口改为两种不同的操作方式：<code>try_pop()</code>与<code>wait_and_pop()</code>。前者尝试从队列中弹出值，并总是立即返回(带有<code>isSuccess</code>标志)；后者则持续等待至目标弹出。综上，<code>threadsafe_queue</code>接口如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue(); </span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp;); </span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>; <span class="comment">// delete assign</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span>; <span class="comment">// 传入引用作为输出</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>; <span class="comment">// 若失败则返回nullptr</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue; </span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue() &#123;&#125; </span><br><span class="line">  threadsafe_queue(threadsafe_queue <span class="keyword">const</span>&amp; other) &#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>; </span><br><span class="line">    data_queue=other.data_queue; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.push(new_value);</span><br><span class="line">    data_cond.notify_one(); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    value=data_queue.front(); </span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt; (data_queue.front()))</span></span>; </span><br><span class="line">    data_queue.pop(); </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty()) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=data_queue.front();</span><br><span class="line">    data_queue.pop(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty()) </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;(); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt; (data_queue.front()))</span></span>; </span><br><span class="line">    data_queue.pop(); <span class="keyword">return</span> res; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>wait_and_pop</code>的使用方法如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">threadsafe_queue&lt;data_chunk&gt; data_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">    data_queue.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    data_chunk data; </span><br><span class="line">    data_queue.wait_and_pop(data); </span><br><span class="line">    <span class="built_in">process</span>(data); </span><br><span class="line">    <span class="keyword">if</span>(is_last_chunk(data)) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="notify-one的不足与notify-any"><a href="#notify-one的不足与notify-any" class="headerlink" title="notify_one的不足与notify_any"></a>notify_one的不足与notify_any</h1><p>&nbsp;<br><code>notify_one()</code>的不足在于，它将触发当前正在执行<code>wait()</code>的<strong>一个</strong>线程检查其状态并从<code>wait()</code>返回，但开发者无法精准地通知到某个<strong>指定</strong>进程，即使该进程正处于等待状态。</p><p>若存在几个线程正在等待同一事件，并且它们都需要对该事件作出响应（应用场景如共享数据初始化或多个线程等待共享数据更新）。此时我们可以调用<code>notify_all()</code>这一成员函数，顾名思义，这将导致当前所有正在执行<code>wait()</code>的线程检查它们正在等待的条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;在线程运行过程中经常发生如下场景：线程A需要等待线程B完成某操作。有三种方案可以解决这一需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;反复检查共享标志位(例如mutex)，直到某线程完成操作后将其置位。&lt;br&gt;这将造成两点浪费：首先，线程不得不耗费宝贵的运行时间循环检查数据；其次，如果mutex被线程A上锁（它需要锁住互斥量以查看被其保护的标志位），那么其他线程将无法获得该锁，甚至连已完成任务的线程B也无法锁住互斥量以重置该标志位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;std::this_thread::sleep_for()&lt;/code&gt;令线程在等待间隙短暂休眠&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; flag; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::mutex m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wait_for_flag&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::unique_lock&amp;lt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::mutex&amp;gt; &lt;span class=&quot;title&quot;&gt;lk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(m)&lt;/span&gt;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!flag) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lk.unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::this_thread::sleep_for(&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::chrono::milliseconds(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// 休眠100ms &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//....此时可以保证其他线程获取该锁，重置flag&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lk.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方案2优于方案1，但缺憾在于开发者无法确定休眠时间取多少合适。过少的休眠时间等于没有，过多的休眠时间又会造成任务必须等待线程苏醒。尽管休眠时间过长很少会对程序运行产生直接影响，但在对实时性较高的场景中（例如游戏画面绘制），这意味着一场灾难。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用C++标准库提供的工具&lt;br&gt;最基本的处理等待事件机制为条件变量(condition variable)。从本质而言，条件变量的存在与事件或条件相关联，并且必须存在一些等待该变量被满足的线程。若当前执行线程确定条件已被满足，那么它将通知一个或多个等待该条件变量被满足的线程，以便唤醒它们接着执行任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++并发编程实战" scheme="https://xander.wiki/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C++" scheme="https://xander.wiki/tags/C/"/>
    
      <category term="并发编程" scheme="https://xander.wiki/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
