<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>13.以const_iterator代替iterator</title>
    <url>/2018/07/01/13.%E4%BB%A5const_iterator%E4%BB%A3%E6%9B%BFiterator/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>(建议将本节与Effective STL Item26、27结合阅读）<br>理论上来说，当你不需要改变迭代器所指对象时，你应当尽量使用const_iterator，这条规则对于C++98与C++11都适用。但实际上在C++98中，使用const_iterator会面临处处受限的窘境。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>举例而言，假若你希望在一个vector&lt;int&gt;中搜索1983第一次出现的位置，并在其位置插入一个1998，如果当前vector内不存在1983，则在vector尾端插入。使用C++98中的iterator可以轻松完成上述操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">…</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">std</span>::<span class="built_in">find</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(), <span class="number">1983</span>);</span><br><span class="line">values.insert(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure><br>由于我们并没有改变iterator指向的元素，理论上我们应当将其改为const_iterator。话虽如此，但在C++98中却并不简单，下面展示了一个似是而非的修正版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator IterT; </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator ConstIterT; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">…</span><br><span class="line">ConstIterT ci = <span class="built_in">std</span>::<span class="built_in">find</span>(<span class="keyword">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">begin</span>()),</span><br><span class="line">                          <span class="keyword">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">end</span>()),</span><br><span class="line">                          <span class="number">1983</span>);</span><br><span class="line">values.insert(<span class="keyword">static_cast</span>&lt;IterT&gt;(ci), <span class="number">1998</span>); <span class="comment">// may not compile</span></span><br></pre></td></tr></table></figure><br>find函数中使用了强制转换，原因在于：在C++98中，从一个non-const容器中获取const_iterator并非易事。当然了，也不一定非要使用强制转换，你可以定义一个常量引用指向values，然后在源代码中以该常量引用替换values。但不管怎么说，从获取一个指向non-const容器内部元素的const_iterator总是很麻烦。</p>
<p>即使你真的获取到了const_iterator，事情也未必会发展地如你所愿。在C++98中，插入和删除函数参数必须为iterator类型，这也就是上述代码最后千方百计将const_iterator转换回来的原因。不过，在上述代码的注释中标明强制转换可能无法编译（正确的转换方法与为何会无法编译可见Effective STL Item26、27）。</p>
<hr>
<h1 id="C-11中的const-iterator"><a href="#C-11中的const-iterator" class="headerlink" title="C++11中的const_iterator"></a>C++11中的const_iterator</h1><p>&nbsp;<br>C++11中一切都发生了改变，通过cbegin与cend成员函数，non-const容器也可以轻松获取const_iterator。此外，以往STL中需要以iterator标明位置的成员函数（例如insert、erase等等）现如今也可以用const_iterator作为参数,现在我们用C++11再次完成刚才所说的功能：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::<span class="built_in">find</span>(values.cbegin(),values.cend(), <span class="number">1983</span>);</span><br><span class="line">values.insert(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="C-14中的const-iterator"><a href="#C-14中的const-iterator" class="headerlink" title="C++14中的const_iterator"></a>C++14中的const_iterator</h1><p>&nbsp;<br>尽管C++11中的const_iterator已经大幅度提高了我们的生产力，但其对于开发通用库程序时还是略显不足。这些程序可能会接收一个容器，返回其数据结构起始和结束的位置。我们认为真正的泛型应当以非成员函数的形式出现，而非成员函数。</p>
<p>假设我们需要泛型之前的findAndInsert程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container, <span class="keyword">const</span> V&amp; targetVal,<span class="keyword">const</span> V&amp; insertVal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::cbegin;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::cend;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::<span class="built_in">find</span>(cbegin(container),cend(container),targetVal);</span><br><span class="line">    container.insert(it, insertVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>遗憾的是上述程序只能在C++14中生效，原因在于C++11只添加了begin、end这两种非成员函数泛型版本，C++14才完成了cbegin、cend的加入。</p>
<p>但我们也可以稍加变动，在C++11中实现自己的cbegin：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">cbegin</span>(<span class="title">const</span> <span class="title">C</span>&amp; <span class="title">container</span>)-&gt;<span class="title">decltype</span>(<span class="title">std</span>:</span>:<span class="built_in">begin</span>(container))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">begin</span>(container); <span class="comment">// see explanation below</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其工作原理为：如果实参为non-const,那么container将会成为一个const C&amp;，并且对container调用begin将得到一个const_iterator。这种实现的一大优点在于对于那些带有begin成员函数却不带有cbegin成员函数的容器，你甚至可以直接在函数内部调用begin转换之。</p>
<p>如果C是一个内置数组，那么这个模板函数也能够正确地运行，因为container被推衍为一个const数组的引用，C++11的非成员函数begin会返回一个指向数组首元素的指针，又由于数组现为const，因此指针类型为一个指向const的指针，这与const_iterator是等价的。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>以const_iterator代替iterator。</strong></li>
<li><strong>begin，end之类函数的非成员函数版本比其成员函数版本更加适合于泛型程序。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>14.若函数不会发生异常，则将其声明为noexcept</title>
    <url>/2018/07/01/14.%E8%8B%A5%E5%87%BD%E6%95%B0%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%88%99%E5%B0%86%E5%85%B6%E5%A3%B0%E6%98%8E%E4%B8%BAnoexcept/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在C++98中，异常规格是一个很麻烦的事情。你必须时刻关注函数可能抛出的异常，一旦函数的实现发生改变，其异常规格也需要发生变化。轻易更改异常规格可能会破坏客户端代码，因为调用者可能依赖于原始的异常规格。编译器并不能帮助你维持函数实现、异常规格、客户端代码之间的一致性。大多数程序员都认为C++98的异常规格实在是太不友善了。</p>
<p>在长期的开发过程中人们逐渐产生了一项共识:函数的异常规格只需要告诉人们该函数是否可能会抛出一个异常即可。C++11以这种非黑即白式的异常规格取代了C++98中繁琐且易于出错的规格（不过它们现在仍然有效）。在C++11中，我们使用noexcept表征某个函数不会抛出任何异常。</p>
<hr>
<h1 id="noexcept声明"><a href="#noexcept声明" class="headerlink" title="noexcept声明"></a>noexcept声明</h1><p>&nbsp;<br>函数是否应当被声明为noexcept是一个接口设计问题。对于使用者来说，函数是否可能会抛出异常是一个关键问题。调用者理当了解被调用函数的异常状态，并且该状态会影响调用程序的异常安全性及效率。从这个角度而言，noexcept声明重要性不亚于const，如果一个不可能抛出异常的函数不声明为noexcept，那这个接口规范真是太失败了。</p>
<p>不过声明noexcept还有额外的目的：促使编译器生成更加恰当的目标码。假设当前存在一个函数f承诺不会抛出任何异常，那么它们在C++98与C++11中分别表示为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// no exceptions from f: C++98 style</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// no exceptions from f: C++11 style</span></span><br></pre></td></tr></table></figure><br>如果在运行期间f抛出了异常，违背了其异常规格，C++98异常规格会展开调用堆栈给f的调用者，并且在执行完一些与当前无关的操作后终止程序。C++11异常规格则保证堆栈仅可能展开于程序结束运行之前。</p>
<p>展开调用堆栈与可能展开调用堆栈对于代码生成有着极大影响，在noexcept函数中，如果异常传播到别处，那么优化器不需要保持运行期堆栈处于不可展开状态，也不必确保noexcept函数中的对象按照构造的相反顺序销毁。带有throw()或完全不具备异常规格的函数则不具备这种优化弹性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// most optimizable</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// less optimizable</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span></span>; <span class="comment">// less optimizable</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="移动语义、性能优化与noexcept"><a href="#移动语义、性能优化与noexcept" class="headerlink" title="移动语义、性能优化与noexcept"></a>移动语义、性能优化与noexcept</h1><p>&nbsp;</p>
<p>在某些情况下，使用noexcept十分恰当，移动操作就是一个典型的例子。假设你有一个使用vector&lt;Widget&gt;的C++98代码库，widget通过push_back不断加入该vector::<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br><span class="line">…</span><br><span class="line">Widget w;</span><br><span class="line">… <span class="comment">// work with w</span></span><br><span class="line">vw.push_back(w); <span class="comment">// add w to vw</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure><br>你希望利用C++11中的移动语义来提升程序性能，因此，你通过某种方式，例如自己撰写or自动生成（见Item17）来确保widget拥有移动操作。</p>
<p>当一个新元素被添加到一个std::vector时，std::vector可能没有空间(及size==cap)。当发生这种情况时，std ::vector会分配一个新的，更大的内存块来保存它的元素，并将内存中的元素从旧内存块传送到新的内存块。C++98将每个元素从旧内存复制到新内存，然后销毁旧内存中的对象。这种方法使push_back能够提供strong异常安全保证：如果在复制元素期间抛出异常，则std::vector的状态保持不变。因为在将所有元素成功复制到新内存之前，旧内存中的元素都不会被销毁。</p>
<p>C++11中存在一种针对上述情况的优化方法：以移动替换拷贝。不过这种优化策略破坏了push_back的异常安全保证，例如当前已完成n个元素的移动，但第n+1个元素在移动时抛出异常，此时push_back不得不被迫中止。在此情况下，原本的vector已经发生更改，并且将已经移动的元素再次移动回来并不现实，因为在此移动过程中可能会再次触发异常。因此，除非我们明确地了解移动操作不会抛出异常，否则C++11不会主动以移动代替拷贝。</p>
<p>std::vector::push_back采用的策略是”move if you can，but copy if you must”,并且它不是标准库中唯一采取此策略的函数，std::vector::reverse、std::deque::insert也是一样。当移动操作明确不会抛出异常时，这些函数会以移动操作代替C++98中性能低下的复制操作。那么这些函数如何了解移动操作是否可能会抛出异常呢？答案十分显然：通过检查移动操作是否具备noexcept声明。</p>
<hr>
<h1 id="swap与noexcept"><a href="#swap与noexcept" class="headerlink" title="swap与noexcept"></a>swap与noexcept</h1><p>&nbsp;<br>swap是许多STL算法实现的关键组件，并且经常应用于对象的拷贝赋值运算符之中（见Effective C++ Item11）。由于它的广泛使用，因此对其使用noexcept是一件性价比极高的事情。有趣的是，标准库中swap的noexcept有时取决于用户自定义的swap是否noexcept。举例而言，标准库对于数组以及std::pair的swap函数有声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">size_t</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span> (&amp;<span class="title">a</span>)[<span class="title">N</span>], <span class="title">T</span> (&amp;<span class="title">b</span>)[<span class="title">N</span>]) <span class="title">noexcept</span>(<span class="title">noexcept</span>(<span class="title">swap</span>(*<span class="title">a</span>, *<span class="title">b</span>)));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(pair&amp; p)</span> <span class="title">noexcept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">noexcept</span>(swap(first, p.first)) &amp;&amp; </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">noexcept</span>(swap(second, p.second)))</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看出，这些函数是否noexcept取决于noexcept子句中的表达式是否为noexcept。例如，假设当前存在两个vector&lt;Widget&gt;,swap这两个数组是否noexpt取决于swap其中单个元素是否这一行为（即swap Widget）是否noexcept。类似地，交换两个含有Widget的std::pair是否为noexcept亦取决于交换Widget是否noexcept。一言以蔽，交换高层数据数据这一行为是否noexcept取决于交换底层数据是否noexcept。</p>
<h2 id="noexcept承诺"><a href="#noexcept承诺" class="headerlink" title="noexcept承诺"></a>noexcept承诺</h2><p>在讲优化之前，我们需要明确的是：优化固然重要，但程序的正确性更加重要，在前文中我们曾提及noexcept是接口的一部分，仅在你愿意付出长期维持某函数noexcept的代价时你才应当声明此函数为noexcept。如果你声明了一个函数noexcept然后发现noexcept无法维系，你的选择和下场十分惨烈：或冒着破坏客户端代码的风险从函数的声明中删除noexcept（即更改接口）；或更改实现以使异常可以转义，从而保留原始但不正确的异常规格。</p>
<p>从实际情况而言，大部分函数都不会抛出异常，但其调用的子程序则未必尽然。当这种情况发生时，这些函数允许被抛出的异常越过自己直接到达调用链中的异常处理程序。这种不会自己抛出异常的函数不会被声明为noexcept，因为它们会抛出这种“just passing through”的异常。</p>
<p>但也存在一些函数，其本质而言不可能抛出异常，又或者其一旦不抛出异常会带来显著的性能提升，因此将其实现为noexcept性价比很高。如果你可以保证一个函数永不抛出异常，那你应当放心大胆地将其声明为noexcept。值得强调的是，我们这里所说的本质上不可能抛出异常，而非你通过种种手段强行吞下或处理了所有异常。</p>
<p>对于某些函数而言，其默认状态即为noexcept。在C++98中，允许内存释放函数（诸如operator delete、operator delete[])或析构函数抛出异常被视为非常恶劣的编码风格，而在C++11中，这几乎成为了一种语言规则：在默认情况下，所有的内存释放函数与析构函数均被隐式声明为noexcept（也就是说没必要去特意强调它们是noexcept，尽管没有任何坏处）。仅有在类的数据成员明确声明自身析构函数为noexcept(false)时类的析构函数才会不再隐式声明为noexcept。</p>
<hr>
<h1 id="wide-contracts-and-narrow-contracts"><a href="#wide-contracts-and-narrow-contracts" class="headerlink" title="wide contracts and narrow contracts"></a>wide contracts and narrow contracts</h1><p>&nbsp;<br>值得注意的是，某些库接口设计者将函数区分为”wide contracts”与”narrow contracts”。”wide contracts”函数没有任何先决条件，无论当前程序运行状态如何它都能够正常运行，且对传给它的参数没有任何限制，在任何情况下”wide contracts”均不会导致未定义行为。不具备”wide contracts”的函数被称为”narrow contracts”函数，对于此类函数，如果违反了其先决条件，则将触发未定义行为</p>
<p>如果你正在编写一个”wide contracts”函数且明确其不会抛出异常，那么自然可以轻易遵循本节原则将其声明为noexcept。对于”narrow contracts”则相对麻烦，举例而言，假设当前你正在编写一个函数f，其参数为std::string,理论上其不会抛出异常，这意味着f应当被声明为noexcept。现在我们假设f存在一个先决条件：string对象的长度不得超过32个字符，一旦超过则触发未定义行为。f并没有义务检查其先决条件是否满足，因为那是调用者该做的事。即使当前函数存在一个先决条件，将f声明为noexcept似乎也没毛病：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// precondition: s.length() &lt;= 32</span></span><br></pre></td></tr></table></figure><br>但假设当前f的实现者决定检查其先决条件是否违背，那么如何在发现先决条件不成立的情况下向测试程序或客户端处理发出报告？一种直接方法是抛出异常，但我们已经声明该函数为noexcept了，抛出异常只会导致程序直接终止。出于这个理由，库设计者通常仅仅保留”wide contracts”函数的noexcept属性。</p>
<hr>
<h1 id="函数实现与异常规格"><a href="#函数实现与异常规格" class="headerlink" title="函数实现与异常规格"></a>函数实现与异常规格</h1><p>&nbsp;</p>
<p>编译器通常无法识别函数实现与其异常规格之间的不一致。考虑这一段完全合法的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>; <span class="comment">// functions defined elsewhere</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="built_in">setup</span>(); <span class="comment">// set up work to be done</span></span><br><span class="line">    … <span class="comment">// do the actual work</span></span><br><span class="line">    cleanup(); <span class="comment">// perform cleanup actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，noexcept函数doWork调用了non-except setup、cleanup。看起来很矛盾，但这并不意味着程序必然存在问题。例如，setup与cleanup在其文档中表示不会抛出异常，只不过它们没有用noexcept声明。又或者它们是用C语言编写的程序库的一部分（即使是已经移入std命名空间的C标准库中函数也没有声明异常规格，例如，std::strlen未声明为noexcept）。又或者它们是C++98库的一部分，刚刚决定不再使用C++98中的异常规格，并且尚未来得及针对C++11作出修订。</p>
<p>由于上述种种原因，C++允许noexcept函数调用non-noexcept函数，并且编译器不会对此发出任何警告。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>noexcept是函数接口的一部分。</strong></li>
<li><strong>noexcept函数比non-noexcept函数具备更高的优化弹性</strong>。</li>
<li><strong>noexcept对移动操作，交换，内存释放函数及析构函数性价比极高。</strong></li>
<li><strong>大部分函数都是excepttion—neutral而非noexcept。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>16.80-20准则</title>
    <url>/2018/04/26/80-20%E5%87%86%E5%88%99/</url>
    <content><![CDATA[<p>80－20准则说的是大约20％的代码使用了80％的程序资源；大约20%的代码耗用了大约80％的运行时间；大约20％的代码使用了 80％的内存；大约20％的代码执行80％的磁盘访问；80％的维护投入于大约20％的代码上；通过无数台机器、操作系统和应用程序上的实验，这条准则已经被再三地验证过。</p>
<p>80－20准则不只是一条好记的惯用语，它更是一条有关系统性能的指导方针，有着广泛的适用性和坚实的实验基础。不要在具体数字上纠缠不清，不管准确地数字是多少，基本的观点是一样的：<strong>软件整体的性能取决于代码组成中的一小部分。</strong></p>
<p>profiler有助于洞察性能，虽然并非每一次都能被你发现，为了保证开发者能够明晰低效的症结位于何处，最好的方法是用尽可能多的数据profile应用程序。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内存模型与原子类型操作——同步操作与强制顺序</title>
    <url>/2021/06/24/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%BC%BA%E5%88%B6%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>一段经典的生产-消费场景代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!data_ready.load()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep(<span class="built_in">std</span>::milliseconds(<span class="number">1</span>)); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"The answer="</span>&lt;&lt;data[<span class="number">0</span>]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data.push_back(<span class="number">42</span>);</span><br><span class="line">  data_ready=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我们利用原子操作，保证了写入操作必然“先发生于”读取操作。不过，原子操作对顺序要求还有其他选项，它们构成了原子操作间的各种关系，下文将一一说明。<br><a id="more"></a></p>
<hr>
<h1 id="“同步于”"><a href="#“同步于”" class="headerlink" title="“同步于”"></a>“同步于”</h1><p>&nbsp;<br>“同步于”关系只能在原子类型的操作间获得。如果UDT（user-defined-type）包含原子类型，并且施加于UDT实例的行为内包含有原子操作(例如锁住互斥锁) 亦可提供这种关系。但本质上，该关系仅与原子操作绑定。</p>
<p>其基本概念为：对于变量x，若当前存在两种操作：一个适当标记（suitably-tagged）的原子写操作W，与一个适当标记的原子读操作R，W “同步于” R。在这种同步关系下，R要么读取到的是W操作写入的内容，要么读取到的是执行W操作的线程内，W操作后续的写操作所写入的值。</p>
<p>由于所有对原子操作类型的操作默认均为适当标记（suitably-tagged），因此我们可以简化“同步于”关系为：如果线程A存储了一个值，并且线程B读取了这个值，则在默认情况下，线程A的存储操作与线程B的加载操作之间有一个“同步于”关系，如图所示：<br><img src="http://static.zybuluo.com/zsmj2017/ydyg15n8mt9ozb48owqrfbf0/image.png" alt="image.png-234.1kB"></p>
<p>原子操作内的细微差别都来自于“适当标记”部分，C++内存模型允许对原子类型的操作应用各种顺序约束，这就是所谓的标记。</p>
<hr>
<h1 id="“先发生于”"><a href="#“先发生于”" class="headerlink" title="“先发生于”"></a>“先发生于”</h1><p>&nbsp;<br>“先发生于”(happens-before)关系是程序中操作顺序的基础构件——它指定了哪些操作能看见另一些操作的影响。</p>
<p>对于单线程而言，确保“先发生于”关系很简单——只需要在源码中确保操作A先于操作B出现，则存在操作A必在操作B前发生。如果操作A与操作B发生于同一个语句，则不能确保存在“先发生于”关系，例如下述程序可能输出“1，2”或“2，1”。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;”,”&lt;&lt;b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ++i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  foo(get_num(),get_num()); <span class="comment">//无序调用get_num()，未定义行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了避免混淆，我们将单线程内操作A必然发生于操作B之前的关系称为“先序于”（sequenced-before），而将线程间的操作A必然发生另一个线程内操作B之前的关系称为“线程间先发生于”（inter-thread happens-before）。</p>
<p>对于“线程间先发生于”而言，若一个线程内的操作A与另一个线程内的操作B同步，则有A“线程间先发生于”B。该关系具备传递性，即若A“线程间先发生于”B，且B“线程间先发生于”C，则A“线程间先发生于” C。</p>
<p>“线程间先发生于”亦可和“先序于”相结合:若操作A“先序于”操作B，且操作B“线程间先发生于”操作C，则有A“线程间先发生于”C。类似地，如果 A“同步于”B，且B“先序于”C，则A“线程间先发生于”C。</p>
<hr>
<h1 id="原子操作的内存顺序"><a href="#原子操作的内存顺序" class="headerlink" title="原子操作的内存顺序"></a>原子操作的内存顺序</h1><p>&nbsp;<br>正如前文已经提及到的，原子操作共计可以指定六种内存顺序，默认使用memory_order_seq_cst（最严格）：</p>
<ol>
<li>memory_order_relaxed</li>
<li>memory_order_consume</li>
<li>memory_order_acquire</li>
<li>memory_order_release</li>
<li>memory_order_acq_rel</li>
<li>memory_order_seq_cst</li>
</ol>
<p>尽管内存顺序存在六种，但它们仅代表三种内存顺序模型：</p>
<ol>
<li>序列一致 (sequentially consistent) </li>
<li>获得-释放 (acquire-release)：memory_order_consume, memory_order_acquire, memory_order_release，memory_order_acq_rel</li>
<li>宽松 (relaxed)：memory_order_relaxed</li>
</ol>
<p>不同的内存顺序模型在不同的CPU架构下成本不同。举例而言，在基于通过处理器精细控制操作可见性的架构(而非更改可见性的架构)的系统上，“序列一致”顺序相较于“获得-释放”或者“宽松”需要额外的同步指令，“获得-释放”顺序相较于“宽松”也是如此。如果这些系统有很多处理器，额外的同步指将会花费大量的时间，从而降低系统整体性能。另一方面，使用x86或x86-64架构的CPU(比如使用Intel或AMD处理器的台式电脑) 除了执行确保原子性所必须的指令之外，不需要为“获得-释放”执行额外指令，甚至“序列一致”对于加载操作也不需要任何特殊处理，尽管在数据存储层面增加了些许成本。</p>
<p>不同内存顺序模型保证了开发者得以使用更细粒度的顺序关系对程序性能做出提升，下文将依介绍它们的特点及应用范围。</p>
<hr>
<h2 id="序列一致"><a href="#序列一致" class="headerlink" title="序列一致"></a>序列一致</h2><p>序列一致是最容易被理解的内存顺序，因此C++将其定义为默认内存顺序。若原子类型实例上的所有操作均遵循“序列一致”的，则多线程程序的行为将类似于所有操作都是由单个线程按照某种特定的序列执行的——所有线程必须看到相同的操作顺序，不允许存在重新排序的操作。这种约束不适用于使用“宽松”内存顺序原子操作的线程——它们仍然可以看到不同顺序的操作，因此必须在所有线程上使用“序列一致”的操作，才能受益。</p>
<p>下述代码演示了这种顺序约束的作用。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(y.load(<span class="built_in">std</span>::memory_order_seq_cst))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_seq_cst))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(write_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join();</span><br><span class="line">  c.join();</span><br><span class="line">  d.join(); </span><br><span class="line">  assert(z.load()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>assert语句将永远无法触发，因为必将发生存储x或存储y（虽然未指定哪一个）。若在<code>read_x_then_y</code>中加载y返回false（存储x的操作发生在存储y的操作之前），则<code>read_y_then_x</code>中加载x必定会返回true（while循环将保证此刻y已为true）。因为memory_order_seq_cst语义需要在所有标记为memory_order_seq_cst的操作上有一个单一全序，因此在“加载y返回 false”与“存储y”的操作之间存在一个隐含的顺序关系。由于单个全序，当一个线程看到x==true，随后又看到y==false，即意味着在此全序中存储x的操作发生在存储y的操作之前。当然，这个假设是对称的，亦可能存在完全相反的情况，此时先存储y后存储x。</p>
<p>从同步的角度来看，一个“序列一致”的存储操作“同步于”相同变量的加载操作，这个加载操作读取存储的值，这为两个(或更多)线程的操作提供了一个顺序约束，但“序列一致”的约束性比上述描述的更强。对系统中使用“序列一致”原子操作的其他线程，任何加载操作之后执行的“序列一致”的原子操作也必须出现在存储操作之后。</p>
<p>针对read_x_then_y看x为true，且y为false的情况，有图例如下。虚线展示了为了保持“序列一致”而隐含的必须的顺序关系——在 memory_order_seq_cst操作的全局顺序中，为了获得这里给出的结果，加载操作必须在存储操作之前发生。<br><img src="http://static.zybuluo.com/zsmj2017/0ab1ct7dl4ju0kc1sypp3ukd/image.png" alt="image.png-287.1kB"></p>
<p>“序列一致”是最简单直观的顺序，也是最昂贵的内存顺序，因为它需要所有线程间进行全局同步。在一个多处理器系统上，这可能需要在处理器之间进行大量并且耗时的通信。</p>
<hr>
<h2 id="非序列一致"><a href="#非序列一致" class="headerlink" title="非序列一致"></a>非序列一致</h2><h3 id="宽松"><a href="#宽松" class="headerlink" title="宽松"></a>宽松</h3><p>原子类型上的操作以宽松顺序执行时，不会参与任何“同步于”关系。在同一线程内，对于同一变量的操作服从“先序于”关系。而线程间几乎没有任何顺序要求，唯一特例是线程访问单个的原子变量不能重排——当线程看到一个原子变量的特定值后，该线程随后的读操作将无法检索到这个变量更早的值。以下代码实例将展示宽松顺序的影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_relaxed));</span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join(); </span><br><span class="line">  assert(z.load()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次assert可能会触发，因为加载x的操作可能读取到false，即使加载y的操作读取到true，并且存储x的操作“先发生于”存储y的操作。由于x，y是不同的变量，因此各操作对其数据可见性并不做顺序性保证。</p>
<p>宽松顺序对于不同变量可以自由重排，只需遵守约束“先发生于”关系即可(例如读取到y为true后，仅能保证接下来该线程不会读取到y为true之前的值)，它不会引入“同步于”关系。尽管在存储与存储，加载与加载操作间存在着“先发生于”关系，但存储和加载间并不存在这种关系，因此载入操作可以看到次序颠倒的存储操作，下图展示了这种关系。<br><img src="http://static.zybuluo.com/zsmj2017/87l6exoj7ney3p024g9qdwe2/image.png" alt="image.png-106.4kB"></p>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>接下来关注一个略微复杂点的实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">std::atomic&lt;int&gt; x(0),y(0),z(0);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">go</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">const</span> loop_count=<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_values</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y,z; </span><br><span class="line">&#125;;</span><br><span class="line">read_values values1[loop_count]; </span><br><span class="line">read_values values2[loop_count]; </span><br><span class="line">read_values values3[loop_count]; </span><br><span class="line">read_values values4[loop_count]; </span><br><span class="line">read_values values5[loop_count];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;* var_to_inc,read_values* values)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!go)</span><br><span class="line">    <span class="built_in">std</span>::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 自旋，等待信号</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i) &#123;</span><br><span class="line">    values[i].x=x.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    values[i].y=y.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    values[i].z=z.load(<span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">    var_to_inc-&gt;store(i+<span class="number">1</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">std</span>::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_vals</span><span class="params">(read_values* values)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!go)</span><br><span class="line">    <span class="built_in">std</span>::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 自旋，等待信号</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i) &#123;</span><br><span class="line">    values[i].x=x.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    values[i].y=y.load(<span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">    values[i].z=z.load(<span class="built_in">std</span>::memory_order_relaxed); </span><br><span class="line">    <span class="built_in">std</span>::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(read_values* v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i) </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;v[i].x&lt;&lt;<span class="string">","</span>&lt;&lt;v[i].y&lt;&lt;<span class="string">","</span>&lt;&lt;v[i].z&lt;&lt;<span class="string">")"</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(increment,&amp;x,values1)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(increment,&amp;y,values2)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(increment,&amp;z,values3)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(read_vals,values4)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t5</span><span class="params">(read_vals,values5)</span></span>;</span><br><span class="line">  go=<span class="literal">true</span>; <span class="comment">// 开始执行主循环的信号</span></span><br><span class="line">  t5.join();</span><br><span class="line">  t4.join();</span><br><span class="line">  t3.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  t1.join();</span><br><span class="line">  <span class="built_in">print</span>(values1);</span><br><span class="line">  <span class="built_in">print</span>(values2);</span><br><span class="line">  <span class="built_in">print</span>(values3);</span><br><span class="line">  <span class="built_in">print</span>(values4);</span><br><span class="line">  <span class="built_in">print</span>(values5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序内有三个全局原子变量和五个线程。每一个线程循环10次，使用memory_order_relaxed读取三个原子变量的值，并且将它们存储在一个数组上。其中三个线程每次通过循环来更新其中一个原子变量，而剩下的两个线程负责读取。当线程都被joined了，则打印出每个线程存到数组上的值。如果没有明确的延迟，第一个线程可能在最后一个线程开始前结束，因此使用原子变量go来确保线程尽可能接近同一时间开始循环。一旦go被设定为true，则所有线程均将开始执行。</p>
<p>该程序一种可能的输出如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,7,0),(6,7,8),(7,9,8),(8,9,8), (9,9,10) &#x2F;&#x2F; increment</span><br><span class="line">(0,0,0),(0,1,0),(0,2,0),(1,3,5),(8,4,5),(8,5,5),(8,6,6),(8,7,9),(10,8,9), (10,9,10) &#x2F;&#x2F; increment</span><br><span class="line">(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,0,4),(0,0,5),(0,0,6),(0,0,7),(0,0,8), (0,0,9) &#x2F;&#x2F; increment</span><br><span class="line">(1,3,0),(2,3,0),(2,4,1),(3,6,4),(3,9,5),(5,10,6),(5,10,8),(5,10,10), (9,10,10),(10,10,10) &#x2F;&#x2F; read</span><br><span class="line">(0,0,0),(0,0,0),(0,0,0),(6,3,7),(6,5,7),(7,7,7),(7,8,7),(8,8,7),(8,8,9), (8,8,9) &#x2F;&#x2F; read</span><br></pre></td></tr></table></figure></p>
<p>我们可以关注到几点：</p>
<ol>
<li>线程1中x每次增1，线程2中y每次增1，线程3中z每次增1。</li>
<li>在给定输出集合中，x，y，z均为不均匀增序，且相对顺序在各线程中不同。</li>
<li>线程3只关注到了z的更新，无视x与y的更新，但不影响其他线程可以关注到z的更新。</li>
</ol>
<h3 id="类比分析"><a href="#类比分析" class="headerlink" title="类比分析"></a>类比分析</h3><p>想象每个原子变量是一个小隔间里的办事员，它拿着小本子记录着一个列表（变量值的历史版本）。当你要一个值的时候，它就从列表中取出一个值给你（load），如果你想写入一个值，那它就把这个新值写在列表的最后（store）。</p>
<p>当然，读取值是有一定规则的。当你第一次向它获取值时，它可能会给你列表中的任意值。此后如果你继续要，它可能会给你同一个值，或者出现在该值后的任意值。如果你写入一个值后再向它要一个值，则要么给你你写入的值，要么给你出现在该值后的任意值。（先发生于）</p>
<p>举个例子，若它的列表上开始有5，10，23，3，1，2这几个值。如果你问他要一个值， 你可能获取这几个数中的任意一个。假设它给你10，那么下次再问它要值的时候可能会再给你10，或者10 后面的数，但绝对不会是5。如果连续要5次，它可能回复“10，10，1，2，2”。如果你要它写下42，则它会将列表更新为“5，10，23，3，1，2，42”，此后将只会向你提供42这个值，直到有新值被写入后它才有可能给你新值。</p>
<p>现在让情况复杂一些——假设当前存在多个人对这个可怜的办事员发号施令，但它一次只能处理一个人的请求，为了确保能保证每个人拿到的新值都符合上述规则，它选择使用一个便利贴指向各个值，用以标识当前各人的所了解到的列表状态，具体如下图所示：<br><img src="http://static.zybuluo.com/zsmj2017/w9yacv1ey7kt32ipevwpenko/image.png" alt="image.png-223.3kB"></p>
<p>那么上一个实例的输出就很容易理解了——<code>write_x_then_y</code>函数就类似于A通知x办事员写下 true，之后又通知y办事员写下true。线程反复运行<code>read_y_then_x</code>就类似于B反复向y要值，直到它说true，然后再向x要值。x没必要告诉B最新值true，它完全有可能告诉B false。</p>
<p>除此之外，该办事员也支持一些其他操作，例如“写下这个数字，并且告诉我现在列表中的最后一个数字”(exchange)，或“当列表的最后一个数字为某值则写下这个数字;否则的话，告诉我我试图去猜的值（此时已经未必是列表最后一个）是多少”(compare_exchange_strong)。</p>
<hr>
<h2 id="获取—释放"><a href="#获取—释放" class="headerlink" title="获取—释放"></a>获取—释放</h2><p>“获得-释放”是“宽松”的增强版——在不存在全序操作的前提下引入了同步。在这种顺序模型中，原子加载是获得(acquire)操作(memory_order_acquire)，原子存储是释放(memory_order_release)操作，原子读-改-写操作(如<code>fetch_add</code>或<code>exchange</code>可以是“获得”/“释放”中的任意一个，或者两者兼备 (memory_order_acq_rel)，一个“释放”操作同步于一个“获取”操作。</p>
<h3 id="代码实例1"><a href="#代码实例1" class="headerlink" title="代码实例1"></a>代码实例1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">  <span class="keyword">if</span>(y.load(<span class="built_in">std</span>::memory_order_acquire))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_acquire))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(write_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join();</span><br><span class="line">  c.join();</span><br><span class="line">  d.join(); </span><br><span class="line">  assert(z.load()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里assert可能会触发，因为可能加载x和y的时候都读取到的是false。下图展示了程序的一种可能运行流程：<br><img src="http://static.zybuluo.com/zsmj2017/ky9ttwheysxdkh241sxnq327/image.png" alt="image.png-174.3kB"></p>
<h3 id="代码实例2"><a href="#代码实例2" class="headerlink" title="代码实例2"></a>代码实例2</h3><p>获取-释放的正确使用实例如下文所示——将两次存储由一个线程来完成，存储y时使用<code>std::memory_order_release</code>，读取y时使用<code>std::memory_order_acquire</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_acquire)); <span class="comment">// 自旋，等待y被设置为true</span></span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed)) </span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join();</span><br><span class="line">  assert(z.load()!=<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于y的存储/读取操作存在“同步于关系”，而x，y的存储操作又在一个线程，存在”先序于”关系，因此，当<code>read_y_then_x</code>中的y被读取为true时，x必然为true，此时将导致z自增，此时assert将不会触发。为了提供同步，<code>std::memory_order_acquire</code>与<code>std::memory_order_release</code>必须成对进行。</p>
<h3 id="类比分析-1"><a href="#类比分析-1" class="headerlink" title="类比分析"></a>类比分析</h3><p>同样以办事员举例，获取-释放操作需要在此前的建模中引入“批次”的概念。具体而言，每个已经完成的存储都是某一批次更新的一部分，因此，你在告诉办事员数值时，必须提及“请记下99，作为第423批的一部分”，一个批次中的末尾存储需要说明为“请记下127，作为第423批的最后存储”。此后的存储将变为424批次。</p>
<p>获取值则分为2种情况：</p>
<ol>
<li>简单请求一个值（宽松），此时办事员给你提供一个值</li>
<li>请求一个值，并且希望了解它是否是某批次中的最后一个（获取-释放）。若该值不是批次中的最后一个，办事员会说它是个普通值，否则它将提供如下信息：“数字为987，该值是956批次的最后一个，来源于Anne”。这即是获取-释放的核心操作：当你向办事员提供了你所了解的批次后，它会在其列表中查找该批次的最后一个值，然后要么给你该值，要么给予更靠后的值。</li>
</ol>
<p>那么我们将根据上述原则分析代码实例——首先，线程a运行<code>write_x_then_y</code>，告知办事员x“请写下true作为来自线程a的批次1的一部分”，然后，线程a告诉办事员y，“请写下true，这是来自线程a的批次1的最后一个写”。与此同时，线程b正在运行<code>read_y_then_x</code>，线程b持续向办事员y请求一个带批次信息的值(<code>std::memory_order_acquire</code>)，直到获取true，此时办事员y将告诉线程b，该值为来自线程a批次1的最后一次写。线程b继续向办事员x请求一个值，但这次他会说“请给我一个值，并且我从线程a了解到了批次1”。 此时办事员x将不得不查看它的记事本，从中找到批次1的最后一个写入操作——true。</p>
<h3 id="用“获得-释放”传递同步"><a href="#用“获得-释放”传递同步" class="headerlink" title="用“获得-释放”传递同步"></a>用“获得-释放”传递同步</h3><p>正如前文所述，若A“线程间先发生于”B，且B“线程间先发生于”C，则有A“线程间先发生于”C。这意味着“获得-释放”可用于在若干线程间同步数据，即使“中间”线程没有接触到数据。</p>
<p>具体而言，若当前存在三个线程:线程A修改一些共享变量，并对同步变量a执行“存储-释放”(store-release)。线程B使用“加载-获得”(load-acquire)读取“存储-释放”的同步变量a，并对第中同步变量b执行“存储-释放”。线程C对变量b执行“加载-获得”，若线程C确保自己读取到了b“存储-释放”后的值，则线程C此时对共享变量的读取必然也是“存储-释放”后的值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">3</span>];</span><br><span class="line">std::atomic&lt;bool&gt; sync1(false),sync2(false);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data[<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line">  data[<span class="number">1</span>] = <span class="number">97</span>;</span><br><span class="line">  data[<span class="number">2</span>] = <span class="number">17</span>;</span><br><span class="line">  sync1.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!sync1.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">  sync2.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!sync2.load(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">  assert(data[<span class="number">0</span>]==<span class="number">42</span>);</span><br><span class="line">  assert(data[<span class="number">1</span>]==<span class="number">97</span>);</span><br><span class="line">  assert(data[<span class="number">2</span>]==<span class="number">17</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span> ,<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">3</span>);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.join();</span><br><span class="line">    b.join();</span><br><span class="line">    c.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实际上，我们可以对上述实例做进一步的改进，利用<code>std::memory_order_acq_rel</code>特性使得同步变量仅需要一个即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">sync</span><span class="params">(<span class="number">0</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  sync.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> expected=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 反复查看sync是否为1，否则以其值更新expected，是则存入2</span></span><br><span class="line">  <span class="keyword">while</span>(!sync.compare_exchange_strong(expected, <span class="number">2</span>, <span class="built_in">std</span>::memory_order_acq_rel)) </span><br><span class="line">    expected=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(sync.load(<span class="built_in">std</span>::memory_order_acquire) &lt; <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="“获得-释放”与memory-order-consume的数据相关性"><a href="#“获得-释放”与memory-order-consume的数据相关性" class="headerlink" title="“获得-释放”与memory_order_consume的数据相关性"></a>“获得-释放”与memory_order_consume的数据相关性</h3><p>（C++17明确建议不要使用memory_order_consume, 若有兴趣，可直接查阅原文）</p>
<hr>
<h2 id="“释放序列”与“同步于”"><a href="#“释放序列”与“同步于”" class="headerlink" title="“释放序列”与“同步于”"></a>“释放序列”与“同步于”</h2><p>释放序列定义：若存储操作被标记为<code>memory_order_release</code>，<code>memory_order_acq_rel</code>或<code>memory_order_seq_cst</code>，加载操作被标记为<code>memory_order_consum</code>， <code>memory_order_acquire</code>或<code>memory_order_sqy_cst</code>，并且操作链上的每个操作加载的值是由前面的操作写入的，那么操作链就构成了一个释放序列(release sequence)。</p>
<p>释放序列性质：最初的存储“同步于”最终的加载操作，操作链上的任何原子“读-改-写”操作可以拥有任意的内存顺序(memory_order_relaxed)。</p>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p>考虑以<code>atomic&lt;int&gt;</code>对象作为对共享队列内条目数的计数器：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queue_data; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_queue</span><span class="params">()</span> </span>&#123; <span class="comment">// init</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">const</span> number_of_items=<span class="number">20</span>;</span><br><span class="line">  queue_data.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_items; ++i) &#123;</span><br><span class="line">    queue_data.push_back(i); </span><br><span class="line">  &#125;</span><br><span class="line">  count.store(number_of_items, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_queue_items</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> item_index;</span><br><span class="line">    <span class="comment">// fetch返回操作前的值</span></span><br><span class="line">    <span class="keyword">if</span>((item_index = count.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acquire)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      wait_for_more_items();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">process</span>(queue_data[item_index - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(populate_queue)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(consume_queue_items)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join();</span><br><span class="line">  c.join(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点关注<code>fetch_sub</code>的内存顺序是<code>std::memory_order_acquire</code>，这意味着该加载操作与之前的存储操作构成了同步关系, 显然，若仅有一个消费者线程时不会发生任何问题。若存在两个消费线程，第二个<code>fetch_sub</code>操作将看到第一个线程写入的值，而不是<code>store</code>写入的值。若没有释放序列的性质，第二个线程与第一个线程不会存在“先发生于”关系，因此可能读到错误的count值，除非第一个<code>fetch_sub</code>具备<code>memory_order_release</code>语义，但这为两个消费者线程引入了不必要的同步关系。不过，第一个<code>fetch_sub()</code>存在于“释放序列”中，所以<code>store</code>能同步于第二个<code>fetch_sub</code>操作，两个消费者线程间仍然不存在“同步于”关系。下图虚线展示了“释放序列”，实线展示了“先发生于”关系：<br><img src="http://static.zybuluo.com/zsmj2017/x6l8hb72r6u91c7c4qfpnhr4/image.png" alt="image.png-478.1kB"></p>
<hr>
<h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>栅栏通常也被称为“内存屏障”(memory barriers)，可以在不修改任何数据的情况下强制执行内存顺序约束，通常配合<code>std::memory_order_relax</code>使用。正如前文所述，不同变量上的宽松操作通常可以被编译器或者硬件自由地重排，栅栏限制了这种自由度并引入了“先发生于”和“同步于”关系。</p>
<h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y; </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release); <span class="comment">// 1</span></span><br><span class="line">  y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_relaxed));</span><br><span class="line">  <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire); <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed))</span><br><span class="line">    ++z; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>; </span><br><span class="line">  a.join();</span><br><span class="line">  b.join(); </span><br><span class="line">  assert(z.load()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码1“同步于”代码2，因此当y为true时，x已经存储为true，此时assert将不会触发。在栅栏上施加“获取-释放”将在代码内引入“同步于”关系。</p>
<hr>
<h2 id="使用原子操作对非原子操作排序"><a href="#使用原子操作对非原子操作排序" class="headerlink" title="使用原子操作对非原子操作排序"></a>使用原子操作对非原子操作排序</h2><p>（本节的主题是通过“获取-释放”引入“同步于”关系，从而保证非原子操作得以排序，实际上，本节大部分relax操作可以直接被替换为非原子操作）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">false</span>;</span><br><span class="line">  y = <span class="literal">false</span>;</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">std</span>::atomic_signal_fence(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">  y = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_write_z</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y) &#123; <span class="comment">// 自旋</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"y is false"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">std</span>::atomic_signal_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">      ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_write_z)</span></span>;</span><br><span class="line">    a.join();</span><br><span class="line">    b.join();</span><br><span class="line">    assert(z != <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(以上是我本人写的示例代码，但是对<code>while(!y)</code>存疑，是否可能由于编译器优化造成死循环？clang下未发生死循环情况，运行符合预期)</p>
<h3 id="互斥锁实现解析"><a href="#互斥锁实现解析" class="headerlink" title="互斥锁实现解析"></a>互斥锁实现解析</h3><p>非原子操作同样遵循“先发生于”传递关系——如果一个非原子操作“先序于”一个原子操作，并且这个原子操作“先发生于”另一个线程中的操作，那么这个非原子操作也会“先发生于”另一个线程中的那个操作，以下述代码实现的简单自旋锁为例（上一篇介绍原子类型时曾经提及）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::atomic_flag flag; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  spinlock_mutex(): flag(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.test_and_set(<span class="built_in">std</span>::memory_order_acquire)); <span class="comment">// 忙-等待</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，该自旋锁在内部构成了“释放-获取”顺序，从而可以保证在非原子操作间引入“同步于”关系。当持有锁的线程完成对保护数据的修改后调用<code>unlock</code>——即调用带有 <code>std::memory_order_release</code>语义的<code>flag.clear()</code>，该操作“同步于”随后对<code>flag.test_and_set()</code>的调用——即另一个线程调用<code>lock</code>。对保护数据的修改必然“先序于”<code>unlock</code>，因此将“先发生于”随后第二个线程对<code>lock</code>的调用。值得注意的是，第二个线程获得锁同样“先序于”该线程对保护数据的任何访问。</p>
<p>尽管其他互斥锁的实现各有差异，但基本原理是一样的:<code>lock</code>是一个内部内存位置上的获得操作，<code>unlock</code>是同样的内存位置上的一个释放操作。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内存模型与原子类型操作——内存模型基础</title>
    <url>/2020/03/14/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;</p>
<p>C++11标准引入了全新的多线程内存模型，如果没有它准确地定义基本构建块（building blocks）的工作方式，那么前文所提到的一切并发工具都将成为空谈。</p>
<p>C++内存模型基本可以分为2部分：内存结构（structs，与对象在内存中的布局有关）与并发性，一般认为前者比后者重要，尤其是需要深入了解底层原子操作时。</p>
<a id="more"></a>
<hr>
<h1 id="object-amp-amp-memory-location"><a href="#object-amp-amp-memory-location" class="headerlink" title="object &amp;&amp; memory location"></a>object &amp;&amp; memory location</h1><p>&nbsp;<br>C++中任何数据均由object构成（并非是狭义上的“对象”）。C++标准对object的定义是“一块内存区域”。当然，object并不能一概而论，有些object较为简单，例如POD类型，而另一些则以用户自定义类型的形式出现。有些object存在子object（例如数组，派生类的实例，以及具有non-static data member的类实例），有些则并不具备。</p>
<p>无论object是何种类型，其必然被存储于一个或多个内存位置（memory location）上。内存位置要么是标量类型的对象(如<code>unsigned int</code>或<code>my class*</code>)或子对象，要么是一块连续的位域（bit fields）。需要注意，在位域中，即使相邻的位域内存储着不同的对象，他们依旧被视作具有相同的内存位置。下图清晰地展示了一个struct的objects 与 memory locations。<br><img src="http://static.zybuluo.com/zsmj2019/u4xaaorysd8xs1u8b97gddpo/WX20200313-194502@2x.png" alt="WX20200313-194502@2x.png-133.9kB"></p>
<p>首先，整个struct是一个由几个子对象组成的对象，每个子对象对应一个数据成员。bf1和bf2位字段共享一个内存位置，std::string对象s内部由几个内存位置组成。除此之外，每个成员都有自己的内存位置。注意零长度位字段 bf3(bf3这个名字是用来注释的，C++中零长度位字段必须未命名)如何将bf4分隔到它自己的内存位置，但它本身没有内存位置。(C++中零长度的未命名位域有特殊含义:让下一个位域从分配单元的边界开始。C++中位域的内存布局是与机器相关的，取地址操作符&amp;不能作用于位域)。</p>
<p>抛开细节，从上图中可以得出四点结论：</p>
<ol>
<li>任何变量都是一个对象，即使它本身是其他对象的data member。</li>
<li>每一个对象至少占据一个内存位置。</li>
<li>基本类型（如int或char）无论大小必然占据一个内存位置，即使他们毗邻或是是数组的一部分。</li>
<li>相邻的位域共享同一个内存位置。</li>
</ol>
<hr>
<h1 id="object-amp-amp-memory-location-amp-amp-concurrency"><a href="#object-amp-amp-memory-location-amp-amp-concurrency" class="headerlink" title="object &amp;&amp; memory location &amp;&amp; concurrency"></a>object &amp;&amp; memory location &amp;&amp; concurrency</h1><p>&nbsp;<br>首先需要阐明：在C++中，一切事物均与其内存位置挂钩。如果两个线程各自访问不同的内存位置，那么岁月静好，反之，若两个线程访问同一个内存位置，则必须提高警惕。此外，如果不存在线程更新内存位置，此时同样无需担忧——只读数据不需要保护与同步，但如果某个线程需要修正数据，则意味着引入数据竞争的可能性。</p>
<p>为了规避数据竞争，我们必须强制指定线程访问数据的先后顺序。方案一已经在第三章提过：使用互斥锁。如果在两次访问前锁定了相同的mutex，则可以确保同一时刻仅有一个线程访问数据，因此线程访问数据的顺序必然是有序的（尽管无法知道线程们谁先谁后）。另一种方案是在内存位置上使用原子操作（定义具体可见下一节）的同步属性，强制定义线程访问数据的顺序。若在多线程下试图对同一内存位置写入数据而不使用原子操作，则将引起数据竞争，从而导致未定义行为。</p>
<p>这里需要明确指出的是，使用原子操作并不能规避数据竞争（仍未指定各原子操作访问内存位置的先后性），但原子操作可以规避未定义行为。</p>
<hr>
<h1 id="modification-orders"><a href="#modification-orders" class="headerlink" title="modification orders"></a>modification orders</h1><p>&nbsp;<br>C++程序中的任意对象从都具备明确的修改顺序（modification order），由所有线程对该对象的写入操作组成，其开端为对象初始化。在大多数情况下，每一次程序时的修改顺序并不完全相同，但系统中所有线程都必须对该顺序达成一致。使用原子操作后，编译器将采取必要的同步措施保证线程按照修改顺序写入数据。如果对象类型并非原子类型，开发者应当保证采取足够的同步措施以确保每一个线程严格遵守修改顺序。</p>
<p>这一要求意味着某些投机执行（speculative execution）将不再被允许（禁止优化部分数据的读写顺序）。使用原子操作后，线程已经明确了解对象的修改顺序，那么读操作后的写操作必须等待读操作完成后执行，而写操作后的读操作也是同理，不可提前读取或写入。相关细节我们将在后续章节进一步讨论。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内存模型与原子类型操作——原子操作与原子类型</title>
    <url>/2020/06/02/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>原子类型操作(atomic operation)具备不可分割性，其仅存在执行完成与未执行两种状态。</p>
<p>如若某线程正在以原子操作load一个对象的值（对该对象的所有修改都由原子操作完成），那么它仅能读取到该对象在修改前，亦或某一次修改后的值（无法获取中间状态）。非原子类型操作不具备此性质，因此线程很可能读取到某个对象的中间状态，从而造成数据竞争。</p>
<a id="more"></a>
<hr>
<h1 id="标准原子类型"><a href="#标准原子类型" class="headerlink" title="标准原子类型"></a>标准原子类型</h1><p>&nbsp;<br>所有标准原子类型都可以在<code>&lt;atomic&gt;</code>头文件中找到。尽管从理论角度出发，开发者可以使用互斥锁保证任何数据类型均对外展现出原子性，但从C++语言定义而言，仅有这些类型是真正的原子类型。</p>
<p>事实上，可能标准原子类型也是通过使用锁实现了原子性。为了探究这一点，几乎所有标准原子类型（特例为<code>std::atomic_flag</code>）都具备这样一个接口<code>is_lock_free()</code>，开发者可以通过调用此接口来判断，当前行为究竟是语义上的原子行为（此时该接口返回true）还是编译器或者函数库内部在执行加锁操作模拟原子性（此时该接口返回false）。了解原子类型是否具备语义上的原子性在性能优化领域较为重要：如果某类型内部同样使用了mutex，那么可能将无法带来期望的性能收益。</p>
<p>除了直接使用<code>std::atomic</code>类模板外，标准库也提供了一系列名称来引用原子类型。但由于历史原因，在较老的编译器上，这些替代类型名称可能引用对应 std::atomic&lt;&gt;的特化类或这个特化类的一个基类，支持C++17的编译器则不存在此问题。因此，如果混合使用类型名与<code>std::atomic&lt;&gt;</code>特化类，可能导致代码不可移植。</p>
<p>类型名与<code>std::atomic&lt;&gt;</code>特化类映射表如下：<br><img src="http://static.zybuluo.com/zsmj2017/ulsub2apkxgv7hlabpfxrdxv/WechatIMG13.png" alt="WechatIMG13.png-417kB"></p>
<p>除此以外，C++标准库还针对<code>std::size_t</code>等非基本原子类型提供typedef，其映射表如下：<br><img src="http://static.zybuluo.com/zsmj2017/jut87ru9vyn16t0qv66fsr0w/image-20210610152408616.png" alt="image-20210610152408616.png-298.2kB"></p>
<p>标准原子类型理论上不可复制或赋值，因为它们没有<code>copy ctor</code>或<code>copy assignment operator</code>。但它们支持通过诸如<code>load()</code>,<code>store</code>，<code>exchange</code>等被相应的内置类型赋值或隐式转换。此外，它们也支持相应的相关计算符，例如<code>+=</code>,<code>-=</code>等等。整形与指针的原子类型还支持<code>++</code>，<code>--</code>。这些计算符同样具备实现同样功能的成员函数，如<code>fetch_add()</code>、<code>fetch_or()</code>等等。<br>一般而言，对象的赋值运算符往往返回引用，如果将该惯例应用于原子类型，则获取存储数据时程序中势必存在一个特殊的读操作，这可能导致数据竞争（在assign和read之间可能存在一个线程正在修改数据）。因此，对于赋值运算符而言，其返回值是被存储的数据，而对于命名成员函数而言，返回值是操作前的数据。</p>
<p><code>std::atomic&lt;&gt;</code>类模板不仅仅是一组特化。它确实存在一个主模板，可用于创建用户自定义类型的原子变体。其操作被限定为<code>load()</code>、<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。</p>
<p>每个原子类型上操作都有一个可选的内存顺序参数，它是<code>std::memory_order</code>枚举类型的某个值，可以用来指定所需的内存顺序语义。<code>std::memory_order</code>枚举值分别为：<br>1.std::memory_order_relaxed<br>2.std::memory_order_acquire<br>3.std::memory_order_consume<br>4.std::memory_order_acq_rel<br>5.std::memory_order_release<br>6.std::memory_order_seq_cst</p>
<p>该内存顺序参数依赖于操作的类别，在不指定的情况下，默认使用<code>std::memory_order_seq_cst</code>。</p>
<hr>
<h1 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a>std::atomic_flag</h1><p>&nbsp;<br><code>std::atomic_flag</code>是最简单的标准原子类型，表征布尔量，此类型的对象仅有两种状态:set或clear。实际上，它被设计为一种基础构建模块，很少应用于实际工程。以下将简称<code>std::atomic_flag</code>类型对象为flag对象。</p>
<p>flag对象必须用<code>ATOMIC_FLAG_INIT</code>初始化，即初始化为clear状态，这也意味着它无法被初始化为set状态。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic_flag f = ATOMIC_FLAG_INIT;</span><br></pre></td></tr></table></figure><br>它是唯一在初始化时需要这种特殊处理的原子类型，也是唯一保证无锁的原子类型。此外，static flag对象保证其具备静态初始化特性，即该对象总在首次使用前完成初始化。</p>
<p>flag对象在完成初始化后，仅能对其施加三种操作：destroy，clear，test_and_set（读取值后set），分别对应着析构函数，<code>clear()</code>成员函数以及<code>test_and_set()</code>成员函数。<code>clear()</code>和<code>test_and_set()</code>都可以指定内存顺序。</p>
<p>所有原子类型均不支持copy ctor &amp;&amp; copy assignment，flag对象也不例外。原因很简单：应用于原子类型的所有操作均应具备原子性，但赋值和拷贝构造涉及到两个独立对象。在执行拷贝构造或拷贝赋值操作时，必须先从一个对象读取值，然后将其写入另一个对象，这一组合行为不可能具备原子性。</p>
<p><code>std::atomic_flag</code>所具备的特性使其非常适合实现自旋互斥锁，具体实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::atomic_flag flag; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  spinlock_mutex(): flag(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.test_and_set(<span class="built_in">std</span>::memory_order_acquire)); <span class="comment">// 忙-等待</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>flag对象类似于bool，但其未提供标准get接口（C++20引入<code>test()</code>成员函数），因此如存在相关需求，请使用<code>std::atomic&lt;bool&gt;</code>。</p>
<hr>
<h1 id="std-atomic-lt-bool-gt"><a href="#std-atomic-lt-bool-gt" class="headerlink" title="std::atomic&lt;bool&gt;"></a>std::atomic&lt;bool&gt;</h1><p>&nbsp;<br>相较于flag对象，<code>std::atomic&lt;bool&gt;</code>的灵活程度大为提高。尽管不支持copy ctor与copy assign，但可以使用内置的bool类型构造它——这意味着它可以被初始化为true或false。此外，<code>std::atomic&lt;bool&gt;</code>对象亦可接受来自内置bool类型的赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一点：不同于常规赋值操作，原子类型的赋值操作返回的并非引用，而是被赋予的值。原因很简单，返回引用可能会导致另一个线程修改当前存储数据，这将导致数据竞争。</p>
<p><code>std::atomic&lt;bool&gt;</code>使用<code>strore()</code>成员函数写入true或false值，使用<code>exchange()</code>成员函数完成对原始值的检索与替换，读取操作使用的是成员函数<code>load()</code>。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> x=b.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">b.store(<span class="literal">true</span>);</span><br><span class="line">x=b.exchange(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br></pre></td></tr></table></figure></p>
<p>除<code>exchange</code>外，<code>std::atomic&lt;bool&gt;</code>还有两个”read-change-write”操作，分别是<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。</p>
<p>compare-exchange操作是使用原子类型进行编程的基石——它将原子变量的值与提供的预期值进行比较，若相等，则存储提供的值。如果值不相等，则预期值将被更新为原子变量存储的值。该操作返回布尔量，若执行了存储操作（值相等）且存储成功则为true，否则为false。</p>
<p><code>compare_exchange_weak()</code>的weak之处在于，即使原始值与预期值一致时，存储也可能会不成功，此时原始值不变，<code>compare_exchange_weak()</code>返回false。这种情况多见于当前机器不支持compare-exchange指令（意味着无法保证操作原子性），若此时执行操作的线程在必要的指令序列中被切换出去，而操作系统在其位置调度了另一个线程，将导致数据存储失败。因此<code>compare_exchange_weak()</code>通常应用于循环内：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="keyword">bool</span>&gt; b; <span class="comment">// 在其他某个地方设置</span></span><br><span class="line"><span class="comment">// b内部数据为存储值</span></span><br><span class="line"><span class="comment">// expected为期待值</span></span><br><span class="line"><span class="comment">// true为提供值</span></span><br><span class="line"><span class="keyword">while</span>(!b.compare_exchange_weak(expected,<span class="literal">true</span>) &amp;&amp; !expected); <span class="comment">// 若存储失败，将持续执行</span></span><br></pre></td></tr></table></figure><br><code>compare_exchange_strong()</code>的strong之处在于，当存储值等于期待值时，该函数返回ture（即使存储失败），否则返回false。</p>
<p>若当前提供值依赖于存储值，则开发者可以利用期待值被更新为存储值的特性，利用期待值计算提供值。这里需要注意，若这种计算过程非常耗时，则使用strong优于weak，因为weak所在的循环将导致提供值被反复计算，即使期待值未发生变更。</p>
<p>除flag外，原子类型并不保证无锁性，若有需要，<code>std::atomic&lt;bool&gt;</code>可以通过<code>is_lock_free()</code>成员函数检查其操作是否具备无锁性。</p>
<hr>
<h1 id="std-atomic-lt-T-gt"><a href="#std-atomic-lt-T-gt" class="headerlink" title="std::atomic&lt;T*&gt;"></a>std::atomic&lt;T*&gt;</h1><p>&nbsp;<br>std::atomic&lt;T*&gt;具备所有std::atomic<bool>的接口与性质，本节主要描述其特性。</p>
<p>std::atomic<T*>支持指针运算，类似于普通指针，其行为是在存储的地址上做原子加法与减法，其接口也类似与普通指针类型，有+=，-=，++(前置&amp;&amp;后置)， —(前置&amp;&amp;后置)，它们的返回值是一个普通的T*，指向增加/减少后的内存地址。</p>
<p>除上述接口外，std::atomic<T*>还提供了接口<code>fetch_add()</code>与<code>fetch_sub()</code>，其返回值与上述接口不同，返回执行加/减操作前的原始值。</p>
<p>std::atomic<T*>具体使用示例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span>&#125;;</span><br><span class="line">Foo some_array[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;Foo*&gt; <span class="title">p</span><span class="params">(some_array)</span></span>; </span><br><span class="line">Foo*x=p.fetch_add(<span class="number">2</span>); <span class="comment">//p加2，并返回老的值 </span></span><br><span class="line">assert(x==some_array); </span><br><span class="line">assert(p.load()==&amp;some_array[<span class="number">2</span>]);</span><br><span class="line">x=(p-=<span class="number">1</span>); <span class="comment">//p减1，并返回新的值 </span></span><br><span class="line">assert(x==&amp;some_array[<span class="number">1</span>]); </span><br><span class="line">assert(p.load()==&amp;some_array[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="标准整形原子类型"><a href="#标准整形原子类型" class="headerlink" title="标准整形原子类型"></a>标准整形原子类型</h1><p>&nbsp;<br>除load(), store(), exchange(), compare_exchange_weak(),compare_exchange_strong()接口外，原子整形类型如std::atomic<int>和 std::atomic<unsigned long long>有相当全面的一整套运算接口:fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor()，以及复合赋值形式的操作((+=, -=, &amp;=, |=和^=)，++和—(前置&amp;&amp;后置)。因为原子整数值通常用作计数器或位掩码，因此缺失乘法，除法，移位操作符也许并不能算作遗憾。如有需要，在循环内反复调用compare_exchange_weak()即可。</p>
<p>类似于指针操作，<code>fetch()</code>接口均返回修改前的旧值，前置操作符返回修改后的新值，后置操作符返回修改前的旧值。</p>
<hr>
<h1 id="std-atomic-lt-T-gt-1"><a href="#std-atomic-lt-T-gt-1" class="headerlink" title="std::atomic&lt;T&gt;"></a>std::atomic&lt;T&gt;</h1><p>&nbsp;<br>给定用户自定义的类型UDT，std::atomic&lt;UDT&gt;提供了与std::atomic&lt;bool&gt;相同的接口，当然，与存储值相关的返回类型为UDT，而非bool。</p>
<p>并非任意UDT均可与std::atomic&lt;&gt;搭配使用：UDT必须具备一个trivial拷贝赋值操作符，这意味着该类型必须没有虚函数和虚基类，并且必须使用编译器生成的拷贝赋值操作符——这一要求对其基类和非静态数据成员同样生效。这保证了编译器可以使用memcpy（或一个等价操作）来完成赋值。此外，compare_exchange使用的是memcmp式的比较操作，因此不支持bitwise相等的UDT实例在执行compare_exchange操作时将会不符合预期，即使比较值满足自定义operator==（顺带提一嘴，std::atomic&lt;double&gt;与std::atomic&lt;float&gt;尽管是标准类型，使用<code>compare_exchange_strong</code>时也存在同样的坑，原因在于数据的存储形式不同）。</p>
<p>这些限制背后的原因前文已经提及——不要将指针和引用作为参数传递给用户提供的函数，从而在锁范围外传递受保护数据。一般来说，编译器无法为std::atomic&lt;UDT生成无锁代码，因此它必须生成和使用一个内部锁。如果允许用户提供自定义拷贝赋值或比较操作符，则需要将对受保护数据的引用作为参数传递给用户提供的函数，这可能导致数据竞争。此外，这些限制增加了编译器直接为 std::atomic&lt;UDT&gt;使用原子指令的机会，因为它可以直接将UDT实例视为一组原始字节。</p>
<p>这些限制意味着开发者不能创建一些较为复杂的原子数据类型，例如<code>std::atomic&lt;std::vector&lt;int&gt;&gt;</code>(它有一个特殊的拷贝构造和拷贝赋值操作符)。但这并不算大问题——数据结构越复杂，对其进行复杂操作的可能性越高，而不只是原子操作里简单的赋值和比较，此类数据最好使用<code>std::mutex</code>，以确保为所需操作适当地保护数据。</p>
<p>如果UDT的大小 &lt;= int或void*，那么大多数平台都能够对std::atomic&lt;UDT&gt;使用原子指令。一些平台还能对两倍于int或void*大小的用户自定义类型使用原子指令。这些平台通常支持所谓的双字比较-交换(double-word-compare-and-swap)指令，该指令对应于compare_exchange_xxx函数。</p>
<p>综上，下表展示了std::atomic&lt;T&gt;上可使用的各项操作：<br><img src="http://static.zybuluo.com/zsmj2017/l5jxrrnhm2mvnxa1cda7vzhj/image.png" alt="image.png-224.6kB"></p>
<hr>
<h1 id="应用于原子操作的自由函数"><a href="#应用于原子操作的自由函数" class="headerlink" title="应用于原子操作的自由函数"></a>应用于原子操作的自由函数</h1><p>TODO::不甚重要，日后补充</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程</title>
    <url>/2018/07/17/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>C++11的一大成就在于将并发性融入语言和库中，这意味着在C++历史上，程序员第一次可以在所有平台上编写具有标准行为的多线程程序，作为C++开发者，我们应当坚信这只是C++通用并发编程的开始。</p>
<p>标准库中存在两个future模板，它们分别是std::future与std::shared_future。在大多数场合开发者并不需要了解它们的区别，因此本章中提到的future一般都是代指这两种。</p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板元编程入门</title>
    <url>/2022/08/05/C++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本文只是针对TMP(Template Metaprogramming)的简单说明，并不涉及模板元编程中的各种黑魔法诸如编译期堆排序，实现反射特性等等。<br>旨在对TMP做一个入门科普，以及简单介绍TMP在实际业务中存在哪些应用。</p>
<a id="more"></a>
<hr>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>&nbsp;<br>C++模板特化，偏特化的一些匹配原则。（参考C++ Primer相关章节即可）<br>C++模板类型推导的基本原理，以及模板类型推导的一些常见问题。<br>具体可见<a href="https://xander.wiki/2018/06/20/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%A1%8D/">Effective Modern C++ Item1</a>。</p>
<hr>
<h1 id="模板元编程的基本概念"><a href="#模板元编程的基本概念" class="headerlink" title="模板元编程的基本概念"></a>模板元编程的基本概念</h1><p>&nbsp;<br>顾名思义，模板元编程就是用模板来实现元编程，它工作于<strong>编译期</strong>，而非运行期。<br>开发者尝试使用模板实例化的一些特性和约束来完成一些计算任务，或者实现一些在运行期很难完成的功能。</p>
<h2 id="TMP的简单应用（编译期求值）"><a href="#TMP的简单应用（编译期求值）" class="headerlink" title="TMP的简单应用（编译期求值）"></a>TMP的简单应用（编译期求值）</h2><h3 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h3><p>abs相当于是TMP内的”hello,world”, 我们通过它来了解最基础的模板元编程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt; <span class="comment">// use template parameter as a function parameter</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_abs</span>&#123;</span></span><br><span class="line">    <span class="keyword">static_assert</span>(N != INT_MIN, <span class="string">"N must not be INT_MIN"</span>);</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = N &lt; <span class="number">0</span> ? -N : N; <span class="comment">// use static data member as return value</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_my_abs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;<span class="number">-1</span>&gt;::value == <span class="number">1</span>, <span class="string">"my_abs&lt;-1&gt;::value == 1"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;<span class="number">1</span>&gt;::value == <span class="number">1</span>, <span class="string">"my_abs&lt;1&gt;::value == 1"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;<span class="number">0</span>&gt;::value == <span class="number">0</span>, <span class="string">"my_abs&lt;0&gt;::value == 0"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;<span class="number">-6</span>&gt;::value == <span class="number">6</span>, <span class="string">"my_abs&lt;-6&gt;::value == 6"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(my_abs&lt;INT_MAX&gt;::value == INT_MAX, <span class="string">"my_abs&lt;INT_MAX&gt;::value == INT_MAX"</span>);</span><br><span class="line">    <span class="comment">// cannot compile</span></span><br><span class="line">    <span class="comment">// static_assert(my_abs&lt;INT_MIN&gt;::value == -INT_MIN, "my_abs&lt;INT_MIN&gt;::value == -INT_MIN");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fibonacci"><a href="#fibonacci" class="headerlink" title="fibonacci"></a>fibonacci</h3><p>为了展现tmp并非只能完成简单计算求值，有fibonacci的TMP递归实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span> &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;0&gt; &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;1&gt; &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bad impl!!!</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_fibonacci</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Fibonacci&lt;45&gt;::value = "</span> &lt;&lt; Fibonacci&lt;<span class="number">45</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// calculates fibonacci(45) at compile time</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"fibonacci(45) = "</span> &lt;&lt; fibonacci(<span class="number">45</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// cost too much run time</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Fibonacci&lt;10000&gt;::value = "</span> &lt;&lt; Fibonacci&lt;<span class="number">10000</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过编译期递归并不能为所欲为，其递归深度取决于编译器允许的模板实例化的最大深度，不过可以通过<code>-ftemplate-depth=N</code>进行调整。<br>（constexpr函数同样存在编译期递归深度限制问题）</p>
<hr>
<h2 id="TMP的简单应用（操作类型）"><a href="#TMP的简单应用（操作类型）" class="headerlink" title="TMP的简单应用（操作类型）"></a>TMP的简单应用（操作类型）</h2><p>到目前为止，给出的2个示例并不能真正体现TMP的优势，毕竟我们完全可以用constexpr函数取代abs&lt;&gt;和fibonacci&lt;&gt;。 TMP的优势在于，它的参数可以是一个类型，而非一个值。实际上，c++内早就有这种函数，例如sizeof。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">4</span>, <span class="string">"int is not 4 bytes"</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span> ll == <span class="number">8</span>, <span class="string">"long long is not 8 bytes"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) == <span class="number">8</span>, <span class="string">"long long is not 8 bytes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入类型，输出值"><a href="#输入类型，输出值" class="headerlink" title="输入类型，输出值"></a>输入类型，输出值</h3><p>假设存在一个场景，我们需要根据指定类型返回一个值，例如根据指定类型，返回该类型的最大值或者最小值(也就是<code>std::numeric_limits</code>)。 那么可以有简单实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">max_value</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">max_value</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = INT_MAX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">max_value</span>&lt;long&gt; &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">long</span> value = LONG_MAX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MY_CLASS</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max_value&lt;<span class="keyword">int</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max_value&lt;<span class="keyword">long</span>&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// cannot compile</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; Max_value&lt;MY_CLASS&gt;::value &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到，对于已经完成特化的部分类型，max_value运行地很好，但对于其他类型，将会直接导致编译报错。<br>这种技法被称之为SFINAE（Substitution Failure Is Not An Error）。SFINAE是元编程基础组件<code>std::enable_if</code>的重要基础，后续会继续提到。</p>
<h3 id="输入类型，输出类型"><a href="#输入类型，输出类型" class="headerlink" title="输入类型，输出类型"></a>输入类型，输出类型</h3><p>也许我们不应该仅仅将目光停留在输出数值上，更进一步地，TMP可以输出一个类型，而不仅仅是数值。</p>
<h4 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h4><p>模板函数可以根据输入类型的一些特性，返回特定类型。在某些场景下这种名叫type traits的技法非常有用，例如stl中的大部分泛型算法都基于这种技法。</p>
<h5 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h5><p>举一个最简单的例子，让某个迭代器移动指定的步长, <code>advance</code>函数声明大致类似于<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">  ... <span class="comment">// impl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>众所周知，stl内各容器的迭代器均为具体的类型，并且具备不同的特性，以vector举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">simpleAlloc</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:<span class="comment">// alias declarartions</span></span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> pointer = value_type *;</span><br><span class="line">  <span class="keyword">using</span> iterator = value_type *;<span class="comment">// iterator is raw pointer</span></span><br><span class="line">  <span class="keyword">using</span> const_iterator = <span class="keyword">const</span> value_type *;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">const</span> value_type &amp;;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">size_t</span>;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:<span class="comment">// data member</span></span><br><span class="line">  <span class="comment">// iterator to indicate the vector's memory location</span></span><br><span class="line">  iterator start;</span><br><span class="line">  iterator finish;</span><br><span class="line">  iterator end_of_storage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于vector而言，它的迭代器类型为<code>value_type *</code>，单纯的指针类型，支持随机访问。<br>而<code>list</code>则不然，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">list_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> self = list_iterator&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> link_type = list_node&lt;T&gt; *;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> iterator_category = bidirectional_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> pointer = T *;</span><br><span class="line">  <span class="keyword">using</span> reference = T &amp;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data member</span></span><br><span class="line">  link_type node;<span class="comment">// raw pointer link to list_node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// increasement</span></span><br><span class="line">  self &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    self temp = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// decreasement</span></span><br><span class="line">  self &amp;<span class="keyword">operator</span>--() &#123;</span><br><span class="line">    node = node-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    self temp = *<span class="keyword">this</span>;</span><br><span class="line">    --(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>list的迭代器显然仅仅支持双向递增递减，并不支持随机访问。<br>slist（单链表)的迭代器具体实现此处略过不再赘述，不过它的迭代器仅支持前向递增。<br>显然，枚举出所有迭代器并一一重载是不现实的:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(slist&lt;T&gt;::iterator &amp;i, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(<span class="built_in">list</span>&lt;T&gt;::iterator &amp;i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;::iterator &amp;i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>stl将迭代器分为以下5种类型，并存在以下继承关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;; <span class="comment">// 前向迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;; <span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;; <span class="comment">// 随机访问迭代器</span></span><br></pre></td></tr></table></figure>
<p>并且定义迭代器type traits为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> Iterator::iterator_category;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> Iterator::difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T *&gt; &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in c++14 style</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">iterator_category_t</span> =</span></span><br><span class="line"><span class="class">    <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:iterator_category;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">difference_type_t</span> = <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:difference_type;</span><br></pre></td></tr></table></figure>
<p>因此，自定义迭代器只需要在内部声明<code>iterator_category</code>和<code>difference_type</code>（为了避免忘记声明，stl提供了一个模板以供继承），即可使用type_traits。 因此，<code>advance</code>函数具体实现为:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  i += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">  _advance(i, n, <span class="keyword">iterator_category_t</span>&lt;InputIterator&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>事实上，type traits在stl泛型算法中的应用随处可见（这也与stl的设计理念有关），例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span> *<span class="title">p</span>) &#123;</span></span><br><span class="line">  p-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">beg</span>, <span class="title">ForwardIterator</span> <span class="title">end</span>) &#123;</span></span><br><span class="line">  <span class="keyword">using</span> is_POD_type = <span class="keyword">typename</span> type_traits&lt;ForwardIterator&gt;::is_POD_type;</span><br><span class="line">  destroy_aux(beg, <span class="built_in">end</span>, is_POD_type());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的value_type不存在non—trivial destructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">beg</span>, <span class="title">ForwardIterator</span> <span class="title">end</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">false_type</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (; beg != <span class="built_in">end</span>; ++beg) destroy(&amp;*beg);<span class="comment">// 毕竟迭代器不是真正的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在trivial destructor</span></span><br><span class="line"><span class="comment">// 如果对象的析构函数无关痛痒，那么反复调用它是一种效率上的巨大浪费</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>, <span class="title">ForwardIterator</span>, <span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对char*、wchar_t*的特化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span> *)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">wchar_t</span> *, <span class="keyword">wchar_t</span> *)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不胜枚举。</p>
<hr>
<h2 id="构建模板元编程的基础组件"><a href="#构建模板元编程的基础组件" class="headerlink" title="构建模板元编程的基础组件"></a>构建模板元编程的基础组件</h2><h3 id="模板元编程中的代码复用"><a href="#模板元编程中的代码复用" class="headerlink" title="模板元编程中的代码复用"></a>模板元编程中的代码复用</h3><h4 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h4><p>假设存在一个场景，开发者需要对输入的类型添加或删除某种属性。<br>先从最简单的例子开始———擦除某种类型的<code>const</code>属性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>&lt;const T&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure><br>移除<code>volatile</code>也是类似的，如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span>&lt;volatile T&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>擦除<code>reference</code>也是类似的，如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，<code>add_lreference</code>，<code>add_rrefernce</code>的实现也并不复杂，此处不再赘述。</p>
<h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>前文所提及的所有模板元案例，要么基于<code>xxx::value</code>，要么基于<code>xxx::type</code>（表示TMP的返回是一个类型还是一个值）。<br>每一次模板元编程都写一次<code>using type = xxx</code>是一次非常磨人的行为，类似的代码理论上应该被复用。因此，我们有必要实现一些基础组件，并根据这些基础组件来完成模板元编程的开发工作。</p>
<h3 id="TMP基础组件"><a href="#TMP基础组件" class="headerlink" title="TMP基础组件"></a>TMP基础组件</h3><h4 id="证同的实现与应用"><a href="#证同的实现与应用" class="headerlink" title="证同的实现与应用"></a>证同的实现与应用</h4><p>证同操作是一个单纯的投射，输入一个T类型，返回一个T类型。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>通过<code>identity</code>，<code>remove_xxx</code>的实现可以更加优雅：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>:</span> identity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>&lt;const T&gt;:</span> identity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> :</span> identity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt;:</span> identity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt;:</span> identity&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="编译期数值的实现与应用"><a href="#编译期数值的实现与应用" class="headerlink" title="编译期数值的实现与应用"></a>编译期数值的实现与应用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T val&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_constant</span> &#123;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> T value = val;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> type = integral_constant;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据<code>integral_constant</code>，开发者可以使用<code>integral_constant&lt;T, val&gt;</code>来创建和使用编译期数值，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> val&gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="keyword">bool</span>, val&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = bool_constant&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = bool_constant&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<h4 id="how-to-impl-is-same"><a href="#how-to-impl-is-same" class="headerlink" title="how to impl is_same?"></a>how to impl is_same?</h4><p><code>is_same</code>，顾名思义，返回两个类型是否相同，其具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_same</span> :</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_same</span>&lt;T, T&gt; :</span> true_type &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="how-to-impl-is-void"><a href="#how-to-impl-is-void" class="headerlink" title="how to impl is_void ?"></a>how to impl is_void ?</h4><p>操作类型的基础是了解当前传入的类型，在泛型编程中，我们时常需要类似于<code>is_int</code>,<code>is_float</code>,<code>is_pointer</code>等等诸如此类的类型判断。<br>本文并不关注描述如何实现以上工具，只是试图表明以上工具均可以通过前文已有所涉及的基础组件加以实现。<br>还是从最简单的例子开始，尝试通过几种方法来实现 <code>is_void</code>。</p>
<h5 id="通过特化穷举所有可能"><a href="#通过特化穷举所有可能" class="headerlink" title="通过特化穷举所有可能"></a>通过特化穷举所有可能</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>:</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void&gt;:</span> true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void const&gt;:</span> true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void volatile&gt;:</span> true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>&lt;void const volatile&gt;:</span> true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="use-is-same-amp-amp-remove-cv"><a href="#use-is-same-amp-amp-remove-cv" class="headerlink" title="use is_same &amp;&amp; remove_cv"></a>use is_same &amp;&amp; remove_cv</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span> :</span> is_same&lt;<span class="keyword">remove_cv_t</span>&lt;T&gt;::type, <span class="keyword">void</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="use-is-one-of"><a href="#use-is-one-of" class="headerlink" title="use is_one_of"></a>use is_one_of</h5><p><code>is_one_of</code>，顾名思义，返回一个类型是否存在于类型列表中（not in std)，其具体实现如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>  ...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_one_of</span>;</span> <span class="comment">// only a declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_one_of</span>&lt;T&gt; :</span> false_type &#123;&#125;; <span class="comment">// 递归基</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_one_of</span>&lt;T, U, Args...&gt; :</span> bool_constant&lt;is_same&lt;T, U&gt;::value || is_one_of&lt;T, Args...&gt;::value&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><br>如何使用<code>is_one_of</code>来实现<code>is_void</code>是非常显然的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span>:</span> is_one_of&lt;T,<span class="keyword">void</span>, <span class="keyword">const</span> <span class="keyword">void</span>, <span class="keyword">volatile</span> <span class="keyword">void</span>, <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上关于<code>is_void</code>的实现充分说明，类似于普通函数，模板元编程在实现过程中同样存在多种方案可供选择，并非仅有单一实践。</p>
<h4 id="编译期判断"><a href="#编译期判断" class="headerlink" title="编译期判断"></a>编译期判断</h4><h5 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h5><p>编译期同样存在if判断的需求与使用场景，例如某个模板类需要根据泛型参数<code>T</code>的具体属性来决定继承基类<code>B1</code>或<code>B2</code>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span></span><br><span class="line">  ...<span class="comment">// sth</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> &#123;</span></span><br><span class="line">  ...<span class="comment">// sth</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> val, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = xxx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> conditional&lt;<span class="built_in">std</span>::is_void&lt;T&gt;::value, B1, B2&gt;::type &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中<code>conditional</code>是一个标准的元编程实现，其作用为:val为true，则type == T，否则type == U。<br>显然，<code>conditional</code>的实现并无特别：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> val, <span class="keyword">typename</span> T, <span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span>&lt;true, T, U&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span>&lt;false, T, U&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = U;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h5><p><code>enable_if</code>的实现基础来自于SFINAE，在TMP中使用非常广泛。<br>在实际开发工作中经常存在某种场景，即当前泛型函数仅应该支持符合条件的某些类型，其余类型应当在编译期触发报错，例如:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该模板函数接受参数：整形，浮点，string_view， xxx库提供的数组与字典结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;</span><br><span class="line">              <span class="built_in">std</span>::is_same&lt;T, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::value ||</span><br><span class="line">              <span class="built_in">std</span>::is_same&lt;T, xxx::string_view&gt;::value || <span class="built_in">std</span>::is_integral&lt;T&gt;::value ||</span><br><span class="line">              <span class="built_in">std</span>::is_floating_point&lt;T&gt;::value || <span class="built_in">std</span>::is_same&lt;T, xxx::Values&gt;::value ||</span><br><span class="line">              <span class="built_in">std</span>::is_same&lt;T, xxx::Dictionary&gt;::value&gt;::type * = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">process</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t, <span class="keyword">const</span> T &amp;val) &#123;</span><br><span class="line">  ... <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>enable_if</code>有实现如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> val&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">enable_if</span> &#123;</span>&#125;; <span class="comment">// nothing in struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">enable_if</span>&lt;true&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">void</span>; <span class="comment">// dont need use this type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="模板元编程的实际应用"><a href="#模板元编程的实际应用" class="headerlink" title="模板元编程的实际应用"></a>模板元编程的实际应用</h1><p>&nbsp;</p>
<h2 id="判断类型是否存在某个对外暴露的符号"><a href="#判断类型是否存在某个对外暴露的符号" class="headerlink" title="判断类型是否存在某个对外暴露的符号"></a>判断类型是否存在某个对外暴露的符号</h2><p>简单介绍一下TMP在实际工程中的应用情况，例如：判断当前类型是否内含有某public member function或者pulic data member，思路和<code>enable_if</code>思路大致类似。<br>这里仅以如何判断当前类型存在拷贝赋值函数举例。   </p>
<h2 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h2><p>decltype 与 declval<br><a href="https://xander.wiki/2018/06/25/%E4%BA%86%E8%A7%A3decltype%E6%8A%80%E6%9C%AF/">https://xander.wiki/2018/06/25/%E4%BA%86%E8%A7%A3decltype%E6%8A%80%E6%9C%AF/</a><br><a href="https://stdrc.cc/post/2020/09/12/std-declval/" target="_blank" rel="noopener">https://stdrc.cc/post/2020/09/12/std-declval/</a><br>void_t<br><a href="https://blog.csdn.net/ding_yingzi/article/details/79983042" target="_blank" rel="noopener">https://blog.csdn.net/ding_yingzi/article/details/79983042</a></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">copy_assignment_t</span> = <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;T &amp;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct has_copy_assignment : <span class="built_in">std</span>::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in c++17 style</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_copy_assignment</span>&lt;T, std::void_t&lt;copy_assignment_t&lt;T&gt;&gt;&gt; :</span> <span class="built_in">std</span>::is_same&lt;<span class="keyword">copy_assignment_t</span>&lt;T&gt;, T &amp;&gt; &#123;&#125;; <span class="comment">// 特化最优匹配</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    B &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> B &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(has_copy_assignment&lt;A&gt;::value, <span class="string">"A has copy assignment"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(!has_copy_assignment&lt;B&gt;::value, <span class="string">"B has no copy assignment"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，如需检验某个类是否具备public data member，只需要更改<code>decltype</code>内的判断条件即可。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板元编程</tag>
      </tags>
  </entry>
  <entry>
    <title>2.C++式类型转换</title>
    <url>/2018/04/23/C++%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>(本节内容在Effective C++ 28中亦有涉及）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>类型转换这种东西c语言就有，但是过于粗鲁(允许任何类型之间的相互转换）也难以识别（因为它用圆括号和标识符）<br>c++引入了四种类型转换，分别是static_cast，const_cast，dynamic_cast以及reinterpret_cast.</p>
<hr>
<h1 id="四种类型转换的作用"><a href="#四种类型转换的作用" class="headerlink" title="四种类型转换的作用"></a>四种类型转换的作用</h1><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>强制隐式类型转换，其特点在于无法去除const属性。</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>const_cast用于去除表达式的const或volatileness属性。</p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>dynamic_cast可以把指向bc的指针或者引用改为指向dc的，转换失败则返回空指针（转换指针）或者抛出异常（转换引用）实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWidget</span>:</span> <span class="keyword">public</span> Widget &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(SpecialWidget *psw)</span></span>;</span><br><span class="line">Widget *pw;</span><br><span class="line">...<span class="comment">//指向某个SpecialWidget对象</span></span><br><span class="line">update(<span class="keyword">dynamic_cast</span>&lt;SpecialWidget*&gt;(pw));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateViaRef</span><span class="params">(SpecialWidget&amp; rsw)</span></span>;</span><br><span class="line">updateViaRef(<span class="keyword">dynamic_cast</span>&lt;SpecialWidget&amp;&gt;(*pw));</span><br></pre></td></tr></table></figure></p>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>reinterpret_cast的操作结果几乎都是执行期定义（很难移植），一般用作函数指针类型之间的切换，实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FuncPtr)</span><span class="params">()</span></span>; <span class="comment">//一个函数指针，该函数没有参数 返回值类型为void</span></span><br><span class="line">FuncPtr funcPtrArray[<span class="number">10</span>]; <span class="comment">// funcPtrArray 是一个能容纳10个FuncPtrs指针的数组</span></span><br></pre></td></tr></table></figure><br>当前我们希望把下面这个函数指针放入数组内：<code>int dosth()</code>当然这必须要使用类型转换，于是有：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">funcPtrArray[<span class="number">0</span>] = <span class="keyword">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;doSomething);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>Data语义学——Data Member的绑定</title>
    <url>/2018/05/12/Data%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Data%20Member%E7%9A%84%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>考虑以下程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> x;<span class="comment">//外部的x变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span>,<span class="keyword">float</span>,<span class="keyword">float</span>);</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">X</span><span class="params">(<span class="keyword">float</span> new_x)</span> <span class="keyword">const</span> </span>&#123;x=new_x;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果我们调用<code>Point3d::X()</code>,那么它返回的是<code>Point3d::x</code>还是<code>extern x</code>？熟悉C++的人都明白是前者，但并非一直以来都是前者。</p>
<p>在C++最早的编译器上，如果在Point3d::X()的两个函数实例中对x进行参阅（取用）操作，这操作将会指向global x object。这种结果基本上不在开发者的预期之内，因此直接导致了C++早期的两种防御性程序设计风格：</p>
<ol>
<li><strong>将所有的data members放在class声明起头处，以确保正确的绑定：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>将所有的inline functions无论大小都置于声明之外</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Point3d(<span class="keyword">float</span>,<span class="keyword">float</span>,<span class="keyword">float</span>);</span><br><span class="line">  <span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">X</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">Point3d::X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这些程序设计风格直至今日仍然存在，虽然已经不再具备必要性。这个古老的语言规则被称为“member scope resolution rules”，大意是“一个inline函数实体，在整个class声明未被完全看见之前，是不会被evaluated的”。C++ Standard以“member scope resolution rules”来精炼这个“rewriting rule”，其效果是，如果一个inline函数在class声明后立刻被定义的话，那么还是对其evaluate，也就是说，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> x;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//对函数的分析将延迟至class声明的右大括号出现才开始</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//分析在这里进行</span></span><br></pre></td></tr></table></figure><br>因此，在一个inline member function躯体内的一个data member绑定操作，会在整个class声明完成后才完成。</p>
<p>然而，这对于member function的argument list并不为真。Argument list中的名称还是会在它们第一次遭遇时被适当地resloved。因此在extern与nested type names之间的非直觉操作绑定操作还是会发生。例如，在下面的程序段中，length的类型在两个member function signatures中都被reslove为global typedef，也就是int。当后续再有length的nested typedef声明出现时，C++<br>Standard就把之前的绑定标示为非法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//length被resloved为global</span></span><br><span class="line">    <span class="comment">//_val被resloved为Point3d::_val</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">(length val)</span> </span>&#123;_val = val;&#125;</span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//length必须在“本class对它的第一个参考操作”之前被看见</span></span><br><span class="line">    <span class="comment">//该声明将使之前的参考操作不合法</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;</span><br><span class="line">    length _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上述这种语言状况，仍然需要某种防御性编程风格：<strong>请始终将nested type声明放在class的起始处。</strong>在上述例子中，如果把length的nested type定义于“在class中被参考”之前，就可以确保非直觉绑定的正确性。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>41.Consider pass by value for copyable parameters that are cheap to move and always copied.</title>
    <url>/2018/07/19/Consider%20pass%20by%20value%20for%20copyable%20parameters/</url>
    <content><![CDATA[<p>（本节标题完美揭示了全部主旨，不宜翻译）</p>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假定当前存在一个Widget class，其成员函数addName接受一个string并将其添加到内部容器中。一般为了保证效率，我们通常会对左值string执行pass-by-const-reference，对右值执行move：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; newName)</span> <span class="comment">// take lvalue;</span></span></span><br><span class="line"><span class="function">    </span>&#123; names.push_back(newName); &#125; <span class="comment">// copy it</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; newName)</span> <span class="comment">// take rvalue;</span></span></span><br><span class="line"><span class="function">    </span>&#123; names.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(newName)); &#125; <span class="comment">// move it;</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>以上代码运行地非常良好，就是函数可能太多了一点，我们不得不写下两份声明，两份实现，两份文档。。。诸如此类。此外，目标码中将存在两个函数，这无疑会导致程序的占用空间增大。内联会优化这一行为，但你并不能保证内联的必然执行。</p>
<p>另一种方法是使addName成为一个形参为universal reference的函数模板：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// take lvalues and rvalues;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// copy lvalues,move rvalues;</span></span><br><span class="line">        names.push_back(<span class="built_in">std</span>::forward&lt;T&gt;(newName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这减少了源码的大小，但可能会造成更加恶劣的情况。作为模板，addName的实现通常必须位于头文件中，因此它可能在目标码中生成相当多的函数，原因在于它不仅对lvalue和rvalue产生不同的实例化，它还对std::string和可转换为std::string的类型产生不同的实例化（见Item25）。此外，有些参数类型无法通过universal reference传递（见Item30），如果客户传递了不正确的参数类型，编译器所提出的错误报告可能会令人头大（见Item27）。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>有没有一种函数，既能针对不同情况作出不同处理（copy左值，移动右值），又能只在源码和目标码中仅仅出现一次，并且还不需要使用universal reference？事实上真的有。我们唯一要做的就是摒弃入门时的第一条C++准则——禁止对自定义类型采用值传递形式。对于Addname中的newname这种参数，采用值传递确实是一种正当选择。以下是值传递版本的实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> newName)</span> <span class="comment">// take lvalue or rvalue; move it</span></span></span><br><span class="line"><span class="function">    </span>&#123; names.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(newName)); &#125; </span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此代码中唯一不太显然之处就是push_back的实参中采用了std::move。通常情况下，move一般与右值一起使用（见Item25），但在本例中我们可以清楚地看出：</p>
<ol>
<li><strong>newName是完全独立的对象，更改newName不会影响caller。</strong></li>
<li><strong>这是newName的最后一次使用，移动它并不影响程序的其他地方。</strong></li>
</ol>
<p>因此使用move不会产生任何问题。</p>
<hr>
<h1 id="性能剖析"><a href="#性能剖析" class="headerlink" title="性能剖析"></a>性能剖析</h1><p>&nbsp;<br>在C++98中，pass-by-value将导致昂贵的性能损耗， pass-by-value意味着无论caller传入的是什么都必须经由copy constructor构造。但在C++11中，addName将仅为lvalue执行拷贝构造。 对于右值，它将执行移动构造。例如在如下语句中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Bart"</span>)</span></span>;</span><br><span class="line">w.addName(name); <span class="comment">// call addName with lvalue</span></span><br><span class="line">…</span><br><span class="line">w.addName(name + <span class="string">"Jenne"</span>); <span class="comment">// call addName with rvalue(see below)</span></span><br></pre></td></tr></table></figure><br>在第一次调用addName时，newName由左值初始化，因此与C++98一样采用拷贝构造。在第二次调用中，newName由一个匿名std::string对象初始化，该对象是一个右值，因此newName由移动构造。一切都如我们所愿。</p>
<hr>
<h2 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h2><p>&nbsp;<br>前文讨论的三种方案依次如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// Approach 1:overload for lvalues and rvalues</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123; names.push_back(newName); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123; names.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(newName)); &#125;</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// Approach 2:use universal reference</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123; names.push_back(<span class="built_in">std</span>::forward&lt;T&gt;(newName)); &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// Approach 3:pass by value</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123; names.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(newName)); &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们可以将前两种称为“by-reference approaches”，因为它们都通过reference传递参数。现有两种测试场景如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Bart"</span>)</span></span>;</span><br><span class="line">w.addName(name); <span class="comment">// pass lvalue</span></span><br><span class="line">…</span><br><span class="line">w.addName(name + <span class="string">"Jenne"</span>); <span class="comment">// pass rvalue</span></span><br></pre></td></tr></table></figure><br>针对上述三种方案，现有分析如下：</p>
<ol>
<li><strong>重载</strong><br>无论传入的是左值还是右值，其均被绑定至一个名为newName的引用。将实参绑定至引用没有任何成本。在左值重载函数中，newName被copy至Widget::names中。在右值重载函数中，newName被移动至Widget::names中。总的来说，左值需要一次拷贝，右值需要一次移动。</li>
<li><strong>universal reference</strong><br>与重载一样，实参被绑定至引用newName，绑定操作没有成本。由于使用了std::forward，lvalue std::string参数将会被copy到Widget::names中，而ravlue std::string将会被移动到该容器内。总的来说成本与重载一致：左值需要一次拷贝，右值需要一次引用。（在本次分析中我们假设传入的总是string，而非别的类型）。</li>
<li><strong>传值</strong><br>无论传入的是左值还是右值，string对象newName都必须构造，区别在于传入左值则采用拷贝构造，传入右值则采用移动构造。在函数体中，newName将被无条件地移动到Widget::names之中。总的来说，成本总是为一次构造（copy/move)+一次move，这比上两种方案多了一次move。</li>
</ol>
<hr>
<h1 id="以传值代替引用的条件"><a href="#以传值代替引用的条件" class="headerlink" title="以传值代替引用的条件"></a>以传值代替引用的条件</h1><p>&nbsp;<br>现在我们将镜头拉回至标题：<strong>Consider pass by value for copyable parameters that are cheap to move<br>and always copied</strong><br>该标题实则已经表明了作者的一切立场，以下将一一解读：</p>
<ol>
<li>你应当<strong>考虑（consider)</strong>使用传值。尽管它只需要撰写一次，并且避免了目标码膨胀，但传值比其替代方案成本更高，并且可能存在其他成本（详见下文）。</li>
<li>传值仅针对可拷贝的对象，move-only类型无法拷贝，在这种情况下，“重载”解决方案只需要一个重载：采用rvalue引用的重载。<br>举例而言，当前Widget class内含一个unique_ptr&lt;std::string&gt;对象与一个由于unique_ptr是一个move-only类型，因此重载版本完全可以写为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   …</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPtr</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; ptr)</span></span></span><br><span class="line"><span class="function">   </span>&#123; p = <span class="built_in">std</span>::<span class="built_in">move</span>(ptr); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
其调用形式大致类似于：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line">w.setPtr(<span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"Modern C++"</span>));</span><br></pre></td></tr></table></figure>
其总成本为一次移动操作（移动unique_ptr匿名对象至p）。<br>如果将该类设计为pass-by-value：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   …</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPtr</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function">   </span>&#123; p = <span class="built_in">std</span>::<span class="built_in">move</span>(ptr); &#125;</span><br><span class="line">   …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
则将首先移动构造ptr，然后再将其移入p中，其成本为右值重载的两本。</li>
<li>仅在移动操作成本较低时选择pass-by-value，否则多付出的一次move操作将导致得不偿失。</li>
<li>应当考虑为始终执行copy的参数选择pass-by-value。举例而言，假如在加入容器前需要对字符串长度进行判断，符合条件者方可加入：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> newName)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((newName.length() &gt;= minLen) &amp;&amp;(newName.length() &lt;= maxLen))&#123;</span><br><span class="line">           names.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(newName));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这种情况下可能会造成不必要的copy操作，因此在使用pass-by-value之前必须确保该参数定会被copy。</li>
</ol>
<hr>
<h2 id="赋值拷贝"><a href="#赋值拷贝" class="headerlink" title="赋值拷贝"></a>赋值拷贝</h2><p>即使我们真正符合上述条件，pass-by-value也未必是最佳方案。原因在于函数可能会以两种方式拷贝参数：构造（copy构造与move构造）、赋值（copy赋值与move赋值）。<br>addName成员函数使用构造：其参数newName被传递给vector::push_back，在该函数内部，newName被拷贝构造为vector尾端的一个新元素。本节开篇便分析了这种情况，此时无论传递的是左值还是右值都会导致额外的一次move的开销。<br>使用赋值copy参数时，情况会变得较为复杂。假设当前存在一个表示密码的类，因为密码可以更改，我们提供了setter函数changeTo，采用pass-by-value策略，该class实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Password</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Password</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> pwd)</span>: <span class="title">text</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(pwd))</span> </span>&#123;&#125; <span class="comment">// construct text</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> newPwd)</span></span>&#123; <span class="built_in">text</span> = <span class="built_in">std</span>::<span class="built_in">move</span>(newPwd); &#125; <span class="comment">// assign text</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>; <span class="comment">// text of password</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>尽管将密码设为纯文本似乎有些不妥，但请忽略它而将焦点关注于可能发生的问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">initPwd</span><span class="params">(<span class="string">"Supercalifragilisticexpialidocious"</span>)</span></span>;</span><br><span class="line"><span class="function">Password <span class="title">p</span><span class="params">(initPwd)</span></span>;</span><br></pre></td></tr></table></figure><br>上述程序一切正常，相对于重载或universal reference方案，我们只需要多付出一次move成本而已。但用户可能会试图更改密码，例如他们会写下此类程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> newPassword = <span class="string">"Beware the Jabberwock"</span>;</span><br><span class="line">p.changeTo(newPassword);</span><br></pre></td></tr></table></figure><br>传递给changeTo的参数是一个左值（newPassword），因此在构造参数newPwd时将触发string的拷贝构造函数，该构造函数分配内存以保存新密码，然后将newPwd移动到text，这会导致原有text占用的内存被释放。因此，changeTo中有两个动态内存管理操作：一个为新密码分配内存，另一个为旧密码释放内存。</p>
<p>但事实上，因为旧密码要长于新密码。所以我们本没有必要执行动态内存分配。倘若当前采用的是重载版本，将不会触发任何内存分配行为（因为采取了赋值构造）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Password</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">     <span class="comment">// the overload for lvalues can reuse text's memory if text.capacity() &gt;= newPwd.size()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeTo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; newPwd)</span></span>&#123;</span><br><span class="line">        <span class="built_in">text</span> = newPwd;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>; <span class="comment">// as above</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>执行内存动态分配可能要比move操作多花数个数量级的时间，因此pass-by-value在此场景下并不可取。此外，如果旧text长度小于新text的长度，那么无论采取何种方案，内存动态分配所带来的开销均不可避免。因此，参数复制的成本可能会取决于该参数的值。上述分析只适用于值是保存在堆内存中的，需要动态分配内存的类型，例如std::string与std::vector。</p>
<p>此外，上述分析只适用于实参是左值的情况，如果传递的是右值，那么开销还是很低的，因为不需要进行拷贝构造，省却了拷贝构造带来的内存分配开销（内存分配一般仅发生于copy操作之中）。</p>
<p>总而言之，赋值拷贝性能取决于实参类型，左值与右值的比率，是否存在动态内存分配等等。甚至还需要考虑要传入参数的具体实现方案，以std::string举例，如果它使用了SSO优化进行实现，那么赋值操作会将要赋值的内容放到SSO的buffer中，因此情况又将不同。</p>
<hr>
<h1 id="最终定论"><a href="#最终定论" class="headerlink" title="最终定论"></a>最终定论</h1><p>&nbsp;<br>通常情况下，最实际的做法是采用”有罪推定”的策略，也就是平时均使用重载或universal reference方案，除非明显pass-by-value的效率更高。</p>
<p>现如今软件总是越快越好，因此pass-by-value未必是一个良好方案，因为避免一次廉价的move开销也相当重要，我们无法明确一个操作会有多少次这样的move操作。例如Widget::addName通过值传递造成了一次额外的move操作，但是这个函数内部又调用了Widget::validateName，这个函数也是值传递的方式，这就又造成了一次额外的move开销，validateName内部如果再调用其他的函数，并且这个函数同样是值传递的方式呢?，这就造成了累加效应，如果使用引用传递的话就不会有这样的累加效应了。</p>
<hr>
<h1 id="pass-by-value与slicing"><a href="#pass-by-value与slicing" class="headerlink" title="pass-by-value与slicing"></a>pass-by-value与slicing</h1><p>&nbsp;<br>如果当前存在一个形参为基类对象或派生类对象的函数，此时应当谨慎使用pass-by-value，因为这会去除派生类的所有特性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> … &#125;; <span class="comment">// base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWidget</span>:</span> <span class="keyword">public</span> Widget &#123; … &#125;; <span class="comment">// derived class</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(Widget w)</span></span>; <span class="comment">// func for any kind of Widget,including derived types;</span></span><br><span class="line">…</span><br><span class="line">SpecialWidget sw;</span><br><span class="line">…</span><br><span class="line">processWidget(sw); <span class="comment">// processWidget sees a Widget, not a SpecialWidget!</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Data语义学——Data Member的布局</title>
    <url>/2018/05/12/Data%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Data%20Member%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>已知下面一组data member：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Point3d*&gt; *freeList;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> chunkSize = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Nonstatic data members在class object中的排列顺序将与其被声明的顺序一致，任何中间介入的static data member不计入对象布局，它们被置于程序的data segment之中，与class object无关。</p>
<p>C++ Standard约定，在同一个access section（例如private，public，protected），members的排列只需符合“较晚出现的members在object中具备较高的地址”这一条件。也就是说<strong>，members可能在内存中并不是连续排列的，alignment造就了这种情况（填补了一些bytes）。</strong></p>
<p>编译器还可能会自己生成一些data members以完成特定的功能，比如说vptr，其具体位置视编译器而定，可能在user members之前，之后，之间，只要保证满足上一段所说的要求即可。</p>
<p>可能一个class会由于写作原因出现多个access sections：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该class生成的object大小与组成均与单access section时相同，access section的多寡并不会造成额外负担。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Data语义学——Data Member的存取</title>
    <url>/2018/05/12/Data%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Data%20Member%E7%9A%84%E5%AD%98%E5%8F%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d origin;</span><br><span class="line">origin.x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
<p>可能会有人好奇x的存取成本有多大，答案是视Point3d与x如何声明而定，x可能是一个static member或者nonstatic。Point3d可能是一个独立的class，也可能从另一个单一的base class派生而来，甚至可能是从多重继承或虚拟继承而来，下面将依次介绍这几种情况。<br>在探究之前，我们再次抛出一个问题：从object本身存取data member与从指向object的指针存取data member有何差异：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d origin,*pt = &amp;origin;</span><br><span class="line">origin.x = <span class="number">0.0</span>;pt-&gt;x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><br>在本节结束前我们将回答这个问题。</p>
<hr>
<h1 id="static-data-members"><a href="#static-data-members" class="headerlink" title="static data members"></a>static data members</h1><p>&nbsp;<br>Static data members被编译器提出于class之外，并被视为一个global变量（只在class生命范围之内可见）。每一个member的存取access level，以及与class的关联性，并不会导致任何空间或时间的额外负担。</p>
<h2 id="指针存取与对象存取"><a href="#指针存取与对象存取" class="headerlink" title="指针存取与对象存取"></a>指针存取与对象存取</h2><p>每一个static data member仅具备一个实体，存放于程序的data segment之中，每次程序存取static member都会被编译器视为该extern实体的存取操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">origin.chunkSize=<span class="number">250</span>;<span class="comment">//Point3d::chunkSize=250;</span></span><br><span class="line">pt-&gt;chunkSize=<span class="number">250</span>;<span class="comment">//Point3d::chunkSize=250;</span></span><br></pre></td></tr></table></figure><br>这是C++语言中“通过一个指针与直接操作对象存取member，效果完全一样”的唯一情况。造成这种情况的原因在于<code>.操作符</code>根本并没有进入object内部获取数据。如果该static data member从复杂继承关系中继承而来，并不影响这个结论的正确性，因为static data member仅仅具备一个实体，其存取路径不受任何继承关系影响。</p>
<h2 id="函数调用存取"><a href="#函数调用存取" class="headerlink" title="函数调用存取"></a>函数调用存取</h2><p>如果static data member的存取经由函数调用而被存取，如果我们写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">foobar().chunkize=<span class="number">250</span>;</span><br></pre></td></tr></table></figure><br>调用foobar()时会发生什么？（foobar()的结果并不能改变static member，作者的意思在于查看编译器在此处是否存在优化）<br>在C++ pre-Standard规格中，ARM（Annotated Reference Manual）并未指定foobar()是否必须被evaluated。但C++ Standard明确要求foobar()必须被evaluated，虽然其结果并无用处：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>) foobar();<span class="comment">//evaluate expression,discarding result</span></span><br><span class="line">Point3d.chunkSize()=<span class="number">250</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="名变换"><a href="#名变换" class="headerlink" title="名变换"></a>名变换</h2><p>若取一个static data member的地址，会得到一个指向其数据类型的指针，而不是一个指向其class member的指针，因为static member并不内含在一个class object之中,这一点十分显然。<br>但如果有两个classes，每一个都声明了一个static member freeList，那么当它们都置于程序的data segment内部时会出现名称冲突。编译器的解决方法是暗中对每一个static data member编码（name-mangling，名变换）。名变换具备两个特点：</p>
<ol>
<li>每一种算法对应一种独一无二的名字</li>
<li>编译系统如果需要与开发者进行交互，这些名称可以被轻易推导回原有名称。</li>
</ol>
<hr>
<h1 id="Nonstatic-Data-Members"><a href="#Nonstatic-Data-Members" class="headerlink" title="Nonstatic Data Members"></a>Nonstatic Data Members</h1><p>&nbsp;</p>
<h2 id="Nonstatic-Data-Members与object"><a href="#Nonstatic-Data-Members与object" class="headerlink" title="Nonstatic Data Members与object"></a>Nonstatic Data Members与object</h2><p>Nonstatic Data Members存在于class object内部，除非经由explicit/implicit class object，没有办法直接存取它们。只要我们试图在某个member function中直接处理一个nonstatic data member，那么implicit class object就一定会发生：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point3d::translate</span><span class="params">(<span class="keyword">const</span> Point3d &amp;pt)</span></span>&#123;</span><br><span class="line">    x+=pt.x;</span><br><span class="line">    y+=pt.y;</span><br><span class="line">    z+=pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实质上这一系列操作都是通过this指针完成，其函数的真正表示形式大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point3d::translate</span><span class="params">(point3d *<span class="keyword">const</span> <span class="keyword">this</span>,<span class="keyword">const</span> Point3d &amp;pt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x+=pt.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y+=pt.y;</span><br><span class="line">    <span class="keyword">this</span>-&gt;z+=pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="nonstatic-data-members的存取"><a href="#nonstatic-data-members的存取" class="headerlink" title="nonstatic data members的存取"></a>nonstatic data members的存取</h2><p>如果需要对一个nonstatic data member进行存取操作，那么编译器需要获取当前object的地址，然后通过偏移量计算出data member的地址，举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp;origin+(&amp;Point3d::_y<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><br>-1操作是其中的重点。指向data member的指针，其offset的值总是被加上1，这样就可以让编译器区分出“一个指向data member的指针，用以指出class的第一个member”，以及“一个指向class object的指针”两种情况。</p>
<h2 id="nonstatic-data-member与继承"><a href="#nonstatic-data-member与继承" class="headerlink" title="nonstatic data member与继承"></a>nonstatic data member与继承</h2><p>每一个nonstatic data member的offset在编译期间便已得知，甚至如果member属于一个base class subobject也是一样，因此，存取一个nonstatic data member的效率等价于存取一个C struct member或一个nonderived class的member。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承为数据的存取导入了一层间接性，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d *pt3d;</span><br><span class="line">pt3d-&gt;_x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><br>如果_x是一个virtual base class的member，存取速度相较于其他情况要慢一点，其具体原因可见后续章节（继承对于对象布局的影响）。</p>
<p>我们回到本节一开始时提出的问题：通过对象存取与通过指针存取有多大的差别？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">origin.x = <span class="number">0.0</span>;</span><br><span class="line">pt-&gt;x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><br>如果继承体系中存在一个virtual base class，且被存取的member是一个从virtual base class继承得到的member时，上述两种写法存在较大差异。因为在此时我们无法确定pt必然指向哪一种class type（因此我们也就不知道编译期这个member真正的offset），因此该存取操作必然需要被延后到执行期，经由一个额外的间接引导。但如果使用对象则不存在这种问题，因为静态类型早已绑定，其offset也早已在编译期确定。一个优秀的编译器甚至能够静态地经由origin解决对x的存取。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Data语义学——对象成员的效率</title>
    <url>/2018/05/14/Data%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>本节含有数个测试，旨在测试聚合、封装、继承所引发的额外负担。所有测试均以各别局部变量的加减、赋值等操作的存取成本为依据。我认为本节内容更偏重编译器优化，不同的编译器效果不同，有兴趣的读者可自行翻书。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Data语义学——前言</title>
    <url>/2018/05/11/Data%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<p>假设现有多重继承体系如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> Y,<span class="keyword">public</span> Z &#123;&#125;;</span><br></pre></td></tr></table></figure><br>上述X、Y、Z、A中没有任何一个class内含明显的数据，它们之间只存在继承关系，因此理论上每一个class的大小都应该为0，但事实上，它们的大小均不为0：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(X) == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(Y) == <span class="number">4</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(Z) == <span class="number">4</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(A) == <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p>
<p>一个空的class如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class X &#123;&#125;;</span><br></pre></td></tr></table></figure><br>事实上并非是空的，它有一个隐晦的1byte，那是被编译器安插进去的一个char（Effective C++ 40）。因此这个class具现化得到的object能够在内存中配置独一无二的地址：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X a,b;</span><br><span class="line"><span class="keyword">if</span>(&amp;a == &amp;b)...</span><br></pre></td></tr></table></figure><br>那为什么Y和Z的大小会是4呢，这与三个因素有关：</p>
<ol>
<li><strong>语言本身的额外负担</strong><br>当语言支持virtual base classes时，就会导致一些额外负担。在derived class中，这个额外负担反应在某种形式的指针身上，它或者指向virtual base class subobject，或者指向一个相关表格：表格中存放的是virtual base class subobject的地址或其偏移量。</li>
<li><strong>编译器对于特殊情况所做的优化处理</strong><br>Virtual base class X subobject的1 bytes大小也出现在class Y和Z上。传统上它被放在derived class的固定（不发生变动）部分的末端。有些编译器会对empty virtual base class提供特殊支持，但有的没有。</li>
<li><strong>Alignment的限制</strong><br>在大部分机器上，群聚的结构体大小会受到alignment的限制，使它们能够更有效的在内存中被存取。</li>
</ol>
<p>每一个class object都必须有足够大小来容纳其所有nonstatic data members，有时候它们的大小可能会和我们预想的要大一些，原因在于：</p>
<ol>
<li>由编译器自动加上的额外data members，用以支持某些语言特性（主要是virtual特性）。</li>
<li>因为alignment的需要。</li>
</ol>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Data语义学——指向Data Members的指针</title>
    <url>/2018/05/14/Data%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E6%8C%87%E5%90%91Data%20Members%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>通过指向Data Members的指针，我们可以更加细致地探究对象布局，比如说了解vptr是在顶端还是底端，又或者说了解class中access sections的次序。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>考虑下面的Point3d，其内含一个virtual function，一个static member，以及三个坐标值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Point3d();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Point3d origin;</span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该class object内部会含有vptr，我们不能确定的是其位于头部还是尾部。</p>
<p>在一个32位的机器上，一个float是4bytes，一个vptr也是4bytes。因此，三个坐标值在对象中的偏移量应该是0,4,8（vptr位于尾部）或4,8,12（位于头部）。但如果你去取data members的地址，传回的值会总是多1，也就是1,5,9或5,9,13。下面将详细描述原因。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>如何区分一个“没有指向任何data member”的指针和一个“指向第一个data member的指针”？考虑如下例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> Point3d::*p1 = <span class="number">0</span>;<span class="comment">//Point3d::*的意思在于“指向Point3d data member”的指针类型</span></span><br><span class="line"><span class="keyword">float</span> Point3d::*p2 = &amp;Point3d::x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p1==p2)&#123;<span class="comment">//如何区分p1 p2?</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"contain same value"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了区分p1与p2，每一个真正的member offset值都会被加1，因此编译器和开发者都应当明确，在真正使用该值以指出一个member之前，先减1。</p>
<h2 id="真正Data地址与offset"><a href="#真正Data地址与offset" class="headerlink" title="真正Data地址与offset"></a>真正Data地址与offset</h2><p>在明确了“指向data members的指针”之后，我们发现解释<code>&amp; Point3d::z</code>与<code>&amp; origin.z</code>之间的差异则非常容易。<br>取一个nonstatic data member的地址将获得其在class中的offset，而取一个绑定于真正object身上的data，将会得到该member在内存中的真正地址。。那么我们执行<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp; origin.z - &amp; Point3d::z</span><br></pre></td></tr></table></figure><br>返回得到的就是origin的其实地址，但其类型是<code>float *</code>而非<code>float Point3d::*</code>。</p>
<hr>
<h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>&nbsp;<br>在多重继承下，如果需要将后继base class的指针和一个“derived class object data member”相结合，会由于需要加入offset而变得相当复杂，举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> &#123;</span><span class="keyword">int</span> val1;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> &#123;</span><span class="keyword">int</span> val2;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>:</span>Base1,Base2 &#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> derived::*dmp,Derived *pd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//期待的是一个指向derived的data member指针</span></span><br><span class="line">    <span class="comment">//但实际传入的可能是一个指向base class的data member的指针</span></span><br><span class="line">    pd-&gt;*dmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Derived *pd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//bmp==1,但在derived中，val2==5</span></span><br><span class="line">    <span class="keyword">int</span> Base2::*bmp = &amp;Base2::val2;</span><br><span class="line">    func1(bmp,pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当bmp被作为func1的第一个参数时，其值必须受到调整，否则<code>pd-&gt;*dmp</code>将存取到<code>Base::val1</code>，而非开发者所以为的<code>Base::val2</code>。为了解决这个问题，必须由编译器转为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非null判定</span></span><br><span class="line">func1(bmp?bmp+<span class="keyword">sizeof</span>(Base1):<span class="number">0</span>,pd);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="“指向Members的指针”的效率问题"><a href="#“指向Members的指针”的效率问题" class="headerlink" title="“指向Members的指针”的效率问题"></a>“指向Members的指针”的效率问题</h1><p>&nbsp;<br>接下来作者以一系列数据比较了不同编译器优化下经由指针存取members的效率。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Function语义学——Inline Function</title>
    <url>/2018/05/16/Function%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Inline%20Function/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>众所周知，inline只是对编译器提出的申请，如果该请求被接受，则会使用某个expression合理地将该函数扩展开来。</p>
<hr>
<h1 id="处理inline函数"><a href="#处理inline函数" class="headerlink" title="处理inline函数"></a>处理inline函数</h1><p>&nbsp;<br>一般而言，处理一个inline函数有两个阶段：</p>
<ol>
<li><strong>分析函数定义以确定函数的intrinsic inline ability</strong><br>如果一个函数因为其复杂度或建构问题，被编译器判断为无法inline，则会被转为一个static函数，并在“被编译模块”内产生对应的函数定义。理想情况下链接器会将产生出来的重复代码清除，但实际情况视编译环境而定。</li>
<li><strong>真正的inline函数扩展操作是在调用的哪一点上，这会带来参数求值操作及临时对象管理等问题</strong></li>
</ol>
<hr>
<h1 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h1><p>&nbsp;<br>在inline扩展期间，每一个形参都会被实参所取代，但这种取代操作并非想象中的一一替换，因为这会造成重复求值的可能。一般来说，为了避免这一可能性，我们会引入临时对象。举例而言，如果某个实参是一个常量表达式，我们可以在替换前先完成求值操作，后继需要该实参的地方则以计算值绑定。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>现有inline函数如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&lt;j?i:j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现有三个调用操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minval;</span><br><span class="line">    <span class="keyword">int</span> val1= <span class="number">1024</span>,val2 =<span class="number">2048</span>;</span><br><span class="line">    minval = <span class="built_in">min</span>(val1,val2); <span class="comment">// expression 1</span></span><br><span class="line">    minval = <span class="built_in">min</span>(<span class="number">1024</span>,<span class="number">2048</span>); <span class="comment">// expression 2</span></span><br><span class="line">    minval = <span class="built_in">min</span>(foo(),bar()+<span class="number">1</span>);<span class="comment">// expression 3</span></span><br><span class="line">    <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>三次调用的扩展情况如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">minval = val1 &lt; val2 ? val1 :val2; <span class="comment">//expression 1</span></span><br><span class="line">minval = <span class="number">1024</span>; <span class="comment">//直接计算后完成绑定</span></span><br></pre></td></tr></table></figure><br>expression1与expression2均不会产生任何副作用，而expression3需要导入一个临时对象，以避免重复求值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t1;</span><br><span class="line"><span class="keyword">int</span> t2;</span><br><span class="line">minval= (t1=foo(),t2=bar()+<span class="number">1</span>),t1&lt;t2?t1:t2;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h1><p>&nbsp;<br>如果我们的inline函数存在局部对象，如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minval = i&lt;j?i:j;</span><br><span class="line">    <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们的调用操作如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local_var;</span><br><span class="line">    <span class="keyword">int</span> minval;<span class="comment">//直接展开会造成名称遮蔽</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    minval = <span class="built_in">min</span>(val1,val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>inline被展开后的可能结果如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> local_var;</span><br><span class="line"><span class="keyword">int</span> minval;</span><br><span class="line"><span class="keyword">int</span> _min_lv_minval;<span class="comment">//local var</span></span><br><span class="line">minval = (_min_lv_minval=val1&lt;val2?val1:val2),_min_lv_minval);</span><br></pre></td></tr></table></figure></p>
<p>一般而言，inline函数中的每一个局部变量都必须被放在函数调用的一个封闭区段当中，拥有一个独一无二的名称。如果inline函数以单一表达式扩展多次，那么每一次扩展都需要自己的一组局部变量。如果inline函数以分离的多个式子被扩展多次，那么只需要一组局部变量，就可以重复使用。</p>
<p>inline函数中的局部变量，再加上有副作用的参数，可能会导致大量临时性对象的产生。特别是如果它以单一表达式被扩展多次的话。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">minval = <span class="built_in">min</span>(val1,val2) + <span class="built_in">min</span>(foo(),foo()+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>可能被扩展为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _min_lv_minval_00;</span><br><span class="line"><span class="keyword">int</span> _min_lv_minval_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t1,t2;</span><br><span class="line">minval =</span><br><span class="line">    （(_min_lv_minval_00 = val1 &lt; val2 ? val1:val2),_min_lv_minval_00)+</span><br><span class="line">    （(_min_lv_minval_01 = (t1=foo()),(t2=foo()+<span class="number">1</span>),t1 &lt; t2 ? t1:t2),_min_lv_minval_01);</span><br></pre></td></tr></table></figure><br>inline函数对于封装提供了一种必要的支持，可以有效存取封装于class中的nonpublic数据，同时也是C程序宏定义的有效替代物。</p>
<p>一如我所描述过的，参数带有副作用，又或者以一个单一表达式做多重调用，或在inline函数中存在多个局部变量，都会产生临时性对象。编译器可能无法对它们执行优化操作。另外，inline中再次含有inline可能会形成低效的串联（可能会发生于复杂class体系下的constructors）。inline函数提供了一个强而有力的工具，然而，与non-inline函数比起来，它们需要更加小心地处理。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Function语义学——Member的各种调用方式</title>
    <url>/2018/05/15/Function%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Member%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>最初的C with classes只支持nonstatic member functions。Virtual function在80年代中期被加入，static member function是1987年被最后加入。</p>
<hr>
<h1 id="Nonstatic-Member-Functions"><a href="#Nonstatic-Member-Functions" class="headerlink" title="Nonstatic Member Functions"></a>Nonstatic Member Functions</h1><p>&nbsp;<br>C++的一大设计准则是：nonstatic member function至少需要与一般的nonmember function具备同样的效率。也就是说，假定现在有两个函数如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">magnitude3d</span><span class="params">(<span class="keyword">const</span> Point3d *_this)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Point3d::magnitude3d</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br>这两个函数至少保证具备一致的调用效率，事实上，编译器总是会把member function转为对应的nonmember形式。</p>
<p>假设nonmember function定义式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">magnitude3d</span><span class="params">(<span class="keyword">const</span> Point3d *_this)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(_this-&gt;_x*_this-&gt;_x+</span><br><span class="line">                _this-&gt;_y*_this-&gt;_y+</span><br><span class="line">                _this-&gt;_z*_this-&gt;_z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="member-function的转化步骤"><a href="#member-function的转化步骤" class="headerlink" title="member function的转化步骤"></a>member function的转化步骤</h2><ul>
<li><p><strong>改写函数signature</strong><br>具体来说，则是增加一个额外参数*this，保证class object得以调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Point3d::magnitude</span><span class="params">(Point3d* <span class="keyword">const</span> <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果member function具备const属性，则函数被转化为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Point3d::magnitude</span><span class="params">(<span class="keyword">const</span> Point3d* <span class="keyword">const</span> <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将data member的存取操作改为通过this指针完成</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(_this-&gt;_x*_this-&gt;_x+</span><br><span class="line">            _this-&gt;_y*_this-&gt;_y+</span><br><span class="line">            _this-&gt;_z*_this-&gt;_z);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将转化后的member function重写为一个外部函数，并对它执行名变化处理。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">magnitude_7Point3dFv</span><span class="params">(<span class="keyword">register</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//独一无二的名称</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现该函数已被转化完成，相对应的调用操作也需要执行转化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转化前</span></span><br><span class="line">obj.magnitude();</span><br><span class="line">ptr-&gt;magnitude();</span><br><span class="line"><span class="comment">//转化后</span></span><br><span class="line">magnitude_7Point3dFv(&amp;obj);</span><br><span class="line">magnitude_7Point3dFv(ptr);</span><br></pre></td></tr></table></figure></p>
<h2 id="名变换"><a href="#名变换" class="headerlink" title="名变换"></a>名变换</h2><p>一般来说，member的名称前面需要加上class名称，形成独一无二的命名。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span><span class="keyword">public</span>:<span class="keyword">int</span> ival;...&#125;;</span><br></pre></td></tr></table></figure><br>其中的<code>ival</code>可能被名变换为<code>ival_3Bar</code>，编译器为什么需要对每一个member在名变换时考虑其class？<br>考虑下面的派生操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span><span class="keyword">public</span> Bar &#123;<span class="keyword">public</span>:<span class="keyword">int</span> ival;...&#125;;</span><br></pre></td></tr></table></figure><br>在经过名变换后，Foo的内部描述如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ival_3Bar;</span><br><span class="line">    <span class="keyword">int</span> ival_3Foo;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样保证了在名变换后可以清楚地指出任何一个值。<br>Member functions可以被重载，因此其需要更广泛地名变换手法，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//名变换前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//名变换后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x_5PointFf</span><span class="params">(<span class="keyword">float</span> newX)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x_5PointFv</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种将参数与函数名结合的名变换（函数名称+参数数目+参数类型）保证了：函数如果出现了错误的声明或调用形式，则无法发生正确的连接。但显然，它无法判断返回类型声明错误这种情况。</p>
<hr>
<h1 id="Virtual-Member-Functions"><a href="#Virtual-Member-Functions" class="headerlink" title="Virtual Member Functions"></a>Virtual Member Functions</h1><p>&nbsp;<br>如果normalize()是一个virtual member function，那么以下的调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr-&gt;normalize();</span><br></pre></td></tr></table></figure><br>将会被内部转化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">1</span>])(ptr);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Static-Member-Functions"><a href="#Static-Member-Functions" class="headerlink" title="Static Member Functions"></a>Static Member Functions</h1><p>&nbsp;<br>nonstatic member functions之所以需要this指针，是因为其对某个具体的member进行存取。Static member function不需要存取具体的member，因此它也无需使用this指针。</p>
<p>Static member function具备三大特性：</p>
<ol>
<li>不能够直接存取nonstatic member</li>
<li>不能被声明为const、volatile或virtual</li>
<li>无需经由class object被调用</li>
</ol>
<p>由于缺乏this指针，static member function在内存布局中与nonmember function即为类似。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Data语义学——继承与Data Member</title>
    <url>/2018/05/13/Data%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8EData%20Member/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在C++继承模型中，derived class object所表现出来的东西，是其自身members与其base classes’s members的总和。它们出现的次序没有强制性约定，一般来说，base class members将先出现，但属于virtual base class的除外（virtual继承总能带来各种各样的意外）。</p>
<p>下面提出一个问题：假设我们单独为Point2d与Point3d建立class，而不是令他们派生自某个固有继承体系（如Inside the C++ object model 关于对象一章）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>下述的各个小节将依次讨论不同情况下的区别。在没有virtual functions的情况下，我们可以认为上述两种写法的对象布局与C struct一致：<br><img src="http://static.zybuluo.com/zsmj2017/jp5tg6qlunoszrzobspufq5a/image_1cdbs9ibch0pqjd1og0ea7h5e9.png" alt="image_1cdbs9ibch0pqjd1og0ea7h5e9.png-26.9kB"></p>
<hr>
<h1 id="Inheritance-without-Polymorphism"><a href="#Inheritance-without-Polymorphism" class="headerlink" title="Inheritance without Polymorphism"></a>Inheritance without Polymorphism</h1><p>&nbsp;<br>一般来说，C++中有将非尾端类设计为抽象类的准则，假设我们暂且忽略这一点，将Point3d derived from Point2d，从而保证共享数据和操作数据的方法。一般来说，具体继承不会增加空间或时间的开销，有继承体系如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point2d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>):_x(x),_y(y) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123;_x=newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123;_y=newY;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point2d&amp; rhs)&#123;</span><br><span class="line">        _x+=rhs._x;</span><br><span class="line">        _y+=rhs._y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>)</span><br><span class="line">        :Point2d(x,y),_z(z) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123;_z=newZ;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point3d&amp; rhs)&#123;</span><br><span class="line">        Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">        _z+=rhs.z();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>它们的对象模型如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/480bzhsehdfb517ptj3v2iru/image_1cdbu8p77snq1si1gvs19qs91sm.png" alt="image_1cdbu8p77snq1si1gvs19qs91sm.png-75.4kB"></p>
<h2 id="空间膨胀"><a href="#空间膨胀" class="headerlink" title="空间膨胀"></a>空间膨胀</h2><p>将一个class分为多层，可能会因为“表现class体系的抽象化”而扩张所需空间。C++语言保证，<strong>出现在derived class中的base class subobject具备完整性</strong>，具体如下述实例所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">    <span class="keyword">char</span> c3;</span><br><span class="line">    <span class="keyword">char</span> c4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/zsmj2017/hbvlhopo6pvzo73ea6baayas/image_1cdbuglib14gi1vio1i3ccmf19gl13.png" alt="image_1cdbuglib14gi1vio1i3ccmf19gl13.png-22.9kB"><br>图中左侧的数字表明在32位机器上，这一部分占用了多少bytes（padding表示alignment带来的影响）。<br>现假设出于某些需要，我们将该Concrete分为三层：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> bit1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete2</span>:</span><span class="keyword">public</span> Concrete1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> bit2;</span><br><span class="line">&#125;</span><br><span class="line">clss Concrete3:<span class="keyword">public</span> Concrete2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> bit3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可能从设计的角度来说该结构比较合理，但我们会发现现在的Concrete3已经扩充到了16bytes，足足多了一倍，原因便是subobject的原样性必须保持。现在的对象布局如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/b54p6wdi2kc9m6tqalxs62x9/image_1cdc03hof1afb1j9j14on1dil1bb1g.png" alt="image_1cdc03hof1afb1j9j14on1dil1bb1g.png-245kB"></p>
<h2 id="保证subobject一致性的原因"><a href="#保证subobject一致性的原因" class="headerlink" title="保证subobject一致性的原因"></a>保证subobject一致性的原因</h2><p>看起来很蠢，那么为什么我们非要保证base class subobject的原样性呢？<br>考虑下述指针：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Concrete2 *pc2;</span><br><span class="line">Concrete1 *pc1_1,*pc1_2;<span class="comment">//可以指向任意的concrete object</span></span><br></pre></td></tr></table></figure><br>当我们通过指针来完成复制操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*pc1_2=*pc1_1;</span><br></pre></td></tr></table></figure><br>会执行默认的memberwise复制，对象是被指的object的Concrete2或Concrete3 object。如果pc1_1实际上指向的是Concrete2或Concrete3 object，则上述操作实际上应该复制pc1_1指向对象的Concrete1 subobject部分。</p>
<p>如果，C++将derived class members与subobject捆绑（失去一致性），那么会直接导致复制操作出现各种未定义行为：<br><img src="http://static.zybuluo.com/zsmj2017/8mj8sx1d5fr03mnp37e7c0kh/image_1cdc28lnr174m1jog1ij11uoiiun1t.png" alt="image_1cdc28lnr174m1jog1ij11uoiiun1t.png-430.4kB"></p>
<hr>
<h1 id="Adding-Polymorphism"><a href="#Adding-Polymorphism" class="headerlink" title="Adding Polymorphism"></a>Adding Polymorphism</h1><p>&nbsp;<br>如果我们在现有的继承体系中加入virtual function接口：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point2d&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，virtual function仅仅发生于多态情况下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Point2d&amp; p1.Point2d&amp; p2)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    p1+=p2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中p1与p2既可能指向Point2d object也可能指向Point3d object。多态是面向对象程序设计的核心，支持这样的弹性势必需要给class带来空间与存取时间上的负担。</p>
<h2 id="多态带来的开销"><a href="#多态带来的开销" class="headerlink" title="多态带来的开销"></a>多态带来的开销</h2><ol>
<li><strong>vtbl</strong><br>vtbl将会被生成，其内部存放着所有virtual function的地址，显然，该table的大小与virtual function的数目正相关。内部可能还会有别的slots，用以支持RTTI;</li>
<li><strong>vptr</strong><br>每一个class object内部都被置入一个vptr，提供执行期链接，保证每一个object能够找到对应的vtbl。</li>
<li><strong>加强constructor</strong><br>constructor需要为vptr设定初值，这可能意味着需要在derived class和每一个base class的constructor中重新设定vptr。</li>
<li><strong>加强destructor</strong><br>destructor需要能够抹除指向vbtl的vptr，需要记住的是，destructor的调用次序是反向的：从derived class到base class。</li>
</ol>
<h2 id="vptr的位置"><a href="#vptr的位置" class="headerlink" title="vptr的位置"></a>vptr的位置</h2><p>在设计C++编译器时的一个经典问题是：把vptr置于class object的哪一个位置最佳？</p>
<h3 id="置于尾部"><a href="#置于尾部" class="headerlink" title="置于尾部"></a>置于尾部</h3><p>假设我们将其置于object的尾部：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">no_virts</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d1,d2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">has_virts</span>:</span><span class="keyword">public</span> no_virts&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> d3;</span><br><span class="line">&#125;;</span><br><span class="line">no_virts *p = <span class="keyword">new</span> has_virts;</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/zsmj2017/nzscxmojht7lnb6q0j9grxuj/image_1cdcepq3a1kujvm18c68ci1isp9.png" alt="image_1cdcepq3a1kujvm18c68ci1isp9.png-78.1kB"><br>把vptr置于class object的尾端可以保留base class C struct的对象布局，从而确保即使在C程序中也能使用。</p>
<h3 id="置于头部"><a href="#置于头部" class="headerlink" title="置于头部"></a>置于头部</h3><p>自C++2.0起，虚继承与抽象基类特性被引入，且OO兴起，部分编译器开始把vptr放在object的头部：<img src="http://static.zybuluo.com/zsmj2017/st5vbsypleod3p5gjnojmjeo/image_1cdcfmt601mlv19nbvcla301euc13.png" alt="image_1cdcfmt601mlv19nbvcla301euc13.png-77.9kB"><br>将vptr置于前端，对于“在多重继承下，通过指向class members的指针调用member function”会带来帮助。但代价是丧失了与C struct的语言兼容性</p>
<p>下图展示了Point2d与Point3d加上了virtual function之后的内存布局（vptr位于尾端）：<br><img src="http://static.zybuluo.com/zsmj2017/pu00iyx7251hakdp3btf68l8/image_1cdcfslrde8v2vj191013rmn291g.png" alt="image_1cdcfslrde8v2vj191013rmn291g.png-82.2kB"></p>
<hr>
<h1 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h1><p>&nbsp;<br>在单一继承下，base class与derived class objects均从相同地址开始，只是其大小不同，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d p3d;</span><br><span class="line">Point2d* p = &amp;p3d;</span><br></pre></td></tr></table></figure><br>上述操作并不需要编译器去修改地址，且具备最佳执行效率。<br>上文曾叙述某些编译器将vptr置于class object的起始处。如果base class不具备virtual function而derived class具备的话，此时无法再保持对象起始地址的相同，需要编译器的介入以调整地址（因为vptr插入的缘故）。</p>
<p>多重继承不同于单一继承，也难以塑造模型，其复杂度在于derived class和其上一个base class乃至于上上个base class….之间的“非自然”关系，下文将以实例说明。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">//具备virtual接口</span></span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">//具备virtual接口</span></span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">    Vertex *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/zsmj2017/zd7pgmuplp23hivdldpv3v94/image_1cdci6k8ch0bm5b1rhh7f0lu81t.png" alt="image_1cdci6k8ch0bm5b1rhh7f0lu81t.png-43.6kB"><br>多重继承的主要问题在于derived class objects和其第二或后继的base class objects之间的转换，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">(<span class="keyword">const</span> Vertex&amp;)</span></span>;</span><br><span class="line">Vertex3d v;</span><br><span class="line">...</span><br><span class="line">mumuble(v);<span class="comment">//将v转化为Vertex对象</span></span><br></pre></td></tr></table></figure></p>
<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2><p>对于一个多重派生对象，将其地址指定给“最左端base class的指针”时，情况与单一继承情况一致。但如果你需要指定后继的base class地址，则需要编译器修改地址：加减介于中间的base class subobjects的大小：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vertex3d v3d;</span><br><span class="line">Vertex *pv;</span><br><span class="line">Point2d *p2d;</span><br><span class="line">Point3d *p3d;</span><br></pre></td></tr></table></figure><br>对于上述声明，下面的赋值操作将引发内部地址转换如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pv = &amp;v3d;</span><br><span class="line">pv = (Vertex*)(((<span class="keyword">char</span>*)&amp;v3d)+<span class="keyword">sizeof</span>(Point3d));</span><br></pre></td></tr></table></figure><br>而下面的assignment则只需要简单地拷贝地址即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p2d = &amp;v3d;</span><br><span class="line">p3d = &amp;v3d;</span><br></pre></td></tr></table></figure><br>如果现有两个指针如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vertex3d *pv3d;</span><br><span class="line">Vertex *pv;</span><br></pre></td></tr></table></figure><br>那么下面的assignment无法像上面那样简单地移位：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pv = pv3d;</span><br><span class="line">pv = (Vertex*)(((<span class="keyword">char</span>*)&amp;pv3d)+<span class="keyword">sizeof</span>(Point3d));</span><br></pre></td></tr></table></figure><br>原因在于如果pv3d==0，那么pv将获得sizeof(Point3d),这不可取，因此需要修改为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pv = pv3d?(Vertex*)(((<span class="keyword">char</span>*)&amp;pv3d)+<span class="keyword">sizeof</span>(Point3d)):<span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>引用在赋值时不需要考虑这么多，因为引用始终具备指向性（More Effective C++ 1）。下图给出了当前继承体系下的内存布局：<br><img src="http://static.zybuluo.com/zsmj2017/79qtpiuqhabp3bbzwoinc0gm/image_1cdcliqiiia8k7053914auc012a.png" alt="image_1cdcliqiiia8k7053914auc012a.png-298.9kB"><br>存取后继base class中的data member无需付出额外的成本，因为members的位置在编译期间便已经固定。</p>
<hr>
<h1 id="Virtual-Inheritance"><a href="#Virtual-Inheritance" class="headerlink" title="Virtual Inheritance"></a>Virtual Inheritance</h1><p>&nbsp;<br>多重继承的一大副作用在于，它必须支持某种形式的“shared subobject继承”。其中一个很典型的例子就是iostream library：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ios</span> &#123;</span>..&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span>:</span><span class="keyword">public</span> ios &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span>:</span><span class="keyword">public</span> ios &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span>:</span><span class="keyword">public</span> istream,<span class="keyword">public</span> ostream &#123;...&#125;;</span><br></pre></td></tr></table></figure><br>显然，无论是istream还是ostream内部都含有一个ios subobject。我们希望避免在iostream中出现两个2个ios subobject，因此可以引入虚继承：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ios</span> &#123;</span>..&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> ios &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> ios &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span>:</span><span class="keyword">public</span> istream,<span class="keyword">public</span> ostream &#123;...&#125;;</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/zsmj2017/ynf51jtexz0pk33jfkjnvact/image_1cdcn3a2gnqm15dlcje1q3j19tn2n.png" alt="image_1cdcn3a2gnqm15dlcje1q3j19tn2n.png-227.9kB"></p>
<h2 id="虚继承实现的难点"><a href="#虚继承实现的难点" class="headerlink" title="虚继承实现的难点"></a>虚继承实现的难点</h2><p>实现虚继承的一大难点在于需要找到一个足够有效的方法。将istream与ostream各自维护的一个ios subobject，折叠成为一个由iostream维护的单一ios subobject，并且保存pointer与reference对应的多态指定操作。</p>
<h2 id="虚继承的具体实现"><a href="#虚继承的具体实现" class="headerlink" title="虚继承的具体实现"></a>虚继承的具体实现</h2><p>我们将class分为两部分：不变局部、共享局部。</p>
<ol>
<li><strong>不变局部</strong><br>不变局部中的数据不管后继如何衍化，总是拥有固定的offset，因此这一部分数据可以被直接存取。</li>
<li><strong>共享局部</strong><br>所谓的共享局部则是virtual base class subobject这一部分的数据，其位置会由于派生操作而发生改变，所以它们只能被间接存取。</li>
</ol>
<p>有三种主流策略来实现虚继承，我们将在实例中一一介绍。</p>
<hr>
<h2 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h2><p>现有Vertex3d虚继承体系如下：<br><img src="http://static.zybuluo.com/zsmj2017/0z7276ju43vcjtwydzzml15g/image_1cdcnn2kagir14on1lkg65rdd9.png" alt="image_1cdcnn2kagir14on1lkg65rdd9.png-48.7kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">    Vertex *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Vertex,<span class="keyword">public</span> Point3d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一般布局策略是先安置好不变局部，再建立其共享局部。关键在于如何去读取class的共享部分？</p>
<h3 id="实现模型"><a href="#实现模型" class="headerlink" title="实现模型"></a>实现模型</h3><p>部分编译器会在每一个derived class object中安插一些指针，每个指针指向一个virtual base class。存取继承得到的virtual base class members可以通过这些指针来完成，其对象布局大致如下：<img src="http://static.zybuluo.com/zsmj2017/uqayb22chpgqgdckcsnqw8cq/image_1cdcp8gvs28o10cvt9v19913f0m.png" alt="image_1cdcp8gvs28o10cvt9v19913f0m.png-340.9kB"><br>举例而言，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原有函数</span></span><br><span class="line"><span class="keyword">void</span> Point3d::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Point3d &amp;rhs)&#123;</span><br><span class="line">    _x+=rhs._x;</span><br><span class="line">    _y+=rhs._y;</span><br><span class="line">    _z+=rhs._z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正实现</span></span><br><span class="line">_vbcPoint2d-&gt;_x += rhs._vbcPoint2d-&gt;_x;<span class="comment">//vbc means virtual base class</span></span><br><span class="line">_vbcPoint2d-&gt;_y += rhs._vbcPoint2d-&gt;_y;</span><br><span class="line">_z += rhs._z;</span><br></pre></td></tr></table></figure><br>而一个derived class和一个base class的实例之间的转换如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point2d *p2d = pv3d;</span><br><span class="line">Point2d * p2d = pv3d?pv3d-&gt;__vbcPoint2d:<span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>这种实现模型主要有两个缺点：</p>
<ol>
<li>每一个virtual base class都存在一个与之对应的指针，但我们希望空间开销固定，不能因为virtual base class数目的增长而增长。</li>
<li>继承体系发生纵向增长后，间接存取的层次也将提高，我们希望时间开销固定，不随着继承体系扩张而增长。</li>
</ol>
<p>第二个问题的解决方案是：拷贝所有的virtual base指针放在derived class object内部，保证一次间接访问即可获取data member，但这种方法增加了空间支出。</p>
<p>第一个问题有两种解决策略：</p>
<ol>
<li><strong>virtual base class table</strong><br>Microsoft编译器采纳此法，如果一个class object存在一个或多个virtual base class，即会由编译器生成一个指向virtual base class table的指针，该table内部存放着访问各个virtual base class的指针。</li>
<li><strong>在vbtl中放置virtual base class的offset</strong><br>其实现模型大致如下：<img src="http://static.zybuluo.com/zsmj2017/uv41z78c5sk81pb30zy84y42/image_1cdcqbki0avl6a816871u33f8g13.png" alt="image_1cdcqbki0avl6a816871u33f8g13.png-233.3kB"><br>vbtl由正值或负值来索引，正值则索引到virtual functions，负值则索引至virtual base class offsets。在该模型下，derived class实体与base class实体之间的转换操作如下所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point2d *p2d = pv3d;</span><br><span class="line"><span class="comment">//转换后的程序</span></span><br><span class="line">Point2d *p2d = pv3d? pv3d + pv3d-&gt;_vptr_Point3d[<span class="number">-1</span>]:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="最佳运用方式"><a href="#最佳运用方式" class="headerlink" title="最佳运用方式"></a>最佳运用方式</h3><p>一般而言，virtual base class最有效的一种运用方式是：一个抽象的virtual base class，没有任何data members（类似于Java的Interface）。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Function语义学——Virtual Member Function</title>
    <url>/2018/05/15/Function%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Virtual%20Member%20Function/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>我们已经初步了解了virtual function的实现原理：vtbl与vptr。在本节中，我们将根据一个实例，分析单一继承、多重继承、虚拟继承等各种情况，从细节上探究virtual function模型。</p>
<hr>
<h1 id="运行期类型判断"><a href="#运行期类型判断" class="headerlink" title="运行期类型判断"></a>运行期类型判断</h1><p>&nbsp;<br>为了完成virtual function机制，我们能够在执行期判断出当前pointer或reference的动态类型，如此才能找到并调用相应的函数实体。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>考虑下述语句：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr-&gt;z();</span><br></pre></td></tr></table></figure><br>最直接了当的做法就是把必要的信息加上ptr身上，如此一来，pointer或者reference至少包含两个信息：</p>
<ol>
<li>内容（它所指向的object的地址）</li>
<li>对象的动态类型</li>
</ol>
<p>这个方法有两个缺点：</p>
<ol>
<li>增加了空间负担，即使程序并不体现出多态性</li>
<li>破坏了与C的兼容性</li>
</ol>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>如果不能在pointer或erference中加入信息，那么势必只能在对象中添加信息。显然并非所有的对象都应该被加入信息，我们应该在“可能会运行期多态”的class中加入RTTI信息。识别一个class是否支持多态，只需要去看他是否具备任何virtual function即可。</p>
<hr>
<h1 id="单一继承下virtual-function的实现"><a href="#单一继承下virtual-function的实现" class="headerlink" title="单一继承下virtual function的实现"></a>单一继承下virtual function的实现</h1><p>&nbsp;<br>在明确了需要有信息插入class object之后，我们需要明确：哪些信息需要被插入class？仍以下述语句为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr-&gt;z();</span><br></pre></td></tr></table></figure><br>我们需要了解：</p>
<ol>
<li>ptr的动态类型，以方便调用正确的z()实体。</li>
<li>z()实体位置</li>
</ol>
<p>落实到具体实现，我们需要在每一个具备多态的class object身上增加两个members：</p>
<ol>
<li>一个用以表示动态类型的字符串或者数字</li>
<li>一个指向某个table的指针，该table内部存放着virtual functions的执行期地址</li>
</ol>
<p>上述工作均由编译器完成，执行期只是按图索骥而已。</p>
<p>一个class只会有一个vtbl，每一个vtbl内部含有所有virtual functions函数实体的地址，这些virtual functions包括：</p>
<ul>
<li>该class定义的函数实体，它可能会overriding一个可能存在的base class virtual function函数实体。</li>
<li>继承自base class的函数实体，这是在derived class不覆写时发生的情况。</li>
<li>一个pure_virtual_called函数实体，它既可以扮演pure virtual function的空间保卫者，也可以当做执行期异常处理函数。</li>
</ul>
<h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>考虑下述定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Point&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现有Point2d derived from Point:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>:</span><span class="keyword">public</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point2d&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>;<span class="comment">//override</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//override</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>并有Point3d derived from Point2d:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> Point2d&#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="function">Point2d&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>;<span class="comment">//override</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//override</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其具体的vtbl如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/9vsxcigr9ham7p8mc2l5y3w9/image_1cdha351o116i11o21cr67nojva9.png" alt="image_1cdha351o116i11o21cr67nojva9.png-369.9kB"><br>当一个class派生自另一个class，一共具备三种可能性：</p>
<ol>
<li><strong>继承声明与实现</strong><br>在该情况下virtual functions的地址将会被拷贝到derived class的vtbl中，且保持原有的slot。</li>
<li><strong>只继承声明</strong><br>此时函数实体的地址被置于对应的slot中。</li>
<li><strong>增加新的virtual function</strong><br>此时derived class的vtbl会被扩充，新的virtual function会对应于新的slot。</li>
</ol>
<p>当我们遇到<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr-&gt;z();</span><br></pre></td></tr></table></figure><br>如何完成运行期virtual function的调用呢？</p>
<ol>
<li>尽管我们并不了解ptr的动态类型，但我们了解其vptr的位置，并由vptr找到vtbl</li>
<li>尽管并不明确哪一个z()实体会被调用，但我们明确了解z()必然位于slot4</li>
</ol>
<p>因此，上述语句被转化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">4</span>])(ptr);</span><br></pre></td></tr></table></figure><br>尽管该语句的效果在执行期才能被确定（调用哪个z实体），但至少在编译期我们完成了正确的转化。</p>
<p>在单一继承体系中，virtual function运转良好，但在多继承和虚继承中实际情况却较为麻烦。</p>
<hr>
<h1 id="多重继承下的virtual-function"><a href="#多重继承下的virtual-function" class="headerlink" title="多重继承下的virtual function"></a>多重继承下的virtual function</h1><p>&nbsp;<br>多重继承下支持virtual function的难点在于后继base class，以及在执行期调整this指针。<br>以下述继承体系为例：<br><img src="http://static.zybuluo.com/zsmj2017/3k4rtxf4owdv3ldih5gi6rqj/image_1cdhf6elj1btn1ocfv1n19tgjucm.png" alt="image_1cdhf6elj1btn1ocfv1n19tgjucm.png-15.9kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speakClearly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base1 *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Base1;<span class="comment">//抽象工厂</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2();</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base2 *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Base2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>：<span class="title">public</span> <span class="title">Base1</span>,<span class="title">public</span> <span class="title">Base2</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">    <span class="keyword">virtual</span> ~Derived();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Derived;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>Derived支持virtual function的难点统统落在Base2 subobject上，其中大致有三个问题：</p>
<ol>
<li>virtual destructor</li>
<li>被继承的Base2::mumble()</li>
<li>一组clone()函数实体</li>
</ol>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先，我们将一个从heap中配置得到的Derived对象的地址指定给一个Base2指针：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br></pre></td></tr></table></figure><br>新的Derived对象的地址必须调整，以指向Base2 subobject。在编译期间会有如下代码产生：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived *temp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2* pbase2 = temp?temp+<span class="keyword">sizeof</span>(Base1):<span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>当开发者需要释放pbase2所指向的对象时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pbase2;</span><br></pre></td></tr></table></figure><br>指针必须被再一次调整，以指向Derived对象的起始处。但在这里我们并不能像绑定操作那样在编译期完成offset添加，因为我们只有在运行期才能明确对象的真正类型。</p>
<p>如果我们经由类型为后继base class的指针或者引用来调用virtual function，该调用所连带的this指针调整操作必须在执行期完成，也就是说，编译器所做的关于扩充代码的操作，必须在某个地方插入。关键问题便是在哪里插入。</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>cfront编译器的做法是将vtbl增大，使它容纳此处所需要的this指针。每一个virtual table slot不再是一个指针，而是一个struct，内含可能的offset以及地址。于是调用操作由：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*(pbase2-&gt;vptr[<span class="number">1</span>])(pbase2);</span><br></pre></td></tr></table></figure><br>转变为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*(pbase2-&gt;vptr[<span class="number">1</span>].faddr)(pbase2+pbase2-&gt;vptr[<span class="number">1</span>].offset)</span><br></pre></td></tr></table></figure><br>这方法的缺点是增加了间接性，无论是否需要offset都需要去执行上述语句，并且vtbl的大小也扩大了。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>比较有效率的解决方案是使用thunk。所谓thunk是一小段assembly码，用来完成以下两个任务：</p>
<ol>
<li>以适当的offset调整this指针</li>
<li>跳转至virtual function</li>
</ol>
<p>举例而言，经由一个Base2指针调用Derived destructor，其相关的thunk大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pbase2_dtor_thunk:</span><br><span class="line">    <span class="keyword">this</span>+=<span class="keyword">sizeof</span>(base1);</span><br><span class="line">    Derived::~Derived(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><br>thunk技术保证了vtbl继续内含一个简单的指针，因此多重继承不再需要任何空间上的额外负担。slots中的地址可以指向virtual function，也可以指向一个相关的thunk（如果需要调整this指针）。</p>
<p>调整this指针的第二个额外负担是，函数的调用由于两种不同的可能：</p>
<ol>
<li>经由derived class或第一base class调用</li>
<li>经由后继base class调用</li>
</ol>
<p>同一函数需要在vtbl中存放多笔对应的slots,例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base1* pbase1 = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2* pbase2 = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pbase1;</span><br><span class="line"><span class="keyword">delete</span> pbase2;</span><br></pre></td></tr></table></figure><br>虽然两个delete操作导致相同的derived destructor，但它们需要两个不同的vtbl slots：</p>
<ol>
<li>pbase1不需要调整this指针，其vtbl放置的是真正的destructor地址</li>
<li>pbase2需要调整指针，其vtbl slot需要放置相关的thunk地址。</li>
</ol>
<p>在多重继承下，一个derived class内含n-1个额外的vtbl，n表示上一层base classes的数目。对于实例中的Derived，它会有两个vtbl：</p>
<ol>
<li>一个主要实体，与Base1共享</li>
<li>一个次要实体，与Base2有关</li>
</ol>
<p>针对每一个vtbl，derived对象中有相应的vptr。具体内存结构如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/t692yspb77s1ta8evg4ysyzt/image_1cdhlsdfr1406v33m71ipd1pej13.png" alt="image_1cdhlsdfr1406v33m71ipd1pej13.png-379.6kB"></p>
<hr>
<h2 id="后继base-class对virtual-function的影响"><a href="#后继base-class对virtual-function的影响" class="headerlink" title="后继base class对virtual function的影响"></a>后继base class对virtual function的影响</h2><p>在三种情况下后继base class会影响对virtual function的支持：</p>
<ul>
<li><p><strong>通过指向后继base class的指针来调用derived virtual function</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//ptr必须向后调整sizeof(Base1)</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>
<p>显然，ptr初始情况下指向了base2 subobject，为了能够正确执行，ptr必须调整指向Derived对象的起始处。</p>
</li>
<li><p><strong>通过一个指向derived class的指针调用继承自后继base class的virtual function</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived *pder = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//pder必须向前调整sizeof(Base1)</span></span><br><span class="line">pder-&gt;mumble();</span><br></pre></td></tr></table></figure>
<p>此时，指针必须再次调整。</p>
</li>
<li><p>返回值不相同</p>
<p>具体来说就是clone的实现原理。</p>
</li>
</ul>
<hr>
<h1 id="虚继承下的virtual-functions"><a href="#虚继承下的virtual-functions" class="headerlink" title="虚继承下的virtual functions"></a>虚继承下的virtual functions</h1><p>&nbsp;<br>考虑下述继承体系：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~Point2d();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Point3d();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>Point3d和Point2d的起始部分并不和“非虚拟的单一继承”一致。由于Point2d和Point3d的对象不再相符，两者之间的转换也就需要调整this指针。它们的内存布局：<br><img src="http://static.zybuluo.com/zsmj2017/o41pbxhobsbgk79prj3jpwvl/image_1cdhu6f6t1uoo1qge1sc61avn1to1m.png" alt="image_1cdhu6f6t1uoo1qge1sc61avn1to1m.png-283.1kB"><br>（这个图似乎有点问题，右下角发生了错误）</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Function语义学——指向Member Function的指针</title>
    <url>/2018/05/16/Function%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E6%8C%87%E5%90%91Member%20Function%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在第三章中我们已经看出，取一个nonstatic data member的地址，得到的结果是该member在class布局中的bytes位置（+1）。我们可以想象它是一个不完整的值，必须依附于某个class object才可以完成存取。</p>
<hr>
<h1 id="Nostatic-Nonvirtual-Member-Function的指针"><a href="#Nostatic-Nonvirtual-Member-Function的指针" class="headerlink" title="Nostatic Nonvirtual Member Function的指针"></a>Nostatic Nonvirtual Member Function的指针</h1><p>&nbsp;<br>取一个nonstatic nonvirtual member function的地址，得到的是该函数在内存中真正的地址，但这个值也是不完全的，它也需要被绑定到某个class object的地址上才能调用该函数。所有nonstatic member function都需要对象的地址（以参数this指出）。</p>
<p>一个指向member function的指针其声明语法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>        <span class="comment">//return type</span></span><br><span class="line">( Point::*    <span class="comment">//class the function is member</span></span><br><span class="line">  pmf)        <span class="comment">//name of the pointer</span></span><br><span class="line">()            <span class="comment">//argument list</span></span><br></pre></td></tr></table></figure><br>member function指针使用如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> (Point::*coord)() = &amp;Point::x;<span class="comment">//定义、初始化</span></span><br><span class="line">coord = &amp;Point::y;<span class="comment">//赋值</span></span><br><span class="line">(origin.*coord)();<span class="comment">//调用 被编译器转为(coord)(&amp;origin)</span></span><br><span class="line">(ptr-&gt;*coord)();<span class="comment">//调用 被编译器转为(coord)(ptr)</span></span><br></pre></td></tr></table></figure></p>
<p>指向member function的指针的声明语法，以及指向“member selection运算符”的指针，其作用是作为this指针的空间保留者。这也是static member functions的类型是函数指针，而非“指向member function的指针”的原因。</p>
<p>我们可以认为，使用“指向member function的指针”，其成本并不高于使用一个“nonmember function指针”，这句话的前提是，当前并没有发生virtual function、多重继承、虚继承。</p>
<hr>
<h1 id="支持“指向Virtual-Member-Functions的指针”"><a href="#支持“指向Virtual-Member-Functions的指针”" class="headerlink" title="支持“指向Virtual Member Functions的指针”"></a>支持“指向Virtual Member Functions的指针”</h1><p>&nbsp;<br>考虑以下程序片段：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> (Point::*pmf)() = &amp;Point::z;</span><br><span class="line">Point *ptr = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure><br>显然，pmf指向了Point的一个member function，只不过这一次z()是一个virtual function。ptr指向了一个Point3d对象。<br>接下来我们执行调用操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr-&gt;z();<span class="comment">//正确地调用Point3d::z()</span></span><br><span class="line">(ptr-&gt;*pmf)();<span class="comment">//仍然具备正确性</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Poninter-to-virtual-Member-Function的实现"><a href="#Poninter-to-virtual-Member-Function的实现" class="headerlink" title="Poninter to virtual Member Function的实现"></a>Poninter to virtual Member Function的实现</h2><p>&nbsp;<br>在上文中我们已经明确，对一个nonstatic member function取址得到的是其在内存中的地址。但对于一个virtual function，其地址在编译期是未知的，我们所知道的只是virtual function在其相关vtbl中的索引值。因此，对一个virtual member function取址的时候，我们得到的是一个索引。</p>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>现有Point声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>现对各个member func分别取址：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp;Point::~Point();<span class="comment">//res==1;</span></span><br><span class="line">&amp;Point::x();<span class="comment">//内存中地址</span></span><br><span class="line">&amp;Point::y();<span class="comment">//内存中地址</span></span><br><span class="line">&amp;Point::z()<span class="comment">//res==2</span></span><br></pre></td></tr></table></figure><br>通过pmf来调用z()的话，编译器会将该调用语句转为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*ptr-&gt;vptr[(<span class="keyword">int</span>)pmf])(ptr);</span><br></pre></td></tr></table></figure><br>显然地，pmf需要有两种含义：</p>
<ol>
<li>内存地址</li>
<li>vtbl中的索引值</li>
</ol>
<p>关键在于我们应当如何区分它们。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在cfront编译器中，具体解决方案如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(((<span class="keyword">int</span>)pmf)&amp;~<span class="number">127</span>)?</span><br><span class="line">    (*pmf)(ptr):</span><br><span class="line">    (*ptr-&gt;vptr[(<span class="keyword">int</span>)pmf](ptr));</span><br></pre></td></tr></table></figure><br>这种设计策略要求继承体系中最多只能存在128个virtual functions。由于多重继承的导入，我们需要更一般化的实现方式，并趁机去除virtual functions的数目限制。</p>
<hr>
<h1 id="多重继承下，指向member-function的指针"><a href="#多重继承下，指向member-function的指针" class="headerlink" title="多重继承下，指向member function的指针"></a>多重继承下，指向member function的指针</h1><p>&nbsp;<br>为了保证支持多重继承与虚继承，cfront的作者设计了一个结构体：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">mptr</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        ptrtofunc faddr;</span><br><span class="line">        <span class="keyword">int</span> v_offset;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>index与faddr分别（不同时）带有vbtl索引与nonvirtual member function地址。在该模型下，调用操作<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br></pre></td></tr></table></figure><br>会变成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(pmf.index&lt;<span class="number">0</span>)</span><br><span class="line">    ?(*pmf.faddr)(ptr)<span class="comment">//non-virtual</span></span><br><span class="line">    :(*ptr-&gt;vptr[pmf.index](ptr));</span><br></pre></td></tr></table></figure><br>这种方法有两个缺点：</p>
<ol>
<li><strong>每一个调用操作都必须付出上述成本，检查其是否为virtual或non-virtual。</strong></li>
<li><strong>当传递一个不变值的指针给member function时，它需要产生一个临时对象。</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> Point3d <span class="title">foo</span><span class="params">(<span class="keyword">const</span> Point3d&amp;,Point3d(Point3d::*)())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">const</span> Point3d&amp; p)</span></span>&#123;</span><br><span class="line">    Point3d pt = foo(p,&amp;Point3d::normal);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
假设，&amp;Point3d::normal的值类似于：<code>{0,-1,10727417}</code>,那么将会产生一个具有明确初值的临时对象：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_mptr temp=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">10727417</span>&#125;;</span><br><span class="line">foo(p,temp);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在我们将目光再次拉回结构体。delta字段表示this指针的offset值，而v_offset字段存放的则是一个virtual base class的vptr位置。显然，如果vptr被置于class object的起始处，我们就可以不需要这个字段（当然这令我们丧失了与C语言的兼容性）。这些字段只有在多重继承或者虚拟继承的情况下才具备必要性。</p>
<hr>
<h1 id="“指向Member-Functions的指针”的效率"><a href="#“指向Member-Functions的指针”的效率" class="headerlink" title="“指向Member Functions的指针”的效率"></a>“指向Member Functions的指针”的效率</h1><p>&nbsp;<br>（下文详细测试了不同指针的读取效率。）</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Function语义学——导读</title>
    <url>/2018/05/14/Function%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<p>假设我们有一个Point3d的指针与对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d obj;</span><br><span class="line">Point3d *ptr = &amp;obj;</span><br></pre></td></tr></table></figure><br>当我们试图去调用其成员函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">obj.normalize();</span><br><span class="line">ptr-&gt;normalize();</span><br></pre></td></tr></table></figure><br>其中，Point::normalize()定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point3d <span class="title">Point3d::normalize</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> mag = magnitude();</span><br><span class="line">    Point3d normal;</span><br><span class="line">    normal._x=_x/mag;</span><br><span class="line">    normal._y=_y/mag;</span><br><span class="line">    normal._z=_z/mag;</span><br><span class="line">    <span class="keyword">return</span> normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而Point3d::magnitude()有定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Point3d::magnitude</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(_x*_x+_y*_y+_z*_z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在执行以上步骤时具体发生了什么？<br>答案是未知。C++支持三种类型的member functions:static、nonstatic、virtual，每一种类型被调用的方式都不相同，其具体差异将会在下一节详细描述。但在本节，我们尽管无法判断magnitude是否是virtual，但可以确定他一定不是static，有两个原因：</p>
<ol>
<li>直接存取nonstatic数据</li>
<li>被声明为const</li>
</ol>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Function语义学——函数的效能</title>
    <url>/2018/05/16/Function%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%9A%84%E6%95%88%E8%83%BD/</url>
    <content><![CDATA[<p>（本节讨论了三种函数在优化与未优化之后的结果，它们一般都被转化成为了nonmember形式，具备同样的效率）</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS环境gcc配置</title>
    <url>/2019/03/23/MacOS%E7%8E%AF%E5%A2%83%E4%B8%8Bgcc%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>macOS默认C++编译工具为clang，下文将具体描述如何将编译工具改为gcc7.4.0。(截至目前，笔者已更新至gcc8.3.0)</p>
<a id="more"></a>
<h1 id="安装gcc7"><a href="#安装gcc7" class="headerlink" title="安装gcc7"></a>安装gcc7</h1><p>&nbsp;<br>若读者已安装有<code>homebrew</code>，则可直接于终端输入：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install gcc7@</span><br></pre></td></tr></table></figure><br>下载完毕后gcc将位于<code>usr/local/Cellar/gcc@7/7.4.0/</code>,此时可将<code>gcc@7</code>文件夹重命名为<code>gcc</code>。<br>若读者尚未安装<code>homebrew</code>，可通过<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><br>完成对homebrew的安装。</p>
<h1 id="配置gcc7"><a href="#配置gcc7" class="headerlink" title="配置gcc7"></a>配置gcc7</h1><p>&nbsp;<br>在gcc下载完成后，需要完成环境变量配置。笔者以当前使用的<code>zsh</code>为例，shell为<code>bash</code>的用户将命令行中的<code>.zshrc</code>改为<code>.bashrc</code>即可。</p>
<h2 id="添加path"><a href="#添加path" class="headerlink" title="添加path"></a>添加path</h2><p>&nbsp;<br>在终端中输入<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><br>并于其中添加<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH="/usr/local/Cellar/gcc/7.4.0/bin:$PATH"</span><br></pre></td></tr></table></figure><br>此时path添加完毕。</p>
<h2 id="添加别名"><a href="#添加别名" class="headerlink" title="添加别名"></a>添加别名</h2><p>&nbsp;<br>在完成path添加后，只有在以<code>g++-7</code>与<code>gcc-7</code>时才使用gcc7.4.0，出于便捷的考虑，可于<code>.zshrc</code>内添加alias如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias g++='g++-7'</span><br><span class="line">alias gcc='gcc-7'</span><br></pre></td></tr></table></figure><br>完成添加后于终端输入<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><br>至此环境配置完毕，于终端输入<code>gcc -v</code>后，有输出如下所示：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc version 7.4.0 (Homebrew GCC 7.4.0)</span><br></pre></td></tr></table></figure></p>
<h2 id="更新动态库"><a href="#更新动态库" class="headerlink" title="更新动态库"></a>更新动态库</h2><p>&nbsp;<br>更进一步地，我们需要对动态库执行更新，在终端输入<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name "libstdc++*.dylib"</span><br></pre></td></tr></table></figure><br>可发现新动态库位置为<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/gcc/7.4.0/lib/gcc/7/libstdc++.6.dylib</span><br><span class="line">/usr/local/Cellar/gcc/7.4.0/lib/gcc/7/libstdc++.dylib</span><br></pre></td></tr></table></figure><br>此时可将其复制入<code>/usr/local/lib</code>下，切记不可关闭SIP后替换原本位于<code>/usr/lib</code>下的旧动态库，此操作将导致SIP再次开启后无法进入系统。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/lib</span><br><span class="line">cp /usr/local/Cellar/gcc/7.4.0/lib/gcc/7/libstdc++.6.dylib ./</span><br><span class="line">ln -s libstdc++.6.dylib libstdc++.lib</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2018/07/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>Lambda所做的一切都不具备创新性，相对于手工定义函数，它无非只是节约了大量的打字时间，但lambda的引入使得函数对象的创建更为便捷，在极大程度上影响了C++的日常开发。如果没有lambda，STL中的”_if”算法（例如std::find_if，std::remove_if，std::count_if等）只能与琐碎的谓词搭配使用，lambda使这些算法枯木逢春（某些需要自定义比较函数的算法亦是如此，例如std::sort,std::nth_element,std::lower_bound)。在STL之外，lambda可以为std::unique_ptr和std::shared_ptr快速创建自定义删除器(见Item18、19），并且它们使线程API中条件变量的谓词规范变得简单明了。</p>
<p>在开始本章之前，我们对lambda进行一个简单的复习：</p>
<ol>
<li><strong>lambda是一个表达式</strong>，当其应用于算法时，其形式大致如下所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::find_if(container.<span class="built_in">begin</span>(), container.<span class="built_in">end</span>(),</span><br><span class="line">             [](<span class="keyword">int</span> val) &#123; <span class="keyword">return</span> <span class="number">0</span> &lt; val &amp;&amp; val &lt; <span class="number">10</span>; &#125;);</span><br></pre></td></tr></table></figure></li>
<li><strong>闭包（closure）是一个由lambda创建的运行期对象。</strong><br>根据lambda捕获模式的不同，闭包保存捕获数据的副本或引用。在上文对std::find_if的调用中，闭包是运行期find_if所采纳的第三个参数。</li>
<li><strong>闭包类（closure class）是一个能够实例化闭包的类。</strong><br>每个lambda都会导致编译器生成一个唯一的闭包类，lambda中的语句成为其闭包类的成员函数中的可执行指令。</li>
</ol>
<p>一般而言，lambda用于创建仅用作函数参数的闭包，上文即是这种情况。但闭包具备拷贝性，所以可能会出现对于某些lambda闭包类型的多个闭包（这似乎很容易理解，因为lambda产生了闭包类）。例如在以下代码中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// x is local variable</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">auto</span> c1 = [x](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x * y &gt; <span class="number">55</span>; &#125;; <span class="comment">// c1 is copy of the closure produced by the lambda</span></span><br><span class="line">    <span class="keyword">auto</span> c2 = c1; <span class="comment">// c2 is copy of c1</span></span><br><span class="line">    <span class="keyword">auto</span> c3 = c2; <span class="comment">// c3 is copy of c2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>c1，c2和c3都是由lambda所生成的闭包的副本。</p>
<p>在非正式情况下，lambda，闭包和闭包类完全可以等而视之。但在随后的章节中，区分编译期间存在的内容（lambda和闭包类），运行时存在的内容（闭包）以及它们如何相互关联非常重要。</p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>17.Lazy evaluation</title>
    <url>/2018/04/26/Lazy%20evaluation/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>从效率的角度而言，最好的计算就是不计算。如果必须执行计算，我们可以拖到非计算不可的时候再计算。这种操作广泛适用于各个领域。</p>
<hr>
<h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span> ... &#125;;<span class="comment">//自定义string类</span></span><br><span class="line"><span class="keyword">String</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">String</span> s2 = s1;</span><br></pre></td></tr></table></figure>
<p>一般来说，s2被s1初始化后，s1与s2都有了自己的值，为了完成这个拷贝初始化，我们需要使用new来分配内存，需要调用strcpy函数拷贝数据等等，付出了极大的成本。但实际上此时的s2根本不需要执行拷贝操作，因为s2没被有被使用。</p>
<p>从lazy evaluation的角度而言，我们根本无需拷贝，只需要让s1与s2共享一个值即可。通过做一些记录以便了解哪些对象在共享哪些值，就省略了new与copy的开销。<br>当且仅当某个string被修改时，我们才需要执行真正的拷贝操作。例如当s2需要被修改，此时我们应该赶紧拷贝s1赋予s2，然后修改s2。</p>
<p>引用计数的具体实现机制见More Effective C++ 29，其核心原理就是lazy evaluation：<strong>除非你确实需要，否则不去为任何东西制作拷贝，能共享就共享。</strong></p>
<hr>
<h1 id="区分读写"><a href="#区分读写" class="headerlink" title="区分读写"></a>区分读写</h1><p>&nbsp;<br>仍以上文带有引用计数的string举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s = <span class="string">"Homer's Iliad"</span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[<span class="number">3</span>]; <span class="comment">//读取s[3]</span></span><br><span class="line">s[<span class="number">3</span>] = <span class="string">'x'</span>; <span class="comment">//写入s[3]</span></span><br></pre></td></tr></table></figure><br>读取并不会破坏共享性，但写入则需要对string值建立一个新拷贝。如果我们能够区分读取还是写入，在operator[]中采取不同的操作，那么效率必然会大幅度提升。但事实上我们不可能判断出调用operator[]是执行了读取还是写入，但可以配合More Effective C++ 30中的proxy class来推迟决定，直到我们了解当前是读取还是写入。</p>
<hr>
<h1 id="Lazy-Fetching"><a href="#Lazy-Fetching" class="headerlink" title="Lazy Fetching"></a>Lazy Fetching</h1><p>&nbsp;<br>假设当前程序使用了一些包含许多字段的大型对象，它们的生存期超越了程序运行期，所以它们必须被封存于数据库中，每一个对象都有一个唯一的标识符，以便于从数据库中重新获得对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LargeObject(ObjectID id);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">field1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">field2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">field3</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">field4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">field5</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果要从数据库中获取该对象，有常规方法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreAndProcessObject</span><span class="params">(ObjectID id)</span></span>&#123;</span><br><span class="line">    <span class="function">LargeObject <span class="title">object</span><span class="params">(id)</span></span>;<span class="comment">//构造对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，由于对象实例太大，数据库以及网络的开销也将花费巨大，如果你仅仅只需要某一部分的数据：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreAndProcessObject</span><span class="params">(ObjectID id)</span></span>&#123;</span><br><span class="line">    <span class="function">LargeObject <span class="title">object</span><span class="params">(id)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (object.field2() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object "</span> &lt;&lt; id &lt;&lt; <span class="string">": null field2.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我们只需要获取field2的值，获取其他的都是浪费，因此我们决定，<strong>当对象被建立时，不从数据库读取所有数据。建立的对象只是一个空壳，只有在需要某个数据时，该数据才从数据库中被读取</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LargeObject(ObjectID id);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">field1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">field2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">field3</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">field4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ObjectID oid;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">string</span> *field1Value;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> *field2Value;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">double</span> *field3Value;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">string</span> *field4Value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">LargeObject::LargeObject(ObjectID id)</span><br><span class="line">:oid(id), field1Value(<span class="literal">nullptr</span>), field2Value(<span class="literal">nullptr</span>), field3Value(<span class="literal">nullptr</span>), ...</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">LargeObject::field1</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field1Value == null) &#123;</span><br><span class="line">        ...<span class="comment">//从数据库中为filed 1读取数据，使field1Value 指向这个值;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *field1Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出，每一个成员在访问成员前检查对应的指针是否为空，如为空则进行读取操作。mutable的使用时因为我们可能会在一个const成员函数内修改数据。</p>
<hr>
<h1 id="Lazy-Expression-Evaulation"><a href="#Lazy-Expression-Evaulation" class="headerlink" title="Lazy Expression Evaulation"></a>Lazy Expression Evaulation</h1><p>&nbsp;<br>考虑如下的矩阵运算：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Matrix</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function">Matrix&lt;<span class="keyword">int</span>&gt; <span class="title">m1</span><span class="params">(<span class="number">1000</span>, <span class="number">1000</span>)</span></span>; <span class="comment">// 一个 1000 ＊ 1000 的矩阵</span></span><br><span class="line"><span class="function">Matrix&lt;<span class="keyword">int</span>&gt; <span class="title">m2</span><span class="params">(<span class="number">1000</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">Matrix&lt;<span class="keyword">int</span>&gt; m3 = m1 + m2; <span class="comment">// m1＋m2</span></span><br></pre></td></tr></table></figure><br>显然，eager evaluation差不多会执行1000000次加法。这并不为我们的lazy精神所提倡。<br>lazy evaluation认为应该建立一个数据结构表示m3的值是m1与m2发生交互的结果，再用一个enum表示矩阵间执行加法操作。如果接下来又有<code>m4=m3*m1</code>，那么同样地，我们会记录m4是m3与m1发生交互的结果，用一个enum表示乘法。<br>看起来以上操作并无用处，因为很少有人会列出表达式但不要求计算。但是事实上在很多情况下我们只需要计算矩阵的某一个元素或者某一列，因此我们完全没有理由计算出全部，每一次计算都仅仅针对被需求了解的未知量，剩余的部分将保持未计算的状态，直到确实需要它们。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>如果确实所有的任务都必须完成，那么lazy本质上并没有降低工作量，甚至还增加了内存使用与维护成本。从本质来说，它在当前只做关键的，需要使用的计算，仅此而已。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（10）</title>
    <url>/2018/08/09/OJ%20exercise10/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Valid Palindrome(Leetcode #125)</li>
<li>Implement strStr(Leetcode #28)</li>
<li>String to Integer(Leetcode #8)</li>
<li>Add Binary(Leetcode #67)</li>
<li>Longest Palindrome(Leetcode #409)</li>
<li>二叉搜索树的后续遍历序列（剑指offer #33）</li>
<li>二叉树中和为某一值的路径（剑指offer #34）</li>
<li>复杂链表的复制（剑指offer #35)</li>
<li>二叉搜索树与双向链表（剑指offer #36)</li>
<li>字符串的排列（剑指offer #37)</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Valid-Palindrome-Leetcode-125"><a href="#Valid-Palindrome-Leetcode-125" class="headerlink" title="Valid Palindrome(Leetcode #125)"></a>Valid Palindrome(Leetcode #125)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.<br><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针解题，避开所有无效字符后对二者进行比对。若匹配则执行下一轮，否则退出。这里注意isalnum的使用。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;++i,--j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isalnum</span>(s[i]) == <span class="literal">false</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">		    <span class="keyword">while</span> (<span class="built_in">isalnum</span>(s[j]) == <span class="literal">false</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">		    <span class="keyword">if</span> (<span class="built_in">toupper</span>(s[i]) != <span class="built_in">toupper</span>(s[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Implement-strStr-Leetcode-28"><a href="#Implement-strStr-Leetcode-28" class="headerlink" title="Implement strStr(Leetcode #28)"></a>Implement strStr(Leetcode #28)</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Implement strStr().Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.<br><strong>Example :</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>本身使用暴力是很容易的，我们在暴力的基础上升级为KMP算法。</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="暴力-不匹配则回退，i-j为返回值）"><a href="#暴力-不匹配则回退，i-j为返回值）" class="headerlink" title="暴力(不匹配则回退，i-j为返回值）"></a>暴力(不匹配则回退，i-j为返回值）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=haystack.<span class="built_in">size</span>(),m=needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=n &amp;&amp; j!=m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j])</span><br><span class="line">                ++i,++j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i-=j<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (i-j&gt;n-m)?<span class="number">-1</span>:i-j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="KMP-非常好记忆，是模式串的自匹配，只是在字符类型较多时效率未必高）"><a href="#KMP-非常好记忆，是模式串的自匹配，只是在字符类型较多时效率未必高）" class="headerlink" title="KMP(非常好记忆，是模式串的自匹配，只是在字符类型较多时效率未必高）"></a>KMP(非常好记忆，是模式串的自匹配，只是在字符类型较多时效率未必高）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">size</span>()==<span class="number">0</span> ) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">size</span>()&gt;haystack.<span class="built_in">size</span>()) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next=nextTable(needle);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,n=haystack.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,m=needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;m )&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span> || haystack[i]==needle[j]) </span><br><span class="line">                ++i,++j;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (i-j&gt;n-m)?<span class="number">-1</span>:i-j;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextTable</span><span class="params">(<span class="built_in">string</span> needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,m=needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(m,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t&lt;<span class="number">0</span> || needle[j]==needle[t])&#123;</span><br><span class="line">                ++j,++t;</span><br><span class="line">                next[j]=(needle[j]!=needle[t])?t:next[t];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t=next[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="String-to-Integer-Leetcode-8"><a href="#String-to-Integer-Leetcode-8" class="headerlink" title="String to Integer(Leetcode #8)"></a>String to Integer(Leetcode #8)</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Implement atoi which converts a string to an integer.</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用find_first_of找到第一个不为空的字符，然后判断其是否为+-，若是则设定正负。然后遍历字符串，利用isDigit作为while退出条件。若退出时字符串尚未结束则说明当前存在非法字符。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> base=<span class="number">0</span>,sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = str.find_first_not_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>||str[i]==<span class="string">'-'</span>)</span><br><span class="line">            sign=str[i++]==<span class="string">'+'</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[i]))&#123;</span><br><span class="line">            base=base*<span class="number">10</span>+str[i++]-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=str.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> base*sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Add-Binary-Leetcode-67"><a href="#Add-Binary-Leetcode-67" class="headerlink" title="Add Binary(Leetcode #67)"></a>Add Binary(Leetcode #67)</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given two binary strings, return their sum (also a binary string).The input strings are both non-empty and contains only characters 1 or 0.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>非常类似于之前做的高精度加法或者链表求和,与链表不同的是，我们这里利用str的operator+，将每一次的结果添加于res之后，最终翻转res。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.<span class="built_in">size</span>(), n = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> sum = (a[i--] - <span class="string">'0'</span>) + (b[j--] - <span class="string">'0'</span>) + c;</span><br><span class="line">            res += (<span class="string">'0'</span> + (sum % <span class="number">2</span>));</span><br><span class="line">            carry = (sum &gt;= <span class="number">2</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> sum = (a[i--] - <span class="string">'0'</span>) + c;</span><br><span class="line">            res += (<span class="string">'0'</span> + (sum % <span class="number">2</span>));</span><br><span class="line">            carry = (sum &gt;= <span class="number">2</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> sum = (b[j--] - <span class="string">'0'</span>) + c;</span><br><span class="line">            res += (<span class="string">'0'</span> + (sum % <span class="number">2</span>));</span><br><span class="line">            carry = (sum &gt;= <span class="number">2</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            res += <span class="string">'1'</span>;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Longest-Palindrome-Leetcode-409"><a href="#Longest-Palindrome-Leetcode-409" class="headerlink" title="Longest Palindrome(Leetcode #409)"></a>Longest Palindrome(Leetcode #409)</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.This is case sensitive, for example “Aa” is not considered a palindrome here.<br><strong>Note:</strong><br>Assume the length of given string will not exceed 1,010.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>若某个字母存在奇数次，则我们可以认为最大长度必须要减1，否则不必减1。我们将针对每一个字符遍历依次字符串，尽管遍历需要O（n)的时间，但由于字符种类已知，总开销依然是O（n）。此外，如果存在奇数，返回的结果是size-odds+1，原因在于单独的那一个可以放在最中间。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> odds=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'A'</span>;c&lt;=<span class="string">'z'</span>;++c)</span><br><span class="line">            odds+=count(s.cbegin(),s.cend(),c)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>()-odds+(odds&gt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Longest-Palindromic-Subsequence）"><a href="#扩展（Longest-Palindromic-Subsequence）" class="headerlink" title="扩展（Longest Palindromic Subsequence）"></a>扩展（Longest Palindromic Subsequence）</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line">One possible longest palindromic subsequence is &quot;bbbb&quot;.</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题与上一题不同的地方在于规定了必须是subsequence。本题使用动态规划求解较为方便。设dp[i][j]为字符str[i]、str[j]之间形成的子串所能构建的最长回文串，那么对于dp，存在状态转移方程为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if str[i]&#x3D;&#x3D;str[j] dp[i][j]&#x3D;dp[i+1][j-1]+2;</span><br><span class="line">else dp[i][j]&#x3D;max(dp[i+1][j],dp[i][j-1]);</span><br><span class="line">dp[i][i]&#x3D;1;</span><br></pre></td></tr></table></figure></p>
<h3 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v:dp)</span><br><span class="line">            v.resize(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =s.<span class="built_in">size</span>()<span class="number">-1</span>;i!=<span class="number">-1</span>;--i)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j!=s.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Longest-Palindromic-Substring）"><a href="#扩展（Longest-Palindromic-Substring）" class="headerlink" title="扩展（Longest Palindromic Substring）"></a>扩展（Longest Palindromic Substring）</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>两种做法。</p>
<ol>
<li>若str存在n个元素，那么应当有2n-1个作为回文字符串中点的位置。我们遍历这些中点，求解这些中点所能形成的回文子串的最大长度。最后得到最终的中点及最大长度，使用substr。</li>
<li>动态规划，dp[i][j]表示str[i]到str[j]形成的子串是否为回文串。有状态转移方程为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(j&#x3D;&#x3D;i+1 &amp;&amp; str[i]&#x3D;&#x3D;str[j]) dp[i][j]&#x3D;1;</span><br><span class="line">while(j&gt;i+1) dp[i][j]&#x3D;(str[i]&#x3D;&#x3D;str[j] &amp;&amp; dp[i+1][j-1])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h3><h4 id="扩张法"><a href="#扩张法" class="headerlink" title="扩张法"></a>扩张法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Expand around center</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">max</span>(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxlen) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                maxlen = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxlen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left, ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//use DP</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j] =(j==i+<span class="number">1</span>)?<span class="number">1</span>: dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxlen) &#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>递归式求解。首先找到数组的末尾元素，其必为根节点。然后向前找到第一个不大于根的元素，其必为左子树根节点。若左子树中存在大于根节点的元素则返回false，否则再次判断左右子树是否具备二叉搜索性质。</p>
<h2 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> aux(v,<span class="number">0</span>,v.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">aux</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;=e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> lr=e<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lr&gt;=b &amp;&amp; v[lr]&gt;v[e]) lr--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = b;i&lt;=lr;++i)</span><br><span class="line">            <span class="keyword">if</span>(v[i]&gt;v[e]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> aux(v,b,lr) &amp;&amp; aux(v,lr+<span class="number">1</span>,e<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>朴素深搜,值得注意的是某个节点检查完毕后需要pop_back。</p>
<h2 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">FindPath</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">        aux(root,sum,cur,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeNode* root,<span class="keyword">int</span> gap,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cur,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cur.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val==gap)</span><br><span class="line">                res.push_back(cur);</span><br><span class="line">        aux(root-&gt;left,gap-root-&gt;val,cur,res);</span><br><span class="line">        aux(root-&gt;right,gap-root-&gt;val,cur,res);</span><br><span class="line">        cur.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="复杂链表的复制（剑指offer-35"><a href="#复杂链表的复制（剑指offer-35" class="headerlink" title="复杂链表的复制（剑指offer #35)"></a>复杂链表的复制（剑指offer #35)</h1><p>（在OJ exercise8中已经介绍）</p>
<hr>
<h1 id="二叉搜索树与双向链表（剑指offer-36"><a href="#二叉搜索树与双向链表（剑指offer-36" class="headerlink" title="二叉搜索树与双向链表（剑指offer #36)"></a>二叉搜索树与双向链表（剑指offer #36)</h1><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>递归式地连接。先将左子树构造为双链表，然后连接左子与根节点，然后再将右子树构造为双链表。最终连接完毕，返回根节点，一路向左找到头即可。</p>
<h2 id="解题方案-9"><a href="#解题方案-9" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        aux(root,pre);</span><br><span class="line">        TreeNode* res = root;</span><br><span class="line">        <span class="keyword">while</span>(res-&gt;left)</span><br><span class="line">            res=res-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeNode* cur,TreeNode* &amp;pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        aux(cur-&gt;left,pre);</span><br><span class="line">        cur-&gt;left=pre;</span><br><span class="line">        <span class="keyword">if</span>(pre)</span><br><span class="line">            pre-&gt;right=cur;</span><br><span class="line">        pre=cur;</span><br><span class="line">        aux(cur-&gt;right,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>递归式的解法，需要注意的式aux的string参数并非引用，因此每一次都需要复制，如果采用引用，则需要在aux的最后一行将str复原。（本解法针对重复元素亦有效）</p>
<h2 id="解题方案-10"><a href="#解题方案-10" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        sort(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        aux(str,<span class="number">0</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> beg,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beg&gt;=str.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=beg;i!=str.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;beg &amp;&amp; str[beg]==str[i]) <span class="keyword">continue</span>;</span><br><span class="line">            swap(str[i],str[beg]);</span><br><span class="line">            aux(str,beg+<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（1）</title>
    <url>/2018/07/31/OJ%20exercise1/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Remove Duplicates from Sorted Array（Leetcode #26)</li>
<li>Remove Duplicates from Sorted ArrayⅡ ( Leetcode #80)</li>
<li>数组中重复的数字（剑指offer #3）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Remove-Duplicates-from-Sorted-Array（Leetcode-26"><a href="#Remove-Duplicates-from-Sorted-Array（Leetcode-26" class="headerlink" title="Remove Duplicates from Sorted Array（Leetcode #26)"></a>Remove Duplicates from Sorted Array（Leetcode #26)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>数组的常规删除操作需要耗费线性时间，显然效率过低，考虑到有序数组的特殊性，我们只需要遍历数组，将每一个不同前一个元素的元素置于新数组对应位置即可。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="方案一：直接使用STL"><a href="#方案一：直接使用STL" class="headerlink" title="方案一：直接使用STL"></a>方案一：直接使用STL</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.<span class="built_in">begin</span>(),unqiue(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方案二-手动实现"><a href="#方案二-手动实现" class="headerlink" title="方案二:手动实现"></a>方案二:手动实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span> || nums.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">size_t</span> newsize=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> index=<span class="number">1</span>;index!=nums.<span class="built_in">size</span>();++index)</span><br><span class="line">            <span class="keyword">if</span>(nums[index]!=nums[index<span class="number">-1</span>])</span><br><span class="line">                nums[newsize++]=nums[index];</span><br><span class="line">        <span class="keyword">return</span> newsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Remove-Duplicates-from-Sorted-ArrayⅡ-Leetcode-80"><a href="#Remove-Duplicates-from-Sorted-ArrayⅡ-Leetcode-80" class="headerlink" title="Remove Duplicates from Sorted ArrayⅡ ( Leetcode #80)"></a>Remove Duplicates from Sorted ArrayⅡ ( Leetcode #80)</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most k times and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题是上一题的变体，其要点在于当前数组内允许元素至多重复k次。解题思路十分明了：在上一题中我们采用的是每一个元素与前一个元素比较的策略，本题则改为：首先将nums[k]与nums[0]相比较,如果不相同,更新数组大小与被比对象，相同则不执行更新。</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=k)</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">size_t</span> newsize=k;</span><br><span class="line">        <span class="keyword">size_t</span> compareIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> index=k;index!=nums.<span class="built_in">size</span>();++index)</span><br><span class="line">            <span class="keyword">if</span>(nums[index]!=nums[compareIndex])</span><br><span class="line">                nums[newsize++]=nums[index],++compareIndex;</span><br><span class="line">        <span class="keyword">return</span> newsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数组中重复的数字（剑指offer-3"><a href="#数组中重复的数字（剑指offer-3" class="headerlink" title="数组中重复的数字（剑指offer #3)"></a>数组中重复的数字（剑指offer #3)</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组中存储着值分布在[0,n)区间的元素，试找出某个重复元素。</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于值的区间已知且线性正比于规模，使用数组存储元素出现的次数是一种十分显然的解法，但其空间成本太高。我们只需要找出元素是否重复，并不需要了解其重复次数，因此可将原有数组改造，令下标与值一一对应，若某个值出现在多个下标对应的内存位置上，则该值重复。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> index =<span class="number">0</span>;index!=nums.<span class="built_in">size</span>();++index)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[index]!=index)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[index]==nums[nums[index]])</span><br><span class="line">                    <span class="keyword">return</span> nums[index];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    swap(nums[index],nums[nums[index]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>若当前数组长度为n，数值区间为[1,n）,试以不破坏原始数组的就地算法找出某一个重复元素。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>分治策略：设m为区间[1,n）中间数，若[1，m]在数组中出现的次数大于m，则[1，m]中必然存在重复元素，再次执行分治求解。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">size_t</span> high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">size_t</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=mid) ++count;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;=mid)</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（11）</title>
    <url>/2018/08/10/OJ%20exercise11/</url>
    <content><![CDATA[<p>（今天被JSON解析器的bug拖住了，OJ只刷剑指offer）</p>
<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>序列化二叉树（剑指offer #37）</li>
<li>数组中出现超过一半的数字（剑指offer #39）</li>
<li>最小的k个数（剑指offer #40)</li>
<li>数据流的中位数（剑指offer #41)</li>
<li>连续子数组的最大和（剑指offer #42)</li>
<li>1~n整数中1出现的次数（剑指offer #43）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="序列化二叉树（剑指offer-37）"><a href="#序列化二叉树（剑指offer-37）" class="headerlink" title="序列化二叉树（剑指offer #37）"></a>序列化二叉树（剑指offer #37）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>前序遍历，遇到根节点后将其转为字符。接着处理左右子树。反序列化则解析出节点后作为根，然后递归解析左右子树。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        aux_s(root,str);</span><br><span class="line">        <span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(res,str.c_str());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!str)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* res = aux_d(str);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux_s</span><span class="params">(TreeNode* root,<span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            str+=<span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> r = to_string(root-&gt;val);</span><br><span class="line">        str+=r;</span><br><span class="line">        str+=<span class="string">','</span>;</span><br><span class="line">        aux_s(root-&gt;left,str);</span><br><span class="line">        aux_s(root-&gt;right,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">aux_d</span><span class="params">(<span class="keyword">char</span>* &amp;str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'#'</span>)&#123;</span><br><span class="line">            ++str;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*str!=<span class="string">'\0'</span> &amp;&amp; *str!=<span class="string">','</span>)&#123;</span><br><span class="line">            num=num*<span class="number">10</span>+(*str-<span class="string">'0'</span>);</span><br><span class="line">            ++str;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++str;</span><br><span class="line">        root-&gt;left=aux_d(str);</span><br><span class="line">        root-&gt;right=aux_d(str);</span><br><span class="line">        <span class="keyword">return</span> root;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数组中超过一半的数字"><a href="#数组中超过一半的数字" class="headerlink" title="数组中超过一半的数字"></a>数组中超过一半的数字</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>排序后超过一半的数字必然是中位数，我们只需要判断中位数出现的次数是否大于一半即可，但这需要O（nlogn）。不妨采取攻防策略：初始化count为0，遇到一个数后将它认为是目标值。若后续出现了不同的则减1，相同的则加1.若count==0，将则认为目标值是下一个元素，并再将其置1.最后判定目标值是否正确。只需要两次遍历，时间为O（n)。</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(numbers.empty())</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res=numbers[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=numbers.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">           <span class="keyword">if</span>(numbers[i]==res) ++count;</span><br><span class="line">           <span class="keyword">else</span> --count;</span><br><span class="line">           <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">               res=numbers[i];</span><br><span class="line">               count=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> i:numbers)</span><br><span class="line">           <span class="keyword">if</span>(i==res) ++count;</span><br><span class="line">       <span class="keyword">if</span>(count&gt;numbers.<span class="built_in">size</span>()/<span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>考察STL中partial_sort的实现，采用大顶堆即可。值得注意的是对于heap_algo需要熟练，先pop_heap再pop_back。进入时先push_back再push_heap。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.empty() || k&gt;a.<span class="built_in">size</span>() || k&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(a.cbegin(),a.cbegin()+k)</span></span>;</span><br><span class="line">        make_heap(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i!=a.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;res[<span class="number">0</span>])&#123;</span><br><span class="line">                pop_heap(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">                res.pop_back();</span><br><span class="line">                res.push_back(a[i]);</span><br><span class="line">                push_heap(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort_heap(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数据流中位数"><a href="#数据流中位数" class="headerlink" title="数据流中位数"></a>数据流中位数</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题有点类似于之前做的两个数组的中位数，但有所不同。这道题的核心思想在于使用一个大顶堆和一个小顶堆，保证大堆中的元素比小堆中的元素都要小，则中位数必然在两个堆顶元素中。在执行插入操作时，仅在当前元素小于大顶堆首或大顶堆为空时插入大顶堆，否则默认插入小顶堆。若大顶堆元素个数超出小顶堆两个，将其top push进入小顶堆。若小顶堆元素超过大顶堆一个，则将其top push进入大顶堆。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty()||num&lt;p.top()) p.push(num);</span><br><span class="line">        <span class="keyword">else</span> q.push(num);</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">size</span>()==q.<span class="built_in">size</span>()+<span class="number">2</span>) q.push(p.top()),p.pop();</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">size</span>()+<span class="number">1</span>==q.<span class="built_in">size</span>()) p.push(q.top()),q.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">size</span>()==q.<span class="built_in">size</span>()?(p.top()+q.top())/<span class="number">2.0</span>:p.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;p;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最大的连续子序列和"><a href="#最大的连续子序列和" class="headerlink" title="最大的连续子序列和"></a>最大的连续子序列和</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>一维动态规划,f代表当前连续序列和。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MIN,f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">            f=<span class="built_in">max</span>(f+nums[i],nums[i]),res=<span class="built_in">max</span>(res,f);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a>1~n整数中1出现的次数</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据数位判断个数，具体的思路可见 <a href="https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6</a> 大牛<code>咩咩</code>提出的方案。（核心就是判断i这一位是大于等于2，还是等于1）</p>
<h2 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a=n/i,b=n%i;</span><br><span class="line">            count += (a+<span class="number">8</span>)/<span class="number">10</span>*i+(a%<span class="number">10</span>==<span class="number">1</span>)*(b+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（12）</title>
    <url>/2018/08/13/OJ%20exercise12/</url>
    <content><![CDATA[<p>（周末两天均在完善Json解析器与生成器，现如今可以腾出手来刷题）</p>
<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>数字序列中某一位的数（剑指offer #44）</li>
<li>把数组排成最小的数（剑指offer #45）</li>
<li>把数字翻译成字符串（剑指offer #46)</li>
<li>礼物的最大价值（剑指offer #47)</li>
<li>最长不含重复字符的子字符串（剑指offer #48)</li>
<li>丑数（剑指offer #49）</li>
<li>第一个只出现一次的字符（剑指offer #50）</li>
<li>数组中的逆序对（剑指offer #51）</li>
<li>两个链表的第一个公共节点（剑指offer #52）</li>
<li>在排序数组中查找数字（剑指offer #53）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="数字序列中某一位的数（剑指offer-44）"><a href="#数字序列中某一位的数（剑指offer-44）" class="headerlink" title="数字序列中某一位的数（剑指offer #44）"></a>数字序列中某一位的数（剑指offer #44）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>寻找规律，首先明确当前输入在哪一个区段，然后根据偏移量完成求解。这道题毫无难点，就是写起来很不舒服。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">	    <span class="keyword">int</span> digitNum = <span class="number">1</span>, numberNum = <span class="number">9</span>, start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(numberNum &lt; n/digitNum)&#123;</span><br><span class="line">            n -= digitNum * numberNum;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digitNum += <span class="number">1</span>;</span><br><span class="line">            numberNum *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nthDigit  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%digitNum == <span class="number">0</span>)&#123;</span><br><span class="line">            nthDigit = (start + n/digitNum<span class="number">-1</span>) % <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nthNumber = (start + n/digitNum);</span><br><span class="line">            nthDigit = to_string(nthNumber)[n%digitNum<span class="number">-1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nthDigit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="把数组排成最小的数（剑指offer-45）"><a href="#把数组排成最小的数（剑指offer-45）" class="headerlink" title="把数组排成最小的数（剑指offer #45）"></a>把数组排成最小的数（剑指offer #45）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题的难点在于排序规律，而非组合。我们完全可以将所有数字变为字符串存入vector中，然后利用C++ STL 接收谓词作为排序规则的特性对该vector排序（排序规则为<code>s1+s2&lt;s2+s1</code>），最终将vector转为string即可。</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ns;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:numbers)</span><br><span class="line">            ns.push_back(to_string(i));</span><br><span class="line">        sort(ns.<span class="built_in">begin</span>(),ns.<span class="built_in">end</span>(),[](<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)&#123;<span class="keyword">return</span> s1+s2&lt;s2+s1;&#125;);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:ns)</span><br><span class="line">            res+=s;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="把数字翻译成字符串（剑指offer-46"><a href="#把数字翻译成字符串（剑指offer-46" class="headerlink" title="把数字翻译成字符串（剑指offer #46)"></a>把数字翻译成字符串（剑指offer #46)</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划问题，dp[i]=f[i]*dp[i-1]+g[i]*dp[i-2]。其中dp[i]为前i个字符所能构成的组合数。f[i]表征s[i-1]为数字且不为0，g[i]表征s[i-1]是否能与前一个字符构成组合。需要注意的是‘0‘略微繁琐，这是一道细节题。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(s.length()==<span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">1</span>,dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]&gt;=<span class="string">'1'</span> &amp;&amp; s[i<span class="number">-1</span>]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                dp[i] += dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-2</span>]==<span class="string">'1'</span> || (s[i<span class="number">-2</span>]==<span class="string">'2'</span> &amp;&amp; s[i<span class="number">-1</span>]&gt;=<span class="string">'0'</span> &amp;&amp; s[i<span class="number">-1</span>]&lt;=<span class="string">'6'</span>))</span><br><span class="line">                dp[i] += dp[i<span class="number">-2</span>];           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>这又是一道典型的动态规划。但有所区别的是，这道题没必要设立m*n的矩阵来保存临时值。由于到达坐标(i,j)的格子时能够拿到的礼物的最大价值只依赖坐标为(i-1,j)与(i,j-1）的格子，因此只需要使用一个长度为n的一维数组即可，数组中前j个数字为f(i,0)直到f(i,j)，后面的则为f(i-1,j)直到f(i-1,n-1)。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.empty()||v[<span class="number">0</span>].empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(v[<span class="number">0</span>].<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=v.<span class="built_in">size</span>();++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">0</span>;j!=v[<span class="number">0</span>].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> up = i==<span class="number">0</span>?<span class="number">0</span>:dp[j];</span><br><span class="line">                <span class="keyword">int</span> left = j==<span class="number">0</span>?<span class="number">0</span>:dp[j<span class="number">-1</span>];</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(up,left)+v[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最长不含重复字符的子字符串（剑指offer-48"><a href="#最长不含重复字符的子字符串（剑指offer-48" class="headerlink" title="最长不含重复字符的子字符串（剑指offer #48)"></a>最长不含重复字符的子字符串（剑指offer #48)</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题没必要使用动规。假设子串里含有重复字符，则父串必含有重复字符，单个子问题足以决定父问题，因此可以使用贪心。在动规中，单个子问题影响父问题，并不足以决定父问题。</p>
<p>从左向右扫描，当遇到重复字母时，以上一个重复字母的index+1作为搜索起始位置，复杂度为O（n）。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">map</span><span class="params">(<span class="number">256</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> slow=<span class="number">0</span>,fast=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(fast=<span class="number">0</span>;fast&lt;s.<span class="built_in">size</span>();++fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[fast]]&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">                maxlen=<span class="built_in">max</span>(maxlen,fast-slow);</span><br><span class="line">                slow=<span class="built_in">max</span>(<span class="built_in">map</span>[s[fast]]+<span class="number">1</span>,slow);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[s[fast]]=fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxlen,fast-slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="丑数（剑指offer-49）"><a href="#丑数（剑指offer-49）" class="headerlink" title="丑数（剑指offer #49）"></a>丑数（剑指offer #49）</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>将之前所有的丑数全部存储起来，并且额外保存factor2、3、5作为当前的丑数因子。若当前factorn为最小，则更新其为n*ugly[++indexn];</p>
<h2 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ugly</span><span class="params">(n)</span></span>;</span><br><span class="line">        ugly[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2=<span class="number">0</span>,index3=<span class="number">0</span>,index5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> factor2=<span class="number">2</span>,factor3=<span class="number">3</span>,factor5=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> minf =<span class="built_in">min</span>(<span class="built_in">min</span>(factor2,factor3),factor5);</span><br><span class="line">            ugly[i]=minf;</span><br><span class="line">            <span class="keyword">if</span>(factor2==minf)</span><br><span class="line">                factor2=<span class="number">2</span>*ugly[++index2];</span><br><span class="line">            <span class="keyword">if</span>(factor3==minf)</span><br><span class="line">                factor3=<span class="number">3</span>*ugly[++index3];</span><br><span class="line">            <span class="keyword">if</span>(factor5==minf)</span><br><span class="line">                factor5=<span class="number">5</span>*ugly[++index5];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="第一个只出现一次的字符（剑指offer-50）"><a href="#第一个只出现一次的字符（剑指offer-50）" class="headerlink" title="第一个只出现一次的字符（剑指offer #50）"></a>第一个只出现一次的字符（剑指offer #50）</h1><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一个hashtable保存字符出现的次数，然后遍历字符串找到这个字符即可。</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:str)</span><br><span class="line">            res[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=str.<span class="built_in">size</span>();++i)</span><br><span class="line">            <span class="keyword">if</span>(res[str[i]]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>采用归并排序的策略，其中递归基是beg==end。需要注意的地方在于，若前一半的元素i大于后一半的元素j，则此时存在逆序对的个数为后一般数组剩余元素数，此外，每一次计算后都需要对原有数组完成排序。</p>
<h2 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">copy</span><span class="params">(data.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = aux(data,copy,<span class="number">0</span>,data.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">aux</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; copy,<span class="keyword">int</span> beg,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beg==<span class="built_in">end</span>)&#123;</span><br><span class="line">            copy[beg]=data[beg];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = beg+(<span class="built_in">end</span>-beg)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left = aux(data,copy,beg,mid)%<span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span> right = aux(data,copy,mid+<span class="number">1</span>,<span class="built_in">end</span>)%<span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span> i=mid;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=beg &amp;&amp; j&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;data[j])&#123;</span><br><span class="line">                copy[index--]=data[i--];</span><br><span class="line">                count+=j-mid;</span><br><span class="line">                count%=<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                copy[index--]=data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=beg) copy[index--]=data[i--];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=mid+<span class="number">1</span>) copy[index--]=data[j--];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=beg; i&lt;=<span class="built_in">end</span>; i++) data[i] = copy[i];</span><br><span class="line">        <span class="keyword">return</span> (count+left+right)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="两个链表的第一个公共节点（剑指offer-52）"><a href="#两个链表的第一个公共节点（剑指offer-52）" class="headerlink" title="两个链表的第一个公共节点（剑指offer #52）"></a>两个链表的第一个公共节点（剑指offer #52）</h1><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>假定两个链表长度为a+n与b+n，n为共有部分，那么两个链表一起走a+b+n步后必然相遇，相遇点为第一个共同点或nullptr（n==0）。具体实现就是一旦走到绝地就转向别人的头部。</p>
<h2 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head1, *q = head2;</span><br><span class="line">        <span class="keyword">while</span>(p!=q)&#123;</span><br><span class="line">            p=p?p-&gt;next:head2;</span><br><span class="line">            q=q?q-&gt;next:head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="在排序数组中查找数字（剑指offer-53）"><a href="#在排序数组中查找数字（剑指offer-53）" class="headerlink" title="在排序数组中查找数字（剑指offer #53）"></a>在排序数组中查找数字（剑指offer #53）</h1><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>本质上就是实现STL算法：equal_range;</p>
<h2 id="解题方案-9"><a href="#解题方案-9" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> data[<span class="number">0</span>]==k?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi=data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid]&lt;k)</span><br><span class="line">                lo=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = lo;</span><br><span class="line">        hi=data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;data[mid])</span><br><span class="line">                hi=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = lo;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>-start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（13）</title>
    <url>/2018/08/14/OJ%20exercise13/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>二叉搜索树的第k大节点（剑指offer #54）</li>
<li>二叉树的深度（剑指offer #55）</li>
<li>数组中数字出现的次数（剑指offer #56)</li>
<li>和为s的数字（剑指offer #57)</li>
<li>翻转字符串（剑指offer #58)</li>
<li>队列的最大值（剑指offer #59）</li>
<li>n个骰子的点数（剑指offer #60）</li>
<li>扑克牌的顺子（剑指offer #61）</li>
<li>圆圈中最后剩下的数字（剑指offer #62）</li>
<li>股票的最大利润（剑指offer #63）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="二叉搜索树的第k大节点（剑指offer-54）"><a href="#二叉搜索树的第k大节点（剑指offer-54）" class="headerlink" title="二叉搜索树的第k大节点（剑指offer #54）"></a>二叉搜索树的第k大节点（剑指offer #54）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>中序遍历二叉搜索树即可。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root)&#123;</span><br><span class="line">                temp.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!temp.empty())&#123;</span><br><span class="line">                ++count;</span><br><span class="line">                root = temp.top();</span><br><span class="line">                temp.pop();</span><br><span class="line">                <span class="keyword">if</span>(count==k)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二叉树的深度（剑指offer-55）"><a href="#二叉树的深度（剑指offer-55）" class="headerlink" title="二叉树的深度（剑指offer #55）"></a>二叉树的深度（剑指offer #55）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>深度等于左右子树的深度+1，很典型的递归。</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deepth(pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">deepth</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(deepth(pRoot-&gt;left),deepth(pRoot-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（判定平衡二叉树）"><a href="#扩展（判定平衡二叉树）" class="headerlink" title="扩展（判定平衡二叉树）"></a>扩展（判定平衡二叉树）</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用递归亦可，但这里需要剪枝才能获取最大效率。在以下写法中，只要获取到一次-1（当前并非二叉平衡），则立即终止，避免无谓计算。</p>
<h3 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root)&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left&lt;<span class="number">0</span> || right&lt;<span class="number">0</span> || <span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数组中数字出现的次数（剑指offer-56"><a href="#数组中数字出现的次数（剑指offer-56" class="headerlink" title="数组中数字出现的次数（剑指offer #56)"></a>数组中数字出现的次数（剑指offer #56)</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>主要是异或之后得到一个diff，获取diff中最后一个1出现的位置（<code>diff&amp;=-diff</code>)。这两个数在这一位不同，于是再分别异或即可。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = accumulate(data.cbegin(),data.cend(),<span class="number">0</span>,bit_xor&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        diff&amp;=-diff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:data)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;diff)</span><br><span class="line">                *num1^=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2^=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针法，当前序列和若小于sum，++last，大于则++first。若相等则置入,然后++first。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">int</span> first=<span class="number">1</span>,last=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = (first+last)*(last-first+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur==sum)&#123;</span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(last-first+<span class="number">1</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;=last;++i)</span><br><span class="line">                    temp[i-first]=i;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                ++first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur&gt;sum)</span><br><span class="line">                ++first;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="翻转字符串（剑指offer-58"><a href="#翻转字符串（剑指offer-58" class="headerlink" title="翻转字符串（剑指offer #58)"></a>翻转字符串（剑指offer #58)</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先翻转整个字符串，然后再翻转每一个单词即可</p>
<h2 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (str.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">		    <span class="keyword">return</span> str;</span><br><span class="line">	    reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">auto</span> i = str.rbegin(); i != str.rend();) &#123;</span><br><span class="line">		    <span class="keyword">while</span> (*i == <span class="string">' '</span>) ++i;</span><br><span class="line">		    <span class="keyword">auto</span> j = i;</span><br><span class="line">		    <span class="keyword">while</span> (j != str.rend() &amp;&amp; *j != <span class="string">' '</span>) ++j;</span><br><span class="line">		    reverse(i, j);</span><br><span class="line">		    i = j;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="滑动窗口的最大值（剑指offer-59）"><a href="#滑动窗口的最大值（剑指offer-59）" class="headerlink" title="滑动窗口的最大值（剑指offer #59）"></a>滑动窗口的最大值（剑指offer #59）</h1><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>既可以从头到尾地暴力遍历，也可以利用队列求解。</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="暴力遍历-查找每一个窗口的最大值）"><a href="#暴力遍历-查找每一个窗口的最大值）" class="headerlink" title="暴力遍历(查找每一个窗口的最大值）"></a>暴力遍历(查找每一个窗口的最大值）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.empty()||k==<span class="number">0</span>||k&gt;num.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(num.<span class="built_in">size</span>()+<span class="number">1</span>-k)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxIndex=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxIndex&lt;i)&#123;</span><br><span class="line">                maxIndex=i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;i+k;++j)</span><br><span class="line">                    <span class="keyword">if</span>(num[maxIndex]&lt;=num[j])</span><br><span class="line">                        maxIndex=j;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 <span class="keyword">if</span>(num[i+k<span class="number">-1</span>]&gt;=num[maxIndex])</span><br><span class="line">                     maxIndex=i+k<span class="number">-1</span>;</span><br><span class="line">             res[i]=num[maxIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;num.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty()&amp;&amp;num[s.back()]&lt;=num[i])</span><br><span class="line">                s.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(!s.empty()&amp;&amp;i-s.front()+<span class="number">1</span>&gt;k)</span><br><span class="line">                s.pop_front();</span><br><span class="line">            s.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(k &amp;&amp; i+<span class="number">1</span>&gt;=k)<span class="comment">// 仅在i大于k时记录</span></span><br><span class="line">                res.push_back(num[s.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="n个骰子的点数（剑指offer-60）"><a href="#n个骰子的点数（剑指offer-60）" class="headerlink" title="n个骰子的点数（剑指offer #60）"></a>n个骰子的点数（剑指offer #60）</h1><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>很显然的动态规划问题。现有f(n,s)表征n个骰子扔出和为s的总有可能排列。那么自然存在状态转移方程为：</p>
<blockquote>
<blockquote>
<p>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)<br>f(n,s)=0 s&lt;n||s&gt;6n<br>f(1,1)=f(1,2)=f(1,4)=f(1,5)=f(1,6)=1</p>
</blockquote>
</blockquote>
<p>显然f(n,s)只和f(n-1)..相关，所以没必要存一个二维矩阵，两个一维矩阵足够了。</p>
<h2 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h2><p>(全文收录剑指offer）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printProbability</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">1</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span>* pProbabilities[<span class="number">2</span>];</span><br><span class="line">    pProbabilities[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">    pProbabilities[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_maxValue * number + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pProbabilities[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        pProbabilities[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g_maxValue; ++i) &#123;</span><br><span class="line">        pProbabilities[flag][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= number; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            pProbabilities[<span class="number">1</span>-flag][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>*k; i &lt;= g_maxValue*k; ++i) &#123;</span><br><span class="line">            pProbabilities[<span class="number">1</span>-flag][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= g_maxValue; ++j) &#123;</span><br><span class="line">                pProbabilities[<span class="number">1</span>-flag][i] += pProbabilities[flag][i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="built_in">pow</span>((<span class="keyword">double</span>)g_maxValue, number);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = number; i &lt;= g_maxValue * number; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)pProbabilities[flag][i]/total;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ratio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="扑克牌的顺子（剑指offer-61）"><a href="#扑克牌的顺子（剑指offer-61）" class="headerlink" title="扑克牌的顺子（剑指offer #61）"></a>扑克牌的顺子（剑指offer #61）</h1><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>排序，找出里面有几个0以及几个缺位，如果0的个数多于缺位，则为顺子，否则不是。此外，如果5张牌中存在非0重复元素，则必不可能为顺子。</p>
<h2 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.empty())</span><br><span class="line">		    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    sort(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">	    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">auto</span> i : numbers)</span><br><span class="line">		    <span class="keyword">if</span> (i == <span class="number">0</span>) ++count;</span><br><span class="line">		    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">int</span> block = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != numbers.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		    <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] == numbers[i + <span class="number">1</span>])</span><br><span class="line">			    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		    <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] + <span class="number">1</span> != numbers[i + <span class="number">1</span>])</span><br><span class="line">			    block += numbers[i + <span class="number">1</span>] - numbers[i]<span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> block &lt;= count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="圆圈中最后剩下的数字（剑指offer-62）"><a href="#圆圈中最后剩下的数字（剑指offer-62）" class="headerlink" title="圆圈中最后剩下的数字（剑指offer #62）"></a>圆圈中最后剩下的数字（剑指offer #62）</h1><p>（大名鼎鼎的约瑟夫环）</p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>环形链表可以求解，但最好的方法还是来自于数学公式：</p>
<blockquote>
<blockquote>
<p>f(n,m)=0 n==1<br>f(n,m)=(f(n-1,m)+m)%n n&gt;1</p>
</blockquote>
</blockquote>
<h2 id="解题方案-9"><a href="#解题方案-9" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">            last = (last+m)%i;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="股票的最大利润（剑指offer-63）"><a href="#股票的最大利润（剑指offer-63）" class="headerlink" title="股票的最大利润（剑指offer #63）"></a>股票的最大利润（剑指offer #63）</h1><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历数组，在遍历的同时记住之前所遇到的最小值，用本次减去最小值得到差额，记录遍历过程中最大的差额（本质上是一种贪心）。</p>
<h2 id="解题方案-10"><a href="#解题方案-10" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_min=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=prices.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            profit=<span class="built_in">max</span>(profit,prices[i]-cur_min);</span><br><span class="line">            cur_min=<span class="built_in">min</span>(cur_min,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（14）</title>
    <url>/2018/08/15/OJ%20exercise14/</url>
    <content><![CDATA[<p>（有些题目存在更优解，但留到后期刷leetcode时处理）</p>
<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>求1+2+3+……+n（剑指offer #64）</li>
<li>不用加减乘除作加法（剑指offer #65）</li>
<li>构建乘积数组（剑指offer #66)</li>
<li>把字符串转为整数（剑指offer #67)</li>
<li>树中两个节点的最低公共祖先（剑指offer #68)</li>
<li>z型打印二叉树（剑指offer #69）</li>
<li>二叉树的层序遍历（剑指offer #70）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="求1-2-3-……-n（剑指offer-64）"><a href="#求1-2-3-……-n（剑指offer-64）" class="headerlink" title="求1+2+3+……+n（剑指offer #64）"></a>求1+2+3+……+n（剑指offer #64）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>不许用循环，那只能是用递归了，又不能使用if之类设立递归基，因此</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=n;</span><br><span class="line">        res &amp;&amp; (res += Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="不用加减乘除作加法（剑指offer-65）"><a href="#不用加减乘除作加法（剑指offer-65）" class="headerlink" title="不用加减乘除作加法（剑指offer #65）"></a>不用加减乘除作加法（剑指offer #65）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>位运算。这里的核心要点在于：</p>
<ol>
<li>a^b 相当于两个数不考虑进位相加</li>
<li>(a&amp;b)&lt;&lt;1 相当于两个数的进位</li>
<li>将二者相加</li>
</ol>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1^num2;</span><br><span class="line">            <span class="keyword">int</span> carry = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1=sum,num2=carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="构建乘积数组（剑指offer-66"><a href="#构建乘积数组（剑指offer-66" class="headerlink" title="构建乘积数组（剑指offer #66)"></a>构建乘积数组（剑指offer #66)</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>将计算过程分为两步：</p>
<ol>
<li>从左到右算 B[i]=A[0]*A[1]*…*A[i-1]</li>
<li>从右到左算B[i]*=A[i+1]*…*A[n-1]</li>
</ol>
<p>为了保证O（n），可以采用一个变量保存连乘结果。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">B</span><span class="params">(A.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,res=<span class="number">1</span>;i!=A.<span class="built_in">size</span>();res*=A[i++])</span><br><span class="line">            B[i]=res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>,res=<span class="number">1</span>;i!=<span class="number">-1</span>;res*=A[i--])</span><br><span class="line">            B[i]*=res;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="实现atoi"><a href="#实现atoi" class="headerlink" title="实现atoi"></a>实现atoi</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种是纯粹的细节题，技术上难度不大。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StringToInteger</span><span class="params">(<span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Time:O(n) Space:O(1)</span></span><br><span class="line">	<span class="keyword">long</span> base = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i = str.find_first_not_of(<span class="string">" "</span>);</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">		sign = str[i++] == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i != str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[i])) &#123;</span><br><span class="line">		base = base * <span class="number">10</span> + str[i++] - <span class="string">'0'</span>;</span><br><span class="line">		<span class="keyword">if</span> (base*sign &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">		<span class="keyword">if</span> (base*sign &lt;= INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> base*sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>若此时为二叉搜索树，那情况十分简单：判断当前root-&gt;val与两个节点的值。若两个节点的值都比root大，则祖先在右子树中，若都小，则在左子树之中。若一大一小，则当前即为祖先。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">FindLowestCommonAncestor</span><span class="params">(Node* root, Node* n1, Node* n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root|| !n1 ||! n2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data &gt; n1-&gt;data &amp;&amp; root-&gt;data &gt; n2-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> FindLowestCommonAncestor(root-&gt;left, n1, n2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;data &lt; n1-&gt;data &amp;&amp; root-&gt;data &lt; n2-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> FindLowestCommonAncestor(root-&gt;right, n1, n2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="z型打印二叉树（剑指offer-69）"><a href="#z型打印二叉树（剑指offer-69）" class="headerlink" title="z型打印二叉树（剑指offer #69）"></a>z型打印二叉树（剑指offer #69）</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>递归解决,当然迭代也是可行的</p>
<h2 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">Print</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        aux(root,<span class="number">1</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeNode* root,<span class="keyword">int</span> level,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level&gt;res.<span class="built_in">size</span>())</span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span>(level&amp;<span class="number">1</span>)</span><br><span class="line">            res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res[level<span class="number">-1</span>].insert(res[level<span class="number">-1</span>].<span class="built_in">begin</span>(),root-&gt;val);</span><br><span class="line">        aux(root-&gt;left,level+<span class="number">1</span>,res);</span><br><span class="line">        aux(root-&gt;right,level+<span class="number">1</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二叉树的层序遍历（剑指offer-70"><a href="#二叉树的层序遍历（剑指offer-70" class="headerlink" title="二叉树的层序遍历（剑指offer #70"></a>二叉树的层序遍历（剑指offer #70</h1><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实和上一题是一样的。</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">Print</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        aux(root,<span class="number">1</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeNode* root,<span class="keyword">int</span> level,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level&gt;res.<span class="built_in">size</span>())</span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（15）</title>
    <url>/2018/08/16/OJ%20exercise15/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Regular Expression Matching（Leetcode #10）</li>
<li>Longest Common Prefix（Leetcode #14）</li>
<li>Valid Number（Leetcode #65）</li>
<li>Integer to Roman（Leetcode #12）</li>
<li>Anagrams（Leetcode #242）</li>
<li>Simplify Path (Leetcode #242)</li>
<li>Length of Last Word (Leetcode #58)</li>
<li>Valid Parentheses (Leetcode #20)</li>
<li>Largest Rectangle in Histogram（Leetcode #84）</li>
<li>Evaluate Reverse Polish Notation (Leetcode #150)</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*‘.<br>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).<br><strong>Note:</strong><br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.<br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the precedeng element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题采用递归完成。可以分为两个部分：第二个字符是’*‘与不是。若第二个字符不是，则直接比对当前第一个是否相等，若不相等返回false,相等则返回剩余部分是否相等。若第二个字符是’*‘,则问题可以分为两种情况：</p>
<ol>
<li>若当前第一个字符不相等，忽略*(对应于匹配p.substr(2))。</li>
<li>若当前第一个相等，要么忽略*,要么删去当前的相等字符(s.substr(1))。</li>
</ol>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty())</span><br><span class="line">            <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==p[<span class="number">0</span>] || p[<span class="number">0</span>]==<span class="string">'.'</span> &amp;&amp; !s.empty())</span><br><span class="line">                <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(s[<span class="number">0</span>]==p[<span class="number">0</span>] || p[<span class="number">0</span>]==<span class="string">'.'</span> &amp;&amp; !s.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(isMatch(s,p.substr(<span class="number">2</span>)))</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                s=s.substr(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Wildcard-Matching-Leetcode-44"><a href="#扩展（Wildcard-Matching-Leetcode-44" class="headerlink" title="扩展（Wildcard Matching Leetcode #44)"></a>扩展（Wildcard Matching Leetcode #44)</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*‘.<br>‘?’ Matches any single character.<br>‘*‘ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).<br><strong>Note:</strong><br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like ? or *.<br><strong>Example 3:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路（递归）"><a href="#解题思路（递归）" class="headerlink" title="解题思路（递归）"></a>解题思路（递归）</h3><p>递归解法的思路与上一题类似，若当前模式串字符为’*‘，则略过所有’*‘，若模式串略过’*‘后已到达尾部，必然匹配，否则递归式匹配s,p,若后者不匹配，++s，观察s是否为空（成功匹配）。<br>若当前模式串或主串为空，返回二者是否均为空。<br>若当前首字符相等，递归式匹配二者的下一个。<br>若当前不相等，不匹配。<br>本递归式解法时间复杂度为O(n!*m!),仅仅为了理解题意。</p>
<h3 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">0</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">0</span>]==<span class="string">'*'</span>) p=p.substr(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; !isMatch(s,p)) s=s.substr(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> !s.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.empty()||s.empty())</span><br><span class="line">            <span class="keyword">return</span> s==p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==p[<span class="number">0</span>] || p[<span class="number">0</span>]==<span class="string">'?'</span>) <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路（迭代）"><a href="#解题思路（迭代）" class="headerlink" title="解题思路（迭代）"></a>解题思路（迭代）</h3><p>主要是’*‘的匹配，p每遇到一个’*‘，就保留住当前’*‘坐标与s的坐标，然后s，若不成功则重新扫描。</p>
<h3 id="解题方案（迭代）"><a href="#解题方案（迭代）" class="headerlink" title="解题方案（迭代）"></a>解题方案（迭代）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  slen = s.<span class="built_in">size</span>(), plen = p.<span class="built_in">size</span>(), i, j, iStar = <span class="number">-1</span>, jStar = <span class="number">-1</span>;</span><br><span class="line">	    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i&lt;slen; ++i, ++j) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (p[j] == <span class="string">'*'</span>) &#123; <span class="comment">//meet a new '*', update traceback i/j info</span></span><br><span class="line">			    iStar = i;<span class="comment">//record i</span></span><br><span class="line">			    jStar = j;<span class="comment">//record j</span></span><br><span class="line">			    --i;</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">else</span> &#123;</span><br><span class="line">			    <span class="keyword">if</span> (p[j] != s[i] &amp;&amp; p[j] != <span class="string">'?'</span>) &#123;  <span class="comment">// mismatch happens</span></span><br><span class="line">				    <span class="keyword">if</span> (iStar &gt;= <span class="number">0</span>) &#123; <span class="comment">// met a '*' before, then do traceback</span></span><br><span class="line">					    i = iStar++;</span><br><span class="line">					    j = jStar;</span><br><span class="line">				    &#125;</span><br><span class="line">				    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// otherwise fail</span></span><br><span class="line">			    &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">while</span> (p[j] == <span class="string">'*'</span>) ++j;</span><br><span class="line">	    <span class="keyword">return</span> j == plen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Longest-Common-Prefix（Leetcode-14）"><a href="#Longest-Common-Prefix（Leetcode-14）" class="headerlink" title="Longest Common Prefix（Leetcode #14）"></a>Longest Common Prefix（Leetcode #14）</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Write a function to find the longest common prefix string amongst an array of strings.<br>If there is no common prefix, return an empty string “”.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>纵向比较，拿每个str与第一行相比配，不匹配当即返回。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><p>(由于STL的实现原因，下述代码不会导致数组越界）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=strs[<span class="number">0</span>].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="number">1</span>;j!=strs.<span class="built_in">size</span>();++j)</span><br><span class="line">                <span class="keyword">if</span>(strs[j][i]!=strs[<span class="number">0</span>][i]) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Valid-Number-Leetcode-65"><a href="#Valid-Number-Leetcode-65" class="headerlink" title="Valid Number (Leetcode #65)"></a>Valid Number (Leetcode #65)</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>此题与我在解析JSON数字时十分相似，但JSON格式与此不太相同。此外，本题也可以使用有限自动机实现。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'+'</span>||*s==<span class="string">'-'</span>)</span><br><span class="line">            ++s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*s)) ++s;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(*(s+<span class="number">1</span>)))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> ++s;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*s)) ++s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">toupper</span>(*s)==<span class="string">'E'</span>)&#123;</span><br><span class="line">            ++s;</span><br><span class="line">            <span class="keyword">if</span>(*(s)==<span class="string">'+'</span>||*(s)==<span class="string">'-'</span>)</span><br><span class="line">                ++s;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(*s))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*s)) ++s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (*s==<span class="string">'\0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Integer-to-Roman（Leetcode-12）"><a href="#Integer-to-Roman（Leetcode-12）" class="headerlink" title="Integer to Roman（Leetcode #12）"></a>Integer to Roman（Leetcode #12）</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: C &#x3D; 100, L &#x3D; 50, XXX &#x3D; 30 and III &#x3D; 3.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题存在两种解法，一种为O（1），非常奇怪的特解。一种为通用解。通用解的做法就是取出所有的单位（共13个），然后不断在string中加入。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="特解"><a href="#特解" class="headerlink" title="特解"></a>特解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; M = &#123; <span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span> &#125;;</span><br><span class="line">	    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; C = &#123; <span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span> &#125;;</span><br><span class="line">	    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; X = &#123; <span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span> &#125;;</span><br><span class="line">	    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; I = &#123; <span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span> &#125;;</span><br><span class="line">	    <span class="keyword">return</span> M[num / <span class="number">1000</span>] + C[(num % <span class="number">1000</span>) / <span class="number">100</span>] + X[(num % <span class="number">100</span>) / <span class="number">10</span>] + I[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="通用解"><a href="#通用解" class="headerlink" title="通用解"></a>通用解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; unitS&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unitD&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;num;++i)&#123;</span><br><span class="line">            <span class="keyword">size_t</span> count=num/unitD[i];</span><br><span class="line">            num%=unitD[i];</span><br><span class="line">            <span class="keyword">while</span>(count--) res+=unitS[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Roman-to-Integer-Leetcode-13）"><a href="#扩展（Roman-to-Integer-Leetcode-13）" class="headerlink" title="扩展（Roman to Integer Leetcode#13）"></a>扩展（Roman to Integer Leetcode#13）</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>Example1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><br>Example2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C &#x3D; 100, L &#x3D; 50, XXX &#x3D; 30 and III &#x3D; 3.</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>从后向前扫描，若第i位大于等于第i+1位，则加上第i位，否则减去。</p>
<h3 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> match(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> res=match(s.back());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=s.<span class="built_in">size</span>()<span class="number">-2</span>;i!=<span class="number">-1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=match(s[i]);</span><br><span class="line">            <span class="keyword">int</span> n=match(s[i+<span class="number">1</span>]);</span><br><span class="line">            res+=m&gt;=n?m:-m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (c) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'I'</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'V'</span>:<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'X'</span>:<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'L'</span>:<span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'C'</span>:<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'D'</span>:<span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'M'</span>:<span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">default</span>:<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Anagrams（Leetcode-242）"><a href="#Anagrams（Leetcode-242）" class="headerlink" title="Anagrams（Leetcode #242）"></a>Anagrams（Leetcode #242）</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given two strings s and t , write a function to determine if t is an anagram of s.<br><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br><strong>Example2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>相当容易的题目，以空间换时间即可。</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">256</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">            ++hash[c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t)</span><br><span class="line">            --hash[c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:hash)</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Group-Anagrams-Leetcode-49"><a href="#扩展（Group-Anagrams-Leetcode-49" class="headerlink" title="扩展（Group Anagrams Leetcode #49)"></a>扩展（Group Anagrams Leetcode #49)</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of strings, group anagrams together.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>从常规的角度来说，每一个放在一起的字符串排序之后必然相同，因此可以用一个<code>hashtable&lt;string,string&gt;</code>来存储结果，前一个string是排序结果，后一个是真实值。结着只要遍历vector即可。</p>
<p>本题另有一种巧妙解法，是人为地构建hash函数，每一组string对应一个独有的key。用一个map存储每个key对应的res数组的行号，若当前key已存储在map中，直接res[map[key]].push_back，否则在res中插入一个新的vector，并且更新map[key]=res.size()-1;</p>
<h3 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">	    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; mp;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="built_in">string</span> s : strs) &#123;</span><br><span class="line">		    <span class="built_in">string</span> t = s;</span><br><span class="line">		    sort(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">		    mp[t].push_back(s);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; anagrams;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">auto</span> m : mp) &#123;</span><br><span class="line">		    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">anagram</span><span class="params">(m.second.<span class="built_in">begin</span>(), m.second.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">		    anagrams.push_back(anagram);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> anagrams;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:strs)&#123;</span><br><span class="line">            <span class="keyword">int</span> key=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">                key*=prime[c-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">find</span>(key)!=<span class="built_in">map</span>.<span class="built_in">end</span>())</span><br><span class="line">               res[<span class="built_in">map</span>[key]].push_back(s);      </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&#123;s&#125;);</span><br><span class="line">                <span class="built_in">map</span>[key]=res.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Simplify-Path-Leetcode-242"><a href="#Simplify-Path-Leetcode-242" class="headerlink" title="Simplify Path (Leetcode #242)"></a>Simplify Path (Leetcode #242)</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an absolute path for a file (Unix-style), simplify it.<br>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”<br><strong>Corner Cases:</strong><br>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.In this case, you should ignore redundant slashes and return “/home/foo”.</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>C++没有split，因此我们必须借助于getline(ss,temp,’/‘)。本题需要利用一个stack，当temp为””或”.”时直接无视，若temp为”..”且当前栈非空则pop，否则push temp。最后取出栈中元素，依次加上”/“。最后需要注意的是res若为空，返回的是”/“。</p>
<h2 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res,temp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(getline(ss,temp,<span class="string">'/'</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">""</span>||temp==<span class="string">"."</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">".."</span>&amp;&amp; !stk.empty()) stk.pop_back();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp!=<span class="string">".."</span>) stk.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str:stk)</span><br><span class="line">            res+=<span class="string">"/"</span>+str;</span><br><span class="line">        <span class="keyword">return</span> res.empty()?<span class="string">"/"</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Length-of-Last-Word-Leetcode-58"><a href="#Length-of-Last-Word-Leetcode-58" class="headerlink" title="Length of Last Word (Leetcode #58)"></a>Length of Last Word (Leetcode #58)</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.If the last word does not exist, return 0.<br>Note: A word is defined as a character sequence consists of non-space characters only.<br>Example:<br>Input: “Hello World”<br>Output: 5</p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>非常简单的题目，从后向前遍历，将第一个非” “字符设为起点，再将接下来的第一个” “设为终点即可。</p>
<h2 id="解题方案-9"><a href="#解题方案-9" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> beg = s.rbegin();</span><br><span class="line">        <span class="keyword">while</span>(beg!=s.rend() &amp;&amp; *beg==<span class="string">' '</span>) ++beg;</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">end</span> = beg;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span>!=s.rend() &amp;&amp; *<span class="built_in">end</span>!=<span class="string">' '</span>) ++<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>-beg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Valid-Parentheses-Leetcode-20"><a href="#Valid-Parentheses-Leetcode-20" class="headerlink" title="Valid Parentheses (Leetcode #20)"></a>Valid Parentheses (Leetcode #20)</h1><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>栈的标准应用。</p>
<h2 id="解题方案-10"><a href="#解题方案-10" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c :s)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:stk.push(c);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'['</span>:stk.push(c);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#123;'</span>:stk.push(c);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stk.empty() || stk.top()!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> stk.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stk.empty() || stk.top()!=<span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> stk.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stk.empty() || stk.top()!=<span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> stk.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Longest-Valid-Parentheses-Leetcode-32"><a href="#扩展（Longest-Valid-Parentheses-Leetcode-32" class="headerlink" title="扩展（Longest Valid Parentheses Leetcode #32)"></a>扩展（Longest Valid Parentheses Leetcode #32)</h2><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.<br>Example:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>用栈存储每一个’(‘的位置，并且设立last表征上一个不匹配点’)’的位置。若当前匹配，根据stk的情况更新maxlen。</p>
<h2 id="解题方案-11"><a href="#解题方案-11" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>,last=<span class="number">-1</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>)</span><br><span class="line">                stk.push(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.empty())</span><br><span class="line">                    last=i;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    <span class="keyword">if</span>(stk.empty())</span><br><span class="line">                        maxlen=<span class="built_in">max</span>(maxlen,i-last);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        maxlen=<span class="built_in">max</span>(maxlen,i-stk.top());</span><br><span class="line">                        </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Largest-Rectangle-in-Histogram（Leetcode-84）"><a href="#Largest-Rectangle-in-Histogram（Leetcode-84）" class="headerlink" title="Largest Rectangle in Histogram（Leetcode #84）"></a>Largest Rectangle in Histogram（Leetcode #84）</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br><img src="http://static.zybuluo.com/zsmj2017/ryjh0nmuux2zdc7b2p6okyrw/image_1cl0sedd71qrq1kauccp19e5r5p19.png" alt="image_1cl0sedd71qrq1kauccp19e5r5p19.png-30.8kB"><br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题十分类似于水库存水，解决方案是维护一个递增的栈，若当前元素小于栈顶，令其入栈，否则合并现有栈，直到栈顶元素小于当前元素。结尾是入栈元素0，再次完成合并。</p>
<h2 id="解题方案-12"><a href="#解题方案-12" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(heights.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(heights.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;heights.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.empty()||heights[i]&gt;heights[stk.top()])</span><br><span class="line">                stk.push(i++);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//heights[i]&lt;heights[s.top()]</span></span><br><span class="line">			    <span class="comment">//so we compute the area from [s.top(),i) ,any elements in [s.top(),i) must be &gt;=s[i]</span></span><br><span class="line">                h=heights[stk.top()];</span><br><span class="line">                stk.pop();</span><br><span class="line">                j=stk.empty()?<span class="number">-1</span>:stk.top();</span><br><span class="line">                res=<span class="built_in">max</span>(res,h*(i-j<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Evaluate-Reverse-Polish-Notation-Leetcode-150"><a href="#Evaluate-Reverse-Polish-Notation-Leetcode-150" class="headerlink" title="Evaluate Reverse Polish Notation (Leetcode #150)"></a>Evaluate Reverse Polish Notation (Leetcode #150)</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.Valid operators are +, -, *, /. Each operand may be an integer or another expression.<br><strong>Note:</strong><br>Division between two integers should truncate toward zero.<br>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.<br>Example:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><p>逆波兰表达式求值，栈的典型应用，没有难点，带有浮点数的中缀表达式求值才好玩。</p>
<h2 id="解题方案-13"><a href="#解题方案-13" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>) &gt; &gt; op = &#123;</span><br><span class="line">		    &#123; <span class="string">"+"</span> , [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125; &#125;,</span><br><span class="line">		    &#123; <span class="string">"-"</span> , [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a - b; &#125; &#125;,</span><br><span class="line">		    &#123; <span class="string">"*"</span> , [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125; &#125;,</span><br><span class="line">		    &#123; <span class="string">"/"</span> , [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a / b; &#125; &#125;</span><br><span class="line">	    &#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op.<span class="built_in">find</span>(s)==op.<span class="built_in">end</span>())</span><br><span class="line">                stk.push(stoi(s));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> num1=stk.top();stk.pop();</span><br><span class="line">                <span class="keyword">int</span> num2=stk.top();stk.pop();</span><br><span class="line">                stk.push(op[s](num2,num1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（将中缀表达式变为后缀表达式）"><a href="#扩展（将中缀表达式变为后缀表达式）" class="headerlink" title="扩展（将中缀表达式变为后缀表达式）"></a>扩展（将中缀表达式变为后缀表达式）</h2><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; isp = &#123; &#123; <span class="string">'('</span>,<span class="number">1</span>&#125;,&#123; <span class="string">'^'</span>,<span class="number">6</span>&#125;,&#123; <span class="string">'*'</span>,<span class="number">5</span>&#125;,&#123;<span class="string">'/'</span>,<span class="number">5</span> &#125;,&#123;<span class="string">'+'</span>,<span class="number">3</span>&#125;,&#123;<span class="string">'-'</span>,<span class="number">3</span>&#125;,&#123;<span class="string">')'</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; icp = &#123; &#123; <span class="string">'('</span>,<span class="number">7</span>&#125;,&#123; <span class="string">'^'</span>,<span class="number">6</span>&#125;,&#123; <span class="string">'*'</span>,<span class="number">4</span>&#125;,&#123;<span class="string">'/'</span>,<span class="number">4</span> &#125;,&#123;<span class="string">'+'</span>,<span class="number">2</span>&#125;,&#123;<span class="string">'-'</span>,<span class="number">2</span>&#125;,&#123;<span class="string">')'</span>,<span class="number">1</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>遍历字符串</li>
<li>遇到数字直接rpn.push_back</li>
<li>遇到操作符<br>①如果是左括号 直接入栈<br>②如果是右括号，pop出栈内所有元素，直到遇到一个左括号，再pop掉左括号<br>③如果是操作运算符：<br>  &nbsp;&nbsp;Ⅰ如果栈为空或者栈顶是左括号，入栈<br>  &nbsp;&nbsp;Ⅱ如果当前字符的icp高于栈顶字符的isp，入栈<br>  &nbsp;&nbsp;Ⅲ并不高于isp，弹出所有大于等于当前字符icp的操作符并且送入rpn，弹完之后把当前的push进去<br>④遍历结束，弹出栈内操作符，送入rpn</li>
</ol>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（17）</title>
    <url>/2018/08/18/OJ%20exercise17/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Construct Binary Tree</li>
<li>Unique Binary Search Trees（Leetcode #96）</li>
<li>Validate Binary Search Tree（Leetcode #98）</li>
<li>Convert Sorted Array to Binary Search Tree（Leetcode #108）</li>
<li>Convert Sorted List to Binary Search Tree（Leetcode #109）</li>
<li>Minimum Depth of Binary Tree (Leetcode #111)</li>
<li>Path Sum (Leetcode #112)</li>
<li>Binary Tree Maximum Path Sum (Leetcode #124)</li>
<li>Populating Next Right Pointers in Each Node（Leetcode #116）</li>
<li>Sum Root to Leaf Numbers(Leetcode #129）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Construct-Binary-Tree"><a href="#Construct-Binary-Tree" class="headerlink" title="Construct Binary Tree"></a>Construct Binary Tree</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从中序+前序，以及中序+后序可以重建完全二叉树，其具体思想就是普通的递归（递归基是起点大于终点），现给出二者的实现方案。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><p><strong>Pre+In:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> aux(pre,<span class="number">0</span>,pre.<span class="built_in">size</span>()<span class="number">-1</span>,in,<span class="number">0</span>,in.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">aux</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre,<span class="keyword">int</span> pb,<span class="keyword">int</span> pe,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in,<span class="keyword">int</span> ib,<span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pb&gt;pe || ib&gt;ie) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[pb];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(in[pos]!=rootVal) ++pos;</span><br><span class="line">        root-&gt;left = aux(pre,pb+<span class="number">1</span>,pb+pos-ib,in,ib,pos<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = aux(pre,pb+<span class="number">1</span>+pos-ib,pe,in,pos+<span class="number">1</span>,ie);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>In+Post:</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.empty())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (in.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> TreeNode(in[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> aux(in,<span class="number">0</span>,in.<span class="built_in">size</span>()<span class="number">-1</span>,post,<span class="number">0</span>,post.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">aux</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in,<span class="keyword">int</span> ib,<span class="keyword">int</span> ie,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post,<span class="keyword">int</span> pb,<span class="keyword">int</span> pe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ib&gt;ie || pb&gt;pe)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal = post[pe];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> pos =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(in[pos]!=rootVal) ++pos;</span><br><span class="line">        root-&gt;left = aux(in,ib,pos<span class="number">-1</span>,post,pb,pb+pos<span class="number">-1</span>-ib);</span><br><span class="line">        root-&gt;right = aux(in,pos+<span class="number">1</span>,ie,post,pb+pos-ib,pe<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Unique-Binary-Search-Trees（Leetcode-96）"><a href="#Unique-Binary-Search-Trees（Leetcode-96）" class="headerlink" title="Unique Binary Search Trees（Leetcode #96）"></a>Unique Binary Search Trees（Leetcode #96）</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p>
<p><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是卡特兰数的典型实例。举例而言，当构成元素为1~n时，以i为根节点的树，其左子树由[1,i-1]构成，右子树由[i+1,n]构成。定义f(i)为以[1,i]构成的BST的个数，显然，<br><code>f(0)=0,f(1)=1,f(2)=f(0)*f(1)+f(1)*f(0),f(3)=f(0)*f(2)+f(1)*f(1)+f(2)*f(0)</code>(一个乘式对应着一个root），因此不难得出结论：</p>
<script type="math/tex; mode=display">f(i)=\sum_{k=1}^if(k-1)*f(i-k)</script><p>最终将问题转为一维动态规划求解。</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>,dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;++k)</span><br><span class="line">                dp[i]+=dp[k<span class="number">-1</span>]*dp[i-k];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Unique-Binary-Search-TreesⅡ-Leetcode-95"><a href="#扩展（Unique-Binary-Search-TreesⅡ-Leetcode-95" class="headerlink" title="扩展（Unique Binary Search TreesⅡ  Leetcode#95)"></a>扩展（Unique Binary Search TreesⅡ  Leetcode#95)</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#39;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>针对每一个根递归求解。具体来说，当beg&gt;end时，插入nullptr并return。（递归基）否则构建左右子树的vector，并遍历其元素以作为左右子树。</p>
<h3 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">return</span> aux(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">aux</span><span class="params">(<span class="keyword">int</span> beg,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(beg&gt;<span class="built_in">end</span>)&#123;</span><br><span class="line">            res.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=beg;i&lt;=<span class="built_in">end</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftsubs = aux(beg,i<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightsubs = aux(i+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> nl:leftsubs)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> nr:rightsubs)&#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left=nl;</span><br><span class="line">                    root-&gt;right=nr;</span><br><span class="line">                    res.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Validate-Binary-Search-Tree（Leetcode-98）"><a href="#Validate-Binary-Search-Tree（Leetcode-98）" class="headerlink" title="Validate Binary Search Tree（Leetcode #98）"></a>Validate Binary Search Tree（Leetcode #98）</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一反应是中序遍历二叉树，观察其中是否存在逆序对，这是一个可行的解，此外也可以使用递归实现（设定max与min，观察每一个节点是否超出，每下一层都更新min与max）</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux(root,LONG_MIN,LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">aux</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="built_in">min</span>,<span class="keyword">long</span> <span class="built_in">max</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= <span class="built_in">min</span> || root-&gt;val &gt;= <span class="built_in">max</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> aux(root-&gt;left,<span class="built_in">min</span>,root-&gt;val) &amp;&amp; aux(root-&gt;right,root-&gt;val,<span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Convert-Sorted-Array-to-Binary-Search-Tree（Leetcode-108）"><a href="#Convert-Sorted-Array-to-Binary-Search-Tree（Leetcode-108）" class="headerlink" title="Convert Sorted Array to Binary Search Tree（Leetcode #108）"></a>Convert Sorted Array to Binary Search Tree（Leetcode #108）</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>非常简单的题目。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">aux</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> beg,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beg&gt;<span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = beg+(<span class="built_in">end</span>-beg)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[middle]);</span><br><span class="line">        root-&gt;left = aux(nums,beg,middle<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = aux(nums,middle+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Convert-Sorted-List-to-Binary-Search-Tree（Leetcode-109）"><a href="#Convert-Sorted-List-to-Binary-Search-Tree（Leetcode-109）" class="headerlink" title="Convert Sorted List to Binary Search Tree（Leetcode #109）"></a>Convert Sorted List to Binary Search Tree（Leetcode #109）</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题的难度相较于上一道大了不少，主要原因在于单链表不支持随机访问。但原理总是类似的，我们可以采用快慢指针的方式，首先找到中点，然后完成求解。值得注意的是，在寻找中点时需要记录中点的前一个节点，以便于完成单链表的切断。</p>
<h2 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">        ListNode *p = head, *q = head, *pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &amp;&amp; q-&gt;next) &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(p-&gt;val);</span><br><span class="line">        root-&gt;left = sortedListToBST(head);</span><br><span class="line">        root-&gt;right = sortedListToBST(p-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Minimum-Depth-of-Binary-Tree-Leetcode-111"><a href="#Minimum-Depth-of-Binary-Tree-Leetcode-111" class="headerlink" title="Minimum Depth of Binary Tree (Leetcode #111)"></a>Minimum Depth of Binary Tree (Leetcode #111)</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, find its minimum depth.<br>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its minimum depth &#x3D; 2.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>非常简单的题目，遍历两个子树的min深度即可。值得注意的是若某个子树高度为0，最低高度是另一个子树的高度+根节点。</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">int</span> left = minDepth(root-&gt;left);</span><br><span class="line">	    <span class="keyword">int</span> right = minDepth(root-&gt;right);</span><br><span class="line">	    <span class="keyword">return</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) ? left + right + <span class="number">1</span> : <span class="built_in">min</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>若是求解max，难度更低：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h2><p>若是求解n叉树的maxDep，步骤几乎一样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:root-&gt;children)</span><br><span class="line">            res=<span class="built_in">max</span>(maxDepth(n),res);</span><br><span class="line">        <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Path-Sum-Leetcode-112"><a href="#Path-Sum-Leetcode-112" class="headerlink" title="Path Sum (Leetcode #112)"></a>Path Sum (Leetcode #112)</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the below binary tree and sum &#x3D; 22,</span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br><span class="line">return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>朴素深搜，找到了直接return。</p>
<h2 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val==sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum-root-&gt;val) || hasPathSum(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（"><a href="#扩展（" class="headerlink" title="扩展（"></a>扩展（</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the below binary tree and sum &#x3D; 22,</span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题的思路与上一题类似，但区别在于找到了不能直接return，需要接着往下探索，当某个节点探索完毕后需要对cur执行pop_back;</p>
<h3 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">        aux(root,sum,res,cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cur.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val==sum)</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        aux(root-&gt;left,sum-root-&gt;val,res,cur);</span><br><span class="line">        aux(root-&gt;right,sum-root-&gt;val,res,cur);</span><br><span class="line">        cur.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Binary-Tree-Maximum-Path-Sum-Leetcode-124"><a href="#Binary-Tree-Maximum-Path-Sum-Leetcode-124" class="headerlink" title="Binary Tree Maximum Path Sum (Leetcode #124)"></a>Binary Tree Maximum Path Sum (Leetcode #124)</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a non-empty binary tree, find the maximum path sum.<br>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.<br><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><br><strong>Example2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题十分类似于最长子序列和，但二叉树并不像array那样可以线性遍历，因此可以采取这样的策略：求解左子树，若其值为正，那么对结果有利，可以加上，接着求解右子树，若其对结果有利，也加上。需要注意的是，最后返回只返回了一个方向，这是因为递归需要返回root，不可能出现left-&gt;root-&gt;right的情况。</p>
<h2 id="解题方案-9"><a href="#解题方案-9" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MIN;</span><br><span class="line">        aux(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">aux</span><span class="params">(TreeNode* root,<span class="keyword">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="built_in">max</span>(<span class="number">0</span>,aux(root-&gt;left,res));</span><br><span class="line">        <span class="keyword">int</span> right=<span class="built_in">max</span>(<span class="number">0</span>,aux(root-&gt;right,res));</span><br><span class="line">        res=<span class="built_in">max</span>(res,left+right+root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Populating-Next-Right-Pointers-in-Each-Node（Leetcode-116）"><a href="#Populating-Next-Right-Pointers-in-Each-Node（Leetcode-116）" class="headerlink" title="Populating Next Right Pointers in Each Node（Leetcode #116）"></a>Populating Next Right Pointers in Each Node（Leetcode #116）</h1><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题比昨天的要简单一些，因为这是一颗满二叉树。因此可以采用递归解决。具体来说就是始终连接左-右，右-兄弟之左或右-nullptr。</p>
<h2 id="解题方案-10"><a href="#解题方案-10" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        aux(root,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeLinkNode *root,TreeLinkNode *next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        root-&gt;next=next;</span><br><span class="line">        aux(root-&gt;left,root-&gt;right);</span><br><span class="line">        aux(root-&gt;right,next?next-&gt;left:<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Sum-Root-to-Leaf-Numbers-Leetcode-129）"><a href="#Sum-Root-to-Leaf-Numbers-Leetcode-129）" class="headerlink" title="Sum Root to Leaf Numbers(Leetcode #129）"></a>Sum Root to Leaf Numbers(Leetcode #129）</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.<br>Find the total sum of all root-to-leaf numbers.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>朴素深搜即可。</p>
<h2 id="解题方案-11"><a href="#解题方案-11" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">aux</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> sum*<span class="number">10</span>+root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> aux(root-&gt;left,sum*<span class="number">10</span>+root-&gt;val)+aux(root-&gt;right,sum*<span class="number">10</span>+root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（4）</title>
    <url>/2018/08/03/OJ%20exercise4/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Two Sum（Leetcode #1)</li>
<li>3Sum(Leetcode #15）</li>
<li>3Sum Closet(Leetcode #16)</li>
<li>用两个栈实现队列（剑指offer #9）</li>
<li>斐波那契数列（剑指offer #10）</li>
<li>旋转数组的最小数字(剑指offer #11)</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Two-Sum（Leetcode-1"><a href="#Two-Sum（Leetcode-1" class="headerlink" title="Two Sum（Leetcode #1)"></a>Two Sum（Leetcode #1)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>暴力查找，O(n^2),不可取。</li>
<li>hash_table，占用空间</li>
<li>排序，然后左右夹逼。但leetcode要求返回的是数组下标，此法不可行。剑指offer上有一道可用此法解决。</li>
</ol>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">	    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">	    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		    <span class="keyword">int</span> numberToFind = target - numbers[i];</span><br><span class="line">		    <span class="keyword">if</span> (hash.<span class="built_in">find</span>(numberToFind) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			    res.push_back(hash[numberToFind]);</span><br><span class="line">			    res.push_back(i);			</span><br><span class="line">			    <span class="keyword">return</span> res;</span><br><span class="line">		    &#125;</span><br><span class="line">		    hash[numbers[i]] = i;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(一开始以为这道题并不麻烦，结果忽略了数组元素可能重复的事实，吃了大亏。在存入hashtable时应当注意不可直接全部存入，而是遍历式地存取）</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>顺手用夹逼解决剑指offer#57，它的题目描述如下所示：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i=<span class="built_in">array</span>.cbegin();</span><br><span class="line">        <span class="keyword">auto</span> j=<span class="built_in">array</span>.cend();</span><br><span class="line">        <span class="keyword">if</span>(i==j||i==--j)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*i+*j==sum)&#123;</span><br><span class="line">                res.push_back(*i);</span><br><span class="line">                res.push_back(*j);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*i+*j&lt;sum)</span><br><span class="line">                ++i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3Sum-Leetcode-15）"><a href="#3Sum-Leetcode-15）" class="headerlink" title="3Sum(Leetcode #15）"></a>3Sum(Leetcode #15）</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0?Find all unique triplets in the array which gives the sum of zero.<br><strong>Note:</strong><br>The solution set must not contain duplicate triplets.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题的思路还是排序，然后运用双指针夹逼。首先定义一个指针i指向首节点，然后在其后序元素中不断查找<code>sum=-*i</code>的节点对。待i查找完毕后，向后推进。当<code>*i+*(i+1)+*(i+2)</code>大于0时，结束遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> i = nums.cbegin();</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span> || *i&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;<span class="comment">// make result unique</span></span><br><span class="line">        <span class="keyword">while</span>(i!=nums.cend()<span class="number">-2</span> &amp;&amp; (*i+*(i+<span class="number">1</span>)+*(i+<span class="number">2</span>)&lt;=<span class="number">0</span>))&#123;          </span><br><span class="line">            <span class="keyword">auto</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">auto</span> k = nums.cend()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j!=k)&#123;</span><br><span class="line">                <span class="keyword">if</span>((*j+*k)== -*i)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curres;</span><br><span class="line">                    curres.push_back(*i);</span><br><span class="line">                    curres.push_back(*j);</span><br><span class="line">                    curres.push_back(*k);</span><br><span class="line">                    res.insert(curres);</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((*j+*k)&lt;-*i)</span><br><span class="line">                    ++j;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    --k;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;(res.cbegin(),res.cend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h2><p>在此思路上读者不难想到，求解KSUM的思路均是一致的：先排序，后夹逼即可，因此本文不再收录4SUM的解法。</p>
<hr>
<h1 id="3Sum-Closet-Leetcode-16"><a href="#3Sum-Closet-Leetcode-16" class="headerlink" title="3Sum Closet(Leetcode #16)"></a>3Sum Closet(Leetcode #16)</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 2, 1, -4], and target &#x3D; 1.</span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 &#x3D; 2).</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题的思路与上一题几乎完全一致，只是细节不同。本题中可以设定一个全局变量以保存与target的最小差值，最后返回target与该差值之和即可，当然，若发现最优差值为0，直接返回target。</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><p>（偷了一下懒，拿出了之前写的code，粗略看了一下应该可以优化，例如在当前abs(dis)大于abs(mindis)且继续增加时直接退出本轮循环）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">3</span>) </span><br><span class="line">            <span class="keyword">return</span> accumulate(nums.cbegin(), nums.cend(), <span class="number">0</span>);</span><br><span class="line">	    sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	    <span class="keyword">int</span> mindis = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != nums.<span class="built_in">size</span>() - <span class="number">2</span>; ++index) &#123;</span><br><span class="line">		    <span class="keyword">int</span> aim = target - nums[index];</span><br><span class="line">		    <span class="keyword">int</span> start = index + <span class="number">1</span>, <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		    <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">			    <span class="keyword">int</span> sum = nums[start] + nums[<span class="built_in">end</span>];</span><br><span class="line">			    <span class="keyword">int</span> dis = sum - aim;</span><br><span class="line">			    mindis = <span class="built_in">abs</span>(dis) &lt; <span class="built_in">abs</span>(mindis) ? dis : mindis;</span><br><span class="line">			    <span class="keyword">if</span> (dis==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">			    <span class="keyword">else</span> <span class="keyword">if</span> (dis&gt;<span class="number">0</span>) </span><br><span class="line">                    --<span class="built_in">end</span>;</span><br><span class="line">			    <span class="keyword">else</span></span><br><span class="line">				    ++start;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="keyword">return</span> target + mindis; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="用两个栈实现队列（剑指offer-9）"><a href="#用两个栈实现队列（剑指offer-9）" class="headerlink" title="用两个栈实现队列（剑指offer #9）"></a>用两个栈实现队列（剑指offer #9）</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>现有两个栈s1、s2,在执行push操作时总是将元素push入s1。在执行pop操作时，若当前s2非空，对s2执行pop操作，否则将s1中的所有元素push进入s2（两次先进后出变成了先进先出）。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = stack1.top();</span><br><span class="line">                stack2.push(temp);</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h2><p>如何用队列实现一个栈？有两种策略，第一种策略需要两个队列，而第二种只需要一个队列。下文将依次讲解思路。</p>
<ol>
<li><strong>2个队列实现栈</strong><br>假定现有队列q1、q2,当执行push操作时总是push入q1。当执行pop操作时，若当前q1.size()&gt;1,则将其元素全部push进入q2，然后再pop最末元素。最后，将swap(q1,q2)，令q2再次为空。当然，也可以每一次pop时检查哪个队列为空，将其作为中转，就不用在最后swap了。</li>
<li><strong>1个队列实现栈</strong><br>原理很简单，每执行一次push就对queue作一次重排，保证queue的次序与stack一致。具体操作如下图所示：<br><img src="http://static.zybuluo.com/zsmj2017/oiu30ugdk6dlobqqxrwlos8c/image_1cjve99rd1p371d0v7h75lu1gff9.png" alt="image_1cjve99rd1p371d0v7h75lu1gff9.png-35.5kB"></li>
</ol>
<hr>
<h1 id="斐波那契数列（剑指offer-10）"><a href="#斐波那契数列（剑指offer-10）" class="headerlink" title="斐波那契数列（剑指offer #10）"></a>斐波那契数列（剑指offer #10）</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>没什么好说的，值得注意的是类似爬楼梯之类问题本质也是求解斐波拉契数列。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>,g=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;</span><br><span class="line">            g=f+g;</span><br><span class="line">            f=g-f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="旋转数组的最小数字-剑指offer-11"><a href="#旋转数组的最小数字-剑指offer-11" class="headerlink" title="旋转数组的最小数字(剑指offer #11)"></a>旋转数组的最小数字(剑指offer #11)</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题已经在OJ exercise2 <a href="http://xander.wiki/post/969534c9.html">http://xander.wiki/post/969534c9.html</a>  中提到并实现了。下文将给出存在元素重复的情况。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> rotateArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> lo=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi=rotateArray.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid]&lt;rotateArray[hi])</span><br><span class="line">                hi=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid]==rotateArray[hi])</span><br><span class="line">                --hi;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（16）</title>
    <url>/2018/08/17/OJ%20exercise16/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Binary Tree Preorder Traversal（Leetcode #144）</li>
<li>Binary Tree Inorder Traversal（Leetcode #94）</li>
<li>Binary Tree Postorder Traversal（Leetcode #145）</li>
<li>Binary Tree Level Order Traversal（Leetcode #102）</li>
<li>Binary Tree Zigzag Order Traversal（Leetcode #103）</li>
<li>Recover Binary Search Tree (Leetcode #99)</li>
<li>Same Tree (Leetcode #100)</li>
<li>Balanced Binary Tree (Leetcode #110)</li>
<li>Flatten Binary Tree to Linked List（Leetcode #114）</li>
<li>Populating Next Right Pointers in Each NodeⅡ (Leetcode #117）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Binary-Tree-Preorder-Traversal（Leetcode-144）"><a href="#Binary-Tree-Preorder-Traversal（Leetcode-144）" class="headerlink" title="Binary Tree Preorder Traversal（Leetcode #144）"></a>Binary Tree Preorder Traversal（Leetcode #144）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>二叉树的几种遍历中，以后序最繁琐，前序中序都可以借助栈实现，但这里我将介绍Morris遍历，针对三种遍历次序，无需使用额外空间。（这里就不讨论递归了）<br>Morris遍历的前序和中序都较为简单，仅有后序较为繁琐。前序和中序的区别不大，因此将在中序遍历中统一说明。这里需要说明的是，前序和中序的区别是：</p>
<ul>
<li><strong>前序</strong><br>若pre-&gt;right尚未线索化，输出当前序列，更新cur与pre。</li>
<li><strong>中序</strong><br>若pre-&gt;right已线索化，输出当前序列，更新cur与pre。</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="栈（先进后出，所以先放右子）"><a href="#栈（先进后出，所以先放右子）" class="headerlink" title="栈（先进后出，所以先放右子）"></a>栈（先进后出，所以先放右子）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            TreeNode* temp = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right) stk.push(temp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left) stk.push(temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Morris"><a href="#Morris" class="headerlink" title="Morris"></a>Morris</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode* cur=root,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;left)&#123;</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre=cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right &amp;&amp; pre-&gt;right!=cur)</span><br><span class="line">                    pre=pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(!pre-&gt;right)&#123;</span><br><span class="line">                    res.push_back(cur-&gt;val);</span><br><span class="line">                    pre-&gt;right=cur;</span><br><span class="line">                    pre=cur;</span><br><span class="line">                    cur=cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pre-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">                    cur=cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Binary-Tree-Inorder-Traversal（Leetcode-94）"><a href="#Binary-Tree-Inorder-Traversal（Leetcode-94）" class="headerlink" title="Binary Tree Inorder Traversal（Leetcode #94）"></a>Binary Tree Inorder Traversal（Leetcode #94）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>Morris其算法核心思想在于线索华二叉树，具体步骤为：</p>
<ol>
<li>如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。</li>
<li>如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。<br>&nbsp;&nbsp;a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点(Cur)更新为当前节点的左孩子。<br>&nbsp;&nbsp;b) 如果前驱节点的右孩子为当前节点（已经访问过），将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。</li>
<li>重复以上1、2直到当前节点（Cur）为空。</li>
</ol>
<p>以下为Morris中序遍历图：<br><img src="http://static.zybuluo.com/zsmj2017/3w3kbr1r9zalausmrkeeg8cj/image_1cl377p8j1ubf2ecgi8bd21uen19.png" alt="image_1cl377p8j1ubf2ecgi8bd21uen19.png-136.1kB"></p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="栈-一直向左，直至五路可走转向右）"><a href="#栈-一直向左，直至五路可走转向右）" class="headerlink" title="栈(一直向左，直至五路可走转向右）"></a>栈(一直向左，直至五路可走转向右）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stk.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                root =stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Morris-1"><a href="#Morris-1" class="headerlink" title="Morris"></a>Morris</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode* cur=root,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;left)&#123;</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre=cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right &amp;&amp; pre-&gt;right!=cur)</span><br><span class="line">                    pre=pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(pre-&gt;right==cur)&#123;</span><br><span class="line">                    res.push_back(cur-&gt;val);</span><br><span class="line">                    pre-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">                    pre=cur;</span><br><span class="line">                    cur=cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pre-&gt;right=cur;</span><br><span class="line">                    cur=cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Binary-Tree-Postorder-Traversal（Leetcode-145）"><a href="#Binary-Tree-Postorder-Traversal（Leetcode-145）" class="headerlink" title="Binary Tree Postorder Traversal（Leetcode #145）"></a>Binary Tree Postorder Traversal（Leetcode #145）</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>后序遍历的难度远大于前序与中序，这里将给出stack与morris的实现。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="栈（借助stack还需要cur与pre）"><a href="#栈（借助stack还需要cur与pre）" class="headerlink" title="栈（借助stack还需要cur与pre）"></a>栈（借助stack还需要cur与pre）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur=root,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur || !stk.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* top = stk.top();</span><br><span class="line">                <span class="keyword">if</span>(top-&gt;right==pre || top-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    <span class="comment">// has no right child or right child has been visited</span></span><br><span class="line">                    res.push_back(top-&gt;val);</span><br><span class="line">                    pre=top;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur=top-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="栈配合双端队列（反转前序的过程）"><a href="#栈配合双端队列（反转前序的过程）" class="headerlink" title="栈配合双端队列（反转前序的过程）"></a>栈配合双端队列（反转前序的过程）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            TreeNode* top = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_front(top-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;left) stk.push(top-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;right) stk.push(top-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.cbegin(),res.cend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="morris"><a href="#morris" class="headerlink" title="morris"></a>morris</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        TreeNode *cur, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        function&lt;<span class="keyword">void</span> (TreeNode*)&gt; visit = [&amp;res](TreeNode* node) &#123;res.push_back(node-&gt;val); &#125;;</span><br><span class="line">        dummy.left = root; cur = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode *node = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (node-&gt;right &amp;&amp; node-&gt;right != cur) &#123;</span><br><span class="line">                    node = node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;right) &#123;</span><br><span class="line">                    node-&gt;right = cur;</span><br><span class="line">                    pre = cur;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    visit_reverse(cur-&gt;left, prev, visit);</span><br><span class="line">                    prev-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    prev = cur;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(TreeNode* from, TreeNode* to)</span> </span>&#123;</span><br><span class="line">        TreeNode* x = from, *y = from-&gt;right, *z;</span><br><span class="line">        <span class="keyword">if</span> (from == to) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != to) &#123;</span><br><span class="line">            z = y-&gt;right;</span><br><span class="line">            y-&gt;right = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit_reverse</span><span class="params">(TreeNode* from, TreeNode* to, function&lt;<span class="keyword">void</span> (TreeNode*)&gt; &amp;visit)</span> </span>&#123;</span><br><span class="line">        TreeNode* p = to;</span><br><span class="line">        reverse(from, to);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            <span class="keyword">if</span> (p == from) <span class="keyword">break</span>;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(to, from);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Binary-Tree-Level-Order-Traversal（Leetcode-102）"><a href="#Binary-Tree-Level-Order-Traversal（Leetcode-102）" class="headerlink" title="Binary Tree Level Order Traversal（Leetcode #102）"></a>Binary Tree Level Order Traversal（Leetcode #102）</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果仅输出一个vector，层序遍历和前序遍历几乎一致，只需要把stack换成queue。如果需要输出vector&lt;vector&lt;vector&lt;int&gt; &gt;,则递归的思路写起来十分清晰。此外，也可以使用两个queue来解决问题。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        aux(root,<span class="number">1</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeNode* root,<span class="keyword">size_t</span> level,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level&gt;res.<span class="built_in">size</span>())</span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        aux(root-&gt;left,level+<span class="number">1</span>,res);</span><br><span class="line">        aux(root-&gt;right,level+<span class="number">1</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="双queue"><a href="#双queue" class="headerlink" title="双queue"></a>双queue</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; current,next;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">        current.push_back(root);</span><br><span class="line">        <span class="keyword">while</span> (!current.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!current.empty())&#123;</span><br><span class="line">                root = current.front();</span><br><span class="line">                current.pop_front();</span><br><span class="line">                level.push_back(root-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left) next.push_back(root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right) next.push_back(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            level.<span class="built_in">clear</span>();</span><br><span class="line">            swap(next, current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（-Binary-Tree-Level-Order-Traversal-II-Leetocde107）"><a href="#扩展（-Binary-Tree-Level-Order-Traversal-II-Leetocde107）" class="headerlink" title="扩展（ Binary Tree Level Order Traversal II Leetocde107）"></a>扩展（ Binary Tree Level Order Traversal II Leetocde107）</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).<br>For example:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its bottom-up level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果要偷懒的话，直接reverse上一题的答案即可，但我辈当然不齿这种方案。那只能先获取整个树的高度，然后对于指定的位置的vector执行push_back，总得来说问题不大。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">height</span>(root);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">res</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">        aux(root,<span class="number">1</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left),<span class="built_in">height</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeNode* root,<span class="keyword">int</span> level,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        res[res.<span class="built_in">size</span>()-level].push_back(root-&gt;val);</span><br><span class="line">        aux(root-&gt;left,level+<span class="number">1</span>,res);</span><br><span class="line">        aux(root-&gt;right,level+<span class="number">1</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Binary-Tree-Zigzag-Order-Traversal（Leetcode-103）"><a href="#Binary-Tree-Zigzag-Order-Traversal（Leetcode-103）" class="headerlink" title="Binary Tree Zigzag Order Traversal（Leetcode #103）"></a>Binary Tree Zigzag Order Traversal（Leetcode #103）</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题的思路和上一题类似，但是遇到奇数层就push_back，遇到偶数层就push_front即可。但对于vector来说，在头端插入需要线性的时间，因此需要别的数据结构并加以转化，此题也许用迭代效果更佳。（利用stack实现倒序）</p>
<h2 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">	    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">	    <span class="built_in">deque</span>&lt;TreeNode*&gt; dtn;</span><br><span class="line">	    dtn.push_back(root);</span><br><span class="line">	    <span class="keyword">bool</span> <span class="built_in">leftToRight</span> = <span class="literal">true</span>;</span><br><span class="line">	    <span class="keyword">while</span> (!dtn.empty()) &#123;</span><br><span class="line">		    <span class="keyword">int</span> <span class="built_in">size</span> = dtn.<span class="built_in">size</span>();</span><br><span class="line">		    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">		    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">			    TreeNode* node = dtn.front();</span><br><span class="line">			    dtn.pop_front();</span><br><span class="line">			    <span class="comment">// find position to fill node's value</span></span><br><span class="line">			    <span class="keyword">int</span> index = (<span class="built_in">leftToRight</span>) ? i : (<span class="built_in">size</span> - <span class="number">1</span> - i);</span><br><span class="line">			    row[index] = node-&gt;val;</span><br><span class="line">			    <span class="keyword">if</span> (node-&gt;left) dtn.push_back(node-&gt;left);</span><br><span class="line">			    <span class="keyword">if</span> (node-&gt;right) dtn.push_back(node-&gt;right);</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="comment">//after this level</span></span><br><span class="line">		    <span class="built_in">leftToRight</span> = !<span class="built_in">leftToRight</span>;</span><br><span class="line">		    res.push_back(row);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Recover-Binary-Search-Tree-Leetcode-99"><a href="#Recover-Binary-Search-Tree-Leetcode-99" class="headerlink" title="Recover Binary Search Tree (Leetcode #99)"></a>Recover Binary Search Tree (Leetcode #99)</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Two elements of a binary search tree (BST) are swapped by mistake.Recover the tree without changing its structure.<br><strong>Example1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure><br><strong>Example2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>中序遍历将其存在一个vector中，通过查看逆序对就能明确哪两个需要交换。如果不能使用辅助存储空间，则需要借助morris遍历实现。</p>
<p>此外，该问题亦存在递归解法，采用pre与first、second三个指针记录中序遍历下的逆序对。若存在逆序对，若first尚不明确，将pre赋予first（乱序的两个节点在中序下相邻），再将root赋予sec。</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="空间O-n-的中序遍历"><a href="#空间O-n-的中序遍历" class="headerlink" title="空间O(n)的中序遍历"></a>空间O(n)的中序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; store;</span><br><span class="line">        inOrderTraverse(root, store);</span><br><span class="line">        swapValue(store);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode* &amp;root, <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) inOrderTraverse(root-&gt;left, res);</span><br><span class="line">        res.push_back(root);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) inOrderTraverse(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapValue</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;vtn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vtn.empty() || vtn.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != vtn.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j != vtn.<span class="built_in">size</span>() - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vtn[j]-&gt;val &gt; vtn[j + <span class="number">1</span>]-&gt;val) swap(vtn[j]-&gt;val, vtn[j + <span class="number">1</span>]-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归（DFS）"><a href="#递归（DFS）" class="headerlink" title="递归（DFS）"></a>递归（DFS）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre=<span class="literal">nullptr</span>,*first=pre,*sec=pre;</span><br><span class="line">        aux(root,pre,first,sec);</span><br><span class="line">        <span class="keyword">if</span>(first &amp;&amp; sec) swap(first-&gt;val,sec-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aux</span><span class="params">(TreeNode* root,TreeNode* &amp;pre,TreeNode* &amp;first,TreeNode* &amp;sec )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        aux(root-&gt;left,pre,first,sec);</span><br><span class="line">        <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;val&gt;root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!first) first=pre;</span><br><span class="line">            sec=root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        aux(root-&gt;right,pre,first,sec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Morris中序遍历"><a href="#Morris中序遍历" class="headerlink" title="Morris中序遍历"></a>Morris中序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pair&lt;TreeNode*, TreeNode*&gt; broken;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!curr-&gt;left) &#123;</span><br><span class="line">                detect(broken, prev, curr);</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = curr-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (node-&gt;right &amp;&amp; node-&gt;right!=curr)&#123;</span><br><span class="line">                    node = node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;right) &#123;</span><br><span class="line">                    node-&gt;right = curr;</span><br><span class="line">                    curr = curr-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    detect(broken, prev, curr);</span><br><span class="line">                    node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    prev = curr;</span><br><span class="line">                    curr = curr-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(broken.first-&gt;val, broken.second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detect</span><span class="params">(pair&lt;TreeNode*, TreeNode*&gt; &amp;broken, TreeNode* prev, TreeNode* curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prev &amp;&amp; prev-&gt;val &gt; curr-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!broken.first) broken.first = prev;</span><br><span class="line">            broken.second = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Same-Tree-Leetcode-100"><a href="#Same-Tree-Leetcode-100" class="headerlink" title="Same Tree (Leetcode #100)"></a>Same Tree (Leetcode #100)</h1><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题可以引申出子树问题（剑指offer已经解答），值得留意。</p>
<h2 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Symmetric-Tree-Leetcode-101"><a href="#扩展（Symmetric-Tree-Leetcode-101" class="headerlink" title="扩展（Symmetric Tree Leetcode #101)"></a>扩展（Symmetric Tree Leetcode #101)</h2><h3 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> aux(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">aux</span><span class="params">(TreeNode* left,TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left || !right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val!=right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> aux(left-&gt;left,right-&gt;right) &amp;&amp; aux(left-&gt;right,right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展（Invert-Binary-Tree-Leetcode-226）"><a href="#扩展（Invert-Binary-Tree-Leetcode-226）" class="headerlink" title="扩展（Invert Binary Tree Leetcode #226）"></a>扩展（Invert Binary Tree Leetcode #226）</h2><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>用递归的话十分容易，用迭代则需要一个queue作为辅助空间走一次BFS。</p>
<h3 id="解题方案-9"><a href="#解题方案-9" class="headerlink" title="解题方案"></a>解题方案</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">            <span class="built_in">std</span>::swap(root-&gt;left,root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* temp=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp)&#123;</span><br><span class="line">                q.push(temp-&gt;left);</span><br><span class="line">                q.push(temp-&gt;right);</span><br><span class="line">                swap(temp-&gt;left,temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Balanced-Binary-Tree-Leetcode-110"><a href="#Balanced-Binary-Tree-Leetcode-110" class="headerlink" title="Balanced Binary Tree (Leetcode #110)"></a>Balanced Binary Tree (Leetcode #110)</h1><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>注意剪枝</p>
<h2 id="解题方案-10"><a href="#解题方案-10" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deepth(root)&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = deepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = deepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>( left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span> || <span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Flatten-Binary-Tree-to-Linked-List（Leetcode-114）"><a href="#Flatten-Binary-Tree-to-Linked-List（Leetcode-114）" class="headerlink" title="Flatten Binary Tree to Linked List（Leetcode #114）"></a>Flatten Binary Tree to Linked List（Leetcode #114）</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For example, given the following tree:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br><span class="line">The flattened tree should look like:</span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>既然要求就地，那只能寻找规律了。可以设立cur表征当前节点，当cur==nullptr时终止循环。若其左右子树健全，寻找其中序遍历下的pre，令pre-&gt;right=cur-&gt;right。接着将右子树绑定到左子树cur-&gt;right=cur-&gt;left。最后切断左子树与根的联系，转向右子树。</p>
<h2 id="解题方案-11"><a href="#解题方案-11" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left &amp;&amp; cur-&gt;right)&#123;</span><br><span class="line">                TreeNode* pre = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right) pre=pre-&gt;right;</span><br><span class="line">                pre-&gt;right=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                cur-&gt;right=cur-&gt;left;</span><br><span class="line">            cur-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            cur=cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Populating-Next-Right-Pointers-in-Each-NodeⅡ-Leetcode-117）"><a href="#Populating-Next-Right-Pointers-in-Each-NodeⅡ-Leetcode-117）" class="headerlink" title="Populating Next Right Pointers in Each NodeⅡ (Leetcode #117）"></a>Populating Next Right Pointers in Each NodeⅡ (Leetcode #117）</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br>Initially, all next pointers are set to NULL.<br><strong>Note:</strong><br>You may only use constant extra space.<br>Recursive approach is fine, implicit stack space does not count as extra space for this problem.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the following binary tree,</span><br><span class="line">     1</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2    3</span><br><span class="line"> &#x2F; \    \</span><br><span class="line">4   5    7</span><br><span class="line">After calling your function, the tree should look like:</span><br><span class="line">     1 -&gt; NULL</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> &#x2F; \    \</span><br><span class="line">4-&gt; 5 -&gt; 7 -&gt; NULL</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于需要常量空间,BFS不可行，因此只能再次通过设立cur，head，tail的方案，逐层地扫描建立。算法核心思想为：head与tail分别表征下一层的起点与重点（横向），若cur存在左子，若tail存在则更新tail，否则初始化tail与head。存在右子时亦是如此。cur左右子扫描完毕后cur=cur-&gt;next。若其为空，则令cur转向下一层头部，并将tail与head置零。</p>
<p>如果去除常量空间这个条件，那么BFS算法如下所示。</p>
<h2 id="解题方案（优解）"><a href="#解题方案（优解）" class="headerlink" title="解题方案（优解）"></a>解题方案（优解）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode* cur=root,*head=<span class="literal">nullptr</span>,*tail=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tail)&#123;</span><br><span class="line">                    tail-&gt;next=cur-&gt;left;</span><br><span class="line">                    tail=tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tail=cur-&gt;left;</span><br><span class="line">                    head=tail;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">               <span class="keyword">if</span>(tail)&#123;</span><br><span class="line">                    tail-&gt;next=cur-&gt;right;</span><br><span class="line">                    tail=tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tail=cur-&gt;right;</span><br><span class="line">                    head=tail;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!cur)&#123;</span><br><span class="line">                cur=head;</span><br><span class="line">                head=tail=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解题方案（BFS）"><a href="#解题方案（BFS）" class="headerlink" title="解题方案（BFS）"></a>解题方案（BFS）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeLinkNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">size</span>--)&#123;</span><br><span class="line">                root=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">size</span>) root-&gt;next=q.front();</span><br><span class="line">                <span class="keyword">else</span> root-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（2）</title>
    <url>/2018/08/01/OJ%20exercise2/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Search in Rotated Sorted Array（Leetcode #33)</li>
<li>Search in Rotated Sorted ArrayⅡ ( Leetcode #81）</li>
<li>二维数组查找（剑指offer #4）</li>
<li>替换空格（剑指offer #5）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Search-in-Rotated-Sorted-Array（Leetcode-33"><a href="#Search-in-Rotated-Sorted-Array（Leetcode-33" class="headerlink" title="Search in Rotated Sorted Array（Leetcode #33)"></a>Search in Rotated Sorted Array（Leetcode #33)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题数组不含有重复元素，此外指定时间复杂度为O(logn)，必须采用二分。本题的关键在于：若nums[m]&gt;=nums[l]，则[l,m]必为升序。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> last = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">            <span class="keyword">size_t</span> mid = first+(last-first)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[first]&lt;=nums[mid])&#123;<span class="comment">//写&lt;亦可,为下一题做准备</span></span><br><span class="line">                <span class="keyword">if</span>(nums[first]&lt;=target &amp;&amp; target&lt;nums[mid])</span><br><span class="line">                    last=mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    first = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[last<span class="number">-1</span>])</span><br><span class="line">                    first = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    last = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>本题还有一种解法，即首先二分找出最小元素（必为翻转点），此后利用传统二分查找即可。找出最小元素的算法如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> lo = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">size_t</span> hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> mid = lo+(hi-lo)/<span class="number">2</span>; </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">return</span> nums[mid + <span class="number">1</span>];      </span><br><span class="line">            <span class="keyword">if</span> (nums[hi] &lt; nums[mid]) </span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>（本方案结合下题，稍加改进即可解决剑指offer#11）。如果当前需要寻找旋转（且带有重复元素）数组的max，笔者认为需要将比对区间由[mid,hi]改为[lo,mid]，此想法尚未验证。</p>
<hr>
<h1 id="Search-in-Rotated-Sorted-ArrayⅡ-Leetcode-81）"><a href="#Search-in-Rotated-Sorted-ArrayⅡ-Leetcode-81）" class="headerlink" title="Search in Rotated Sorted ArrayⅡ ( Leetcode #81）"></a>Search in Rotated Sorted ArrayⅡ ( Leetcode #81）</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).You are given a target value to search. If found in the array return true, otherwise return false.</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>在本题中允许重复，因此若nums[m]&gt;=nums[l]，则[l,m]为升序的推论不成立(见上一题解决方案Line10）。反例为：[1,2,1,1,1];<br>我们将nums[m]&gt;=nums[l]分为两种可能：</p>
<ol>
<li>nums[m]&gt;nums[l],则区间[l,m]必为升序</li>
<li>nums[m]==nums[l],自增l，观察结果</li>
</ol>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]==target;</span><br><span class="line">        <span class="keyword">size_t</span> first=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> last=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">            <span class="keyword">size_t</span> mid = first+(last-first)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[first]&lt;nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[first]&lt;=target &amp;&amp; target&lt;nums[mid])</span><br><span class="line">                    last=mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    first=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[first]==nums[mid])</span><br><span class="line">                ++first;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[last<span class="number">-1</span>])</span><br><span class="line">                    first=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    last=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二维数组查找"><a href="#二维数组查找" class="headerlink" title="二维数组查找"></a>二维数组查找</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有一二维数组，元素按照每一行从左向右递增，每一列从上向下的规律排序完毕，试以线性时间完成元素查找。</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>从左下角或右上角开始查找即可。试以左下角为例，小则向上，大则向右。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">array</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j!=<span class="built_in">array</span>[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]&lt;target)</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="keyword">else</span> --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>将某字符串内所有空格替换为”%20”。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>暴力法需要对线性表进行反复插入，造成不必要的开销。应当预判替换完毕的线性表长度，然后倒序遍历字符串完成拷贝操作。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">char</span>* cur = str;</span><br><span class="line">	    <span class="keyword">while</span> (*cur != <span class="string">'\0'</span>)</span><br><span class="line">		    <span class="keyword">if</span> (*cur++ == <span class="string">' '</span>) count++;</span><br><span class="line">	    <span class="keyword">int</span> newlength = length + count * <span class="number">2</span>;</span><br><span class="line">	    <span class="keyword">char</span>* last = str + newlength - <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">char</span>* rcur = str + length - <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">while</span> (count) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (*rcur != <span class="string">' '</span>)</span><br><span class="line">		    	*last-- = *rcur--;</span><br><span class="line">		    <span class="keyword">else</span> &#123;</span><br><span class="line">			    count--;</span><br><span class="line">			    *last-- = <span class="string">'0'</span>;</span><br><span class="line">			    *last-- = <span class="string">'2'</span>;</span><br><span class="line">		        *last-- = <span class="string">'%'</span>;</span><br><span class="line">			    rcur--;</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（6）</title>
    <url>/2018/08/05/OJ%20exercise6/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Gray Code(Leetcode #89)</li>
<li>Gas Station(Leetcode #134）</li>
<li>Candy(Leetcode #135)</li>
<li>Single Number(Leetcode #136)</li>
<li>二进制中1的个数（剑指offer #15）</li>
<li>数值的整数次方（剑指offer #16）</li>
<li>打印从1到最大的n位数(剑指offer #17)</li>
<li>删除链表的节点（剑指offer #18）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Gray-Code-Leetcode-89"><a href="#Gray-Code-Leetcode-89" class="headerlink" title="Gray Code(Leetcode #89)"></a>Gray Code(Leetcode #89)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.<br>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,3,2]</span><br><span class="line">Explanation:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br></pre></td></tr></table></figure><br>For a given n, a gray code sequence may not be uniquely defined.For example, [0,2,3,1] is also a valid gray code sequence.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>解题的核心思想在于，格雷码与自然数的二进制码存在对应关系，其公式为：<code>Nth Gray Code == n^(n&gt;&gt;1)</code>。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="built_in">pow</span>(<span class="number">2</span>,n),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> index=<span class="number">1</span>;index!=<span class="built_in">pow</span>(<span class="number">2</span>,n);++index)</span><br><span class="line">            res[index]=index^(index&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Gas-Station-Leetcode-134）"><a href="#Gas-Station-Leetcode-134）" class="headerlink" title="Gas Station(Leetcode #134）"></a>Gas Station(Leetcode #134）</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.<br>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.<br><strong>Note:</strong><br>If there exists a solution, it is guaranteed to be unique.Both input arrays are non-empty and have the same length.Each element in the input arrays is a non-negative integer.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8</span><br><span class="line">Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7</span><br><span class="line">Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6</span><br><span class="line">Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 0. Your tank &#x3D; 4 - 3 + 2 &#x3D; 3</span><br><span class="line">Travel to station 1. Your tank &#x3D; 3 - 3 + 3 &#x3D; 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can&#39;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一种解法基于暴力，对每一个节点都判断其能否到达终点。<br>第二种解法基于推论：若从点A无法到达点B，那么A到B之间的任何一个点都不可能到达点B。因此只需要在失败后将目光投向下一个节点即可（本题的思路让我想起了最大子序列和）。</p>
<hr>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> index = <span class="number">0</span>; index != gas.<span class="built_in">size</span>(); ++index) &#123;</span><br><span class="line">		    <span class="keyword">int</span> res = canTraverse(index, gas, cost);</span><br><span class="line">		    <span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="keyword">return</span> res;</span><br><span class="line">		    <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canTraverse</span><span class="params">(<span class="keyword">size_t</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">size_t</span> loop = <span class="number">0</span>; loop != n; ++loop) &#123;</span><br><span class="line">		    res += (gas[(i + loop) % n] - cost[(i + loop) % n]);</span><br><span class="line">		    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>（tank表征当前存量，total表征需要克服的缺额）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,total=<span class="number">0</span>,tank=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=gas.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            tank+=gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(tank&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">                total+=tank;</span><br><span class="line">                tank=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total+tank&lt;<span class="number">0</span>?<span class="number">-1</span>:start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Candy-Leetcode-135"><a href="#Candy-Leetcode-135" class="headerlink" title="Candy(Leetcode #135)"></a>Candy(Leetcode #135)</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are N children standing in a line. Each child is assigned a rating value.You are giving candies to these children subjected to the following requirements:Each child must have at least one candy.Children with a higher rating get more candies than their neighbors.What is the minimum candies you must give?<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,0,2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用两个数组，一个从前向后遍历，确保从前向后的区间必然保证优先级，一个从后向前，做同样的动作。最终每个孩子分到的糖果是这两个数组中对应位置的最大值。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp1</span><span class="params">(ratings.<span class="built_in">size</span>(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp2</span><span class="params">(temp1)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>;i!=ratings.<span class="built_in">size</span>();++i)</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i<span class="number">-1</span>])</span><br><span class="line">                temp1[i]=temp1[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=ratings.<span class="built_in">size</span>()<span class="number">-2</span>;i!=<span class="number">-1</span>;--i)</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>])</span><br><span class="line">                temp2[i]=temp2[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=temp1.<span class="built_in">size</span>();++i)</span><br><span class="line">            res+=<span class="built_in">max</span>(temp1[i],temp2[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Single-Number-Leetcode-136"><a href="#Single-Number-Leetcode-136" class="headerlink" title="Single Number(Leetcode #136)"></a>Single Number(Leetcode #136)</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于重复元素，需要了解的一个重要性质是：A^A=0；了解这个后这道题自然迎刃而解。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulate(nums.cbegin(),nums.cend(),<span class="number">0</span>,bit_xor&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>倘若当前数组内存在两个只出现了一次的元素，如何找出这两个元素？</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>全部异或后得到这两个数的异或值<code>diff</code>,然后执行<code>diff&amp;=-diff</code>，可以获取这两个数从后向前第一个不相等的位（例如00001,00100）等。对于原有数组中的元素，必然可以被分为两组，一组该位为0，一组该位为1。这两个数就位于这两组之中，再次对两组执行异或运算即可。</p>
<h3 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = accumulate(data.cbegin(),data.cend(),<span class="number">0</span>,bit_xor&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        diff&amp;=-diff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:data)</span><br><span class="line">            <span class="keyword">if</span>(i&amp;diff)</span><br><span class="line">                *num1^=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2^=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="更进一步的扩展"><a href="#更进一步的扩展" class="headerlink" title="更进一步的扩展"></a>更进一步的扩展</h2><p>如果当前数组内元素都出现了3次，仅有一个只出现了两次，如何找出这个元素？</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>用二进制模拟三进制，思路如下：因为一个元素最多出现3次，那么采用2个bit即可表征所有状态：00—&gt;01-&gt;10-&gt;00;因此我们设立两个int：ones、twos，用来记录元素出现的次数。因此，建立真值表如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">twos</th>
<th style="text-align:center">ones</th>
<th style="text-align:center">number</th>
<th style="text-align:center">output twos</th>
<th style="text-align:center">output ones</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>综上，有运算式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ones = (ones ^ nums[i]) &amp; ~twos;</span><br><span class="line">twos = (twos ^ nums[i]) &amp; ones;</span><br></pre></td></tr></table></figure></p>
<h3 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones=<span class="number">0</span>,twos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> index=<span class="number">0</span>;index!=nums.<span class="built_in">size</span>();++index)&#123;</span><br><span class="line">            ones=ones^nums[index]&amp;~twos;</span><br><span class="line">            twos=twos^nums[index]&amp;ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接位运算，记住<code>x&amp;=(x-1)</code>表示去掉最右边的1.</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">             n&amp;=(n<span class="number">-1</span>),++res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接照抄了STL的解法，不过需要注意的是这里可能exponent是负数。</p>
<h2 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(base==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">abs</span>(base<span class="number">-1</span>)&lt;= <span class="number">1e-10</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">bool</span> flag = exponent&gt;<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">      exponent = <span class="built_in">abs</span>(exponent);</span><br><span class="line">      <span class="keyword">while</span>(!(exponent&amp;<span class="number">1</span>))</span><br><span class="line">          base*=base,exponent&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">double</span> result = base;</span><br><span class="line">      exponent&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">          base*=base;</span><br><span class="line">          <span class="keyword">if</span>(exponent&amp;<span class="number">1</span>)</span><br><span class="line">              result*=base;</span><br><span class="line">          exponent&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> flag?<span class="number">1</span>/result:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="打印从1到最大的n位数-剑指offer-17"><a href="#打印从1到最大的n位数-剑指offer-17" class="headerlink" title="打印从1到最大的n位数(剑指offer #17)"></a>打印从1到最大的n位数(剑指offer #17)</h1><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题的关键在于如何高精度表示数字，用数组或字符串存储即可。再配合上一节所说的Plus One即可打印所有数字，过程略去不表。</p>
<hr>
<h1 id="删除链表的节点（剑指offer-18）"><a href="#删除链表的节点（剑指offer-18）" class="headerlink" title="删除链表的节点（剑指offer #18）"></a>删除链表的节点（剑指offer #18）</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>O（1）时间删除单链表的指定节点。</p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题可以分为以下几步：</p>
<ol>
<li>如果头结点为空或指定节点为空，直接返回。</li>
<li>单链表中仅有头结点，删除头结点后返回。</li>
<li>需要删除的点是尾节点，遍历链表，找到尾节点之前的点，令其next指向nullptr。</li>
<li>被删除的节点只是寻常节点（不需要获取前向节点），此时令其值为其next的值，其next指向next—&gt;next即可。</li>
</ol>
<h2 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h2><p>(仅给出最后一种情况的解答）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next=node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（7）</title>
    <url>/2018/08/06/OJ%20exercise7/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Add Two Numbers(Leetcode #2)</li>
<li>Reverse Linked ListⅡ(Leetcode #92）</li>
<li>Partition List(Leetcode #86)</li>
<li>Remove Duplicates from Sorted List(Leetcode #83)</li>
<li>Rotate List（Leetcode #61）</li>
<li>正则表达式匹配（剑指offer #18）</li>
<li>表达数值的字符串(剑指offer #19)</li>
<li>调整数组顺序保证奇数在偶数之前（剑指offer #20）</li>
<li>链表的倒数第k个节点（剑指offer #21）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Add-Two-Numbers-Leetcode-2"><a href="#Add-Two-Numbers-Leetcode-2" class="headerlink" title="Add Two Numbers(Leetcode #2)"></a>Add Two Numbers(Leetcode #2)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从头到尾遍历即可，需要注意边界情况与鲁棒性。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>)</span></span>; </span><br><span class="line">        ListNode *cur = &amp;preHead;</span><br><span class="line">	    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">		    <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">		    carry = sum / <span class="number">10</span>;</span><br><span class="line">		    cur-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">		    l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">		    l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">		    cur = cur-&gt;next;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Follow up:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>有大佬提出了不用额外空间也不破坏原有数组的做法，具体解答可见：<a href="https://leetcode.com/problems/add-two-numbers-ii/discuss/154058/C++-Solution-without-recursion-and-Space-complexity-O(1" target="_blank" rel="noopener">https://leetcode.com/problems/add-two-numbers-ii/discuss/154058/C++-Solution-without-recursion-and-Space-complexity-O(1</a>) 出于赶时间的原因（其实是没想出来），笔者用栈完成了这道题的求解（把这道题强行变成了上一道题），需要注意的地方在于返回的链表不可逆序连接。</p>
<h3 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; val1,val2;</span><br><span class="line">        <span class="keyword">while</span>(l1) val1.push(l1-&gt;val),l1=l1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(l2) val2.push(l2-&gt;val),l2=l2-&gt;next;</span><br><span class="line">        ListNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* next = cur;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!val1.empty() || !val2.empty() || carry)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=(val1.empty()?<span class="number">0</span>:val1.top())+(val2.empty()?<span class="number">0</span>:val2.top())+carry;</span><br><span class="line">            <span class="keyword">if</span>(!val1.empty()) val1.pop();</span><br><span class="line">            <span class="keyword">if</span>(!val2.empty()) val2.pop();</span><br><span class="line">            carry=val/<span class="number">10</span>;</span><br><span class="line">            cur = <span class="keyword">new</span> ListNode(val%<span class="number">10</span>);</span><br><span class="line">            cur-&gt;next=next;</span><br><span class="line">            next=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Reverse-Linked-ListⅡ-Leetcode-92）"><a href="#Reverse-Linked-ListⅡ-Leetcode-92）" class="headerlink" title="Reverse Linked ListⅡ(Leetcode #92）"></a>Reverse Linked ListⅡ(Leetcode #92）</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Reverse a linked list from position m to n. Do it in one-pass.<br><strong>Note: 1 ≤ m ≤ n ≤ length of list.</strong><br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题可以用模仿单链表翻转（迭代版本）的求解思路完成，也可以运用下一种思路：<br>假定当前有单链表<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>，m=1,n=3;我们设立三个指针<code>pre</code>,<code>cur</code>,<code>next</code>。最终我们需要做的是将2移动到4的位置，为了完成这一步骤需要m-n次循环，循环过程如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:   1-&gt;2-&gt;3-&gt;4-&gt;5      pre:1 cur:2 next:3</span><br><span class="line">1st:     1-&gt;3-&gt;2-&gt;4-&gt;5      pre:1 cur:2 next:4</span><br><span class="line">2nd:     1-&gt;4-&gt;3-&gt;2-&gt;5      pre:1 cur:2 next:5</span><br></pre></td></tr></table></figure><br>在每一次循环中，我们需要执行的是：</p>
<ol>
<li>cur-&gt;next = next-&gt;next;</li>
<li>next-&gt;next = pre-&gt;next;</li>
<li>pre-&gt;next = next;</li>
<li>next = cur-&gt;next;</li>
</ol>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n-=m;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        preHead.next = head;</span><br><span class="line">        ListNode* pre=&amp;preHead;</span><br><span class="line">        <span class="keyword">while</span>(--m) pre=pre-&gt;next;</span><br><span class="line">        ListNode* cur = pre-&gt;next;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            cur-&gt;next=next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">            next=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Partition-List-Leetcode-86"><a href="#Partition-List-Leetcode-86" class="headerlink" title="Partition List(Leetcode #86)"></a>Partition List(Leetcode #86)</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.<br>You should preserve the original relative order of the nodes in each of the two partitions.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>STL算法中有stable_partition与partition，前一种我没学过。不过单链表具有非常好的分割特性，不必那么麻烦。直接将原有链表分为两条，然后再合并即可。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode preHead1(-1), preHead2(-1);</span><br><span class="line">	    ListNode *p = &amp;preHead1, *q = &amp;preHead2;</span><br><span class="line">	    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (head-&gt;val &lt; x) p = p-&gt;next = head;</span><br><span class="line">		    <span class="keyword">else</span> q = q-&gt;next = head;</span><br><span class="line">		    head = head-&gt;next;</span><br><span class="line">	    &#125;</span><br><span class="line">	    p-&gt;next = preHead2.next;</span><br><span class="line">	    q-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	    <span class="keyword">return</span> preHead1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Remove-Duplicates-from-Sorted-List-Leetcode-83"><a href="#Remove-Duplicates-from-Sorted-List-Leetcode-83" class="headerlink" title="Remove Duplicates from Sorted List(Leetcode #83)"></a>Remove Duplicates from Sorted List(Leetcode #83)</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>单链表不具备随机访问特性，只能从头到尾地遍历一次。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val==cur-&gt;next-&gt;val)</span><br><span class="line">                cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们用<code>prev</code>与<code>cur</code>两个指针完成求解。将所有重复元素直接略过。</p>
<h3 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        preHead.next=head;</span><br><span class="line">        ListNode* pre=&amp;preHead,*cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">           <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val==cur-&gt;next-&gt;val)</span><br><span class="line">               cur=cur-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(pre-&gt;next==cur)</span><br><span class="line">               pre=cur;</span><br><span class="line">           cur=cur-&gt;next;</span><br><span class="line">           pre-&gt;next=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Rotate-List（Leetcode-61）"><a href="#Rotate-List（Leetcode-61）" class="headerlink" title="Rotate List（Leetcode #61）"></a>Rotate List（Leetcode #61）</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><br><strong>Explanation:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>STL有关于rotate的算法实现，但单链表自身存在特殊性质：我们可以把它连接成环，确定开头后再断开即可。</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;next) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = head;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">step</span> = length - k % length;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">step</span>--)</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        head = node-&gt;next;</span><br><span class="line">        node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="正则表达式匹配（剑指offer-18）"><a href="#正则表达式匹配（剑指offer-18）" class="headerlink" title="正则表达式匹配（剑指offer #18）"></a>正则表达式匹配（剑指offer #18）</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>本题与leetcode#10 相同。是一道难度较大的题（我感觉字符串的题都好难啊）。</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果第2个字符不为*，那么我们先判断首字符是否匹配。若首字符匹配，递归式判断剩下的,否则返回false。若第二个字符为*且当前首字符匹配，我们有两种选择：</p>
<ol>
<li>无视模式串中的’*’</li>
<li>无视文本串中当前匹配的字符</li>
</ol>
<p>若第二个字符为*且当前首字符不匹配，直接认为<code>p[0]p[1]</code>为空，继续执行匹配。</p>
<h2 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*p==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> *s==<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(*(p+<span class="number">1</span>)!=<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p==*s || *p==<span class="string">'.'</span> &amp;&amp; *s!=<span class="string">'\0'</span>)</span><br><span class="line">                <span class="keyword">return</span> match(s+<span class="number">1</span>,p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(*p==*s || *p==<span class="string">'.'</span> &amp;&amp; *s!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(match(s,p+<span class="number">2</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> match(s,p+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="表达数值的字符串"><a href="#表达数值的字符串" class="headerlink" title="表达数值的字符串"></a>表达数值的字符串</h1><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>类似于JSON项目中解析数字的实现。</p>
<h2 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'+'</span>|| *s==<span class="string">'-'</span>)</span><br><span class="line">            ++s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*s)) ++s;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'.'</span>)&#123;</span><br><span class="line">            ++s;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(*s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*s)) ++s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">'e'</span>||*s==<span class="string">'E'</span>)&#123;</span><br><span class="line">            ++s;</span><br><span class="line">            <span class="keyword">if</span>(*s==<span class="string">'+'</span>|| *s==<span class="string">'-'</span>) ++s;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(*s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*s)) ++s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *s==<span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="调整数组顺序保证奇数在偶数之前（剑指offer-20）"><a href="#调整数组顺序保证奇数在偶数之前（剑指offer-20）" class="headerlink" title="调整数组顺序保证奇数在偶数之前（剑指offer #20）"></a>调整数组顺序保证奇数在偶数之前（剑指offer #20）</h1><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题就是在考察stable_partition的实现，简单地说，可以利用插排或者冒泡。如果不用稳定的话，那直接参照STL的partition实现。</p>
<h2 id="解题方案-9"><a href="#解题方案-9" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=<span class="built_in">array</span>.<span class="built_in">size</span>();++i)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">size_t</span> j=<span class="built_in">array</span>.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;i;--j)</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">array</span>[j]&amp;<span class="number">1</span> &amp;&amp; !(<span class="built_in">array</span>[j<span class="number">-1</span>]&amp;<span class="number">1</span>))</span><br><span class="line">                   swap(<span class="built_in">array</span>[j],<span class="built_in">array</span>[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="链表的倒数第k个节点"><a href="#链表的倒数第k个节点" class="headerlink" title="链表的倒数第k个节点"></a>链表的倒数第k个节点</h1><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>快慢指针，不过需要注意鲁棒性。</p>
<h2 id="解题方案-10"><a href="#解题方案-10" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pListHead==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p=pListHead;</span><br><span class="line">        ListNode* q=p;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!q &amp;&amp; (k!=<span class="number">0</span>)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（3）</title>
    <url>/2018/08/02/OJ%20exercise3/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Median of Two Sorted Arrays（Leetcode #4)</li>
<li>Long Consecutive Sequence(Leetcode #128）</li>
<li>从尾到头打印链表（剑指offer #6）</li>
<li>重建二叉树（剑指offer #7）</li>
<li>二叉树的下一个节点(剑指offer #8)</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Median-of-Two-Sorted-Arrays（Leetcode-4"><a href="#Median-of-Two-Sorted-Arrays（Leetcode-4" class="headerlink" title="Median of Two Sorted Arrays（Leetcode #4)"></a>Median of Two Sorted Arrays（Leetcode #4)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.<br><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure><br><strong>Example 2</strong>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line">The median is (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>笔者直接将问题改造为更一般的通用情况：已知两个有序数组，找到二者所有元素中第k大的元素。思路有以下三种：</p>
<ol>
<li>归并排序，这是最显然的解法。但是无论时间还是空间均有较大消耗。</li>
<li>在1的基础上，采用一个计数器记录当前m大的元素，当m==k时终止算法。此时不再具备空间消耗，但时间复杂度不变。</li>
<li>在2的基础上我们发现，每一次比较都排除了一个在第k大元素之前的元素。我们可以充分利用数组有序的特性，每一次都删除一半的元素，如此则可实现O(log(m+n))的复杂度。</li>
</ol>
<h3 id="思路剖析"><a href="#思路剖析" class="headerlink" title="思路剖析"></a>思路剖析</h3><p>针对思路3，现有分析如下：<br>假设数组A与B元素个数均大于k/2，我们将A的第k/2个元素与B的第k/2个元素进行比较，即比较A[k/2-1]、B[k/2-1]，比较结果有三种可能（为了简化分析，假设k为偶数，所得结论对于k为奇数亦成立）：</p>
<ol>
<li>A[k/2-1]==B[k/2-1]</li>
<li>A[k/2-1]&gt;B[k/2-1]</li>
<li>A[k/2-1]&lt;B[k/2-1]</li>
</ol>
<p>若A[k/2-1] &lt; B[k/2-1]，则意味着区间[A[0],A[k/2-1]]内的所有元素必然不大于A<code>U</code>B的top k元素，则可直接舍弃这k/2个元素，对于&lt;的情况亦是如此（证明很简单，令A[k/2-1]=P，则P至多为A<code>U</code>B的第k-1个元素）。若A[k/2-1]==B[k/2-1]，则表明已经找到了第k大的元素。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="思路二（计数器-归并）"><a href="#思路二（计数器-归并）" class="headerlink" title="思路二（计数器+归并）"></a>思路二（计数器+归并）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> sumsize=nums1.<span class="built_in">size</span>()+nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> evenflag = (sumsize&amp;<span class="number">1</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">size_t</span> k = evenflag?(sumsize+<span class="number">1</span>)/<span class="number">2</span>:sumsize/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> evenflag?findKth(nums1,nums2,k):(findKth(nums1,nums2,k)+findKth(nums1,nums2,k+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">size_t</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>,current=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=nums1.<span class="built_in">size</span>()&amp;&amp;j!=nums2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            current = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++],++count;</span><br><span class="line">            <span class="keyword">if</span>(count==k)</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (i==nums1.<span class="built_in">size</span>())?nums2[j+k-count<span class="number">-1</span>]:nums1[i+k-count<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路三（二分）"><a href="#思路三（二分）" class="headerlink" title="思路三（二分）"></a>思路三（二分）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total=m+n;</span><br><span class="line">        <span class="keyword">if</span>(total&amp;<span class="number">1</span>) <span class="keyword">return</span> aux(A,m,B,n,(total+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (aux(A,m,B,n,total/<span class="number">2</span>)+aux(A,m,B,n,total/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">aux</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> aux(B,n,A,m,k);</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> B[k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(B[<span class="number">0</span>],A[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> pa=<span class="built_in">min</span>(k/<span class="number">2</span>,m),pb=k-pa;</span><br><span class="line">        <span class="keyword">if</span>(A[pa<span class="number">-1</span>]&lt;B[pb<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> aux(A+pa,m-pa,B,n,k-pa);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[pa<span class="number">-1</span>]&gt;B[pb<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> aux(A,m,B+pb,n-pb,k-pb);</span><br><span class="line">        <span class="keyword">return</span> A[pa<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>对于这种求第k个元素，很容易联想到大顶堆或小顶堆，笔者出于时间原因没有验证，但采用堆必然消耗空间，有兴趣的读者可以自行尝试。</p>
<hr>
<h1 id="Long-Consecutive-Sequence-Leetcode-128）"><a href="#Long-Consecutive-Sequence-Leetcode-128）" class="headerlink" title="Long Consecutive Sequence(Leetcode #128）"></a>Long Consecutive Sequence(Leetcode #128）</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.Your algorithm should run in O(n) complexity.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>最长连续整数序列，第一反应必然是排序去重求解，但排序不满足O(n)的时间复杂度。因此可采用以空间换取时间的策略，将所有元素存入hashtable，对于每一个元素，以其为中心向两侧扩张，直到不再连续(当然亦可以采用hashset）。</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="方案一（排序）"><a href="#方案一（排序）" class="headerlink" title="方案一（排序）"></a>方案一（排序）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">	    sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	    nums.erase(unique(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">	    <span class="keyword">size_t</span> length = <span class="number">1</span>, maxlength = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) </span><br><span class="line">		        length++;</span><br><span class="line">		    <span class="keyword">else</span> &#123;</span><br><span class="line">			    maxlength = maxlength &gt; length ? maxlength : length;</span><br><span class="line">			    length = <span class="number">1</span>;</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    maxlength = maxlength &gt; length ? maxlength : length;</span><br><span class="line">	    <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方案二（hashtable"><a href="#方案二（hashtable" class="headerlink" title="方案二（hashtable)"></a>方案二（hashtable)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)</span><br><span class="line">            used[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">size_t</span> maxlength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">size_t</span> length=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; used.<span class="built_in">find</span>(j) != used.<span class="built_in">end</span>();++j) </span><br><span class="line">                used[j] = <span class="literal">true</span>,++length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; used.<span class="built_in">find</span>(j) != used.<span class="built_in">end</span>(); --j)</span><br><span class="line">                used[j] = <span class="literal">true</span>,++length;</span><br><span class="line">            maxlength = maxlength &gt; length ? maxlength : length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="从尾到头打印链表（剑指offer-6）"><a href="#从尾到头打印链表（剑指offer-6）" class="headerlink" title="从尾到头打印链表（剑指offer #6）"></a>从尾到头打印链表（剑指offer #6）</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>没什么好说的，从尾到头是标准的先进后出，自然想到了栈。此外，本题采用递归也能实现。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="方案一（栈）"><a href="#方案一（栈）" class="headerlink" title="方案一（栈）"></a>方案一（栈）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; aux;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            aux.push(head);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!aux.empty())&#123;</span><br><span class="line">            ListNode* temp = aux.top();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">            aux.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方案二-递归）"><a href="#方案二-递归）" class="headerlink" title="方案二(递归）"></a>方案二(递归）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        print_aux(head,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prints_aux</span><span class="params">(ListNode* head,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            prints_aux(head-&gt;next,res);</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="重建二叉树（剑指offer-7）"><a href="#重建二叉树（剑指offer-7）" class="headerlink" title="重建二叉树（剑指offer #7）"></a>重建二叉树（剑指offer #7）</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>以下将探讨如何从前序遍历、中序遍历序列还原二叉树。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路很简单：前序的第一个Node为root，在中序序列中找到root，其左右分别为左子树和右子树。再对左右子树执行递归构建即可。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> construct_aux(pre,vin,<span class="number">0</span>,pre.<span class="built_in">size</span>(),<span class="number">0</span>,vin.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct_aux</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vin,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">size_t</span> pb,<span class="keyword">size_t</span> pe,<span class="keyword">size_t</span> ib,<span class="keyword">size_t</span> ie)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pb==pe)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootvalue = pre[pb];</span><br><span class="line">            TreeNode* root = <span class="keyword">new</span> TreeNode(rootvalue);</span><br><span class="line">            <span class="keyword">size_t</span> pos=ib;</span><br><span class="line">            <span class="keyword">while</span>(pos!=ie)</span><br><span class="line">                <span class="keyword">if</span>(vin[pos]==rootvalue) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> pos++;</span><br><span class="line">            root-&gt;left = construct_aux(pre,vin,pb+<span class="number">1</span>,pb+<span class="number">1</span>+pos-ib,ib,pos);</span><br><span class="line">            root-&gt;right = construct_aux(pre,vin,pb+<span class="number">1</span>+pos-ib,pe,pos+<span class="number">1</span>,ie);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h2><p>利用中序与后序还原二叉树也是类似的思路：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.empty())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> construct_aux(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode * <span class="title">construct_aux</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;post,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">size_t</span> ib, <span class="keyword">size_t</span> ie, <span class="keyword">size_t</span> pb, <span class="keyword">size_t</span> pe)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (ib == ie)</span><br><span class="line">		    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	    <span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="keyword">int</span> rootvalue = post[pe<span class="number">-1</span>];</span><br><span class="line">		    TreeNode* root = <span class="keyword">new</span> TreeNode(rootvalue);</span><br><span class="line">		    <span class="keyword">size_t</span> pos = ib;</span><br><span class="line">		    <span class="keyword">while</span> (pos != ie)</span><br><span class="line">			    <span class="keyword">if</span> (vin[pos] == rootvalue) <span class="keyword">break</span>;</span><br><span class="line">			    <span class="keyword">else</span> pos++;</span><br><span class="line">		    root-&gt;left = construct_aux(vin, post, ib, pos, pb, pb+pos-ib);</span><br><span class="line">		    root-&gt;right = construct_aux(vin, post, pos+<span class="number">1</span>, ie, pb+pos-ib, pe<span class="number">-1</span>);</span><br><span class="line">		    <span class="keyword">return</span> root;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉树的下一个节点-剑指offer-8"><a href="#二叉树的下一个节点-剑指offer-8" class="headerlink" title="二叉树的下一个节点(剑指offer #8)"></a>二叉树的下一个节点(剑指offer #8)</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>求解某二叉树在中序遍历下的下一个节点，struct TreeNode内含有指向父亲的指针。</p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题可按照以下步骤求解：</p>
<ol>
<li>若该节点存在右子树，则下一个节点必为其右子树的最左侧节点。</li>
<li>在不满足1的条件下，若该节点为左子，则其父为下一节点。</li>
<li>在不满足1的条件下，若该节点为右子，上溯至其第一个不为右子的祖先之父。</li>
</ol>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pNode)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right)&#123;</span><br><span class="line">                pNode=pNode-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(pNode-&gt;left)</span><br><span class="line">                    pNode=pNode-&gt;left;</span><br><span class="line">                <span class="keyword">return</span> pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(pNode-&gt;parent)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(pNode-&gt;parent-&gt;left==pNode)</span><br><span class="line">                        <span class="keyword">return</span> pNode-&gt;parent;</span><br><span class="line">                    pNode=pNode-&gt;parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（5）</title>
    <url>/2018/08/04/OJ%20exercise5/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Remove Element(Leetcode #27)</li>
<li>Next Permutation(Leetcode #31）</li>
<li>Permurtation Sequence(Leetcode #60)</li>
<li>Plus One(Leetcode #60)</li>
<li>矩阵中的路径（剑指offer #12）</li>
<li>机器人的运动范围（剑指offer #13）</li>
<li>剪绳子(剑指offer #14)</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Remove-Element-Leetcode-27"><a href="#Remove-Element-Leetcode-27" class="headerlink" title="Remove Element(Leetcode #27)"></a>Remove Element(Leetcode #27)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从一个数组中去除指定元素，返回新长度。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>很容易的题目，借鉴STL rmove的实现策略。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> newsize=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> index=<span class="number">0</span>;index!=nums.<span class="built_in">size</span>();++index)</span><br><span class="line">            <span class="keyword">if</span>(nums[index]!=val) </span><br><span class="line">                nums[newsize++]=nums[index];</span><br><span class="line">        <span class="keyword">return</span> newsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Next-Permutation-Leetcode-31）"><a href="#Next-Permutation-Leetcode-31）" class="headerlink" title="Next Permutation(Leetcode #31）"></a>Next Permutation(Leetcode #31）</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>还是STL中的算法，这里简单地描述一下如何实现：</p>
<ol>
<li>从后向前到找一组元素对，记作i,ii,满足<code>*i&lt;*ii</code>;如果找不到这样的元素对，翻转[first,last)；</li>
<li>从后向前，找到第一个比*i大的元素，记作j，swap(i,j);</li>
<li>翻转[ii,last)</li>
</ol>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> i =nums.<span class="built_in">end</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">auto</span> ii = nums.<span class="built_in">end</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=nums.<span class="built_in">begin</span>() &amp;&amp; !(*i&lt;*ii)) --i,--ii;</span><br><span class="line">        <span class="keyword">if</span>(i==nums.<span class="built_in">begin</span>() &amp;&amp; ((*ii)&lt;(*i)))&#123;</span><br><span class="line">            reverse(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> j =nums.<span class="built_in">end</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(*i&lt;*j)) --j;</span><br><span class="line">        swap(*i,*j);</span><br><span class="line">        reverse(ii,nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>剑指offer #38（输出所有字符串序列）也可采用此种方案实现，现有实现方案如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(str.empty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> old =str;</span><br><span class="line">        sort(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        res.push_back(str);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            next_permutation(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(str==old)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Permurtation-Sequence-Leetcode-60"><a href="#Permurtation-Sequence-Leetcode-60" class="headerlink" title="Permurtation Sequence(Leetcode #60)"></a>Permurtation Sequence(Leetcode #60)</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations.<br>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:<br>“123”、”132”、”213”、”231”、”312”、”321”<br>Given n and k, return the kth permutation sequence.<br><strong>Note:</strong><br>Given n will be between 1 and 9 inclusive.<br>Given k will be between 1 and n! inclusive.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 3, k &#x3D; 3</span><br><span class="line">Output: &quot;213&quot;</span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 9</span><br><span class="line">Output: &quot;2314&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>一个不太好的想法是利用STL next_permutation函数，循环k次自然能得到指定序列，但这种方法不甚可取。我们可以换一种思路，采用康托编码完成求解。该算法的核心思想是：假定第k个(康托编码从0计数）排列为<code>[a1,a2,a3,a4....,an]</code>，那么存在公式：<code>K=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[2]*1!+a[1]*0!</code>,也就是说，必有<code>a1=k/(n-1)!</code>，<code>a2=k%(n-1)!/(n-2)!</code>等等，其中<code>a[n]</code>代表比处在第n位的数字小，并且在第n位前面没有出现过的数字的个数。（个位是第1位）<br>核心计算流程可见<a href="https://blog.csdn.net/neutre/article/details/78065633" target="_blank" rel="noopener">https://blog.csdn.net/neutre/article/details/78065633</a></p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">rest</span><span class="params">(n, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> index = <span class="number">0</span>; index != n; index++)</span><br><span class="line">            rest[index] = <span class="string">'1'</span> + index;</span><br><span class="line">        <span class="keyword">if</span> (--k==<span class="number">0</span>) <span class="keyword">return</span> rest;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">result</span><span class="params">(n,<span class="string">'0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = rest.<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">            result[i] = rest[k/ factorial(n)]  ;</span><br><span class="line">            it=<span class="built_in">remove</span>(rest.<span class="built_in">begin</span>(), it, result[i++]);</span><br><span class="line">            k %= factorial(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> n*factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Plus-One-Leetcode-60"><a href="#Plus-One-Leetcode-60" class="headerlink" title="Plus One(Leetcode #60)"></a>Plus One(Leetcode #60)</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.<br>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>没什么好说的，做了一个小小的优化：一开始判定是不是由全9组成，是则直接构造返回值（似乎并不是优化）。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number9 = count(digits.cbegin(),digits.cend(),<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">if</span>(number9==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(number9+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ri=digits.rbegin();ri!=digits.rend();++ri)&#123;</span><br><span class="line">            *ri+=carry;</span><br><span class="line">            carry = *ri&gt;=<span class="number">10</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            *ri%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="矩阵中的路径（剑指offer-12）"><a href="#矩阵中的路径（剑指offer-12）" class="headerlink" title="矩阵中的路径（剑指offer #12）"></a>矩阵中的路径（剑指offer #12）</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。</p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>回溯。由于不能重复进入某个格子，因此需要定义一个bool数组保存进入情况。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><p>（这道题的数组用起来很不顺手，改天用纯C++写一个）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="literal">nullptr</span> || rows==<span class="number">0</span> || cols==<span class="number">0</span> ||str==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="literal">false</span>,rows*cols);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;           </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)                </span><br><span class="line">                <span class="keyword">if</span>(isHsaPath(matrix,rows,cols,str,visited,i,j))                   </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isHsaPath</span><span class="params">(<span class="keyword">char</span> *matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">char</span> *str,<span class="keyword">bool</span> *visited,<span class="keyword">int</span> curx,<span class="keyword">int</span> cury)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'\0'</span>)           </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;      </span><br><span class="line">        <span class="keyword">if</span>(cury==cols)       </span><br><span class="line">            curx++,cury=<span class="number">0</span>;          </span><br><span class="line">        <span class="keyword">if</span>(cury==<span class="number">-1</span>)</span><br><span class="line">            curx--,cury=cols<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(curx&lt;<span class="number">0</span>||curx&gt;=rows)           </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;      </span><br><span class="line">        <span class="keyword">if</span>(visited[curx*cols+cury]||*str!=matrix[curx*cols+cury])           </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;      </span><br><span class="line">        visited[curx*cols+cury]=<span class="literal">true</span>;      </span><br><span class="line">        <span class="keyword">bool</span> sign=isHsaPath(matrix,rows,cols,str+<span class="number">1</span>,visited,curx<span class="number">-1</span>,cury)</span><br><span class="line">                 ||isHsaPath(matrix,rows,cols,str+<span class="number">1</span>,visited,curx+<span class="number">1</span>,cury)       </span><br><span class="line">                 ||isHsaPath(matrix,rows,cols,str+<span class="number">1</span>,visited,curx,cury<span class="number">-1</span>)</span><br><span class="line">                 ||isHsaPath(matrix,rows,cols,str+<span class="number">1</span>,visited,curx,cury+<span class="number">1</span>); </span><br><span class="line">        visited[curx*cols+cury]=<span class="literal">false</span>;   </span><br><span class="line">        <span class="keyword">return</span> sign; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8=19。请问该机器人能够达到多少个格子？</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>类似于上一题，也可以采用回溯解决。这个问题中的visit数组不需要回溯，因为它仅仅表明该格子不再纳入计算而已。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">visited</span><span class="params">(rows)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:visited)</span><br><span class="line">            v.resize(cols,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> aux(<span class="number">0</span>,<span class="number">0</span>,rows,cols,visited,threshold);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">aux</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;visited,<span class="keyword">int</span> threshold)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=rows || j&lt;<span class="number">0</span> || j&gt;=cols || sum(i)+sum(j)&gt;threshold)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> aux(i<span class="number">-1</span>,j,rows,cols,visited,threshold)</span><br><span class="line">               +aux(i+<span class="number">1</span>,j,rows,cols,visited,threshold)</span><br><span class="line">               +aux(i,j<span class="number">-1</span>,rows,cols,visited,threshold)</span><br><span class="line">               +aux(i,j+<span class="number">1</span>,rows,cols,visited,threshold)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            res+=(i%<span class="number">10</span>);</span><br><span class="line">            i/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有一根长度为n的绳子，可将其剪为m段。试问绳长为n的情况下最大成绩是多少。</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>动态规划，已知f(n)=max(f(i)*f(n-i));用一个数组来记录绳子长度的最大成绩。</li>
<li>贪心，n&gt;=5时，尽可能多剪长度为3的绳子，当剩下的长度为4时，直接再剪为两段。</li>
</ol>
<h2 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxResult</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(length+<span class="number">1</span>)</span></span>;</span><br><span class="line">	res[<span class="number">0</span>] = <span class="number">0</span>;res[<span class="number">1</span>] = <span class="number">1</span>;res[<span class="number">2</span>] = <span class="number">2</span>;res[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> res[length];</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; i++) &#123;</span><br><span class="line">		<span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> r = res[j] * res[i - j];</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">max</span> &lt; r)</span><br><span class="line">				<span class="built_in">max</span> = r, res[i] = <span class="built_in">max</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxResult</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>*(length==<span class="number">3</span>)</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> number3 = length/<span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">if</span>(length - number3*<span class="number">3</span> == <span class="number">1</span>) number3 -= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> number2 = (length - number3*<span class="number">3</span>)/<span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, number3)*Math.<span class="built_in">pow</span>(<span class="number">2</span>, number2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（9）</title>
    <url>/2018/08/08/OJ%20exericse9/</url>
    <content><![CDATA[<p>（最近在写Json解析器，刷题的时间有所减少，今天只有五道剑指offer）</p>
<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>对称的二叉树（剑指offer #28）</li>
<li>顺时针打印矩阵(剑指offer #29)</li>
<li>包含min函数的栈（剑指offer #30）</li>
<li>栈混洗甄别（剑指offer #31）</li>
<li>树的层次遍历（剑指offer #32）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>递归，若root的左右子均存在，判断其值是否相等，再判断left-&gt;right与right-&gt;left是否相等 &amp;&amp; left-&gt;left与right-&gt;right是否相等。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!root)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> isS(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isS</span><span class="params">(TreeNode* left,TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left || !right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp; isS(left-&gt;left,right-&gt;right) &amp;&amp; isS(left-&gt;right,right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>设立好四个边界，依次遍历即可</p>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>||matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">0</span>,bottom=matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=(bottom+<span class="number">1</span>)*(right+<span class="number">1</span>);</span><br><span class="line">        res.resize(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i) res[count++]=matrix[top][i];</span><br><span class="line">            ++top;</span><br><span class="line">            <span class="keyword">if</span>(count==n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;=bottom;++i) res[count++]=matrix[i][right];</span><br><span class="line">            --right;</span><br><span class="line">            <span class="keyword">if</span>(count==n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;--i) res[count++]=matrix[bottom][i];</span><br><span class="line">            --bottom;</span><br><span class="line">            <span class="keyword">if</span>(count==n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom;i&gt;=top;--i) res[count++]=matrix[i][left];</span><br><span class="line">            ++left;</span><br><span class="line">            <span class="keyword">if</span>(count==n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="包含min的栈"><a href="#包含min的栈" class="headerlink" title="包含min的栈"></a>包含min的栈</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>用两个栈<code>substack</code>与<code>lastmin</code>和一个私有data member<code>min</code>实现这一数据结构。初始化时令<code>min=INT_MAX</code>。当执行pop操作时，若substack栈顶元素为min，令min=lastmin.top，pop lastmin,否则pop substack。当执行push操作时，若当前元素小于min，min等于当前元素，push进入lastmin，否则push入substacck。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&lt;minValue)&#123;</span><br><span class="line">            minValue=value;</span><br><span class="line">            lastmin.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        substack.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(substack.top()==minValue)&#123;</span><br><span class="line">            lastmin.pop();</span><br><span class="line">            minValue=lastmin.top();</span><br><span class="line">        &#125;</span><br><span class="line">        substack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> substack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; substack,lastmin;</span><br><span class="line">    <span class="keyword">int</span> minValue=INT_MAX;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="栈混洗甄别"><a href="#栈混洗甄别" class="headerlink" title="栈混洗甄别"></a>栈混洗甄别</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一个辅助栈,若栈为空或栈顶元素与对应元素不相等，一直入栈，若某时刻无法入栈则返回false。若栈顶元素与当前相等则出栈，执行下一次比对。</p>
<h2 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">auto</span> i=pushV.cbegin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j=popV.cbegin();j!=popV.cend();++j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp.empty() || temp.top()!=*j)</span><br><span class="line">                <span class="keyword">if</span>(i==pushV.cend())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> temp.push(*i++);</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>层次遍历即为BFS，记得使用队列。</p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que_aux;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        que_aux.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que_aux.empty())&#123;</span><br><span class="line">            TreeNode* temp = que_aux.front();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left) que_aux.push(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right) que_aux.push(temp-&gt;right);</span><br><span class="line">            que_aux.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>18.Over-eager evaluation</title>
    <url>/2018/04/26/Over-eager%20evaluation/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在上一节中，我们通过Lazy evalution来提高效率。但本节不存在Lazy，我们试图去让程序做的事情比被要求的还要多，通过这种方式来提高软件的性能。其核心就是本节主题Over-eager evaluation<strong>：在要求你做某些事情以前就完成它们</strong>。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>下述这个模板类表示一个存有大量数字型数据的集合：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NumericalType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DataCollection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">NumericalType <span class="title">min</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">NumericalType <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">NumericalType <span class="title">avg</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>假设 min,max 和 avg 函数分别返回现在这个集合的最小值，最大值和平均值，有三种方法实现这些功能：</p>
<ul>
<li>lazy evaluation<br>确实需要返回值我们才去计算。</li>
<li>eager evaluation<br>当函数被调用时，我们分析集合内所有数据，进行计算</li>
<li>over-eager evaluation<br>随时跟踪目前集合的min，max，avg（每当集合发生变化即更新数据）因此函数调用时无需计算。</li>
</ul>
<p>在频繁调用函数的情况下，我们把跟踪所花费的时间分摊于所有函数调用，那么实际花销反而比lazy与eager都要少。隐藏于其背后的思想是：如果一个计算需要频繁进行，那你应该设计某种数据结构进行高效处理，降低每一次计算的开销。</p>
<hr>
<h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><p>&nbsp;<br>over-eager evaluation最简单的实现是cache，缓存那些已经被计算出来并且以后可能仍然需要的值。<br>举例而言，办公室成员的所有信息都被放在数据库内，我们应该建立cache保存已经查到的信息，如此在以后需要时无需反复的查询数据库内部。<br>以下以办公人员隔间号作为信息举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCubicleNumber</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; employeeName)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; CubicleMap;</span><br><span class="line">    <span class="keyword">static</span> CubicleMap cubes;<span class="comment">//cache</span></span><br><span class="line">    <span class="keyword">auto</span> it = cubes.<span class="built_in">find</span>(employeeName);</span><br><span class="line">    <span class="keyword">if</span> (it == cubes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cubicle = <span class="comment">//search in database</span></span><br><span class="line">        cubes[employeeName] = cubicle;</span><br><span class="line">        <span class="keyword">return</span> cubicle;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*it).second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="prefetech"><a href="#prefetech" class="headerlink" title="prefetech"></a>prefetech</h1><p>&nbsp;<br>举例而言，每一次磁盘的读取并不是读你所需要的那一小块，而是直接读取一整块或者一个扇区。因为读取大块所需要的时间比读取好几个小块所需要的时间短，而且经验表明如果需要某一个地方的数据，那么也有可能会需要其周边的数据。（位置相关现象）正因为如此，系统设计者才有理由为指令与数据使用磁盘cache和内存cache，以及指令prefetch.<br>有可能你会说你对这种低级硬件处理没兴趣，那在数据结构中prefetch也有发挥作用。那就是vector的动态增长：一般而言，我们并不给vector分配恰好的cap，而是总是趋向于分配所需要的2倍大小，当vector饱和时，则再次分配当前cap两倍大小的cap.</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>本节的核心思想在于：更快的速度需要更多的内存，也就是以空间换时间的策略。<br>当你需要支持某些操作但不需要立即得到结果时，使用lazy evaluation。<br>当你必须支持某些操作并且其结果总是被不止一次的重复需求时，记得caching与prefetching。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>30.Proxy Class</title>
    <url>/2018/04/29/Proxy%20Class/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>C++无法自由地创建多维数组，你可能会作出反驳：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> data[<span class="number">10</span>][<span class="number">20</span>];</span><br></pre></td></tr></table></figure><br>但我指的是以变量作为构建数组的形参：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(<span class="keyword">int</span> dim1, <span class="keyword">int</span> dim2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[dim1][dim2];<span class="comment">//error</span></span><br><span class="line">    <span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[dim1][dim2];<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="实现二维数组"><a href="#实现二维数组" class="headerlink" title="实现二维数组"></a>实现二维数组</h1><p>&nbsp;<br>为了实现二维数组，我们不得不自己新建一个class，以期待完成功能：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array2D(<span class="keyword">int</span> dim1, <span class="keyword">int</span> dim2);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>遗憾的是Array2D生成的对象并不具备索引功能。也就是说：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Array2D&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[<span class="number">3</span>][<span class="number">6</span>];<span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>我们只能最多重载一个operator[]，不可能重载operator[][]（详见More Effective C++ 7）。<br>事实上，我们完全有理由相信，一个二维数组在调用operator[]后应当返回一个Array1D对象，然后我们通过重载Array1D的operator[]即可顺利完成索引操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">Array2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Array1D</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">        <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line">    Array1D <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    <span class="keyword">const</span> Array1D <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Array2D&lt;<span class="keyword">float</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[<span class="number">3</span>][<span class="number">6</span>];<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><br>Array2D的用户并不需要知道Array1D类的存在。这个背后的“一维数组”对象从概念上来说，并不是为 Array2D 类的用户而存在的。其用户编程时就象他们在使用真正的二维数组一样<br>每个Array1D对象扮演的是一个一维数组，而这个一维数组并不存在于使用Array2D的程序中<strong>。“用来代表其他对象”的对象通常被称为代理类。</strong>Array1D就是一个代理类，它的对象扮演的是一个在概念上不存在的一维数组。</p>
<hr>
<h1 id="区分opeator-的读写操作"><a href="#区分opeator-的读写操作" class="headerlink" title="区分opeator[]的读写操作"></a>区分opeator[]的读写操作</h1><p>&nbsp;<br>​我们已经了解operator[]会在两种不同的情况下调用：读和写。读是一个右值操作而写是一个左值操作。<br>在实现引用计数时我们假设所有operator[]操作均为写，这直接导致了一系列麻烦的操作，以及shareable标志位的诞生。<br>事实上我们可以通过Proxy class区分operato[]的操作，其原理为：<strong>将判断读和写的行为推迟到我们明确operator[]的结果会被如何使用</strong>。显然，这是Lzay evaluation的一大体现。</p>
<h2 id="String中的proxy对象"><a href="#String中的proxy对象" class="headerlink" title="String中的proxy对象"></a>String中的proxy对象</h2><p>结合String实例,我们可以修改operator[],令其返回一个proxy对象而非字符本身，然后观察proxy会被如何使用。<br>String中的proxy对象只能做3件事：</p>
<ol>
<li>创建，指定扮演哪个字符</li>
<li>将其作为赋值的目标，此时扮演左值</li>
<li>以其他方式使用，扮演右值</li>
</ol>
<p>以带有引用计数的String class为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CharProxy</span> &#123;</span> <span class="comment">// proxies for string chars</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CharProxy(<span class="keyword">String</span>&amp; str, <span class="keyword">int</span> index);</span><br><span class="line">        CharProxy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CharProxy&amp; rhs);</span><br><span class="line">        CharProxy&amp; <span class="keyword">operator</span>=(<span class="keyword">char</span> c);</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">String</span>&amp; theString;</span><br><span class="line">        <span class="keyword">int</span> charIndex;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> CharProxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    CharProxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CharProxy</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当前String的operator[]函数将返回的是CharProxy对象。然而，String类的用户并不需要了解这一点：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s1, s2;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1[<span class="number">5</span>];</span><br><span class="line">s2[<span class="number">5</span>] = <span class="string">'x'</span>;</span><br><span class="line">s1[<span class="number">3</span>] = s2[<span class="number">8</span>];</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="右值操作"><a href="#右值操作" class="headerlink" title="右值操作"></a>右值操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; s1[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>表达式s1[5]返回的是一个CharProxy对象。由于Proxy对象并没有定义IO流操作，于是编译器开始试图寻找令该语句编译成功的方法，最终找到了隐式转换。以上是代理类被作为右值操作时的常规行为。</p>
<h3 id="左值操作"><a href="#左值操作" class="headerlink" title="左值操作"></a>左值操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s2[<span class="number">5</span>] = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure>
<p>表达式s2[5]返回的是一个CharProxy对象，但这次它是赋值操作的目标。由于赋值的目标是CharProxy 类，因此调用的是harProxy类中的赋值操作。这至关重要，因为<strong>当进入Proxy对象的赋值函数时，我们明确当前String的operator[]执行了左值操作</strong>，因此有必要执行某些操作保证程序正常运行。</p>
<hr>
<h2 id="String的operator-实现"><a href="#String的operator-实现" class="headerlink" title="String的operator[]实现"></a>String的operator[]实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">String</span>::CharProxy <span class="keyword">String</span>::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CharProxy(<span class="keyword">const_cast</span>&lt;<span class="keyword">String</span>&amp;&gt;(*<span class="keyword">this</span>), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>::CharProxy <span class="keyword">String</span>::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">return</span> CharProxy(*<span class="keyword">this</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个函数都创建和返回一个proxy对象来代替字符。根本没有对那个字符作任何操作:我们将它推迟到直到我们知道是读操作还是写操作。<br>需要注意的是const版本返回一个const Proxy对象，因此它不能被赋值，这正是我们想要的。并且在该函数中为了与构造函数匹配，我们使用了类型转换，此处类型转换构造的对象也是const，不用担心数据被篡改的问题。</p>
<hr>
<h2 id="Proxy对象的实现"><a href="#Proxy对象的实现" class="headerlink" title="Proxy对象的实现"></a>Proxy对象的实现</h2><h3 id="构造与转换"><a href="#构造与转换" class="headerlink" title="构造与转换"></a>构造与转换</h3><p>通过operator[]返回的proxy对象记录了它属于哪个string，以及下标。当proxy对象作为右值被使用时，其返回值是一个不可修改的proxy对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>::CharProxy::CharProxy(<span class="keyword">String</span>&amp; str, <span class="keyword">int</span> index)</span><br><span class="line">: theString(str), charIndex(index) &#123;&#125;</span><br><span class="line"><span class="keyword">String</span>::<span class="function">CharProxy::<span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> theString.value-&gt;data[charIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><p>赋值操作的实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>::CharProxy&amp;</span><br><span class="line"><span class="keyword">String</span>::CharProxy::<span class="keyword">operator</span>=(<span class="keyword">const</span> CharProxy&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;isShared()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> StringValue(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    theString.value-&gt;data[charIndex] = rhs.theString.value-&gt;data[rhs.charIndex];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以char作为形参执行的赋值操作也大同小异：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>::CharProxy&amp; <span class="keyword">String</span>::CharProxy::<span class="keyword">operator</span>=(<span class="keyword">char</span> c)&#123;</span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;isShared()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> StringValue(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    theString.value-&gt;data[charIndex] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然，我们应当编写一个private member function消除它们之间的代码重复。</p>
<hr>
<h1 id="Porxy-class的局限性"><a href="#Porxy-class的局限性" class="headerlink" title="Porxy class的局限性"></a>Porxy class的局限性</h1><p>Proxy并非完美，在某些场合下它离无缝替代差的很远。</p>
<h2 id="取址"><a href="#取址" class="headerlink" title="取址"></a>取址</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;s1[<span class="number">1</span>]; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>我们没法把一个charProxy*赋值给char*，要解决的话只能重载取址运算符。<br>const版本很容易实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">String</span>::CharProxy::<span class="keyword">operator</span>&amp;() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(theString.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>non-const版本则颇类似于前一节中的operator[]:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">String</span>::CharProxy::<span class="keyword">operator</span>&amp;()&#123;</span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;isShared()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> StringValue(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    theString.value-&gt;markUnshareable();<span class="comment">//无法保证其被用于何种操作，因此锁定不可共享</span></span><br><span class="line">    <span class="keyword">return</span> &amp;(theString.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="带引用计数的数组模板"><a href="#带引用计数的数组模板" class="headerlink" title="带引用计数的数组模板"></a>带引用计数的数组模板</h2><p>如果我们想用proxy类来区分其operator[]作左值还是右值时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Proxy(Array&lt;T&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> index);</span><br><span class="line">        Proxy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; rhs);</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> Proxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    Proxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该带有引用计数的数组可能被这样使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Array&lt;<span class="keyword">int</span>&gt; intArray;</span><br><span class="line">...</span><br><span class="line">intArray[<span class="number">5</span>] = <span class="number">22</span>;</span><br><span class="line">intArray[<span class="number">5</span>] += <span class="number">5</span>;<span class="comment">//error!</span></span><br><span class="line">++intArray[<span class="number">5</span>];<span class="comment">//error!</span></span><br></pre></td></tr></table></figure><br>无法编译的原因在于我们没有为代理类重载这些操作符。相似的，我们也无法通过代理类来调用实际对象的member function，也没法作为非const的引用传给函数。</p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>我们之所以能用代理类是因为它和真实对象间存在隐式转换，但当我们期待原对象发生隐式转换时，表达式将无法通过编译，原因在于隐式转换无法在同一时间触发多次。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>Proxy Class可以完成一些其它方法很难甚至不可能实现的行为,例如：</p>
<ol>
<li>多维数组</li>
<li>区分左右值操作</li>
<li>限制隐式类型转换</li>
</ol>
<p>Proxy Class亦有缺点，代理对象始终是一个临时对象，不可避免地存在着构造与析构的成本。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ每日练习（8）</title>
    <url>/2018/08/07/OJ%20exercise8/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><ol>
<li>Swap Nodes in Pairs(Leetcode #24)</li>
<li>Copy List with Random Pointer(Leetcode #138）</li>
<li>Linked List Cycle(Leetcode #141)</li>
<li>Reorder List(Leetcode #143)</li>
<li>LRU Cache（Leetcode #146）</li>
<li>环的入口节点（剑指offer #23）</li>
<li>翻转链表(剑指offer #24)</li>
<li>合并已排序的链表（剑指offer #25）</li>
<li>树的子结构（剑指offer #26）</li>
<li>二叉树的镜像（剑指offer #27）</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="Swap-Nodes-in-Pairs-Leetcode-24"><a href="#Swap-Nodes-in-Pairs-Leetcode-24" class="headerlink" title="Swap Nodes in Pairs(Leetcode #24)"></a>Swap Nodes in Pairs(Leetcode #24)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, swap every two adjacent nodes and return its head.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><br><strong>Note:</strong><br>Your algorithm should use only constant extra space.You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>迭代版：采用三指针从头到尾遍历，当不再存在一对节点时终止遍历。<br>递归版：对于一对节点，我们只需要明确，first-&gt;newfirst，second-&gt;first,当不再存在节点对时终止递归。</p>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="function">ListNode <span class="title">preHead</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        preHead.next = head;</span><br><span class="line">        ListNode* pre=&amp;preHead,*cur=head,*next=cur-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            pre-&gt;next=next;</span><br><span class="line">            cur-&gt;next=next-&gt;next;</span><br><span class="line">            next-&gt;next=cur;</span><br><span class="line">            pre=cur;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next) cur=cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> preHead.next;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next) next=cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> preHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(head-&gt;next-&gt;next);</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Copy-List-with-Random-Pointer-Leetcode-138）"><a href="#Copy-List-with-Random-Pointer-Leetcode-138）" class="headerlink" title="Copy List with Random Pointer(Leetcode #138）"></a>Copy List with Random Pointer(Leetcode #138）</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.Return a deep copy of the list.</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以用hashmap完成存储，但这里我采用的时空间O(1)的算法。思路大致如下：</p>
<ol>
<li>针对每一个节点都完成复制，从而令链表1—&gt;2-&gt;3变成1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3</li>
<li>将random节点进行连接，具体表现为cur-&gt;next-&gt;random=cur-&gt;random-&gt;next</li>
<li>分离两个链表</li>
</ol>
<h2 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode* cur=head,*next=cur-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            RandomListNode* copy = <span class="keyword">new</span> RandomListNode(cur-&gt;label);</span><br><span class="line">            cur-&gt;next=copy;</span><br><span class="line">            copy-&gt;next=next;</span><br><span class="line">            cur=next;</span><br><span class="line">            next=next?next-&gt;next:<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=head,next=cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;<span class="built_in">random</span>)</span><br><span class="line">                cur-&gt;next-&gt;<span class="built_in">random</span> = cur-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">            cur=next;</span><br><span class="line">            next=next?next-&gt;next-&gt;next:<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=head,next=cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="function">RandomListNode <span class="title">pre</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        pre.next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            cur-&gt;next-&gt;next = next?next-&gt;next:<span class="literal">nullptr</span>;</span><br><span class="line">            cur-&gt;next=next;</span><br><span class="line">            cur=next;</span><br><span class="line">            next=next?next-&gt;next-&gt;next:<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Linked-List-Cycle-Leetcode-141"><a href="#Linked-List-Cycle-Leetcode-141" class="headerlink" title="Linked List Cycle(Leetcode #141)"></a>Linked List Cycle(Leetcode #141)</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>快慢指针，没什么好说的。</p>
<h2 id="解题方案-2"><a href="#解题方案-2" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    ListNode *p = head, *q = p;</span><br><span class="line">	    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">		    p = p-&gt;next-&gt;next;</span><br><span class="line">		    q = q-&gt;next;</span><br><span class="line">		    <span class="keyword">if</span> (p == q) </span><br><span class="line">		        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.Note: Do not modify the linked list.</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>还是快慢指针，p的前进速度是q的两倍。设head到环起点的距离为S,环起点到pq相遇点的距离为M。假设当他们相遇时q走了K步，显然存在K=S+M。又p走了2K步（速度2倍），表明环的长度为K，即q再走K-M步必然到达环起点，而K-M=S。因此令一个指针从head前进，当其与q相遇时必然该点为环起点。</p>
<h3 id="解题方案-3"><a href="#解题方案-3" class="headerlink" title="解题方案"></a>解题方案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p=head,*q=p;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">            p=p-&gt;next-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p==q)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p!=q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* k=head;</span><br><span class="line">        <span class="keyword">while</span>(k!=q)</span><br><span class="line">            k=k-&gt;next,q=q-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Reorder-List-Leetcode-143"><a href="#Reorder-List-Leetcode-143" class="headerlink" title="Reorder List(Leetcode #143)"></a>Reorder List(Leetcode #143)</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…<br>You may not modify the values in the list’s nodes, only nodes itself may be changed.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>解题思路大致是找到中间的那个节点，然后前半部分不动，后半部分翻转，然后再合并两个链表，大致如下所示：<code>1-&gt;2-&gt;3-&gt;4-&gt;5 1-&gt;2-&gt;3&lt;-4&lt;-5 1-&gt;5-&gt;2-&gt;4-&gt;3</code></p>
<h2 id="解题方案-4"><a href="#解题方案-4" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head ||!head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode* p =head,*q=p;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;next)&#123;<span class="comment">//not p &amp;&amp; p-&gt;next</span></span><br><span class="line">            p=p-&gt;next-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;<span class="comment">//q is the middle node</span></span><br><span class="line">        ListNode* cur = q-&gt;next;</span><br><span class="line">        q-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next=q;</span><br><span class="line">            q=cur;</span><br><span class="line">            cur=temp;</span><br><span class="line">        &#125;<span class="comment">//q is the new first node</span></span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* next =cur-&gt;next;</span><br><span class="line">            ListNode* newnext = q-&gt;next;</span><br><span class="line">            cur-&gt;next=q;</span><br><span class="line">            q-&gt;next = next;</span><br><span class="line">            q=newnext;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="LRU-Cache（Leetcode-146）"><a href="#LRU-Cache（Leetcode-146）" class="headerlink" title="LRU Cache（Leetcode #146）"></a>LRU Cache（Leetcode #146）</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.<br>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.<br><strong>Follow up:</strong><br>Could you do both operations in O(1) time complexity?<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们采用hashmap与双链表来完成LRU算法，原因在于双链表的插入与删除可以O(1),hashmap的查找可以O（1）。<br>具体实现细节：</p>
<ol>
<li>越靠近链表头部说明最近使用频次越高，反之则说明最少。</li>
<li>访问节点时，若该节点存在，将其交换至链表头部，同时更新hashmap中该节点的地址。</li>
<li>插入节点时，若size已饱和，将list尾端元素删除，同时删除hashmap中对应的项，将新节点放在链表头部。</li>
</ol>
<h2 id="解题方案-5"><a href="#解题方案-5" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LRUCache.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CacheNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	CacheNode(<span class="keyword">int</span> k, <span class="keyword">int</span> v) :key(k), value(v) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;CacheNode&gt; cacheList;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;CacheNode&gt;::iterator&gt; cacheMap;</span><br><span class="line">	<span class="keyword">size_t</span> capacity;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LRUCache(<span class="keyword">int</span> cap) :capacity(cap) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	LRUCache() &#123;&#125;;<span class="comment">//Exists no LRUCache without a cap</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//LRUCache.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LRUCache.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LRUCache::get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cacheMap.<span class="built_in">find</span>(key) == cacheMap.<span class="built_in">end</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//move the element to the list's begin so we determine it as the recently used element</span></span><br><span class="line">		cacheList.splice(cacheList.<span class="built_in">begin</span>(), cacheList, cacheMap[key]);</span><br><span class="line">		cacheMap[key] = cacheList.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">return</span> cacheMap[key]-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::set</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cacheMap.<span class="built_in">find</span>(k) == cacheMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cacheList.<span class="built_in">size</span>() == capacity) &#123;</span><br><span class="line">			<span class="comment">//erase the least used lement from both map and list</span></span><br><span class="line">			cacheMap.erase(cacheList.back().key);</span><br><span class="line">			cacheList.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//insert the CacheNode into the list and map</span></span><br><span class="line">		cacheList.insert(cacheList.<span class="built_in">begin</span>(), CacheNode(k, v));</span><br><span class="line">		cacheMap[k] = cacheList.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//Update the CacheNode's value and move it to the list's begin</span></span><br><span class="line">		cacheMap[k]-&gt;value = v;</span><br><span class="line">		cacheList.splice(cacheList.<span class="built_in">begin</span>(), cacheList, cacheMap[k]);</span><br><span class="line">		cacheMap[k] = cacheList.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="环的入口节点（剑指offer-23）"><a href="#环的入口节点（剑指offer-23）" class="headerlink" title="环的入口节点（剑指offer #23）"></a>环的入口节点（剑指offer #23）</h1><p>（本题已在上文有所提及，略去不表）</p>
<hr>
<h1 id="翻转链表-剑指offer-24"><a href="#翻转链表-剑指offer-24" class="headerlink" title="翻转链表 (剑指offer #24)"></a>翻转链表 (剑指offer #24)</h1><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>无非是分为迭代和递归两种。<br>迭代：<code>1-&gt;2-&gt;3 =&gt;  1&lt;-2 3 =&gt; 1&lt;-2&lt;-3</code><br>递归：找出末尾节点p=func(head)，然后对于每一个输入节点head，都有head-&gt;next-&gt;next=head,head-&gt;next=nullptr;</p>
<h2 id="解题方案-6"><a href="#解题方案-6" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *p = ReverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next=head;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="合并已排序的链表（剑指offer-25）"><a href="#合并已排序的链表（剑指offer-25）" class="headerlink" title="合并已排序的链表（剑指offer #25）"></a>合并已排序的链表（剑指offer #25）</h1><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接参考了STL merge算法。</p>
<h2 id="解题方案-7"><a href="#解题方案-7" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">pre</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        ListNode *cur=&amp;pre;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val) cur=cur-&gt;next=l1,l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> cur=cur-&gt;next=l2,l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next=l1?l1:l2;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="树的子结构（剑指offer-26）"><a href="#树的子结构（剑指offer-26）" class="headerlink" title="树的子结构（剑指offer #26）"></a>树的子结构（剑指offer #26）</h1><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>递归解法建立在求解两个树是否相等的基础上。撰写一个判断两个树是否相等的函数，然后再主函数中针对左右子树递归调用即可。</p>
<h2 id="解题方案-8"><a href="#解题方案-8" class="headerlink" title="解题方案"></a>解题方案</h2><p>（本解法认为空树是任何树的子树）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isSame(s,t)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(s-&gt;left,t)||isSubtree(s-&gt;right,t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* a, TreeNode*b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a&amp;&amp;!b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((!a||!b)||a-&gt;val!=b-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(a-&gt;left,b-&gt;left) &amp;&amp; isSame(a-&gt;right,b-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="树的镜像"><a href="#树的镜像" class="headerlink" title="树的镜像"></a>树的镜像</h1><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>同样是递归思路求解。递归过程如下：</p>
<ol>
<li>root为空，返回；</li>
<li>若root不为空，交换两颗子树，并对它们执行镜像操作。</li>
</ol>
<h2 id="解题方案-9"><a href="#解题方案-9" class="headerlink" title="解题方案"></a>解题方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        swapTree(pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapTree</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        swap(root-&gt;left,root-&gt;right);</span><br><span class="line">        swapTree(root-&gt;left);</span><br><span class="line">        swapTree(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ Exercises</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>VimTutor小结</title>
    <url>/2020/05/05/VimTutor/</url>
    <content><![CDATA[<p>本文为vimtutor总结，仅摘录部分常用vim语句以供复习。<br><a id="more"></a></p>
<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>i   输入欲插入文本 &lt;ESC&gt;            在光标前插入文本<br>A   输入欲添加文本&lt;ESC&gt;             在一行后添加文本</p>
<hr>
<h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><ol>
<li>欲从当前光标删除至下一个单词，请输入：dw</li>
<li>欲从当前光标删除至当前行末尾，请输入：d$</li>
<li>欲删除整行，请输入：dd</li>
<li>在正常模式下修改命令的格式是：<code>operator   [number]   motion</code><br>其中：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operator - 操作符，代表要做的事情，比如 d 代表删除</span><br><span class="line">[number] - 可以附加的数字，代表动作重复的次数</span><br><span class="line">motion   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，$ 代表行末等等。</span><br></pre></td></tr></table></figure></li>
<li>欲移动光标到行首，请按数字0键：0</li>
<li>欲撤消以前的操作，请输入：u<br>欲撤消在一行中所做的改动，请输入：U<br>欲撤消以前的撤消命令，恢复以前的操作结果，请输入：<code>CTRL-R</code></li>
</ol>
<hr>
<h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><ol>
<li>要重新置入已经删除的文本内容，请输入 p。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。(被删除文本存入缓存，个人认为类似于剪切)。</li>
<li>要替换光标所在位置的字符，请输入r和要替换掉原位置字符的新字符即可。</li>
<li>更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入ce可以替换当前光标到单词的末尾的内容；输入c$可以替换当前光标到行末的内容。</li>
<li>更改类命令的格式是：<code>c   [number]   motion</code></li>
</ol>
<hr>
<h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><ol>
<li><code>CTRL-g</code> 用于显示当前光标所在位置和文件状态信息。<br>G用于将光标跳转至文件最后一行。<br>gg用于将光标跳转至文件第一行。<br>先敲入一个行号然后输入G则是将光标移动至该行号代表的行。</li>
<li>输入/然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。<br>输入?然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。<br>完成一次查找之后按n键是重复上一次的命令，可在同一方向上查找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。<br><code>CTRL-O</code>带您跳转回较旧的位置，<code>CTRL-I</code>则带您到较新的位置。</li>
<li>如果光标当前位置是括号(、)、[、]、{、}，按%会将光标移动到配对的括号上。</li>
<li>在一行内替换<strong>头一个</strong>字符串 old 为新的字符串 new，请输入  <code>:s/old/new</code><br>在一行内替换<strong>所有的</strong>字符串 old 为新的字符串 new，请输入  <code>:s/old/new/g</code><br>在<strong>两行内</strong>替换所有的字符串 old 为新的字符串 new，请输入  <code>:#,#s/old/new/g</code><br>进行<strong>全文替换时询问用户</strong>确认每个替换<strong>需添加 c 标志</strong>      <code>:%s/old/new/gc</code></li>
</ol>
<hr>
<h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><ol>
<li><code>:!command</code>用于执行一个外部命令 command。如<code>:!ls :rm sth</code>  </li>
<li><code>:w FILENAME</code>  可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。</li>
<li><code>v motion :w FILENAME</code> 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。</li>
<li><code>:r FILENAME</code>可提取磁盘文件FILENAME并将其插入到当前文件的光标位置后面。</li>
<li><code>:r !dir</code>可以读取dir命令的输出并将其放置到当前文件的光标位置后面。</li>
</ol>
<hr>
<h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><ol>
<li>输入o可以在光标下方打开新的一行并进入插入模式。<br>输入O可以在光标上方打开新的一行。</li>
<li>输入a可以在光标所在位置之后插入文本 。<br>输入A可以在光标所在行的行末之后插入文本。</li>
<li>e命令可以使光标移动到单词末尾，因此在单词后插入为ea。</li>
<li>操作符y复制文本，p粘贴先前复制的文本。</li>
<li>输入R将进入替换模式，直至按&lt;ESC&gt;键回到正常模式。</li>
<li>输入 <code>:set xxx</code> 可以设置 xxx 选项。一些有用的选项如下：<br> ‘ic’ ‘ignorecase’       查找时忽略字母大小写<br> ‘is’ ‘incsearch’        查找短语时显示部分匹配<br> ‘hls’ ‘hlsearch’        高亮显示所有的匹配短语<br> 选项名可以用完整版本，也可以用缩略版本。</li>
<li>在选项前加上 no 可以关闭选项：<code>:set noic</code></li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>12. STL容器的线程安全性</title>
    <url>/2018/04/09/STL%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h1 id="STL提供的线程安全性"><a href="#STL提供的线程安全性" class="headerlink" title="STL提供的线程安全性"></a>STL提供的线程安全性</h1><p>&nbsp;<br>基本上STL容器提供的线程安全性只有以下两点：</p>
<ol>
<li><strong>多个线程读取是安全的</strong><br>多个线程可以读同一个容器内的数据，读时不允许写操作</li>
<li><strong>多个线程对不同的容器写入是安全的</strong></li>
</ol>
<hr>
<h1 id="如何实现线程安全性"><a href="#如何实现线程安全性" class="headerlink" title="如何实现线程安全性"></a>如何实现线程安全性</h1><p>&nbsp;<br>完全的线程安全很难实现，一个库可能试图以下列方式实现这样完全线程安全的容器：</p>
<ol>
<li>对于容器成员函数的每一次调用都锁住该容器直到调用完成。</li>
<li>在容器返回的迭代器生存期结束之前锁住容器</li>
<li>对于作用于容器的每个算法，在算法执行期间都锁住容器。（实际上这一点毫无必要，因为算法无法识别它们正在操作的容器)</li>
</ol>
<hr>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>&nbsp;<br>现在考虑一个例子：将vector内的第一个5改成0，如果它存在的话。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>())&#123;</span><br><span class="line">    *first5 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在多线程运行环境中，另一个线程可能在find操作完成后立刻修改v中的数据。那样第三行与v.end的检测将毫无意义，因为v的元素已经不再是原来的元素。并且如果执行了插入或者删除操作，first5也已经失效。<br>之前列举的3个方法都无法防止上述问题，迭代器调用返回得很快，生存期只有一行，find也是，无法帮助锁定。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>为了保证上述代码的线程安全，v必须从行1到行3都保持锁定，STL无法做到自动判断容器是否需要锁定，因此必须手动完成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">getMutexFor(v);<span class="comment">//需要自己实现的容器锁操作</span></span><br><span class="line"><span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    *first5 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">releaseMutexFor(v);</span><br></pre></td></tr></table></figure><br>从面向对象的角度而言，解决方法是构建一个lock类，其类模板大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Template&lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Lock(<span class="keyword">const</span> Containers container)</span><br><span class="line">        : c(container)&#123;</span><br><span class="line">            getMutexFor(c);</span><br><span class="line">        &#125;</span><br><span class="line">    ~Lock()&#123;</span><br><span class="line">        releaseMutexFor(c); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> Container&amp; c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，这种方法是在用类来管理资源的生存期（RAII)，其使用案例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">lock</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *first5 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//lock对象析构，v解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>另外，这种解决方案是异常安全的，因<strong>为在异常发生的情况下，局部对象会被销毁，此时lock也会释放互斥量</strong>。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>STL允许在一个容器上的多线程读取和不同容器上的多线程写入，除此之外不能依赖任何库自带的线程安全性。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>多线程</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp dev tools &amp;&amp; clang tools</title>
    <url>/2023/12/18/c++%20dev%20tools%20&amp;&amp;%20clang%20tools/</url>
    <content><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><ol>
<li>C++ dev tools</li>
<li>clang tools</li>
</ol>
<a id="more"></a>
<hr>
<h1 id="C-dev-tools"><a href="#C-dev-tools" class="headerlink" title="C++ dev tools"></a>C++ dev tools</h1><h2 id="why-we-need-tools"><a href="#why-we-need-tools" class="headerlink" title="why we need tools"></a>why we need tools</h2><p>C makes it easy to shoot yourself in the foot;<br>C++ makes it harder, but when you do it blows your whole leg off.                             </p>
<p align="right">-- Bjarne Stroustrup</p>                 

<p>C++ is a powerful language, but it is also a complex language, so it is easy to import bad smell code into cur project.<br>We can keep our code high quality by code review, but it is not efficient and not enough.<br>CR is a human work, it cost too many time and energy to find some simple or hide bugs.<br>So we need some tools to help us to find the simple bugs automatically and bring our attention to the important &amp;&amp; interesting things.</p>
<h3 id="what-is-good-code"><a href="#what-is-good-code" class="headerlink" title="what is good code"></a>what is good code</h3><ul>
<li>easy to read</li>
<li>easy to maintain</li>
<li>easy to use</li>
<li>work as expected</li>
<li>work fast</li>
</ul>
<h2 id="tools-help-us-write-good-code"><a href="#tools-help-us-write-good-code" class="headerlink" title="tools help us write good code"></a>tools help us write good code</h2><ol>
<li>formatter</li>
<li>code generator</li>
<li>code analyzer</li>
<li>code refactor tools</li>
<li>test framework</li>
<li>benchmark (test) framework</li>
</ol>
<hr>
<h3 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h3><h4 id="why-we-need-formatter"><a href="#why-we-need-formatter" class="headerlink" title="why we need formatter"></a>why we need formatter</h4><ul>
<li>ensure consistent code style accross the code data base</li>
<li>reduce time on code style discussions</li>
<li>keep CR reviewer focus on logic</li>
<li>automatically format code to save time</li>
</ul>
<h4 id="when-we-format-code"><a href="#when-we-format-code" class="headerlink" title="when we format code"></a>when we format code</h4><ul>
<li>save file</li>
<li>pre-commit hook</li>
<li>CI</li>
</ul>
<h4 id="formatter-tools-list"><a href="#formatter-tools-list" class="headerlink" title="formatter tools list"></a>formatter tools list</h4><ul>
<li>clang-format</li>
<li>astyle</li>
<li>…</li>
</ul>
<hr>
<h3 id="code-generator"><a href="#code-generator" class="headerlink" title="code generator"></a>code generator</h3><h4 id="why-we-need-code-generator"><a href="#why-we-need-code-generator" class="headerlink" title="why we need code generator"></a>why we need code generator</h4><ul>
<li>reduce time on boring work</li>
<li>keep code style guidelines</li>
<li>use common design patterns</li>
<li>avoid human error</li>
</ul>
<h4 id="when-we-use-code-generator"><a href="#when-we-use-code-generator" class="headerlink" title="when we use code generator"></a>when we use code generator</h4><ul>
<li>generate implementation codesnippet from a interface</li>
<li>generate ctor &amp;&amp; dtor &amp;&amp; copy ctor &amp;&amp; move ctor &amp;&amp; copy assignment &amp;&amp; move assignment </li>
<li>generate getter &amp;&amp; setter member function</li>
<li>generate implementation codesnippet from a proto</li>
<li>…</li>
</ul>
<h4 id="code-generator-tools-list"><a href="#code-generator-tools-list" class="headerlink" title="code generator tools list"></a>code generator tools list</h4><ul>
<li>IDES(Visual Studio, CLion, …)</li>
<li>protoc</li>
<li>…</li>
</ul>
<hr>
<h3 id="code-analyzer"><a href="#code-analyzer" class="headerlink" title="code analyzer"></a>code analyzer</h3><h4 id="why-we-need-code-analyzer-linter"><a href="#why-we-need-code-analyzer-linter" class="headerlink" title="why we need code analyzer (linter)"></a>why we need code analyzer (linter)</h4><ul>
<li>find undefined behavior &amp;&amp; potential bugs automatically</li>
<li>find bad smell code automatically</li>
<li>keep code style guidelines (modernize, readability, performance, …)</li>
<li>…</li>
</ul>
<h4 id="static-analyzer"><a href="#static-analyzer" class="headerlink" title="static analyzer"></a>static analyzer</h4><ul>
<li>Build warnings</li>
<li>Other tools<ul>
<li>clang-tidy</li>
<li>coverity</li>
<li>cppcheck</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="dynamic-analyzer"><a href="#dynamic-analyzer" class="headerlink" title="dynamic analyzer"></a>dynamic analyzer</h4><ul>
<li>valgrind</li>
<li>address sanitizer</li>
<li>…</li>
</ul>
<hr>
<h3 id="code-refactor-tools"><a href="#code-refactor-tools" class="headerlink" title="code refactor tools"></a>code refactor tools</h3><h4 id="what-is-refactor"><a href="#what-is-refactor" class="headerlink" title="what is refactor"></a>what is refactor</h4><ul>
<li>Basic set<ul>
<li>rename</li>
<li>extract function</li>
<li>…</li>
</ul>
</li>
<li>Profound set<ul>
<li>change function signature</li>
<li>push/pull data member up/down in class hierarchy</li>
<li>modernize</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="why-we-need-refactor-tools"><a href="#why-we-need-refactor-tools" class="headerlink" title="why we need refactor tools"></a>why we need refactor tools</h4><p>Maybe you will say, we can do refactor by hand or use regex, why we need tools to do it?</p>
<p>Just think about rename:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example for confusing names</span></span><br><span class="line">Struct stat stat; <span class="comment">// stat is a struct name, but also a variable name</span></span><br><span class="line">stat(<span class="string">"file"</span>, &amp;stat); <span class="comment">// stat is a function name</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, stat.<span class="built_in">size</span>);</span><br></pre></td></tr></table></figure>
<p>If we want to rename struct name ‘stat’ to ‘Mystat’, how can we do it?<br>We can use refactor tools such like clang-rename to do it, thanks clangParse, clangSema, clangAST and many other tools did the hard work.</p>
<h4 id="code-refactor-tools-list"><a href="#code-refactor-tools-list" class="headerlink" title="code refactor tools list"></a>code refactor tools list</h4><ul>
<li>IDES(Visual Studio, CLion, …)</li>
<li>clangRefactor</li>
<li>clangMR(MapReduce)</li>
<li>…</li>
</ul>
<hr>
<h3 id="test-framework"><a href="#test-framework" class="headerlink" title="test framework"></a>test framework</h3><p>Every one know test is important, so I will not talk about why we need test.</p>
<h4 id="test-framework-list"><a href="#test-framework-list" class="headerlink" title="test framework list"></a>test framework list</h4><ul>
<li>Google Test</li>
<li>Boost.Test</li>
<li>…</li>
</ul>
<hr>
<h3 id="benchmark-test-framework"><a href="#benchmark-test-framework" class="headerlink" title="benchmark (test) framework"></a>benchmark (test) framework</h3><h4 id="what-is-benchmark"><a href="#what-is-benchmark" class="headerlink" title="what is benchmark"></a>what is benchmark</h4><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h5><p>For example, we want to compare the performance of two implements.<br>First one use <code>std::unordered_map</code> to store the data, and second one use <code>std::map</code> to store the data.<br>We know <code>std::unordered_map</code> is faster than <code>std::map</code>, but we don’t know how much find faster when we use them store 10000 int and with a O2 optimization.<br>So we write benchmark code to compare them.  </p>
<p><a href="https://quick-bench.com/q/JMw0rZ4-Ucaytj2j0uduX8kAHbA" target="_blank" rel="noopener">benchmark_result</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomNumber</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="title">dis</span><span class="params">(<span class="number">1</span>, <span class="number">1000000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dis(gen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for std::unordered_map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_UnorderedMap_Read</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">unordered_map</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = RandomNumber();</span><br><span class="line">        <span class="built_in">unordered_map</span>[num] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            benchmark::DoNotOptimize(<span class="built_in">unordered_map</span>.<span class="built_in">find</span>(RandomNumber()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_UnorderedMap_Read);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for std::map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_Map_Read</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = RandomNumber();</span><br><span class="line">        <span class="built_in">map</span>[num] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            benchmark::DoNotOptimize(<span class="built_in">map</span>.<span class="built_in">find</span>(RandomNumber()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_Map_Read);</span><br><span class="line"></span><br><span class="line">BENCHMARK_MAIN();</span><br></pre></td></tr></table></figure>
<h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h5><p>We want to use <code>std::string_view</code> instead of <code>const std::string&amp;</code> to pass string parameter to a function.<br>But how much performance improvement we can get?<br>Suppose we use both const char* and std::string to pass a string parameter to a function.<br>We write benchmark code to compare them.  </p>
<p><a href="https://quick-bench.com/q/qoswOAQLY-J5ve2dgwHYNDM_HO8" target="_blank" rel="noopener">benchmark_result</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function that generates random strings</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GenerateRandomString</span><span class="params">(<span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> chars = <span class="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">    <span class="built_in">std</span>::random_device random_device;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">generator</span><span class="params">(random_device())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="title">distribution</span><span class="params">(<span class="number">0</span>, chars.<span class="built_in">size</span>() - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> random_string;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        random_string += chars[distribution(generator)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random_string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function that takes std::string_view</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FunctionWithStringView</span><span class="params">(<span class="built_in">std</span>::string_view str)</span> </span>&#123;</span><br><span class="line">    benchmark::DoNotOptimize(str.data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function that takes const std::string&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FunctionWithStringRef</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">    benchmark::DoNotOptimize(str.data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for std::string_view with const char*</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_StringViewWithChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = GenerateRandomString(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        FunctionWithStringView(cstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_StringViewWithChar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for const std::string&amp; with const char*</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_StringRefWithChar</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = GenerateRandomString(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        FunctionWithStringRef(cstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_StringRefWithChar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for std::string_view with std::string</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_StringViewWithString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = GenerateRandomString(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        FunctionWithStringView(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_StringViewWithString);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Benchmark for const std::string&amp; with std::string</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BM_StringRefWithString</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = GenerateRandomString(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        FunctionWithStringRef(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BENCHMARK(BM_StringRefWithString);</span><br><span class="line"></span><br><span class="line">BENCHMARK_MAIN();</span><br></pre></td></tr></table></figure>
<h4 id="why-we-need-benchmark"><a href="#why-we-need-benchmark" class="headerlink" title="why we need benchmark"></a>why we need benchmark</h4><ul>
<li>performance compare: compare the performance of algorithms || data structures || implementations</li>
<li>performance optimization: identify the bottleneck</li>
<li>performance regression: ensure the performance is not worse than before</li>
</ul>
<h4 id="benchmark-framework-tools"><a href="#benchmark-framework-tools" class="headerlink" title="benchmark framework tools"></a>benchmark framework tools</h4><ul>
<li>Google Benchmark</li>
<li>Boost.Test</li>
<li><a href="https://quick-bench.com/" target="_blank" rel="noopener">https://quick-bench.com/</a></li>
<li>…</li>
</ul>
<hr>
<h1 id="clang-tools"><a href="#clang-tools" class="headerlink" title="clang tools"></a>clang tools</h1><h2 id="clang-family"><a href="#clang-family" class="headerlink" title="clang family"></a>clang family</h2><ul>
<li>clang: C, C++, Objective-C and Objective-C++ compiler</li>
<li>clang-format: code formatter</li>
<li>clang-tidy: code analyzer &amp;&amp; code refactor tools</li>
<li>clang-refactor: code refactor tools</li>
<li>clangd: language server, support code completion, go to definition, find references, rename, …</li>
<li>…</li>
</ul>
<h2 id="precondition-when-we-use-clang-tools"><a href="#precondition-when-we-use-clang-tools" class="headerlink" title="precondition when we use clang tools"></a>precondition when we use clang tools</h2><p>Compile your source code with clang, make sure they can be compiled successfully to a object file.<br>And then we can use clang tools to analyze &amp;&amp; refactor our code.<br>Plz take care: only need compile with clang :-), no need to use or deploy the outputs.</p>
<h2 id="what-can-we-do-with-clang-tools"><a href="#what-can-we-do-with-clang-tools" class="headerlink" title="what can we do with clang tools"></a>what can we do with clang tools</h2><h3 id="write-our-own-checkers"><a href="#write-our-own-checkers" class="headerlink" title="write our own checkers"></a>write our own checkers</h3><p>For example, our code data base was fulled with some bad smell code, but they can pass all the clang-tidy checkers and compiled successfully without any warnings.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slowloop.cc</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = GetSomeData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// If compiler dont optimize strlen(str) to a const value, this loop will run as O(n^2)</span></span><br><span class="line"><span class="comment">// But dont generate any warnings</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can use clang-AST to make sure what happened when clang compile this code.<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang++ -Xclang -ast-dump -fsyntax-only slowloop.cc</span><br></pre></td></tr></table></figure><br>And We can get a output AST such like this:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">|   `-ForStmt <span class="number">0x9759b40</span> &lt;<span class="built_in">line</span>:<span class="number">6</span>:<span class="number">3</span>, <span class="built_in">line</span>:<span class="number">8</span>:<span class="number">3</span>&gt;                                                                           <span class="comment">// for(</span></span><br><span class="line">|     |-DeclStmt <span class="number">0x97599a8</span> &lt;<span class="built_in">line</span>:<span class="number">6</span>:<span class="number">8</span>, col:<span class="number">24</span>&gt;</span><br><span class="line">|     | `-VarDecl 0x9759930 &lt;col:8, col:23&gt; col:15 used index 'size_t':'unsigned int' cinit                            // size_t index = 0;</span><br><span class="line">|     |   `-ImplicitCastExpr 0x9759998 &lt;col:23&gt; 'size_t':'unsigned int' &lt;IntegralCast&gt;</span><br><span class="line">|     |     `-IntegerLiteral 0x9759970 &lt;col:23&gt; 'int' 0</span><br><span class="line">|     |-&lt;&lt;&lt;<span class="literal">NULL</span>&gt;&gt;&gt;                                                                                                     <span class="comment">// i &lt; strlen(str);</span></span><br><span class="line">|     |-BinaryOperator 0x9759ae8 &lt;col:26, col:44&gt; 'bool' '&lt;'</span><br><span class="line">|     | |-ImplicitCastExpr 0x9759ad8 &lt;col:26&gt; 'size_t':'unsigned int' &lt;LValueToRValue&gt;</span><br><span class="line">|     | | `-DeclRefExpr 0x97599c0 &lt;col:26&gt; 'size_t':'unsigned int' lvalue Var 0x9759930 'index' 'size_t':'unsigned int'</span><br><span class="line">|     | `-CallExpr 0x9759aa8 &lt;col:34, col:44&gt; 'size_t':'unsigned int'</span><br><span class="line">|     |   |-ImplicitCastExpr 0x9759a98 &lt;col:34&gt; 'size_t (*)(const char *) __attribute__((cdecl))' &lt;FunctionToPointerDecay&gt;</span><br><span class="line">|     |   | `-DeclRefExpr 0x9759a38 &lt;col:34&gt; 'size_t (const char *) __attribute__((cdecl))':'size_t (const char *)' lvalue Function 0x92edfb8 'strlen' 'size_t (const char *) __attribute__((cdecl))':'size_t (const char *)'</span><br><span class="line">|     |   `-ImplicitCastExpr 0x9759ac8 &lt;col:41&gt; 'const char *' &lt;LValueToRValue&gt;</span><br><span class="line">|     |     `-DeclRefExpr 0x9759a18 &lt;col:41&gt; 'const char *' lvalue Var 0x9759890 'str' 'const char *'</span><br><span class="line">|     |-UnaryOperator 0x9759b20 &lt;col:47, col:49&gt; 'size_t':'unsigned int' lvalue prefix '++'                             // ++i</span><br><span class="line">|     | `-DeclRefExpr 0x9759b00 &lt;col:49&gt; 'size_t':'unsigned int' lvalue Var 0x9759930 'index' 'size_t':'unsigned int'</span><br><span class="line">|     `-CompoundStmt <span class="number">0x9759b30</span> &lt;col:<span class="number">56</span>, <span class="built_in">line</span>:<span class="number">8</span>:<span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure><br>Finally, we can write our own checkers(patterns) to find this kind of bad smell code.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">forStmt(hasCondition(hasDescendant(callExpr(callee(functionDecl(hasName(<span class="string">"strlen"</span>)))))))</span><br></pre></td></tr></table></figure></p>
<p>For more info, u can see </p>
<ul>
<li><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html" target="_blank" rel="noopener">LibASTMatchersReference</a></li>
<li><a href="https://llvm.org/devmtg/2020-09/slides/Clang-tidy_for_Customized_Checkers_and_Large_Scale.pdf" target="_blank" rel="noopener">Clang-tidy CustomizedCheckers</a></li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>tools</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>clang-tidy customized checker example</title>
    <url>/2024/01/21/clang-tidy%20customized%20checker%20example/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本文给出了一个自定义clang-tidy checker的实例，并介绍了引入该实例的背景和原因，旨在帮助读者以此为蓝本快速开发own clang-tidy checker。<br>本文并不对clang-tidy的基本使用做过多介绍，不熟悉的读者可以阅读<a href="https://clang.llvm.org/extra/clang-tidy/" target="_blank" rel="noopener">官方文档</a>。<br>此外，本文同样可以视作对<a href="https://xander.wiki/2023/12/18/c++%20dev%20tools%20&amp;&amp;%20clang%20tools/#write-our-own-checkers">write our own checkers</a>的补充说明。</p>
<a id="more"></a>
<hr>
<h1 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在近期工作中，我们的c++研发偶遇了一个问题：common code在某些编译条件下匹配到了不符预期的函数重载，因而引入了较难排查的运行期错误。</p>
<p>具体而言，有demo code如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_WIDE_STRINGS</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> MyString;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MY_TEXT(str) L##str</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> MyString;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MY_TEXT(str) str</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdPartyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ThirdPartyClass(<span class="keyword">bool</span> value) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bool constructor called with value: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ThirdPartyClass(<span class="keyword">const</span> <span class="keyword">char</span> *value) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Const char* constructor called with value: "</span> &lt;&lt; value</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// should have a ctor with const wchar_t* parameter but not</span></span><br><span class="line">  <span class="comment">// ThirdPartyClass(const wchar_t *value) &#123;</span></span><br><span class="line">  <span class="comment">//   std::cout &lt;&lt; "const wchar_t* constructor called with value: " &lt;&lt; value &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thirdPartyFunction</span><span class="params">(<span class="keyword">bool</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bool function called with value: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thirdPartyFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Const char* function called with value: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// should have a function with const wchar_t* parameter but not</span></span><br><span class="line"><span class="comment">// void thirdPartyFunction(const wchar_t *value) &#123;</span></span><br><span class="line"><span class="comment">//   std::cout &lt;&lt; "const wchar_t* function called with value: " &lt;&lt; value &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ThirdPartyClass <span class="title">instance1</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="function">ThirdPartyClass <span class="title">instance2</span><span class="params">(<span class="string">"Hello, World"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  MyString str = MY_TEXT(<span class="string">"Hello, World"</span>);</span><br><span class="line">  <span class="function">ThirdPartyClass <span class="title">instance3</span><span class="params">(str.c_str())</span></span>; <span class="comment">// call ThirdPartyClass(bool value) when use wide strings</span></span><br><span class="line"></span><br><span class="line">  thirdPartyFunction(<span class="literal">true</span>);</span><br><span class="line">  thirdPartyFunction(<span class="string">"Hello, World"</span>);</span><br><span class="line">  thirdPartyFunction(str.c_str());<span class="comment">// call thirdPartyFunction(bool value) when use wide strings</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在上述代码中，我们使用了一个第三方库中的类<code>ThirdPartyClass</code>，该类有多个构造函数。<br>类似的，我们使用了一个第三方库中函数<code>thirdPartyFunction</code>，该函数有多个重载。   </p>
<p>除此之外，我们还定义了一个<code>MyString</code>类型，该类型在不同编译条件下分别是<code>std::string</code>和<code>std::wstring</code>的别名。  </p>
<p>我们预期，在使用<code>MyString str.c_str()</code>作为实参时，<code>ThirdPartyClass</code>的构造函数和<code>thirdPartyFunction</code>的函数<strong>总是</strong>调用形参是<code>const char*</code>的重载版本。<br>如果传入的是<code>const wchar_t*</code>，则<strong>应当抛出一个build error，以显式地提示开发当前需要对字符串执行编码转换</strong>。</p>
<p>遗憾的是，当我们使用<code>std::wstring</code>作为<code>MyString</code>并传入<code>c_str()</code>时，<strong><code>ThirdPartyClass</code>的构造函数和<code>thirdPartyFunction</code>的函数将会调用形参是<code>bool</code>的重载版本</strong>，原因很简单：任何指针类型都可以隐式转换为<code>bool</code>类型。<br>在没有任何重载版本匹配<code>const wchar_t*</code>的情况下，编译器会选择<code>bool</code>的重载版本，并且导致后续触发运行期错误（构造了错误的对象或者调用了错误的函数）。由于编译器往往认为这种转换是合理的，因此也不会有任何警告信息。</p>
<p>以下分别为使用<code>std::string</code>和<code>std::wstring</code>作为<code>MyString</code>时的运行输出：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> use std::string</span></span><br><span class="line">clang++ ./demo.cpp &amp;&amp; ./a.out </span><br><span class="line">Bool constructor called with value: 1</span><br><span class="line">Const char* constructor called with value: Hello, World</span><br><span class="line">Const char* constructor called with value: Hello, World # meet our expectation</span><br><span class="line">Bool function called with value: 1</span><br><span class="line">Const char* function called with value: Hello, World</span><br><span class="line">Const char* function called with value: Hello, World # meet our expectation</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> use std::wstring</span></span><br><span class="line">clang++ ./demo.cpp -DUSE_WIDE_STRINGS &amp;&amp; ./a.out</span><br><span class="line">Bool constructor called with value: 1</span><br><span class="line">Const char* constructor called with value: Hello, World</span><br><span class="line">Bool constructor called with value: 1 # unexpected, with no warning</span><br><span class="line">Bool function called with value: 1</span><br><span class="line">Const char* function called with value: Hello, World</span><br><span class="line">Bool function called with value: 1 # unexpected, with no warning</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们可以通过 <code>加强培训</code> + <code>code review</code> + <code>高覆盖度单元测试</code> 来避免这种问题，但以上方式需要付出巨大的成本和心智负担。<br>因此，我们希望简单轻松地解决此问题，至少我们期待可以<strong>将错误从运行期提前到编译期</strong>。</p>
<p>以下为一些可能的解决方案：</p>
<ol>
<li>修改第三方库<br>针对这个case，我们可以考虑修改第三方库，为<code>ThirdPartyClass</code>添加一个<code>const wchar_t*</code>的构造函数，为<code>thirdPartyFunction</code>添加一个<code>const wchar_t*</code>的重载版本。<br>如此，当我们使用<code>std::wstring</code>作为<code>MyString</code>时，编译器将会选择形参为<code>const wchar_t*</code>的最优重载，从而避免运行期错误。</li>
<li>自定义clang-tidy checker<br>我们可以考虑自定义一个clang-tidy checker，用于检查所有<strong>存在<code>const wchar_t*</code>在函数调用或对象构造过程中转为<code>bool</code>的场景</strong>，并且在检测到相关场景后抛出build warning（或者更进一步地，视作build error）。</li>
</ol>
<p>方案1的优点无需赘述，但其缺点也显而易见：</p>
<ul>
<li>大多数场景下，第三方库无法直接修改</li>
<li>后续引入新的第三方库时，需要重复这个过程以避免再次出现类似问题</li>
</ul>
<p>因此本文将关注于更加通用化的方案2，即使用自定义clang-tidy checker。</p>
<hr>
<h1 id="自定义clang-tidy-checker"><a href="#自定义clang-tidy-checker" class="headerlink" title="自定义clang-tidy checker"></a>自定义clang-tidy checker</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><a href="https://clang.llvm.org/extra/clang-tidy/Contributing.html" target="_blank" rel="noopener">clang-tidy-extra</a><br><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html" target="_blank" rel="noopener">AST Matchers</a></p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>clang-tidy新增checker有2种方式</p>
<ol>
<li>新建checkers，并将其编译成动态链接库，然后通过令clang-tidy以<code>-load</code>参数加载plugin</li>
<li>新建checkers，并将checkers编译进clang-tidy二进制文件中</li>
</ol>
<p>方案1也就是所谓的<code>Out-of-tree check plugins</code>。<br>显然，相较于方案2需要rebuild clang-tidy，方案1更加灵活。<br>此外，由于中文互联网社区对方案1的描述较少，因此本文将仅关注方案1，并给出方案1的demo级具体实现。<br>方案2可参考<a href="https://zhuanlan.zhihu.com/p/518339529" target="_blank" rel="noopener">为clang-tidy添加自定义check</a>。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 目录结构</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── WCharToBoolConversionCheck.cpp</span><br><span class="line">├── WCharToBoolConversionCheck.h</span><br><span class="line">└── build_and_test.sh # for test</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(WCharToBoolConversionCheckPlugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(LLVM REQUIRED CONFIG)</span><br><span class="line"><span class="keyword">find_package</span>(Clang REQUIRED CONFIG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CLANG_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;LLVM_DEFINITIONS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(WCharToBoolConversionCheck SHARED WCharToBoolConversionCheck.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(WCharToBoolConversionCheck PRIVATE clangASTMatchers clangTidy)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WCharToBoolConversionCheck.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WCHAR_TO_BOOL_CONVERSION_CHECK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WCHAR_TO_BOOL_CONVERSION_CHECK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidyCheck.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> clang &#123;</span><br><span class="line"><span class="keyword">namespace</span> tidy &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WCharToBoolConversionCheck</span> :</span> <span class="keyword">public</span> ClangTidyCheck &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  WCharToBoolConversionCheck(StringRef Name, ClangTidyContext *Context)</span><br><span class="line">      : ClangTidyCheck(Name, Context) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerMatchers</span><span class="params">(ast_matchers::MatchFinder *Finder)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> ast_matchers::MatchFinder::MatchResult &amp;Result)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace tidy</span></span><br><span class="line">&#125; <span class="comment">// namespace clang</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WCharToBoolConversionCheck.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidy.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidyCheck.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidyModule.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang-tidy/ClangTidyModuleRegistry.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> clang &#123;</span><br><span class="line"><span class="keyword">namespace</span> tidy &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WCharToBoolConversionCheck</span> :</span> <span class="keyword">public</span> ClangTidyCheck &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  WCharToBoolConversionCheck(StringRef Name, ClangTidyContext *Context)</span><br><span class="line">      : ClangTidyCheck(Name, Context) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerMatchers</span><span class="params">(ast_matchers::MatchFinder *Finder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> clang::ast_matchers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Match function calls and constructor calls with a boolean parameter.</span></span><br><span class="line">    Finder-&gt;addMatcher(</span><br><span class="line">        callExpr(forEachArgumentWithParam(expr().bind(<span class="string">"arg"</span>),</span><br><span class="line">                                          parmVarDecl(hasType(booleanType()))))</span><br><span class="line">            .bind(<span class="string">"call"</span>),</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Finder-&gt;addMatcher(</span><br><span class="line">        cxxConstructExpr(</span><br><span class="line">            forEachArgumentWithParam(expr().bind(<span class="string">"arg"</span>),</span><br><span class="line">                                     parmVarDecl(hasType(booleanType()))))</span><br><span class="line">            .bind(<span class="string">"construct"</span>),</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> ast_matchers::MatchFinder::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> *ArgExpr = Result.Nodes.getNodeAs&lt;Expr&gt;(<span class="string">"arg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ArgExpr) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QualType ArgType = ArgExpr-&gt;getType().getCanonicalType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *PT = dyn_cast&lt;PointerType&gt;(ArgType)) &#123;</span><br><span class="line">      QualType PointeeType = PT-&gt;getPointeeType().getCanonicalType();</span><br><span class="line">      <span class="comment">// If the pointee type is wchar_t || const wchar_t, emit a warning.</span></span><br><span class="line">      <span class="keyword">if</span> (PointeeType-&gt;isWideCharType() ||</span><br><span class="line">          (PointeeType.isConstQualified() &amp;&amp;</span><br><span class="line">           PointeeType.getUnqualifiedType()-&gt;isWideCharType())) &#123;</span><br><span class="line">        diag(ArgExpr-&gt;getBeginLoc(),</span><br><span class="line">             <span class="string">"passing 'wchar_t*' to a boolean parameter, which may lead to "</span></span><br><span class="line">             <span class="string">"unexpected behavior"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WCharToBoolConversionModule</span> :</span> <span class="keyword">public</span> ClangTidyModule &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addCheckFactories</span><span class="params">(ClangTidyCheckFactories &amp;CheckFactories)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    CheckFactories.registerCheck&lt;WCharToBoolConversionCheck&gt;(</span><br><span class="line">        <span class="string">"wchar-to-bool-conversion-check"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> ClangTidyModuleRegistry::Add&lt;WCharToBoolConversionModule&gt;</span><br><span class="line">    X(<span class="string">"wchar-to-bool-conversion-module"</span>,</span><br><span class="line">      <span class="string">"Adds checks for wchar_t* to bool conversions."</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace tidy</span></span><br><span class="line">&#125; <span class="comment">// namespace clang</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><h2 id="test-script"><a href="#test-script" class="headerlink" title="test script"></a>test script</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> build_and_test.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -eu</span><br><span class="line"></span><br><span class="line">SCRIPT_DIR=$(cd "$(dirname "$&#123;BASH_SOURCE[0]&#125;")" &amp;&gt;/dev/null &amp;&amp; pwd)</span><br><span class="line">BUILD_DIR="$SCRIPT_DIR/build"</span><br><span class="line"></span><br><span class="line">rm -rf "$&#123;BUILD_DIR&#125;"</span><br><span class="line">mkdir "$&#123;BUILD_DIR&#125;"</span><br><span class="line">cd "$&#123;BUILD_DIR&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> build checker plugin</span></span><br><span class="line"></span><br><span class="line">cmake "$SCRIPT_DIR"</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">cd "$SCRIPT_DIR"</span><br><span class="line"></span><br><span class="line">LIB_FILE="$BUILD_DIR/libWCharToBoolConversionCheck.dylib"</span><br><span class="line">DEMO_FILE="$SCRIPT_DIR/demo.cpp"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> start <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">echo "clang-tidy demo.cpp use std::string"</span><br><span class="line">clang-tidy --checks='-*,wchar-to-bool-conversion-check' -load "$LIB_FILE" "$DEMO_FILE" -- </span><br><span class="line"></span><br><span class="line">echo "clang-tidy demo.cpp use std::wstring"</span><br><span class="line">clang-tidy --checks='-*,wchar-to-bool-conversion-check' -load "$LIB_FILE" "$DEMO_FILE" -- -DUSE_WIDE_STRINGS</span><br></pre></td></tr></table></figure>
<h2 id="test-result"><a href="#test-result" class="headerlink" title="test result"></a>test result</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./build_and_test.sh</span></span><br><span class="line">clang-tidy demo.cpp use std::string # no warning</span><br><span class="line">clang-tidy demo.cpp use std::wstring # report 2 warnings</span><br><span class="line">2 warnings generated.</span><br><span class="line">/Users/XanderLiu/myclang/demo.cpp:55:29: warning: passing 'wchar_t*' to a boolean parameter, which may lead to unexpected behavior [wchar-to-bool-conversion-check]</span><br><span class="line">   55 |   ThirdPartyClass instance3(str.c_str());</span><br><span class="line">      |                             ^</span><br><span class="line">/Users/XanderLiu/myclang/demo.cpp:59:22: warning: passing 'wchar_t*' to a boolean parameter, which may lead to unexpected behavior [wchar-to-bool-conversion-check]</span><br><span class="line">   59 |   thirdPartyFunction(str.c_str());</span><br><span class="line">      |                      ^</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>Target: arm64-apple-darwin22.6.0<br>Homebrew clang version: 17.0.5<br>cmake version: 3.27.0  </p>
<h2 id="src获取与运行"><a href="#src获取与运行" class="headerlink" title="src获取与运行"></a>src获取与运行</h2><ol>
<li>installed llvm &amp;&amp; clang</li>
<li>git clone git@github.com:zsmj2017/ClangTidyCustomizedCheckersExample.git</li>
<li>cd ClangTidyCustomizedCheckersExample</li>
<li>run ./build_and_test.sh or write your own test script</li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>tools</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>16.STL容器与C API</title>
    <url>/2018/04/10/STL%E5%AE%B9%E5%99%A8%E4%B8%8EC%20API/</url>
    <content><![CDATA[<h1 id="获取指针"><a href="#获取指针" class="headerlink" title="获取指针"></a>获取指针</h1><p>&lt;/br&gt;<br>假设有一个vector对象v，而你需要得到一个指向v中数据的指针，这让v可以被当作一个数组在C中使用。<br>我们只需要使用<code>&amp;v[0]</code>即可获得指向首元素的指针。如果是string，请使用<code>s.c_str()</code>.<br>实际上这样做可能会有一些问题，具体而言就是v可能是空的，所以需要<strong>先对v进行empty判定</strong>。</p>
<p>有人说可以用begin这种迭代器来代替&amp;v[0],实际上这完全是胡说八道，因为并不总是能做到迭代器和指针之间的互相转换。<br><code>&amp;*v.begin()</code>倒是真的可以等价于<code>&amp;v[0]</code>,但这种写法除了让别人一目了然你的智力水平外并没有其他好处。</p>
<p>有人会疑惑为什么vctor就可以直接取址，而string不行，原因有以下两点：</p>
<ol>
<li>string的数据并没有保证被存储于连续内存（详见 Effective STL 15）</li>
<li>string并不保证以null结尾</li>
</ol>
<p>因此，string必须使用c_str:</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pString)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(s.c_str())</span></span>;</span><br></pre></td></tr></table></figure></h2><h1 id="C-API初始化STL容器"><a href="#C-API初始化STL容器" class="headerlink" title="C API初始化STL容器"></a>C API初始化STL容器</h1><h2 id="用C-API返回的元素初始化vector"><a href="#用C-API返回的元素初始化vector" class="headerlink" title="用C API返回的元素初始化vector"></a>用C API返回的元素初始化vector</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C API数需要一个指向数组的指针，数组最多有arraySize个double</span></span><br><span class="line"><span class="comment">// 功能为向数组内部写入数据，返回写入数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vd</span><span class="params">(maxNumDoubles)</span></span>;，</span><br><span class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.<span class="built_in">size</span>()));<span class="comment">//数据写入后调整大小</span></span><br></pre></td></tr></table></figure>
<h2 id="用C-API返回的元素初始化string"><a href="#用C-API返回的元素初始化string" class="headerlink" title="用C API返回的元素初始化string"></a>用C API返回的元素初始化string</h2><p>上述写法并不能应用于string类型，因为只有vector保证了与数组具有相同内存分布。（顺序表）<br>但用用C API初始化string也不难，具体来说就是先初始化一个vector&lt;char&gt;，然后再用vector初始化string：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillString</span><span class="params">(<span class="keyword">char</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">vc</span><span class="params">(maxNumChars)</span></span>; </span><br><span class="line"><span class="keyword">size_t</span> charsWritten = fillString(&amp;vc[<span class="number">0</span>], vc.<span class="built_in">size</span>());</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(vc.<span class="built_in">begin</span>(), vc.<span class="built_in">begin</span>()+charsWritten)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="用C-API返回的元素初始化STL中的任何容器"><a href="#用C-API返回的元素初始化STL中的任何容器" class="headerlink" title="用C API返回的元素初始化STL中的任何容器"></a>用C API返回的元素初始化STL中的任何容器</h2><p>因为和数组内存分布一致的只有vector，所以我们的策略十分简单：<strong>把数组内的元素传入vector，然后再用vector初始化STL容器：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vd</span><span class="params">(maxNumDoubles)</span></span>;</span><br><span class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.<span class="built_in">size</span>()));</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; <span class="title">d</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到deque</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; <span class="title">l</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到list</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; <span class="title">s</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到set</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="STL容器传递数据至C-API"><a href="#STL容器传递数据至C-API" class="headerlink" title="STL容器传递数据至C API"></a>STL容器传递数据至C API</h1><p>&lt;/br&gt;<br>从上文中自然能领会到反向传递的方法：用STL容器内的元素初始化vector，然后再用vector传入C API：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pints, <span class="keyword">size_t</span> numInts)</span></span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet; <span class="comment">//要传递给API数据的set</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(intSet.<span class="built_in">begin</span>(), intSet.<span class="built_in">end</span>())</span></span>; </span><br><span class="line"><span class="keyword">if</span> (!v.empty()) doSomething(&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>32.erase_remove惯用法</title>
    <url>/2018/04/15/erase_remove%E6%83%AF%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="remove无法删除元素"><a href="#remove无法删除元素" class="headerlink" title="remove无法删除元素"></a>remove无法删除元素</h1><p>&nbsp;<br>remove的声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>);</span></span><br></pre></td></tr></table></figure><br>显然，remove算法操作迭代器而非容器，就像别的算法一样.<br>如果我们想从容器中去除某个元素，必然需要使用容器的成员函数erase，因为remove无法知道它正在操作的容器———因此有结论，从一个容器中remove元素不会改变元素个数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reserve(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>();</span><br><span class="line">v[<span class="number">3</span>] = v[<span class="number">5</span>] = v[<span class="number">9</span>] = <span class="number">99</span>; </span><br><span class="line"><span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">99</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>();<span class="comment">//仍然是10</span></span><br></pre></td></tr></table></figure><br>我们需要了解并记住的是：<strong>remove并不“真的”删除东西，因为它做不到。</strong></p>
<hr>
<h1 id="remove的具体实现"><a href="#remove的具体实现" class="headerlink" title="remove的具体实现"></a>remove的具体实现</h1><p>&nbsp;<br>remove移动指定区间中的元素，直到所有不需要“删除”的元素在区间开头，并且返回区间的“新逻辑终点”。一图胜千言：</p>
<ol>
<li>调用remove之前<br><img src="http://static.zybuluo.com/zsmj2017/ji5w3aqu27uje0n86nmceu1t/image_1cb48ijia793d6a1smfgv539j9.png" alt="image_1cb48ijia793d6a1smfgv539j9.png-16.5kB"></li>
<li>执行remove<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">newEnd</span><span class="params">(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">99</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<img src="http://static.zybuluo.com/zsmj2017/0w5oziuwkw95xnmp0e92bh9h/image_1cb48kk5jh151qlf2iv1br2sb4m.png" alt="image_1cb48kk5jh151qlf2iv1br2sb4m.png-19.1kB"></li>
</ol>
<p>然而，因为remove本质上并不是在改变区间元素顺序，所以<code>？</code>处仍然存在值，一般而言，真正的remove之后结果如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/5wibz6vn5dsxt4cl5hg7igey/image_1cb4a9i721jea2001a4t1agn13i413.png" alt="image_1cb4a9i721jea2001a4t1agn13i413.png-18.8kB"><br>这是由于remove的实现所决定的，你可以想象remove完成了一种压缩去，被删除的值表演了被填充的角色，具体而言，其执行方略如下：</p>
<ol>
<li>remove检测v[0],发现无需删除，然后向后移动</li>
<li>v[3]应该删除，于是记录v[3]需要被覆盖，移动到v[4]</li>
<li>v[4]无需删除，将v[4]赋予v[3]，记录v[4]应该被覆盖，移动到v[5]</li>
<li>v[5]应该被删除，所以忽略并移动到6，此时记得4、5都应该被填充</li>
<li>诸如此类，移动过程如下图所示</li>
</ol>
<p><img src="http://static.zybuluo.com/zsmj2017/zfz16kn13opljad1f883og5n/image_1cb4ah4ep164kjup1jpns06hg31g.png" alt="image_1cb4ah4ep164kjup1jpns06hg31g.png-13.2kB"></p>
<hr>
<h1 id="erase-remove惯用法"><a href="#erase-remove惯用法" class="headerlink" title="erase_remove惯用法"></a>erase_remove惯用法</h1><p>&nbsp;<br>erase与remove是一对好搭档，我们应该很自然的配合使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.erase(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">99</span>),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br><strong>list是一个意外，它的remove综合了remove与erase的功能.</strong><br>除此之外，remove_if与unique行为类似于remove，所以记得它们也应该配合erase使用。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>27.const_iterator到iterator的转换(distance、advance)</title>
    <url>/2018/04/14/const_iterator%E5%88%B0iterator%E7%9A%84%E8%BD%AC%E6%8D%A2(distance%E3%80%81advance)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>正如上一节所说，insert与erase只支持iterator或能隐式转为iterator的迭代器。如果我们只有一个const_iterator，那怎么办？有人会试图去使用类型转换：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; IntDeque; </span><br><span class="line"><span class="keyword">typedef</span> IntDeque::iterator Iter;</span><br><span class="line"><span class="keyword">typedef</span> IntDeque::const_iterator ConstIter;</span><br><span class="line">ConstIter ci; <span class="comment">// ci是const_iterator</span></span><br><span class="line"><span class="function">Iter <span class="title">i</span><span class="params">(<span class="keyword">const_cast</span>&lt;Iter&gt;(ci))</span></span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>不能类型转换原因是很简单的，<strong>const_iterator与iterator是完全不同的类</strong>，就像string与vector&lt;int&gt;没有任何关联一样。</p>
<hr>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; IntDeque;</span><br><span class="line"><span class="keyword">typedef</span> IntDeque::iterator Iter;</span><br><span class="line"><span class="keyword">typedef</span> IntDeque::const_iterator ConstIter;</span><br><span class="line">IntDeque d;</span><br><span class="line">ConstIter ci;</span><br><span class="line"><span class="function">Iter <span class="title">i</span><span class="params">(d.<span class="built_in">begin</span>())</span></span>;</span><br><span class="line">advance(i, distance(i, ci));</span><br></pre></td></tr></table></figure>
<p>advance与distance都在头文件<code>&lt;iterator&gt;</code>中。<br>distance返回两个指向同一个容器的iterator之间的距离；advance则用于将一个iterator移动指定的距离。<br>如果i和ci指向同一个容器，那么表达式advance(i, distance(i,ci))会将i移动到与ci相同的位置上。<br>思路很美好，但实际上这段程序不能编译通过。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="无法编译的原因"><a href="#无法编译的原因" class="headerlink" title="无法编译的原因"></a>无法编译的原因</h2><p>distance的定义式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">distance(InputIterator first, InputIterator last);</span><br></pre></td></tr></table></figure><br>我们可以清楚地看到<strong>distance要求两个参数必须一致，最起码能完成隐式转换</strong>，而实际上const_iterator无法转换。</p>
<h2 id="显式指定函数模板参数"><a href="#显式指定函数模板参数" class="headerlink" title="显式指定函数模板参数"></a>显式指定函数模板参数</h2><p>通过<strong>显式地指明distance调用的模板参数类型</strong>，那么编译器则不再从参数推断函数模板参数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">advance(i, distance&lt;ConstIter&gt;(i, ci));</span><br></pre></td></tr></table></figure></p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>对于随机迭代器（vector，string，deque）消耗常数时间，双向迭代器（所有其他容器）需要线性的时间。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>35.mismatch与lexicographical_compare</title>
    <url>/2018/04/16/mismatch%E4%B8%8Elexicographical_compare/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>一个STL菜鸟最常问的问题是“我该如何使用STL来进行忽略大小写的字符串比较？”。这个问题说难很难（考虑国际化问题），说简单也简单（仅设计为strcmp那种样式）。</p>
<hr>
<h1 id="比较字符"><a href="#比较字符" class="headerlink" title="比较字符"></a>比较字符</h1><p>&nbsp;<br>在解决字符串比对问题之前，我们需要有一种方法确定两个字符忽略大小写后是否相等。我们仅考虑最简单的版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciCharCompare</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> Ic1 = <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c1));</span><br><span class="line">    <span class="keyword">int</span> Ic2 = <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c2));</span><br><span class="line">    <span class="keyword">if</span> (Ic1 &lt; Ic2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lc1 &gt; Ic2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此函数遵循了strcmp，可以返回1，-1，0三个值。由于各个char的实现不同（可能有符号可能无符号），我们先将其转为uc，然后再将它们转为小写，如此则忽略了大小写区别，最后将比较结果返回。</p>
<hr>
<h1 id="基于mismatch实现的字符串比对"><a href="#基于mismatch实现的字符串比对" class="headerlink" title="基于mismatch实现的字符串比对"></a>基于mismatch实现的字符串比对</h1><p>&nbsp;<br>在调用mismatch之前，我们必须确定一个字符串是否比另一个要短，将短字符串作为第一个区间传递。这项工作将由以下函数完成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciStringCompareImpl</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciStringCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>()) <span class="keyword">return</span> ciStringCompareImpl(s1, s2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -ciStringCompareImpl(s2, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在真正的字符串比较函数中，大部分工作由mismatch来完成，它返回一对迭代器，表示两个区间中第一个对应的字符不相同的位置：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciStringCompareImpl</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; si, <span class="keyword">const</span> strings s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>::const_iterator, <span class="built_in">string</span>::const_iterator&gt; PSCI;</span><br><span class="line">    PSCI p = mismatch(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), s2.<span class="built_in">begin</span>(), not2(ptr_fun(ciCharCompare))); </span><br><span class="line">    <span class="keyword">if</span> (p.first== s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.second == s2.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ciCharCompare(*p.first, *p.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>重点在于函数中使用的not2与ptr_fun.<br>使用not2是因为mismatch的谓词返回false时算法停止工作，所以我们需要把charcompare返回的0变为1。ptr_function则类似于std::function。</p>
<hr>
<h1 id="基于lexicographical-compare实现的字符串比对"><a href="#基于lexicographical-compare实现的字符串比对" class="headerlink" title="基于lexicographical_compare实现的字符串比对"></a>基于lexicographical_compare实现的字符串比对</h1><p>&nbsp;<br>我们还有一个方法就是把之前的charcompare变成一种类似谓词的形式，这样配合算法使用效果更佳，如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ciCharLess</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span>&#123;<span class="comment">//函数对象</span></span><br><span class="line">    <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c1)) &lt; <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c2));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ciStringCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lexicographical_compare(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(),s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), ciCharLess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>lexicographical_cmp是strcmp的泛型版本。strcmp只对字符数组有效，但前者对任何类型的值的区间都起作用，并且支持自定义比较器。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>31.inline函数剖析</title>
    <url>/2018/04/15/inline%E5%87%BD%E6%95%B0%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>inline函数无论是看起来还是用起来都比宏更像函数而且更好用，调用它们又无需承受函数调用的额外开销。另外，编译器会对不含函数调用的程序执行语境相关最优化。然而，inline函数并不是完美无缺的。</p>
<hr>
<h1 id="inline的成本"><a href="#inline的成本" class="headerlink" title="inline的成本"></a>inline的成本</h1><p>&nbsp;<br>inline的本质是“对函数的每一个调用”都以函数本体替换，这无疑增加了目标码（object code）大小，过度热衷inline可能会导致程序体积太大，随之导致额外的换页行为（page过多）。但是，如果inline函数很小，可能“函数本体”比“函数调用”所产出的代码更小，那当然是再好不过了。</p>
<hr>
<h1 id="inline申请"><a href="#inline申请" class="headerlink" title="inline申请"></a>inline申请</h1><p>&nbsp;<br><strong>inline只是对编译器提出的申请。</strong>这个申请可以显式提出也可以隐式提出。</p>
<h2 id="隐式inline"><a href="#隐式inline" class="headerlink" title="隐式inline"></a>隐式inline</h2><p>隐式就是把函数定义在class内部。一般而言这种隐式申请都是成员函数，不过friend函数也能被定义在class内（Effective C++ 47），如果真是那样，那它们也被隐式声明为inline.</p>
<h2 id="显式inline"><a href="#显式inline" class="headerlink" title="显式inline"></a>显式inline</h2><p>显式声明方法是在函数定义式前加上inline。以&lt;algorithm&gt;中的<code>max template</code>为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?b:a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="inline与template"><a href="#inline与template" class="headerlink" title="inline与template"></a>inline与template</h1><p>&nbsp;<br>inline函数和template函数通常都会被定义在头文件中，所以有人会误以为function template一定是inline.这一点是错误的。<br>inline放在头文件的原因很简单，编译器需要在编译期将某个“函数调用”替换为“被调用函数的本体”。<br>template通常也放在头文件里，因为它一旦被使用，编译器为了具现化必须知道它的样子。<br>总之，<strong>template的具现化与inlining无关</strong>，如果你觉得所有据此template产生的function应该inline，那就声明它为inline，否则不必如此。</p>
<hr>
<h1 id="编译器决定是否inline"><a href="#编译器决定是否inline" class="headerlink" title="编译器决定是否inline"></a>编译器决定是否inline</h1><p>&nbsp;<br><strong>编译器拒绝将过于复杂的函数inline（带有循环或者递归），并且任何virtual函数的调用也会使inline落空。</strong>这是十分显然的，因为virtual意味着运行时才知道调用哪个函数，inline却是在编译期就必须确定。不过幸运的是，如果编译器拒绝了你的inline请求，会反馈一个警告信息。</p>
<p>有时候虽然编译器愿意inlining某个函数，但还是可能为该函数生成一个函数本体。<br>举例而言，如果某个函数需要取某一个inline函数的地址，那编译器会生成一个outlined函数本体，毕竟编译器无法去提出一个指针指向一个不存在的函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;..&#125;;</span><br><span class="line"><span class="keyword">void</span> (*pf)() = f;<span class="comment">//pf指向f</span></span><br><span class="line">...</span><br><span class="line">f();<span class="comment">//确实inline</span></span><br><span class="line">pf();<span class="comment">//生成了函数实体并产生了调用</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="inline与构造、析构函数"><a href="#inline与构造、析构函数" class="headerlink" title="inline与构造、析构函数"></a>inline与构造、析构函数</h1><p>&nbsp;<br>假设有base class与derived class如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;<span class="comment">//空构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>Derived::Derived()</code>看起来似乎很适合被inline，因为它根本不含任何代码，但实际并非如此。<br>构造或者析构函数内部存在着大量处理异常的程序，并且肯定存在着Base类的构造函数或者Derived析构函数。对这些函数的调用影响了编译器是否会对此空白函数inlining.<br>此外，这些代码如果被inline，那他们必然化身为object code充斥着各类Derived class.<br>总而言之，<strong>构造函数和析构函数不适合被声明为inline.</strong></p>
<hr>
<h1 id="inline与程序库"><a href="#inline与程序库" class="headerlink" title="inline与程序库"></a>inline与程序库</h1><p>&nbsp;<br>程序库设计者使用inline之前必须考虑其影响性：<strong>inline无法随着程序库升级而升级</strong>。也就是说如果一旦某一个inline函数被改写，所有用到它的客户端程序都要重新编译。如果是non-inline，那用户只需要重新连接就好了。</p>
<hr>
<h1 id="inline与debug"><a href="#inline与debug" class="headerlink" title="inline与debug"></a>inline与debug</h1><p>&nbsp;<br>我们<strong>无法在inline函数中设置断点</strong>，因为实际上并不存在这个函数。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;</p>
<ol>
<li>将inline函数限制在小型、频繁调用的函数身上，这会使潜在的代码膨胀问题最小化，程序速度提升机会最大化。</li>
<li>不要因为function template出现在头文件就把它声明为inline，这二者并不相关。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS环境下gtest框架的使用</title>
    <url>/2019/04/02/macos%E7%8E%AF%E5%A2%83%E4%B8%8Bgtest%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本篇主要讲述如何在macOS环境下使用googletest框架。<br><a id="more"></a></p>
<h1 id="gtest安装"><a href="#gtest安装" class="headerlink" title="gtest安装"></a>gtest安装</h1><p>&nbsp;<br>首先将gtest克隆至本地并进入：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/google/googletest</span><br><span class="line">cd googletest</span><br></pre></td></tr></table></figure><br>值得注意的是，由于笔者习惯使用gcc作为c++编译器，而在默认情况下，macos直接通过cmake编译gtest时使用的是clang，即输入<code>cmake -DCMAKE_BUILD_TYPE=DEBUG</code>后有显示如下<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The C compiler identification is AppleClang 10.0.0.10001044</span><br><span class="line">The CXX compiler identification is AppleClang 10.0.0.10001044</span><br></pre></td></tr></table></figure><br>因此我们需要对<code>CMakelists.txt</code>作出更改，具体而言，有修改如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.8)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> THIS HAS TO COME BEFORE THE PROJECT LINE</span></span><br><span class="line">set(CMAKE_C_COMPILER "/usr/local/Cellar/gcc/8.3.0/bin/gcc-8") # your gcc path</span><br><span class="line">set(CMAKE_CXX_COMPILER "/usr/local/Cellar/gcc/8.3.0/bin/g++-8") # your g++ path</span><br><span class="line"><span class="meta">#</span><span class="bash"> THIS HAS TO COME BEFORE THE PROJECT LINE</span></span><br><span class="line"></span><br><span class="line">project(googletest-distribution)</span><br></pre></td></tr></table></figure><br>修改完成后就可以愉快地<code>make &amp;&amp; make install</code>啦：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/googletest</span><br><span class="line">mkdir build;cd build;</span><br><span class="line">cmake..</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><br>至此googletest安装完毕,<code>libgetst*.a</code>文件及<code>include</code>已置入<code>/usr/local/lib</code>及<code>/usr/local/include</code>。</p>
<h1 id="使用gtest"><a href="#使用gtest" class="headerlink" title="使用gtest"></a>使用gtest</h1><p>&nbsp;<br>照常使用即可，如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -lgtest -lpthread -o test.o</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>17.new与delete成对使用时必须形式相同</title>
    <url>/2018/04/11/new%E4%B8%8Edelete%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8%E6%97%B6%E5%BF%85%E9%A1%BB%E5%BD%A2%E5%BC%8F%E7%9B%B8%E5%90%8C/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> * stringarray = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> stringarray;</span><br></pre></td></tr></table></figure>
<p>在上述代码中我们成对地使用了<code>new</code>与<code>delete</code>，似乎避开了资源泄露，但其实并非如此。<br>上文动态分配了100个string对象，却只删除了第一个，其它string对象的析构函数根本没有被调用。</p>
<hr>
<h1 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a>new与delete</h1><h2 id="调用new与delete时发生了什么？"><a href="#调用new与delete时发生了什么？" class="headerlink" title="调用new与delete时发生了什么？"></a>调用new与delete时发生了什么？</h2><p>当你使用new的时候，有两件事会发生：</p>
<ol>
<li>内存通过<code>operator new</code>被分配出来（new操作符详见Effective C++ 50 52）</li>
<li>针对此内存有一个或多个构造函数被调用</li>
</ol>
<p>对应的，使用delete的时候也会发生两件事：</p>
<ol>
<li>一个或多个析构函数被调用</li>
<li>通过<code>operator delete</code>释放内存</li>
</ol>
<h2 id="delete如何判定对象个数？"><a href="#delete如何判定对象个数？" class="headerlink" title="delete如何判定对象个数？"></a>delete如何判定对象个数？</h2><p>delete的最大问题在于：即将被删除的内存之内究竟存有多少对象？这决定了会调用多少次析构函数。换句话说<strong>，delete需要明确：被删除的指针究竟指向单一对象还是对象数组</strong>？<br>在编译器的具体实现中，单一对象的内存布局不同于数组的内存布局，数组的内存布局中记录了数组大小，这得以让delete函数知道需要调用多少次析构函数。它们的内存布局大概是这样：<br><img src="http://static.zybuluo.com/zsmj2017/q7o6hnu7bl6ol60j9te6o2yk/image_1cap38n6l1a205v11tnn1t9017gu9.png" alt="image_1cap38n6l1a205v11tnn1t9017gu9.png-11.9kB"></p>
<h2 id="delete的正确使用"><a href="#delete的正确使用" class="headerlink" title="delete的正确使用"></a>delete的正确使用</h2><p>我们通过人为指定的方式让delete明确其操作：<strong>使用delete或delete[]</strong>;<br>前者认定当前指向的是单一对象，后者则认定当前指向数组：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>* pstr1 = <span class="keyword">new</span> <span class="built_in">string</span>；</span><br><span class="line"><span class="built_in">string</span>* pstr2 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> pstr1;</span><br><span class="line"><span class="keyword">delete</span>[] pstr2;</span><br></pre></td></tr></table></figure></p>
<h2 id="误用delete形式的后果"><a href="#误用delete形式的后果" class="headerlink" title="误用delete形式的后果"></a>误用delete形式的后果</h2><p>如果我们对<code>pstr1</code>使用<code>delete[]</code>,结果未定义,可想而知它会误认为当前指向某一个对象数组，然后读取某块内存将其解释为数组大小，然后反复调用析构函数。</p>
<p>如果我们对<code>pstr2</code>没有使用<code>delete[]</code>,结果亦未有定义，但肯定调用的析构函数不足。事实上，<strong>即使针对没有析构函数的内置类型，这种写法也是有害的。</strong></p>
<h2 id="new、delete与typedef"><a href="#new、delete与typedef" class="headerlink" title="new、delete与typedef"></a>new、delete与typedef</h2><p>本节的规则十分简单，无非是<strong>成对使用new与delete时必须保证形式一致</strong>，读者想必会认为稍加注意不难做到。但对于某些重度typedef爱好者而言，还是要多加留心为是：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> AddressLines[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">string</span>* pal = <span class="keyword">new</span> AddressLines;<span class="comment">//pal指向的是数组对象</span></span><br><span class="line"><span class="keyword">delete</span> pal;<span class="comment">//error!</span></span><br><span class="line"><span class="keyword">delete</span>[] pal;</span><br></pre></td></tr></table></figure><br>我认为C++语言应当尽量减少对数组使用typedef定义，在降低了可读性的同时还容易引发错误。在能够使用STL容器的地方坚决不使用动态数组。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>53.placement new与placement delete</title>
    <url>/2018/04/25/placement%20new%E4%B8%8Eplacement%20delete/</url>
    <content><![CDATA[<h1 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h1><p>&nbsp;<br>一般而言，new表达式形式大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> Widget；</span><br></pre></td></tr></table></figure><br>其中一共调用了两个函数：operator new以及Widget的默认构造函数。<br>如果operator new被成功调用，但默认构造函数却抛出了异常，我们应该释放分配的内存并让它恢复原状。客户并没有这个能力，因为pw此时尚未被赋值，客户并不知道已分配的内存的地址，该任务需要C++运行期系统完成。<br>解决方法很简单：调用operator new所对应的那个operator delete。听起来容易，但如果我们曾经声明过带有附加参数的operator new，对应的delete就不好找了。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设现有一个operator new接受一个ostream，用来记录信息，同时具备一个正常形式的class专属delete：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>,ostream&amp; <span class="built_in">log</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>;<span class="comment">//非正常形式new</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//正常形式的delete</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个设计存在问题，但我们在探究原因之前，必须先了解相关术语。</p>
<hr>
<h1 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h1><p>&nbsp;<br>如果一个operator new除了size_t之外还接受其他参数，那它就是一个placement版本。<br>众多placement版本中最受欢迎的是“接受一个指针指向对象被构造之处”：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>它是如此地知名以至于我们默认提及placement new即为该版本。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>显然，在实例中，带有ostream参数的placement new并没有与之对应的delete，所以一旦构造函数抛出异常，系统无法做到自恢复。所以我们应该为它补充上placement delete：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*,ostream&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="名称遮蔽"><a href="#名称遮蔽" class="headerlink" title="名称遮蔽"></a>名称遮蔽</h1><p>&nbsp;<br>成员函数的名称会掩盖其外部作用域的相同名称（Effective C++ 34），如果你的base class中只声明了一个placement new，客户将无法使用正常形式的operator new，delete同理。与此类似的，derived class中的operator news会遮蔽base版本与继承而来的版本。<br>为了避免名称遮蔽，我们需要了解到C++在global作用域提供以下形式的operator new:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">const</span> <span class="keyword">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>如果我们在class内声明任何形式的operator new，它们都会遮掩这些标准形式，除非你的本意就是禁止使用标准形式，否则请确保它们可用。确保可用的方法是：建立一个base class，内含所有正常形式的new与delete。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardNewDeleteForms</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//normal</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">delete</span>(pMemory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//placement</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>,<span class="keyword">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>,ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory,<span class="keyword">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">delete</span>(pMemory,ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//nothrow</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>,<span class="keyword">const</span> <span class="keyword">nothrow_t</span>&amp; nt)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>,nt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory,<span class="keyword">const</span> <span class="keyword">nothrow_t</span>&amp; nt)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">delete</span>(pMemory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当你需要自定义new与delete时，只需要继承该类并使用using机制，即可避免名称遮蔽。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;</p>
<ol>
<li>placement new和placement delete必须同时存在且匹配</li>
<li>自定义版本不得遮蔽正常版本</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>15.string实现的多样性</title>
    <url>/2018/04/10/string%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7/</url>
    <content><![CDATA[<p>（本章并未完全理解 建议结合More Effective C++ 29 写一个带有引用计数的string类以加深认识）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>sizeof(string)返回多少？不同的实现得到的答案不同。有的string大小等价于char*，而有的则是它的7倍大小。</p>
<hr>
<h1 id="string的内部组成"><a href="#string的内部组成" class="headerlink" title="string的内部组成"></a>string的内部组成</h1><p>每一个string的实现都容纳了以下信息：</p>
<ul>
<li>字符串大小（size)</li>
<li>该字符串所需的内存容量(capacity)</li>
<li>字符串的值</li>
</ul>
<p>另外，它们可能含有</p>
<ul>
<li>allocator的拷贝</li>
<li>值的引用计数</li>
</ul>
<p>不同的string实现以不同的方式把这些信息放在一起，为了证明此言非虚，下文给出了string的四种实现</p>
<hr>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="Implement-A"><a href="#Implement-A" class="headerlink" title="Implement A"></a>Implement A</h2><p><img src="http://static.zybuluo.com/zsmj2017/xdsavm0c3xiklk7lxit9ibr0/image_1can0lrfspfg12ulrsh1f66nu59.png" alt="image_1can0lrfspfg12ulrsh1f66nu59.png-28.3kB"><br>在实现A中，每个string有4个部分，配置器拷贝，大小，容量，以及一个指针。该指针指向引用计数以及字符串值的缓冲区。如果使用默认allocator，该实现的size是指针的四倍，而自定义allocator的话则会变得更大一些。</p>
<h2 id="Implement-B"><a href="#Implement-B" class="headerlink" title="Implement B"></a>Implement B</h2><p><img src="http://static.zybuluo.com/zsmj2017/lsl7f3d7bhd1k2om11cso1dh/image_1can0qdv7lmfirra5r1vcbhasm.png" alt="image_1can0qdv7lmfirra5r1vcbhasm.png-32.4kB"><br>实现B的string对象和内置指针一样大（这里假定使用的是默认allocator），因为其内存结构中确实只包含一个指针。该指针指向的对象包含字符串的大小、容量和引用计数，以及容纳字符串值的动态分配缓冲区的指针。对象也包含在多线程系统中与并发控制有关的一些附加数据。我们把这些数据标注为“other”.</p>
<h2 id="Implement-C"><a href="#Implement-C" class="headerlink" title="Implement C"></a>Implement C</h2><p><img src="http://static.zybuluo.com/zsmj2017/pff2i4ggex61wis8iea9xjl7/image_1can120f91jpa1sh91goa1j7a115113.png" alt="image_1can120f91jpa1sh91goa1j7a115113.png-22.7kB"><br>因为与allocator无关，实现C的大小总是等价于指针，X的部分是一些关于值可共享性的数据。（详见More Effective C++ 29）</p>
<h2 id="Implement-D"><a href="#Implement-D" class="headerlink" title="Implement D"></a>Implement D</h2><p><img src="http://static.zybuluo.com/zsmj2017/grp2afnkdd88xwak04lfnqoi/image_1can16lj2647uae1g5gkrc1muo1g.png" alt="image_1can16lj2647uae1g5gkrc1muo1g.png-43.1kB"><br>实现D的大小是指针的7倍。该实现没有使用引用计数，但每个srtring包含了一个最多可以表现15个字符的内部缓冲区。所以小字符串可以直接保留在对象中，如果大于15，则缓冲器的第一部分变成一个指向动态分配位置的指针，字符串的值存放于该内存中。（不可避免地浪费了一部分内存）</p>
<hr>
<h2 id="不同实现下的动态分配"><a href="#不同实现下的动态分配" class="headerlink" title="不同实现下的动态分配"></a>不同实现下的动态分配</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>当写下上述的表达式，我们可以清楚判断出D没有作动态分配，AC则做了一次，B则作了两次（分配对象，分配对象所指的字符缓冲）</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>27.universal reference的替代方案与修正</title>
    <url>/2018/07/14/universal%20reference%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E4%B8%8E%E4%BF%AE%E6%AD%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>上一节描述了针对universal reference作重载的函数可能出现的各种问题，本节将在上一节讨论的基础之上将提出各种解决方案。</p>
<hr>
<h1 id="Abandon-overloading"><a href="#Abandon-overloading" class="headerlink" title="Abandon overloading"></a>Abandon overloading</h1><p>&nbsp;<br>简单地来说，可以根据参数名设置不同的函数，例如将logAndAdd写为logAndAddName与logAndAddNameIdx，不过这种方法并不适用于Person，此外，放弃重载并不明智。</p>
<hr>
<h1 id="Pass-by-const-T-amp"><a href="#Pass-by-const-T-amp" class="headerlink" title="Pass by const T&amp;"></a>Pass by const T&amp;</h1><p>&nbsp;<br>事实上Item26中提出过这种写法，不过对于string来说它可能会生成一个临时对象从而降低效率，权衡利弊后这不失为一种解决方案。</p>
<hr>
<h1 id="Pass-by-value"><a href="#Pass-by-value" class="headerlink" title="Pass by value"></a>Pass by value</h1><p>&nbsp;<br>Itemn41建议说，如果你明确知道会发生copy操作，请使用pass by value。因此我们试以Person为例执行pass by value：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> n)</span>: <span class="title">name</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(n))</span> </span>&#123;&#125; <span class="comment">// Item 41 for use of std::move</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idx)</span>:<span class="title">name</span><span class="params">(nameFromIdx(idx))</span></span>&#123;&#125;</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>因为没有std::string构造函数只接受一个整数，因此传递给Person构造函数的所有int和intlike参数（例如，std::size_t，short，long）都会触发int重载函数调用。类似地，类型为std::string的所有参数（以及可以创建std::strings的东西，例如const char *）都会触发string重载函数调用。</p>
<hr>
<h1 id="Use-Tag-dispatch"><a href="#Use-Tag-dispatch" class="headerlink" title="Use Tag dispatch"></a>Use Tag dispatch</h1><p>&nbsp;<br>无论是pass by const T&amp;还是pass by value均不支持forward。如果我们需要使用forward，那么必须配合使用universal reference。有什么方法可以在不放弃使用universal reference的前提下使用重载吗？</p>
<p>解决方法是，查看所有可能使用的实参类型，然后根据它们的类型依次建立最佳重载版本。universal reference通常可以为所有实参提供精确匹配，但如果universal reference是包含非universal refence的其他参数的参数列表的一部分，其匹配优先级将会降低（此即是Tag dispath的技术基础），下文将以实例举证。</p>
<p>首先，这是logAndAdd的实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names; <span class="comment">// global data structure</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">"logAndAdd"</span>);</span><br><span class="line">    names.emplace(<span class="built_in">std</span>::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数能够正常运行，但如果需要增加int型重载则将陷入Item26所述困境，本节我们将重新实现logAndAdd，以委托两个其他函数的方式（一个接受int，一个接受别的），logAndAdd本身可以接受一切类型的参数。</p>
<p>执行实际工作的两个函数将命名为logAndAddImpl（依然使用了重载），其中一个以universal reference作为参数，因此我们仍然在执行重载与universal reference并行的策略。但本次每个函数都存在一个第二参数，该存在用以表征传入参数是否是一个int类型。也就是说，logAndAddImpl大概长这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span>&#123;</span><br><span class="line">    logAndAddImpl(<span class="built_in">std</span>::forward&lt;T&gt;(name),</span><br><span class="line">    <span class="built_in">std</span>::is_integral&lt;T&gt;()); <span class="comment">// not quite correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该代码并不保证正确，原因在于当一个左值被传递至universal reference name，那么T将被推衍成为一个左值引用，因此如果一个int型左值作为实参传入，当导致T被推衍为int&amp;,这并非是一个int类型，因此is_integral将永远返回false。当我们意识到这个问题的时候就等价于解决了这个问题，Item9中提及的type trait（std::remove_reference)几乎为此而生(C++14可以使用std::remove_reference_t&lt;T&gt;）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span>&#123;</span><br><span class="line">    logAndAddImpl(</span><br><span class="line">        <span class="built_in">std</span>::forward&lt;T&gt;(name),</span><br><span class="line">        <span class="built_in">std</span>::is_integral&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&gt;()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>至此，我们可以将注意力集中至logAndAddImpl，针对非整数类型的重载版本如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, <span class="built_in">std</span>::false_type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">"logAndAdd"</span>);</span><br><span class="line">    names.emplace(<span class="built_in">std</span>::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中的一大难点在于true和false都是运行期值，而我们需要在编译期明确调用函数，这意味着我们需要一个对应于true的类型和一个对应于false的类型，针对这种常见需求，标准库提供了std::true_type和std::false_type。<br>第二个重载版本如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">nameFromIdx</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">std</span>::true_type)</span></span>&#123;</span><br><span class="line">    logAndAdd(nameFromIdx(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在此实现中，我们避免了在logAndAddImpl中执行log（这一设计十分巧妙）。</p>
<p>在此设计中，类型std::true_type和std::false_type是“tag”，其唯一目的在于强制执行我们需要的重载函数。为了优化性能，我们甚至没有给这些参数命名。这种设计常见于TMP之中，当代C++库函数源码中经常出现这种设计。</p>
<hr>
<h1 id="抑制带有universal-references的模板实例化"><a href="#抑制带有universal-references的模板实例化" class="headerlink" title="抑制带有universal references的模板实例化"></a>抑制带有universal references的模板实例化</h1><p>&nbsp;<br>Tag dispatch的使用前提是客户端具备单一（非重载）函数，这些非重载函数内涵某些重载函数。但在Item26中的Person类中，默认生成的函数将自发与开发者定义的函数形成重载，因此tag dispatch并非完美无缺。针对这种universal refernce总被触发的情况，我们还有一招：std::enable_if。</p>
<p>std::enable_if可以强制令编译器认为某个特化模板并不存在（视作被禁用）。在默认情况下，所有模板都已启用，但仅当满足std::enable_if指定的条件时，才会启用使用std::enable_if的模板。以上一节的实例而言，只有当传递的类型不是Person时，我们才想启用Person forward构造函数。如果传递的类型是Person，我们则需要禁用forward构造函数（即令编译器忽视该函数），以copy ctor或move ctor触发调用。std::enable_if的使用范例如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;condition&gt;::type&gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>本书并不介绍关于std::enable_if的具体细节，而是将注意力转向其启用条件表达式。我们需要指定的条件是：仅在T并非Person类型时才会触发模板实例化。type traits能够表征两个类型是否相同:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">!<span class="built_in">std</span>::is_same&lt;Person,T&gt;::value</span><br></pre></td></tr></table></figure><br>但这并不正确，如果universal refernce被左值初始化，那么T必然是一个左值引用，这导致下述代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"Nancy"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>; <span class="comment">// initialize from lvalue</span></span><br></pre></td></tr></table></figure><br>此时T将会被推衍为Person&amp;，从而导致is_same返回false。</p>
<p>显然，针对推衍得到的T类型，我们应当忽略其：</p>
<ol>
<li><strong>reference</strong><br>为了确定是否应当启用universal reference构造函数，我们应当将Person&amp;、Person&amp;&amp;统一视为Person。</li>
<li><strong>const and volatile</strong><br>我们应当将const Person、volatile Person以及const volatile Person都视为Person。</li>
</ol>
<p>type traits再一次立了大功，它提供了std::decay&lt;T&gt;以消去refernce、cv限定符（实际上它还能负责将数组、函数退化为指针）。综上，我们可以得到condition表达式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">!<span class="built_in">std</span>::is_same&lt;Person, <span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::type&gt;::value</span><br></pre></td></tr></table></figure><br>最终，我们得到转发函数如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_same&lt;Person,<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::type&gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>假设派生自Person的类以常规方式实现copy与move操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialPerson</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpecialPerson(<span class="keyword">const</span> SpecialPerson&amp; rhs):Person(rhs)&#123; … &#125;</span><br><span class="line">    SpecialPerson(SpecialPerson&amp;&amp; rhs):Person(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs))&#123; … &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在Item26中我们曾经提及，上述copy、move操作可能并不调用基类对应的函数，而是会选择调用转发函数，原因在于universal reference具备更高的匹配程度（足以匹配const）。对于这种情况，发生在基类之中，确切地来说，我们当前认定Person将仅在传入参数不为Person或其派生类型时才会触发forward构造函数。</p>
<p>type traits再次发挥了作用，std::std::is_base_of&amp;T1, T2&gt;::value将在T2为T1的派生类时返回true（T自身亦可视为T的派生类），因此，我们可以利用它改写刚才的condition：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_base_of&lt;Person,<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::type&gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>利用C++14可以保证我们的代码更加优雅：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_base_of&lt;Person,<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;T&gt; &gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="区分int与non-int"><a href="#区分int与non-int" class="headerlink" title="区分int与non-int"></a>区分int与non-int</h2><p>&nbsp;<br>最终，我们将实践如何用enable_if区分int与non-int，我们需要做的只有两步：</p>
<ol>
<li><strong>添加一个Person构造函数以处理int类型（以重载的形式）</strong></li>
<li><strong>限制模板实例化，对某些参数禁用该模板</strong></li>
</ol>
<p>实践效果如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_base_of&lt;Person, <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;T&gt;&gt;::value &amp;&amp;</span><br><span class="line">            !<span class="built_in">std</span>::is_integral&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n):name(<span class="built_in">std</span>::forward&lt;T&gt;(n))&#123; … &#125;</span><br><span class="line">    <span class="keyword">explicit</span> Person(<span class="keyword">int</span> idx):name(nameFromIdx(idx))&#123; … &#125;</span><br><span class="line">    … <span class="comment">// copy and move ctors, etc.</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>&nbsp;<br>本节所介绍的前三种技术：abandoning overloading, passing by const T&amp;, and passing by value都需要明确为被调用的函数指明所有潜在参数类型，而后两种技术：tag dispatch,constraining template eligibility则使用转发函数，因此不必说明参数类型。是否说明参数类型这一行为直接决定了这些技术的特性。</p>
<p>一般而言，forward函数更为高效，因为它不必创建临时对象，但它亦存在缺点，例如并非所有参数都能做到完美转发（Item30见对此作出详细探讨），此外，forward函数可能会误将错误信息传递至对应的构造函数，举例而言，假设创建Person对象的客户端传递由char16_t（C++11中引入的类型，代表16位字符）而不是char组成的字符串常量：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">u"Konrad Zuse"</span>)</span></span>; <span class="comment">// "Konrad Zuse" consists of characters of type const char16_t</span></span><br></pre></td></tr></table></figure><br>前三种技术将会发现当前仅可采用int或string构造Person，因此产生明确的错误信息。而forward函数会自发将char16_t传入string构造函数，从而导致雪崩。一般来说，系统越复杂，转发层级越多，因此故障的排查也将愈加困难，一般而言，保留univeral reference的原因往往在于当前需要效率至上。</p>
<p>对于Person而言，我们明确universal reference应当构成string的初始化器，因此我们可以使用static_assert配合type traits std::is_constructible加以判断，最终形成的判断句如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_base_of&lt;Person, <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;T&gt;&gt;::value &amp;&amp;</span><br><span class="line">            !<span class="built_in">std</span>::is_integral&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n):name(<span class="built_in">std</span>::forward&lt;T&gt;(n))&#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(</span><br><span class="line">            <span class="built_in">std</span>::is_constructible&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt;::value,</span><br><span class="line">            <span class="string">"Parameter n can't be used to construct a std::string"</span></span><br><span class="line">        );</span><br><span class="line">        … <span class="comment">// the usual ctor work goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">    … <span class="comment">// remainder of Person class (as before)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>13. vector与string相较于动态数组的优越性</title>
    <url>/2018/04/09/vector%E4%B8%8Estring%E7%9B%B8%E8%BE%83%E4%BA%8E%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E8%B6%8A%E6%80%A7/</url>
    <content><![CDATA[<p>如果我们决定使用new进行动态分配，那么我们必须肩负以下责任：</p>
<ol>
<li>有new必然要delete</li>
<li>new[]必然要对应着delete[]</li>
<li>避免重复delete</li>
</ol>
<p>实际上上述操作总是很麻烦，所以我们应该尽可能使用vector或者string来代替动态数组。另外，这两大容器可以配合STL算法，效果绝佳。</p>
<p>事实上除了在多线程中使用引用计数字符串会导致性能下降外，其他情况下vector与string都具有绝对优势。就算这样，我们也可以试图关闭引用计数，或者使用<code>vector&lt;char&gt;</code>,尽管那失去了一些string的专有成员函数。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>40.private继承</title>
    <url>/2018/04/19/private%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="private继承的特性"><a href="#private继承的特性" class="headerlink" title="private继承的特性"></a>private继承的特性</h1><p>&nbsp;<br>private继承的特性可以概括为如下两条：</p>
<ol>
<li>如果classes之间的继承关系是private，编译器不会自动将一个derived class对象转换为一个base class对象。</li>
<li>由private base class继承而来的所有成员，在derived class中都会变成private属性，纵使它们原本是protected或者public.</li>
</ol>
<hr>
<h1 id="private继承的意义"><a href="#private继承的意义" class="headerlink" title="private继承的意义"></a>private继承的意义</h1><p>&nbsp;<br><strong>private继承意味着implemented-in-terms-of。</strong><br>如果我们让class d以private形式继承class b，这说明我们仅仅只是为了采用某些b中已经存在的特性，而不是b和d有任何观念上的交集。<br><strong>private继承完全是一种实现技术</strong>(这也是为何b中所有东西都被转为了private，因为它们都是实现细节）。如果说public继承代表了接口必须被继承，<strong>private继承意味着只有实现部分被继承，接口部分则被隐藏。</strong>private继承在软件设计层毫无意义，它的价值体现在软件实现层。</p>
<hr>
<h1 id="何时使用private继承"><a href="#何时使用private继承" class="headerlink" title="何时使用private继承"></a>何时使用private继承</h1><p>&nbsp;<br>上一节说过，composition也有implemented-in-terms-of的意义，那如何在composition与private继承之间取舍呢？答案是：<strong>尽可能使用复合，只有在必要时（protected成员以及virtual函数牵扯进来）才使用private继承。</strong></p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设我们有一个Widget，我们需要令它能够记录每一个成员函数的被调用次数，并且在运行期间我们将周期性地检查被调用次数。为了完成这项工作，我们需要一个定时器。假定库中存在着Timer class:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">timer</span><span class="params">(<span class="keyword">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//时间到后调用该函数</span></span><br><span class="line">    ...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><br>看起来我们只需要重新定义那个virtual函数就可以指定周期地读取Widget的状态了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="privte继承"><a href="#privte继承" class="headerlink" title="privte继承"></a>privte继承</h3><p>如果需要重定义virtual函数，Widget必须继承自Timer。它们之间的继承关系肯定不是public继承，因为它们并不满足is-a关系，而且用户也不能对着一个widget对象调用onTick成员函数，因为从观念上而言，该接口并不是Widget的一部分。（接口易用性原则 Effective C++ 18）<br>所以我们使用了private继承，并且写作如下形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span><span class="keyword">private</span> Timer&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//重定义函数 读取内部数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个设计很好，但是并不值钱，因为private继承绝非必要。我们完全可以使用一个composition来取代他。</p>
<hr>
<h3 id="composition"><a href="#composition" class="headerlink" title="composition"></a>composition</h3><p>只要在widget内部声明一个嵌套式private class，后者以public形式继承Timer并且重新定义onTick，最后放一个此类对象在该widget内即可，有设计样稿如下：<br><img src="http://static.zybuluo.com/zsmj2017/nq7q04xf83xr8xsqn8dl7iad/image_1cbe3etni1c16pn614dn2ava789.png" alt="image_1cbe3etni1c16pn614dn2ava789.png-8.3kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">widgetTimer</span>:</span><span class="keyword">public</span> Timer&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    widgetTimer Timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="composition写法的优点"><a href="#composition写法的优点" class="headerlink" title="composition写法的优点"></a>composition写法的优点</h4><ol>
<li>未来时态编程兼容性（More Effective C++ 32）<br>未来Widget可能会派生处derived class，但同时你可能会禁止derived class重新定义ontick。如果Widget继承自Timer，以上做法绝无可能实现。（derived class总可以重定义virtual函数）<br>如果Widgettimer是Widget的一个private成员并且继承自Timer，Widget的derived class将无法直接使用WidgetTimer，因此也无法继承或者定义它的virtual函数。（阻止derived class重新定义virtual函数的能力，可见Java与C++中的final）</li>
<li>降低编译依存性<br>如果Widget继承自Timer，那么它必然需要<code>#include Timer.h</code>。<br>但如果现在将WidgetTimer移出Widget之外,然后令Widget内含一个指针指向WidgetTimer，（PIMPL）Widget就可以只带着一个简单的声明式，这种解耦对于大型系统而言极为重要。</li>
</ol>
<p>总之，private继承主要用于<strong>“当一个意欲成为dc的class想访问一个意欲成为bc的class的protected部分，或者为了重定义一个或者多个virtual函数”</strong>，但此时两个class之间的关系决非is-a而是is-implementef-in-terms-of的关系。</p>
<hr>
<h2 id="private继承与empty-class"><a href="#private继承与empty-class" class="headerlink" title="private继承与empty class"></a>private继承与empty class</h2><p>private继承可以帮助实现空间最优化，不过只涉及empty class.</p>
<h3 id="empty-class"><a href="#empty-class" class="headerlink" title="empty class"></a>empty class</h3><p>empty class是指不带有任何数据的class，它们没有non-static成员变量，没有virtual函数（因为会导致vptr），没有virtual base class（亦会造成空间额外开销，可见Effective C++ 41、More Effective C++ 24).<br>从理论上而言，empty class对象不使用任何空间，因为没有任何数据需要存储。但是由于技术上的理由，C++规定凡<strong>是独立对象都必须拥有非0大小</strong>，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="keyword">int</span> x；</span><br><span class="line">    Empty e；<span class="comment">//理论上不占据内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你会发现<code>sizeof（HoldAnInt）</code>&gt;<code>sizeof(int)</code>,因为<code>sizeof(Empty)</code>=1.<br>由于“独立对象都必须拥有非0大小”的规定，编译器将一个char进入了空对象内。而后可能存在的齐位等要求导致了Holdanint可能获得了不止一个char的大小。</p>
<h3 id="EBO-empty-base-optimization"><a href="#EBO-empty-base-optimization" class="headerlink" title="EBO(empty base optimization)"></a>EBO(empty base optimization)</h3><p>之前我们说过，独立对象的大小一定不为0，也就是说，这个约束不适用于对象内的base class成分，所以如果令Holdanint继承自Empty，则有<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span>:</span><span class="keyword">private</span> Empty&#123;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>(HoldAnInt)==<span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><br>这也就是所谓的EBO(empty base optimization).此外，EBO只在单一继承时有效。</p>
<h3 id="EBO的作用"><a href="#EBO的作用" class="headerlink" title="EBO的作用"></a>EBO的作用</h3><p>可能有人会质疑Empty的作用，实际上在STL中存在着大量的类似Empty的基类，例如unary_function等等（详见Effective STL 40)，它们的内部往往内含着有用的typedefs、enums、以及non-virtual函数。正是由于EBO的存在，这些函数保证了derived class的大小不受干扰。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>private继承意味着is-implemented-in-terms-of。它通常比composition的级别低，但是如果dc想要访问base class的protected成员或者重定义virtual时，这种设计是合理的</li>
<li>private继承可以实现EBO，这对需要尽力缩减对象大小的开发者来说是一件好事。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>17.swap去除多余容量</title>
    <url>/2018/04/11/swap%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E5%AE%B9%E9%87%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>当我们的容器内存储了海量的元素之后，可能在某个阶段会进行大量的删除，此时容器已经没有必要再持有过多的内存，为了避免浪费，应该使用某种shrink_to_fit的手法将其cap缩减到合适的大小（<strong>resize与reserve都无法减小cap</strong>）。</p>
<h1 id="Swap技巧"><a href="#Swap技巧" class="headerlink" title="Swap技巧"></a>Swap技巧</h1><h2 id="Swap与shrink-to-fit"><a href="#Swap与shrink-to-fit" class="headerlink" title="Swap与shrink_to_fit"></a>Swap与shrink_to_fit</h2><p>收缩容器的技巧在操作上十分简单：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sth</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Sth&gt; v;</span><br><span class="line">...<span class="comment">//Now v need to be shrinked to the fit capacity</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Sth&gt;(v).swap(v);</span><br></pre></td></tr></table></figure><br>该技巧的执行流程：</p>
<ol>
<li>建立了一个临时变量，并调用拷贝构造函数复制了v中元素<br><strong>拷贝构造只使用了需要的内存，并没有分配所有内存</strong></li>
<li>将临时对象与v交换。</li>
<li>完成此表达式后临时对象被析构。</li>
</ol>
<p>同理，收缩string也是如此：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">string</span>(s).swap(s);</span><br></pre></td></tr></table></figure></p>
<h2 id="Swap与容器清除"><a href="#Swap与容器清除" class="headerlink" title="Swap与容器清除"></a>Swap与容器清除</h2><p>Swap技巧同样也能够直接<strong>清除容器内部所有元素，并减小其容量至最小值</strong>，其原理是使用刚初始化过的临时变量与需要清除的vector或string交换，如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Sth&gt; v;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">vector</span>&lt;Sth&gt;().swap(v);</span><br><span class="line"><span class="built_in">string</span>().swap(s);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>33.public继承：is-a关系</title>
    <url>/2018/04/16/public%E7%BB%A7%E6%89%BF%EF%BC%9Ais-a%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>以c++进行面向对象编程时，最重要的一条规则是<strong>：public inheritance意味着is-a的关系</strong>。</p>
<hr>
<h1 id="is-a关系"><a href="#is-a关系" class="headerlink" title="is-a关系"></a>is-a关系</h1><p>&nbsp;<br>如果你令class d public derived from class b，你等于在同时告诉c++编译器以及代码读者，<strong>每一个类型为d的对象同时也是一个类型为b的对象，反之不成立。</strong><br>这也可以表示为“<strong>每一个需要b对象的地方，d对象也同样适用</strong>”，因为每一个d对象也是一个b对象。<br>该定义只对public继承有效，private继承的意义与此完全不同（详见Effective C++ 40),至于protected继承，其意义十分暧昧。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>大多数人都认为is-a关系十分简单，但实际并非如此,因为直觉容易误导我们。</p>
<h2 id="鸟与企鹅"><a href="#鸟与企鹅" class="headerlink" title="鸟与企鹅"></a>鸟与企鹅</h2><p>企鹅是一种鸟，这是再自然不过的。鸟可以飞，这也是符合直觉的。于是…<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;<span class="comment">//鸟会飞</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span>:</span><span class="keyword">public</span> Bird&#123;<span class="comment">//企鹅是一种鸟</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>实际上企鹅不会飞，但企鹅却继承了fly接口，这明确表明当前继承体系存在问题。</p>
<h3 id="重塑继承体系"><a href="#重塑继承体系" class="headerlink" title="重塑继承体系"></a>重塑继承体系</h3><p>你或许会意识到这是因为不严谨的语言表述导致我们吃了大亏。实际上是这样的：企鹅是鸟，但不是所有鸟都会飞，有的会有的不会。所以这才是正确的继承体系：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bird</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">flyingbird</span>:</span><span class="keyword">public</span> bird&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flying</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">penguin</span>:</span><span class="keyword">public</span> bird &#123;&#125;;</span><br></pre></td></tr></table></figure><br>这种写法针对fly这个接口无疑是成功的，但实际上对于某些软件系统而言，它根本不用去关心鸟会不会飞，此时建立一个flyingbird无疑是不明智的。这引出了一个事实：<br><strong>世界上并不存在一个完美适用于所有软件的完美设计。所谓的最佳设计，取决于系统现在以及未来所关注的重点。</strong></p>
<h3 id="运行期报错处理"><a href="#运行期报错处理" class="headerlink" title="运行期报错处理"></a>运行期报错处理</h3><p>有人会为企鹅重新定义一个fly函数，令其产生一个运行期错误：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">​<span class="class"><span class="keyword">class</span> <span class="title">penguin</span>：<span class="title">public</span> <span class="title">bird</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>：</span></span><br><span class="line"><span class="class">    <span class="title">virtual</span> <span class="title">void</span> <span class="title">fly</span>()&#123;</span></span><br><span class="line">        error(“can <span class="keyword">not</span> fly”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种写法是失败的，它等于在说：企鹅会飞，但是一飞就报错。这违背了我们的设计理念：让接口易于使用，不被误用。（Effective C++ 19）</p>
<hr>
<h2 id="矩形与正方形"><a href="#矩形与正方形" class="headerlink" title="矩形与正方形"></a>矩形与正方形</h2><p>squre应该public derived from rectangle吗？也许你会毫不犹豫地肯定这一观点，“正方形必然是矩形，但反之不成立”。请考虑如下程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> newHeight)</span></span>;</span><br><span class="line">    ...<span class="comment">//setWidth</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>:</span><span class="keyword">public</span> Rectangle &#123;...&#125;;</span><br></pre></td></tr></table></figure><br>Square继承了<code>setHeight</code>等接口，也就是说，我们可以通过调用成员函数，导致正方形长宽不等，那这种对象还能被称为正方形吗。（实际上，在正方形的接口中我们必须确保setHeight之后必须执行setWidth）</p>
<hr>
<h1 id="classes之间的关系"><a href="#classes之间的关系" class="headerlink" title="classes之间的关系"></a>classes之间的关系</h1><p>&nbsp;<br>is-a并非是classes之间唯一的关系，另外两个常见的是has-a与is-implemented-in-terms-of。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>public继承意味着is-a，is-a意味着适用于base对象身上的每一件事情一定也适用于derived对象身上，因为每一个derived对象也一定是一个base对象。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>vultr科学上网脚本备份</title>
    <url>/2019/03/21/vultr%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E8%84%9A%E6%9C%AC%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="SSR脚本"><a href="#SSR脚本" class="headerlink" title="SSR脚本"></a>SSR脚本</h1><p>&nbsp;<br><code>CentOS6</code> ,<code>Debian6</code> ,<code>Ubuntu14</code> 一建部署SSR脚本:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/hombo125/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure></p>
<h1 id="BBR加速"><a href="#BBR加速" class="headerlink" title="BBR加速"></a>BBR加速</h1><p>&nbsp;<br><code>CentOS 6+</code>,<code>Debian 8+</code>,<code>Ubuntu 14+</code> BBR加速脚本：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh" &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>29.不必高估move语义</title>
    <url>/2018/07/15/%E4%B8%8D%E5%BF%85%E9%AB%98%E4%BC%B0move%E8%AF%AD%E4%B9%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>移动语义可以被认为是C++11的首要特性。它不仅允许编译器用相对便宜的移动替换昂贵的拷贝操作，并且在实际中要求编译器如此运转（在条件满足时），但本节要叙述的是：不要过高地看待移动语义。</p>
<hr>
<h1 id="类型支持"><a href="#类型支持" class="headerlink" title="类型支持"></a>类型支持</h1><p>&nbsp;<br>首先，并非所有类型均支持移动语义。在实际使用过程中，可能你当前使用的类型（历史遗留代码）并不支持移动语义。确实，C++11愿意为缺少它们的类生成move操作，但这只发生在声明没有copy操作，移动操作或析构函数的类中（见Item17）。此外，不支持move的data member或base class）也将抑制编译器生成move操作。</p>
<hr>
<h1 id="支持也未必高效"><a href="#支持也未必高效" class="headerlink" title="支持也未必高效"></a>支持也未必高效</h1><p>&nbsp;<br>其次，即使该类型明确具备移动语义，它也未必如你所想般高效。举例而言，C++标准库中的所有容器均支持移动语义，但对于某些容器来说，它们的移动语义并不具备真正的低开销，又或者由于容器元素类型的限制，它们无法采用真正高效的move操作。</p>
<h2 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h2><p>以std::array为例，该容器是C++11中的一个新容器。std::array本质上是一个带有STL接口的内置数组。一般而言，STL容器倾向于将其所有元素均保存在堆上，内部元素仅仅是一个指向堆中内容的指针（真实情况较为复杂，但其差异不影响本次讨）。这些指针的存在为移动容器提供了便利：只需要将现有指针指向对应内容，然后将指针置为nullptr即可，现以移动vector为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; vw1;</span><br><span class="line"><span class="comment">// put data into vw1</span></span><br><span class="line">…</span><br><span class="line"><span class="comment">// move vw1 into vw2. Runs in constant time. Only ptrs in vw1 and vw2 are modified</span></span><br><span class="line"><span class="keyword">auto</span> vw2 = <span class="built_in">std</span>::<span class="built_in">move</span>(vw1);</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/zsmj2017/wnoy6o8pegwe0lyzll516et1/image_1cie5hhbvcjm1ukp1m0c1a4713rh9.png" alt="image_1cie5hhbvcjm1ukp1m0c1a4713rh9.png-21kB"><br>但std::array将元素直接存储于对象内部，因此其move操作看起来如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;Widget, 10000&gt; aw1;</span><br><span class="line"><span class="comment">// put data into aw1</span></span><br><span class="line">…</span><br><span class="line"><span class="comment">// move aw1 into aw2. Runs in</span></span><br><span class="line"><span class="comment">// linear time. All elements in</span></span><br><span class="line"><span class="comment">// aw1 are moved into aw2</span></span><br><span class="line"><span class="keyword">auto</span> aw2 = <span class="built_in">std</span>::<span class="built_in">move</span>(aw1);</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/zsmj2017/6vb9j6bgrv0q0j6wk4fy4tt1/image_1cie5kqjo1pjm150r12rer3g1979m.png" alt="image_1cie5kqjo1pjm150r12rer3g1979m.png-22.1kB"></p>
<p>这里需要注意的是，我们必须移动aw1中每一个Widget至aw2，也就是说当前仍然需要线性的时间，可能这快于copy，但也绝非像某些人所说的“移动容器只需要执行拷贝一个指针的时间”。</p>
<h2 id="SSO-std-string"><a href="#SSO-std-string" class="headerlink" title="SSO std::string"></a>SSO std::string</h2><p>又例如，std::string提供常数时间的移动操作与线性时间的拷贝操作，这让我们感觉移动必然快于拷贝，但情况可能并非如此。许多字符串实现采用小字符串优化（SSO）。对于SSO，“小”字符串（例如，容量不超过15个字符的字符串）存储于std::string对象内的buffer中，而并非使用堆中的内存。移动基于SSO技术实现的字符串并不快于拷贝，因为传统仅拷贝一个指针的行为对其并不适用（内容存储于对象内，因此必须对对象有所操作），对于此类对象，copy并不慢于move。</p>
<hr>
<h1 id="异常安全性"><a href="#异常安全性" class="headerlink" title="异常安全性"></a>异常安全性</h1><p>&nbsp;<br>即使一切安好，move操作最终也可能会导致copy操作。在Item14中曾经提及，为了不破坏历史遗留代码，C++11中的异常规格必然与C++98中相容，因此，对于某些容器，只有在move操作明确不会抛出异常时才可能会取代copy操作。因此，即使move操作确实优于copy操作且当前环境适用于move（例如参数为右值），编译器在move操作并未声明为noexcept的情况下依然会选择对move视而不见。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>在撰写代码时务必谨慎假设move语义并未发挥作用，但如果你明确当前类型必然支持移动语义，那自然可以大胆使用。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2.不要试图编写独立于容器的代码</title>
    <url>/2018/04/06/%E4%B8%8D%E8%A6%81%E8%AF%95%E5%9B%BE%E7%BC%96%E5%86%99%E7%8B%AC%E7%AB%8B%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>​<br>STL本身就是以泛化原则作为基础：</p>
<blockquote>
<ul>
<li>数组被泛化为“以包含对象的类型”为参数的容器</li>
<li>函数被泛化为“以使用的迭代器的类型”为参数的算法</li>
<li>迭代器被泛化为“以其指向的对象的类型”为参数的迭代器</li>
</ul>
</blockquote>
<p>有人可能会试图去开发某种程序，它对任何容器都适用，而这是无必要也是不可能的。不同容器应用场合不同，其特性也不同，我们无法再次对其泛化。<br>但是，我们也许会在某一天发现自己选取的容器并非最佳容器，所以我们试图去改变它。这个时候封装技术就显得很有必要。</p>
<hr>
<p>封装技术最简单的实现方式就是使用类型定义typedef。具体来说，假设原有代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br><span class="line">Widget bestWidget;</span><br><span class="line">... <span class="comment">// 给bestWidget一个值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt;::iterator i = <span class="built_in">find</span>(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), bestWidget);<span class="comment">//寻找等值者</span></span><br></pre></td></tr></table></figure><br>这一种写法相当常见，但下一种更好：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Widget&gt; WidgetContainer;</span><br><span class="line"><span class="keyword">typedef</span> WidgetContainer::iterator WCIterator;</span><br><span class="line">WidgetContainer cw;</span><br><span class="line">Widget bestWidget;</span><br><span class="line">...</span><br><span class="line">WCIterator i = <span class="built_in">find</span>(cw.<span class="built_in">begin</span>(), cw.<span class="built_in">end</span>(), bestWidget);</span><br></pre></td></tr></table></figure></p>
<p>最明显的一个好处就是更换容器时代码无需发生改动。</p>
<hr>
<p>当然，类型定义只是词法上的修改，它并未增加什么功能。如果我们不希望让用户得知我们真正使用的容器，那我们则需要使用class来完成。要想减少在替换容器后需要修改的代码，我们可以把容器隐藏在一个class中，并且尽量减少通过类接口（而使外部）可见的，与容器相关的信息。<br>举例而言，如果我们试图编写一个顾客列表，不直接使用list，而是新建一个customerlist类，并把list隐藏于私有部分，其具体实现可以如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">list</span>&lt;Customer&gt; CustomerContainer;</span><br><span class="line">    <span class="keyword">typedef</span> CustomerContainer::iterator CCIterator;</span><br><span class="line">    CustomerContainer customers;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 通过该接口限制list的可见性</span></span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样既保证了list的私密性，也使代码易于修改。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>8.为多态基类生成virtual析构函数</title>
    <url>/2018/04/08/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E7%94%9F%E6%88%90virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>假设我们定义了一个base class，并随之延伸出一些derived class。用户只需要在程序中使用某个功能，并不关心其实现。因此，我们可以设计一个factory函数。(工厂模式详见More Effective C++ 25）<br>factory函数返回一个base clsss指针，指向新生成的derived class对象。 返回的对象必须位于heap，因此为了避免泄漏内存和其他资源，factory返回的每一个对象都应该被适当的delete。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span>&#123;</span><span class="comment">//计时器基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    ~TimeKeeper();<span class="comment">//此处不应该使用non-virtual析构函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicClock</span>:</span><span class="keyword">public</span> TimeKeeper&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterClock</span>:</span><span class="keyword">public</span> TimeKeeper&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">TimeKeeper* ptk=getTimeKeeper();<span class="comment">//factory函数</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;释放以避免资源泄露</span><br></pre></td></tr></table></figure><br>问题在于factory返回的指针指向一个derived class对象，而那个对象却经由一个base class指针被删除。如果base class的析构函数是non-virtual，则我们再次雪崩。</p>
<hr>
<h1 id="多态基类不使用virtual析构的后果"><a href="#多态基类不使用virtual析构的后果" class="headerlink" title="多态基类不使用virtual析构的后果"></a>多态基类不使用virtual析构的后果</h1><p>c++明确指出，当derived class对象由一个base class指针被删除，而base class带着一个non-virtual析构函数，<strong>其结果未定义</strong> — 一般来说，实际执行时对象的derived成分没被销毁，derived class的析构函数也没执行。也就是说我们得到了一个诡异的<strong>局部销毁对象</strong>。</p>
<hr>
<h1 id="何时需要virtual析构函数？"><a href="#何时需要virtual析构函数？" class="headerlink" title="何时需要virtual析构函数？"></a>何时需要virtual析构函数？</h1><p>一般来说，base class都会有那么一个virtual function。我们在这里指出，<strong>只要一个class有virtual function，我们都应该把它的析构函数定义为virtual。</strong></p>
<p><strong>如果一个class不被用作base class，那给他定义一个virtual 析构函数非常愚蠢</strong>。原因是这样的：<br>欲实现出virtual函数，对象必须携带某些信息，要来指出在运行期哪个virtual函数被调用。这份信息一般由一个virtual table pointer指出。vtp指向一个vbtl(virtual table)每一个带virtual函数的class都会有一个vtbl，当函数调用某个virtual函数，实际被调用的函数取决于对象的vptr所指向的vtbl—编译器在其中寻找函数指针。（关于虚函数的使用成本，详见More Effective C++ 24）<br>总之，虚函数的引入增加了class的大小，并且破坏了原有的内存结构。</p>
<p>另外，<strong>STL所有的类都不能作为base class，它们也没有virtual析构函数</strong>。</p>
<hr>
<h1 id="virtual析构函数在abstract-class中的用法"><a href="#virtual析构函数在abstract-class中的用法" class="headerlink" title="virtual析构函数在abstract class中的用法"></a>virtual析构函数在abstract class中的用法</h1><p>有时我们希望定义一个abstract class，但是手头上并没有pure virtual function，那解决方法很简单：<strong>声明一个pure virtual 析构函数</strong>。<br>但事情还没完，我们<strong>不仅仅需要声明，还需要定义</strong>这个析构函数。可能你会诧异于pure function居然还需要实现，但实际上pure function和有没有实现并没有任何联系。（该论述详见More Effective C++ 33）,具体声明和定义如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line">    <span class="keyword">virtual</span> ～c() = <span class="number">0</span>;<span class="comment">//声明式</span></span><br><span class="line">&#125;;</span><br><span class="line">c::~c() &#123;&#125;<span class="comment">//定义式</span></span><br></pre></td></tr></table></figure><br>因为析构函数的运作规则是是从最深层派生的class开始调用其析构，然后是每一个base class。在derived class的析构动作中编译器会创建一个对其基类析构函数的调用动作，如果没有定义，连接器会报错。</p>
<hr>
<h1 id="是否只要是base-class就需要析构函数？"><a href="#是否只要是base-class就需要析构函数？" class="headerlink" title="是否只要是base class就需要析构函数？"></a>是否只要是base class就需要析构函数？</h1><p>正如标题所说，<strong>只有使用了多态性的base class（具备虚函数）才需要virtual析构</strong>。<br>诸如上节提到的uncopyable类，其根本不需要使用virtual 析构函数。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>polymorphic base class应该声明一个virtual析构。如果一个类至少有一个virtual function，把它也应该拥有一个virtual析构函数</li>
<li>class 不具有多态性或者根本不作为base class，那就不要搞virtual析构。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>10.绝不在构造和析构过程中调用virtual函数</title>
    <url>/2018/04/08/%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++禁止在构造和析构期间调用virtual函数，这是它与Java或者C#的一大不同之处。</p>
<hr>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>假设我们现有一个class用来模拟股市交易，显然每一笔订单都需要经过审计，那么在审计日志中必然也需要创建一笔交易记录，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;<span class="comment">//因交易类型不同做出不同的记录</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction()&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction();<span class="comment">//构造的最后执行记录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span><span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span></span>;<span class="comment">//因交易类型不同做出不同的记录</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>试想一下，当这行语句执行时会发生什么？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="构造、析构次序与virtual函数"><a href="#构造、析构次序与virtual函数" class="headerlink" title="构造、析构次序与virtual函数"></a>构造、析构次序与virtual函数</h1><p>当我们创建derived class时，无疑bc的构造函数优先被调用，因为base class成分会在derived class自身成分被构造之前先构造完毕。这个时候问题来了，bc的构造函数最后使用了virtual function，但它调用的并不是derived class定义的版本，而是bc的pure virtual版。有一个不太恰当的解释：在构造base class构造期间，virtual函数并不是virtual函数。</p>
<p>因为base class的构造早于derived class构造函数，当base class构造函数执行时derived class的成员变量尚未初始化。如果在这期间调用derived class版本的virtual function，无疑该函数几乎必然使用local成员变量，而他们尚未初始化。</p>
<p>更根本的原因在于，<strong>在derived class的base成分构造期间，对象的类型是base class而非derived class。</strong>如果我们试图用dynmaic_cast或者typeid，这些函数也会把对象视为base class类型。这么对待对象是合理的：因为derived class的专属成分尚未被初始化，那么面对它们最安全的做法就是视而不见。<strong>对象在derived class构造函数开始执行前不会成为一个derived class对象。</strong></p>
<p>相同道理也适用于析构函数。当进入了base class的析构函数后，析构对象已经变成了一个base class对象。你不可能在一个bc对象上调用dc的成员函数。</p>
<hr>
<h1 id="潜在危险"><a href="#潜在危险" class="headerlink" title="潜在危险"></a>潜在危险</h1><p>并非每一种virtual函数都明明白白地写在构造或者析构函数中等你改正，考虑下面这种情况：由于构造函数往往有多个，我们通常倾向于把构造函数们共同使用的那一部分代码放进一个初始化函数，但是init函数可能会包含一个virtual函数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction() &#123;init();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    init()&#123;</span><br><span class="line">        ...</span><br><span class="line">        logTransaction();<span class="comment">//此处调用了virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种方法十分毒瘤，因为不会有任何连接器和编译器报错我们只能认真地检查构造函数和析构函数，<strong>确保不管是它们自身还是它们所调用的那些函数都不含有任何virtual函数</strong>。</p>
<hr>
<h1 id="根治策略"><a href="#根治策略" class="headerlink" title="根治策略"></a>根治策略</h1><p>上述解决方法本质上仍然无法解决每当对象被创建就会自发记录的问题，我们已经了解无法在构造/析构函数中使用virtual函数,所以解决方法是将其改为non-virtual,要求dc构造函数必须传递必要信息给Transaction构造函数，而后那个构造函数就可以安全地调用non-virtual logTransaction。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; logInfo)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; logInfo)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">string</span>&amp; logInfo)&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span><span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BuyTransaction(parameters):</span><br><span class="line">        Transaction(createLogString(parameters))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>因为我们做不到virtual函数从base class向下调用，在构造期间，我们只能令derived class将必要的构造信息传递至base class的构造函数。<br><strong>比起在成员初值列给予base class所需要的数据，利用辅助函数创建一个值传给base class往往更加可读。令此函数为static，也就不可能指向derived class内尚未初始化的成员变量。</strong></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不要在构造和析构过程中调用virtual函数，因为此类调用从不会下降至dc层。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>30.为异常安全而努力</title>
    <url>/2018/04/15/%E4%B8%BA%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E8%80%8C%E5%8A%AA%E5%8A%9B/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设存在一个class表示具备背景图案的GUI菜单。该class作用于多线程环境下，所以它有一个互斥器（mutex）作为并发控制（concurrency control)之用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBackground</span><span class="params">(istream&amp; imgSrc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Image* bgImage;<span class="comment">//原始图片资源</span></span><br><span class="line">    <span class="keyword">int</span> imageChanges;<span class="comment">//改变次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>下面是PrettyMenu的changeBackgroun的可能实现(糟糕实现)：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> PrettyMenu:changeBackground(istream&amp; imgSrc)&#123;</span><br><span class="line">    lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> Image(imgSrc);</span><br><span class="line">    unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>异常安全有两个条件，而该函数没有满足其中任何一个条件。</p>
<hr>
<h1 id="异常安全的条件"><a href="#异常安全的条件" class="headerlink" title="异常安全的条件"></a>异常安全的条件</h1><p>&nbsp;<br>当异常被抛出时，带有异常安全性的函数必须：</p>
<ol>
<li>不泄露任何资源<br>上述实例中如果new操作抛出异常，那么资源无法被unlock，也就是无法得到释放</li>
<li>不允许数据破坏<br>上述实例中如果new抛出异常，bgImage将永久性地空悬。</li>
</ol>
<hr>
<h1 id="确保异常安全"><a href="#确保异常安全" class="headerlink" title="确保异常安全"></a>确保异常安全</h1><h2 id="确保资源不被泄露"><a href="#确保资源不被泄露" class="headerlink" title="确保资源不被泄露"></a>确保资源不被泄露</h2><p>确保资源不被泄露的最佳方式是以RAII。（详见Effective C++ 资源管理篇）</p>
<h2 id="确保数据不被破坏"><a href="#确保数据不被破坏" class="headerlink" title="确保数据不被破坏"></a>确保数据不被破坏</h2><h3 id="异常安全保证"><a href="#异常安全保证" class="headerlink" title="异常安全保证"></a>异常安全保证</h3><p>在解决数据破坏问题之前，必须要了解一些相关术语。首先是<strong>异常安全保证</strong>。</p>
<hr>
<p>异常安全提供以下三个保证之一：</p>
<ul>
<li>基本承诺<br><strong>如果异常被抛出，程序的任何事物仍然保持有效状态。</strong>没有任何对象和数据结构因此遭到破坏，所有对象均满足内部前后一致（class约束条件仍然有效），但程序的现实状态不可预料。<br>以实例为背景，我们可以确保在更换背景时如果抛出异常，对象会拥有原背景图案，或者对象会更改为某个默认背景图案，用户无法预期究竟会发生哪种情况。</li>
<li>强烈保证<br>如果运行期间存在异常被抛出，程序状态不改变。也就是说，<strong>运行成功则完全成功，失败则函数调用前的状态</strong>。<br>这比基本承诺所提供的性能要强，因为它确保了程序只有两种状态（调用成功，调用前），而基本承诺具备多个多态的可能（调用成功，调用前，以及任一合法状态）。</li>
<li>nothrow保证（C++11引入noexcept修饰符）<br>最高异常安全保证，确保<strong>程序在运行期间不会抛出任何异常</strong>，永远可以完成预期功能。所有内置类型都提供了nothrow保证（这也就是Effective C++ 26中认为swap处理内置类型及等价为异常安全的原因）。<br>也许有人会认为具备空白异常明细（empty exception specification)者必为nothrow函数，其实并非如此,举例而言：<br><code>int dosth() throw();</code><br>这并非是说dosth不会抛出异常，而是说如果dosth抛出异常，将会执行set_unexpected函数（对程序而言是严重错误）。<strong>函数的声明（包括异常明细）并不能提供任何异常保证，所有性质均由实现来决定</strong>。</li>
</ul>
<p>Exception-safe code必须提供上述三种保证之一，否则则不具备异常安全性。</p>
<hr>
<h3 id="异常安全保证的选择"><a href="#异常安全保证的选择" class="headerlink" title="异常安全保证的选择"></a>异常安全保证的选择</h3><p>nothrow自然是异常安全的最高追求，但很难做到。因为只要我们使用了动态内存，则不可避免地会接触<code>bad_alloc</code>异常。对于大部分函数而言，我们往往只在基本保证和强烈保证之间。</p>
<hr>
<h2 id="异常安全实例"><a href="#异常安全实例" class="headerlink" title="异常安全实例"></a>异常安全实例</h2><p>仍以changeBackground为例，我们提供强烈保证只需要完成以下两点：</p>
<ol>
<li>改用RAII</li>
<li>重排语句次序，保证<strong>对象的状态只会在过程确实完成后才会被改变</strong>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(istream&amp; imgSrc)</span></span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.reset(<span class="keyword">new</span> Image(imgSrc));</span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，这里无需手动delete，且reset中delete执行依赖于新图像的成果创建。也就是说如果new跑出了异常，原本的资源不会遭到破坏，程序依然维持着执行前的状态。</p>
<hr>
<h2 id="强烈保证的设计策略（copy-and-swap）"><a href="#强烈保证的设计策略（copy-and-swap）" class="headerlink" title="强烈保证的设计策略（copy and swap）"></a>强烈保证的设计策略（copy and swap）</h2><p>copy and swap能够很轻松的实现强烈保证，其原理很简单：当为你所需要修改的对象构造一份副本，然后在副本上执行修改，修改完成后swap副本与原件。如果在修改期间发生了异常，我们可以保证原件并没有遭到破坏。<br>其具体实现手法是：将所有“隶属于对象的数据”从原对象放入另一个对象，然后赋予原对象一个指针指向具体实现对象。（pimpl设计模式,详见Effective C++ 32）。对于PrettyMenu而言，其具体写法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span>&#123;</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(istream&amp; imgSrc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;<span class="comment">//详见Effective C++ 26</span></span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;PMimpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;<span class="comment">//构造副本</span></span><br><span class="line">    pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc));<span class="comment">//修改副本</span></span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    swap(pImpl,pNew);<span class="comment">//置换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以下逐步分析本例中copy and swap的具体操作：</p>
<ol>
<li>RAII要求了原始资源Image需要被一个智能指针所持有，所以bgImage是一个智能指针对象。</li>
<li>与PrettyMenu直接有关的数据除了背景图之外，还有背景图变换次数int imageChanges。</li>
<li>将bgImage与imageChanges打包，封装成为一个新的具体实现对象PMimpl。</li>
<li>在PrettyMenu中存有指向具体实现的指针shared_ptr<PMImpl> pImpl.具体实现对象PMimpl同样是一种资源，所以再次使用了RAII，该指针pImpl为private。</li>
<li>pImpl的私有性保证了PMImpl无法被客户直接访问，因此将其设为strcut并不影响数据封装性。</li>
<li>在copy动作中，最先执行的是new PMimpl(*pImpl)语句。该语句在heap上建立了一个PMImpl对象，调用了PMImpl默认拷贝构造函数。</li>
<li>PMImpl的默认拷贝构造函数对于int数据采取了逐bit拷贝，对于shared_ptr对象则调用了其默认拷贝构造函数。</li>
<li>shared_ptr&lt;Image&gt;默认拷贝构造函数执行，计数器自增，此时有两个智能指针指向原始图像资源。至此，PMImpl构造完毕。</li>
<li>pNew执行构造函数，接受一个指向heap中的PMImpl对象，RAII执行完毕，资源被封存入pNew中进行管理。<br>pNew作为原有数据的副本，其raw pointer指向PMImpl对象，PMImp对象内部存有一个int与一个shared_ptr，该智能指针指向原始图像资源，该资源的引用计数为2。</li>
<li>通过new Image语句构造了一个位于heap中的Image对象，将其作为reset的实参。</li>
<li>pNew通过解引用访问PMimpl对象的bgImage，对bgImage执行reset操作。</li>
<li>bgImage并非唯一指向原始资源的智能指针，因此原始图像资源并未析构，计数器自减。bgImage指向新构造的Image对象。</li>
<li>pNew中的背景更换次数自增,执行swap(pImpl,pNew);</li>
<li>pImpl和pNew交换了彼此所指向的对象，此时pImpl指向了一个位于heap中的PMImpl对象，其bgImage指向了新构建的Image对象，且其int数据已发生过自增。</li>
<li>控制流离开changeBackground程序块，位于stack中的pNew对象开始析构。由于pNew是唯一指向原有PMImpl对象的智能指针，原有PMImpl执行析构函数。</li>
<li>原有PMImpl中的int内置类型没有析构函数，bgImage开始析构。</li>
<li>bgImage为唯一指向原有原始图像资源的智能指针，原有原始图像资源析构。至此copy and swap执行完毕。</li>
</ol>
<hr>
<h2 id="强烈保证的连带效应"><a href="#强烈保证的连带效应" class="headerlink" title="强烈保证的连带效应"></a>强烈保证的连带效应</h2><p>使用copy and swap能够做到令对象状态保证“成功或回退”，但一般而言它并不保证整个函数具备强烈保证，举例而言，假设Func是一个执行了copy and swap的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    f1();</span><br><span class="line">    f2();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，如果f1或者f2其异常安全性低于强烈保证，那么很难保证Func具备强烈保证。就算f1与f2都具备强烈保证，Func也未必具备强烈保证。举例而言，假若f1成功执行，f2执行失败，对象状态回退至f1执行之后f2执行之前，显然此时Func不具备强烈保证。</p>
<hr>
<h2 id="copy-and-swap引发的效率问题"><a href="#copy-and-swap引发的效率问题" class="headerlink" title="copy and swap引发的效率问题"></a>copy and swap引发的效率问题</h2><p>copy and swap的精要在于copy被修改的对象，为此我们需要付出构造与析构的成本。pimpl模式下的copy and swap消耗极低，但这并不意味着你每一次都只是构造一个指针而已。</p>
<hr>
<h1 id="基本保证"><a href="#基本保证" class="headerlink" title="基本保证"></a>基本保证</h1><p>&nbsp;<br>当强烈保证不切实际之时，我们应该考虑基本保证。基本保证是异常安全的最后一道屏障，如果无法满足则无法被称为异常安全。<br>异常安全并没有局部与整体的概念，只要某一处不具备异常安全性，即可视作整个程序不具备异常安全性。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>异常安全函数即使发生异常也不会导致资源泄露或者数据破坏。其函数提供分为三种可能的保证：基本、强烈、不抛异常。</li>
<li>copy and swap可能实现强烈保证，但其并非对所有函数都可实现或具备实现意义。</li>
<li>异常安全具备全局性，其等于最弱的局部异常保证。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>20.为含有指针的关联容器指定比较类型</title>
    <url>/2018/04/12/%E4%B8%BA%E5%90%AB%E6%9C%89%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%8C%87%E5%AE%9A%E6%AF%94%E8%BE%83%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假设存在一个元素类型为string<em> 的set，其内容如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp; <span class="comment">//ssp = “set of string ptrs”</span></span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Anteater"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Wombat"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Lemur"</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Penguin"</span>));</span><br><span class="line"><span class="comment">//以为set内部元素已然按照字典序排序</span></span><br></pre></td></tr></table></figure><br>我们试图去遍历并输出它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = ssp.cbegin();i != ssp.cend();++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//以为会获得按照字典序的string对象</span></span><br></pre></td></tr></table></figure><br>但实际上输出的只是一堆地址，并不是string对象。<br>如果你使用的是算法而非显式循环：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(ssp.<span class="built_in">begin</span>(), ssp.<span class="built_in">end</span>(),ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">"\n"</span>));</span><br></pre></td></tr></table></figure><br>你将更早地得到错误信息，上述代码无法编译，ssp内部存放的是string\</em>而非string，所以和ostream_iterator的打印类型不匹配。这也从侧面反映了<strong>算法至少在正确性上确实优于循环</strong>。（Effective STL 43）<br>就算我们在显式循环中使用**i，最后的输出也会不尽人意，你会发现输出的字符串并没有像你想的那样按照首字母排序，而是按照string* 的大小进行排序。<br>原因在于set使用了默认的排序器，ssp的声明其实等价于<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, less&lt;<span class="built_in">string</span>*&gt; &gt; ssp;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="自定义比较类型"><a href="#自定义比较类型" class="headerlink" title="自定义比较类型"></a>自定义比较类型</h1><p>&lt;/br&gt;<br>如果我们试图以指针所指向的对象为排序对象，那么<strong>比较器应该改为自定义的比较仿函数类</strong>，如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringPtrLess</span>:</span></span><br><span class="line">    <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt; &#123;<span class="comment">//该基类详见Effective STL 40</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *ps1 &lt; *ps2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此时，可以声明ssp为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="built_in">string</span>*, StringPtrLess&gt; StringPtrSet;</span><br><span class="line">StringPtrSet ssp;<span class="comment">//按照字典序排序内部指针指向对象的set</span></span><br></pre></td></tr></table></figure><br>这个时候再使用显式循环即可正确完成任务。</p>
<p>如果你想使用算法输出string对象，那必须对一个元素执行解引用，写一个谓词或者lambda配合for_each算法即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//谓词版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">for_each(ssp.<span class="built_in">begin</span>(), ssp.<span class="built_in">end</span>(), <span class="built_in">print</span>);</span><br><span class="line"><span class="comment">//lambda版本</span></span><br><span class="line">for_each(ssp.<span class="built_in">begin</span>(), ssp.<span class="built_in">end</span>(),[](<span class="keyword">const</span> <span class="built_in">string</span> *ps)&#123;<span class="built_in">cout</span> &lt;&lt; *ps &lt;&lt; <span class="built_in">endl</span>;&#125;);</span><br></pre></td></tr></table></figure><br>当然，你也可以自定义解引用仿函数类，然后配合transform与ostream_iterator：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dereference</span> &#123;</span><span class="comment">//传入T*，返回const T&amp;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *ptr)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">transform(ssp.<span class="built_in">begin</span>(), ssp.<span class="built_in">end</span>(),ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">"\n"</span>),Dereference());</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="为何是比较类型而非比较函数"><a href="#为何是比较类型而非比较函数" class="headerlink" title="为何是比较类型而非比较函数"></a>为何是比较类型而非比较函数</h1><p>&lt;/br&gt;<br>也许你会好奇为什么传递给set的永远是一个class而非某个函数，因此有人会试图直接使用函数作为参数声明set:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stringPtrLess</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>* ps1,<span class="keyword">const</span> <span class="built_in">string</span>* ps2)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> *ps1 &lt; *ps2; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, stringPtrLess&gt; ssp;<span class="comment">//无法编译</span></span><br></pre></td></tr></table></figure><br>原因在于set模板的三个参数均为class，而函数不需要类型。<strong>set不需要一个函数，它需要的是能在内部用实例化建立函数的一种类型。</strong></p>
<hr>
<h1 id="通用解决方案"><a href="#通用解决方案" class="headerlink" title="通用解决方案"></a>通用解决方案</h1><p>&lt;/br&gt;<br>我们可以发现，在大多数情况下，比较类型只是解引用指针并比较所指向的对象。鉴于这种情况，我们完全可以定义一个通用仿函数模板：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DereferenceLess</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PtrType&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(PtrType pT1,PtrType pT2)</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//这里采用了值传递，因为指针等内置类型值传递效率更高</span></span><br><span class="line">        <span class="keyword">return</span> *pT1 &lt; *pT2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>声明式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, DereferenceLess&gt; ssp;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&lt;/br&gt;<br>本节虽以指针为名，但<strong>实际上使用范围是内部元素表现为指针的容器</strong>：如元素是<strong>智能指针、迭代器</strong>等。在这些容器中务必自定义比较类型。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
        <tag>关联容器</tag>
      </tags>
  </entry>
  <entry>
    <title>6.了解C++自动生成与调用的函数</title>
    <url>/2018/04/07/%E4%BA%86%E8%A7%A3C++%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%B8%8E%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>即使我们写下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure><br>这样的空类，它本质上也不是空的，而是类似于：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty()&#123;&#125;</span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) &#123;&#125;</span><br><span class="line">    ~Empty() &#123;&#125;</span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在我们没有写的情况下，编译器会自动地生成​default构造函数，copy构造函数，copy assignment操作符和析构函数。<br><strong>这些函数都是inline并且public的。只有在他们被调用时，编译器才会创建它们。</strong></p>
<hr>
<h1 id="自动生成的函数的性质与作用"><a href="#自动生成的函数的性质与作用" class="headerlink" title="自动生成的函数的性质与作用"></a>自动生成的函数的性质与作用</h1><h2 id="default构造与default析构"><a href="#default构造与default析构" class="headerlink" title="default构造与default析构"></a>default构造与default析构</h2><p>default构造函数和析构主要是给编译器调用base clssses和non-static成员变量的构造函数和析构函数。这里需要注意的是，编译器生成的析构函数为non-virtual，<strong>除非this class 的base class自身声明有virtual析构函数。（此时thisclass的析构函数的virtualness源自base class）</strong></p>
<h2 id="copy构造函数与copy-assignment操作符"><a href="#copy构造函数与copy-assignment操作符" class="headerlink" title="copy构造函数与copy assignment操作符"></a>copy构造函数与copy assignment操作符</h2><p>至于copy构造函数与assignment操作符，编译器只是单纯地将来自源对象的non-static成员变量copy到目标对象。假设现有一个Widget Template,它允许你将一个string与一个T类型的数据发生关联：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> <span class="keyword">char</span>* name,<span class="keyword">const</span> T&amp; name);</span><br><span class="line">    Widget(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> T&amp; name);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> thename;</span><br><span class="line">    T value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为已经声明了构造函数，所以编译器不会自动生成default构造函数，也就是说，<strong>一旦你创建了一个class，其对象需要一个参数才能构建，那你无需担心编译器会自动帮它生成无参构造函数。</strong>（关于无参构造函数的弊端可见More Effective 4)</p>
<p>Wideget既没有声明copy构造函数，也没有声明copy assignment操作符。因此编译器会自动生成它们，那么具体是如何实现的？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="string">"sth"</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Widget <span class="title">b</span><span class="params">(a)</span></span>;<span class="comment">//调用自动生成的copy构造函数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="copy构造函数"><a href="#copy构造函数" class="headerlink" title="copy构造函数"></a>copy构造函数</h3><p>编译器生成的copy构造函数会以<code>a.thename</code>与<code>a.value</code>为初值构造<code>b.thename</code>与<code>b.value</code>,因为string存在copy构造函数，因此它调用了string的copy构造函数生成了<code>b.thename</code>,int属于内置类型，不存在copy构造函数,因此<code>b.value</code>将会copy<code>a.value</code>的每一个bits来完成初始化。</p>
<h3 id="copy-assignment操作符"><a href="#copy-assignment操作符" class="headerlink" title="copy assignment操作符"></a>copy assignment操作符</h3><p>copy assignment操作符和copy构造函数略有不同，原因在于并非任何成员对象都可以被赋值（const成员变量，reference）。<br>在c++中，不允许reference改指向不同对象，也不允许const对象被赋值。因此，此时copy assignment无法完成，编译器拒绝生成此操作。也就是说<strong>，当class内含const成员与reference成员时，C++不会生成copy assignment操作符。</strong><br>如果我们试图令内含reference成员或const成员的class支持copy assignment，那我们必须要自定义copy assignment操作符。<br>还有一种情况<strong>C++也不会生成copy assignment操作符，就是base class将copy assignment定义为private.</strong>原因很简单，如果编译器为derived class生成了copy assignment操作符，那它必定会试图调用base class的copy assignment操作符来操作base class的数据成员，可惜它没有这个权限来调用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>编译器会自动生成某些函数，谨记它们的性质、作用、以及在什么情况下不会自动生成。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>37.了解accumulate与for_each</title>
    <url>/2018/04/18/%E4%BA%86%E8%A7%A3accumulate%E4%B8%8Efor_each/</url>
    <content><![CDATA[<h1 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h1><p>有些算法可以帮助我们将一个区间提炼成一个数（或一个对象），诸如count_if，或者min_element和max_element.<br>但有时候我们需要自定义统计的方式，比如说字符串长度求和，指定区间内乘积之类。stl中存在类似的算法，名为accumulate.值得注意的是，<strong>它并不在algorithm中，而是在numeric中。</strong></p>
<h2 id="accumulate的存在形式"><a href="#accumulate的存在形式" class="headerlink" title="accumulate的存在形式"></a>accumulate的存在形式</h2><h3 id="标准求和"><a href="#标准求和" class="headerlink" title="标准求和"></a>标准求和</h3><p>此形式接受一对迭代器和一个初值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; ld; </span><br><span class="line"><span class="keyword">double</span> sum = accumulate(ld.<span class="built_in">begin</span>(), Id.<span class="built_in">end</span>(), <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><br>值得注意的是这里初始值是0.0而非0，不然的话accumulate会计算double累加的结果，并将最终结果转为一个int.</p>
<p>另外，accumulate只需要输入迭代器，那也就是说istream_iterator和istreambuf_iterator也可以使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of the ints on the standard input is"</span> </span><br><span class="line">&lt;&lt; accumulate(istream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cin</span>), istream_iterator&lt;<span class="keyword">int</span>&gt;(),<span class="number">0</span>);</span><br><span class="line"><span class="comment">//建议迭代器命名，原因详见Effective STL 6</span></span><br></pre></td></tr></table></figure></p>
<h3 id="自定义统计-谓词放在最后）"><a href="#自定义统计-谓词放在最后）" class="headerlink" title="自定义统计(谓词放在最后）"></a>自定义统计(谓词放在最后）</h3><h4 id="字符串长度求和"><a href="#字符串长度求和" class="headerlink" title="字符串长度求和"></a>字符串长度求和</h4><p>为了统计各个字符串长度的和，我们首先写下自定义统计函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">stringLengthSum</span><span class="params">(<span class="built_in">string</span>::size_type sumSoFar, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumSoFar + s.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于标准库容器，size_type等价于size_t.<br>长度求和具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; ss; </span><br><span class="line"><span class="built_in">string</span>::size_type lengthSum =accumulate(ss.<span class="built_in">begin</span>(), ss.<span class="built_in">end</span>(), <span class="number">0</span>, stringLengthSum);</span><br></pre></td></tr></table></figure></p>
<h4 id="指定区间内的数值乘积"><a href="#指定区间内的数值乘积" class="headerlink" title="指定区间内的数值乘积"></a>指定区间内的数值乘积</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; vf; </span><br><span class="line"><span class="keyword">float</span> product =accumulate(vf.<span class="built_in">begin</span>(), vf.<span class="built_in">end</span>(),<span class="number">1.0f</span>, multiplies&lt;<span class="keyword">float</span>&gt;());</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h1><p>for_each是一个对区间内所有元素进行某种操作的算法，我认为配合lambda使用效果绝佳。（需要注意的是它返回的执行操作之后的元素的副本，也许使用引用好一些？）</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>10.了解allocator的约定与限制</title>
    <url>/2018/04/08/%E4%BA%86%E8%A7%A3allocator%E7%9A%84%E7%BA%A6%E5%AE%9A%E4%B8%8E%E9%99%90%E5%88%B6md/</url>
    <content><![CDATA[<p>（本节内容并未完全掌握，建议学习STL源码剖析相关章节后再次复习本章）<br>allocator最初作为内存模型的抽象而产生，但最终失败了。后来又被设计成促进全功能内存管理器，但又发现可能会造成效率低下，最终，allocator被弱化成为了对象。</p>
<hr>
<h1 id="allocator的特点"><a href="#allocator的特点" class="headerlink" title="allocator的特点"></a>allocator的特点</h1><p>类似于operator new 和operator new[]，allocator也负责分配和回收内存，但其接口和new，new[],或者malloc毫无相似之处。并且，大部分容器从未向它们相关的allocator索取内存。这是相当奇怪的一点。</p>
<p>正如前文提到的，allocator最初作为内存模型的抽象而产生，那么它必须为其所定义的内存模型中的指针和引用提供类型定义，一般而言，一个类型为T的对象，它的默认allocator<T>提供了allocator<T>::pointer与allocator<T>::reference;</p>
<p>如果你对C++十分了解，你会发现其实我们无法模拟一个引用。这需要重载operator. （该操作符禁止重载）而且模拟引用最好的方式是使用代理对象（proxy object详见More Effective C++ 30),代理对象会带来许多问题。</p>
<p><strong>c++标准明确指出，允许库实现者假定每个分配子的指针等价于T*，而其引用等价于T&amp;.</strong>也就是说，库实现可以忽视typedef并直接使用原始指针和引用。</p>
<p>allocator是对象这一性质意味着它可以拥有成员函数、嵌套类型和类型定义（如reference与pointer）。同时c++标准再一次规定，<strong>STL的实现可以假定所有属于同一种类型的allocator对象等价，且比较结果相等</strong>，这非常很奇怪，但是是可以理解并接受的，举例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 一个用户定义的分配器模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialAllocator</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">typedef</span> SpecialAllocator&lt;Widget&gt; SAW;</span><br><span class="line"><span class="built_in">list</span>&lt;Widget, SAW&gt; L1;</span><br><span class="line"><span class="built_in">list</span>&lt;Widget, SAW&gt; L2;</span><br><span class="line">...</span><br><span class="line">L1.splice(L1.<span class="built_in">begin</span>(), L2); <span class="comment">// 把L2的节点移到L1前端</span></span><br></pre></td></tr></table></figure><br>众所周知，当list的元素从一个list链接到另一个时，并没有复制任何东西，而是仅仅调整了一些指针。当L1被析构时，L1的allocator必须析构自己的所有节点并释放内存，但其现在包含了L2的节点，所以它必须释放最初由L2的allocator分配的节点，这也就是allocator同类型等价的原因，<strong>允许一个allocator对象分配的内存可以由另一个allocator对象安全删除</strong>。<br>这一点也禁止了allocator不允许存在自己的state，更直白的说，allocator不允许有任何non-static成员，如果存在则无法等价。</p>
<hr>
<h1 id="allocator与内存分配"><a href="#allocator与内存分配" class="headerlink" title="allocator与内存分配"></a>allocator与内存分配</h1><p>allocator与new在分配内存上有一点相似之处：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line">pointer allocator&lt;T&gt;::allocate(size_type numObjects);<span class="comment">//pointer 等价于T*</span></span><br></pre></td></tr></table></figure><br>对于new而言，它的参数是所需字节的大小，而<strong>allocator的参数是分配多少个对象</strong>。它们的返回值也不同，operator new返回void*，而allocator<T>::allocate则是返回T*，而且这个<strong>返回值并没有指向某个T对象</strong>，因为根本还没有构造。</p>
<hr>
<h1 id="容器与它们对应的allocator"><a href="#容器与它们对应的allocator" class="headerlink" title="容器与它们对应的allocator"></a>容器与它们对应的allocator</h1><p>大多数标准容器从未单独调用过对应的allocator，这种情况普遍发生于基于节点的容器：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>,allocator&lt;<span class="keyword">int</span>&gt; &gt; L; <span class="comment">//allocator&lt;int&gt;从未分配内存</span></span><br><span class="line"><span class="built_in">set</span>&lt;Widget, SAW&gt; s; <span class="comment">//SAW从未分配内存</span></span><br></pre></td></tr></table></figure><br>list&lt;T&gt;的一个可能实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Allocator = allocator&lt;T&gt; &gt;</span><br><span class="line">class <span class="built_in">list</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Allocator alloc; <span class="comment">// 用于T类型对象的分配器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span> <span class="comment">// 链表里的节点</span></span><br><span class="line">        T data:</span><br><span class="line">        ListNode *prev;</span><br><span class="line">        ListNode *next;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当添加一个node到list时，我们需要从分配器为其获取内存，我们要的并非是T的内存，而是包含了一个T的ListNode的内存。那allocator&lt;T&gt;基本上就是废了。<br>list需要的是从他的分配器类型那里获取用于Listnode的对应分配器的方法。按照协定，分配器需要提供完成那部分工作的typedef，实际上这个东西叫other.是嵌入一个叫做rebind的结构体的typedef，rebind自己是一个嵌入分配器的模板—分配器自己也是一个模板。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span> &#123;</span><span class="comment">// 分配器模板</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在list<T>的实现代码里，需要确定我们持有的T的分配器所对应的ListNode的分配器类型，所以，list的allocator类型为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Allocator::rebind&lt;ListNode&gt;::other</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>如果你需要自己实现一个allocator，你需要明确：</p>
<ol>
<li>allocator是一个模板</li>
<li>提供pointer与reference的typedef</li>
<li>不要给allorator分配state，通常不含有non-static成员</li>
<li>传给allocate的是对象个数而非字节数，同时记得其返回T*指针。</li>
<li>一定要提供标准容器依赖的内嵌rebind模板</li>
</ol>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>2.了解auto技术</title>
    <url>/2018/06/23/%E4%BA%86%E8%A7%A3auto%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br><code>auto</code>的类型推衍法则除了一个特例之外与template function保持一致。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>在上一节中，template function的类型推衍有实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure><br>在函数调用过程中，编译器将使用expr推衍T与ParamType的类型。</p>
<p>当开发者使用<code>auto</code>来声明一个变量时，<code>auto</code>将扮演T在template中的角色，同时，type specifier（类型说明符）则类似于ParamType，如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;<span class="comment">//type specifier为auto</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cx = x;<span class="comment">//type specifier为const auto</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;rx = x;<span class="comment">//type specifier为const auto&amp;</span></span><br></pre></td></tr></table></figure><br>为了推衍出x、cx、rx的类型，编译器会像调用fun template那样执行操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_for_x</span><span class="params">(T param)</span></span>;<span class="comment">//conceptual template</span></span><br><span class="line">func_for_x(<span class="number">27</span>);<span class="comment">//conceptual call</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_for_cx</span><span class="params">(<span class="keyword">const</span> T param)</span></span>;</span><br><span class="line">func_for_cx(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_for_rx</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line">func_for_rx(cx);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>在template function类型推衍中我们根据ParamType的特点将情况分为了三种，使用<code>auto</code>的变量声明表达式与之类似，根据type specifier也分为了三种情况：</p>
<ol>
<li><strong>type specifier是一个pointer或一个reference，但不是一个universal reference；</strong></li>
<li><strong>type specifier是一个universal reference</strong>；</li>
<li><strong>type specifier既不是pointer也不是reference；</strong></li>
</ol>
<p>显然,前文所述的实例分为对应为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;<span class="comment">//case 3</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cx = x;<span class="comment">//case 3</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; rx = cx;<span class="comment">//case 1</span></span><br></pre></td></tr></table></figure><br>Case2有推衍实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;<span class="comment">//x is int and lvalue,so uref1's type is int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx;<span class="comment">// cx is const int and lvalue,so urfe2's type is const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>;<span class="comment">//27 is int and rvalue,so urfe3's type is int&amp;&amp;</span></span><br></pre></td></tr></table></figure><br>在Item1中描述了数组名与函数名在遇到非引用type specifier时会退化为指针的情况，这一特性在auto类型推衍过程中也同样适用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[]=<span class="string">"R.N.Briggs"</span>;</span><br><span class="line"><span class="keyword">auto</span> arr1 = name;<span class="comment">//arr1's type is const char*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; arr2 = name;<span class="comment">//arr2's type is const char(&amp;)[13]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> func1 = someFunc;<span class="comment">//func1's type is void(*)(int,double)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; func2 = someFunc;<span class="comment">//func2's type is void(&amp;)(int,double)</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="auto与template-function类型推衍的不同之处"><a href="#auto与template-function类型推衍的不同之处" class="headerlink" title="auto与template function类型推衍的不同之处"></a>auto与template function类型推衍的不同之处</h1><p>&nbsp;<br>如果我们想要声明一个值为27的int型变量，C++98为我们提供了两种方式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = <span class="number">27</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>C++11引入了列表初始化的概念，因此增加了两种声明方式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x3 = &#123;<span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x4&#123;<span class="number">27</span>&#125;;</span><br></pre></td></tr></table></figure><br>我们将会在Item5中说明，使用<code>auto</code>来声明变量比指定类型更佳，那我们试着把上述声明改为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;</span><br></pre></td></tr></table></figure><br>上述声明均能够通过编译，只是其含义略有差别，前两个声明式仍然保持着声明一个值为27的int变量的含义，但后两个却发生了变化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;;<span class="comment">//x3's type is std::initializer_list&lt;int&gt;,value is &#123;27&#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;<span class="comment">//ditto</span></span><br></pre></td></tr></table></figure><br>造成这一变化的根本原因在于auto的推衍法则：当被声明的变量值被大括号包围时，其变量类型会被推衍为std::initializer_list，当包括中的类型不一致时，类型推衍将无法完成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x5 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>&#125;;<span class="comment">//error can not deduce</span></span><br></pre></td></tr></table></figure><br>需要明确的是在上述语句中发生了两种类型推衍，第一种类型推衍将x5推衍为initializer_list类型（因为其值被大括号包围），但initializer_list本身是一个template，所以我们需要继续执行类型推衍。</p>
<p>这种将大括号初始化推衍为initializer_list是auto与template function唯一不同的地方，后者不允许这种推衍方式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">11</span>,<span class="number">23</span>,<span class="number">9</span>&#125;;<span class="comment">//x's type is initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(&#123;<span class="number">11</span>,<span class="number">23</span>,<span class="number">9</span>&#125;);<span class="comment">//error!can't deduce type for T</span></span><br></pre></td></tr></table></figure><br>但是如果你将template function中的参数声明为std::initializer_list，只是其元素类型T不明确的话，template function可以完成推衍：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(&#123;<span class="number">11</span>,<span class="number">23</span>,<span class="number">9</span>&#125;);<span class="comment">//T's type is int</span></span><br></pre></td></tr></table></figure></p>
<p>综上，auto与template function唯一的推衍区别在于：auto总是假定一个大括号初始化列表代表着一个initializer_list,而template function不作这种假设。</p>
<hr>
<h1 id="C-14中的auto"><a href="#C-14中的auto" class="headerlink" title="C++14中的auto"></a>C++14中的auto</h1><p>&nbsp;<br>在C++14中，auto还可以用来表征函数的返回值类型，并且lambda表达式也经常使用auto来声明参数。不过这两种auto的使用方式遵从template function类型推衍法则，而非auto推衍法则，因此返回一个初始化列表的函数将无法用auto推衍：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span>&#123;<span class="comment">//error,can't deduce type for &#123;1,2,3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>lambda表达式中亦是如此：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> resetV = [&amp;v](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; newValue)&#123; v = newValue;&#125;</span><br><span class="line">...</span><br><span class="line">resetV(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);<span class="comment">//error,can't deduce type for &#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;</p>
<ol>
<li><strong>auto的推衍法则类似于template function，唯一的不同在于auto会假定大括号初始化列表为std::initializer_list,template function则不会。</strong></li>
<li><strong>对函数返回值或lambda表达式参数使用auto时遵从template function类型推衍法则，而非auto自己的法则。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型推衍</tag>
      </tags>
  </entry>
  <entry>
    <title>41.了解ptr_fun、mem_fun以及mem_fun_ref</title>
    <url>/2018/04/19/%E4%BA%86%E8%A7%A3ptr_fun%E3%80%81mem_fun%E4%BB%A5%E5%8F%8Amem_fun_ref/</url>
    <content><![CDATA[<p>(个人认为习得lambda后无需理会本节内容）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>ptr_fun、mem_fun和mem_fun_ref的主要任务是覆盖C++固有的语法矛盾。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>当前存在一个函数f与一个对象x，编码环境不处于x的成员函数内，如果需要在x上调用f，则有三种调用方法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(x);<span class="comment">//当f是一个非成员函数</span></span><br><span class="line">x.f();<span class="comment">//当f是一个成员函数，并且x是一个对象或一个对象的引用</span></span><br><span class="line">p-&gt;f();<span class="comment">//当f是一个成员函数，并且p是一个指向对象的指针</span></span><br></pre></td></tr></table></figure><br>假设有一个测试Widget的函数和一个Widget容器：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br></pre></td></tr></table></figure><br>我们需要测试容器内所有的Widget:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), test);</span><br></pre></td></tr></table></figure><br>但如果test是一个成员函数，我们似乎可以这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(),&amp;Widget::test);<span class="comment">//无法编译</span></span><br></pre></td></tr></table></figure><br>又或者我们还会试图访问指针来执行操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;Widget*&gt; lpw;</span><br><span class="line">for_each(lpw.<span class="built_in">begin</span>(), lpw.<span class="built_in">end</span>(),&amp;Widget::test);<span class="comment">//无法编译</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>for_each不支持将成员函数作为谓词传入，原因在于for_each的实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>, Function f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>) f(*<span class="built_in">begin</span>++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>STL算法中函数和函数对象总是使用用于非成员函数的语法形式调用，这也就是mem_fun与mem_fun_ref存在的意义。它们让成员函数得以作为谓词。</p>
<hr>
<h1 id="mem-fun与mem-fun-ref"><a href="#mem-fun与mem-fun-ref" class="headerlink" title="mem_fun与mem_fun_ref"></a>mem_fun与mem_fun_ref</h1><p>&nbsp;<br>它们具体的实现并不复杂，总体来说是一个函数模板，以下是其中的一个声明：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于不带参数的non-const成员函数</span></span><br><span class="line"><span class="comment">// C是类，R是被指的成员函数的返回类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C&gt; </span><br><span class="line">mem_fun_t&lt;R,C&gt; mem_fun(R(C::*pmf)());</span><br></pre></td></tr></table></figure><br>mem_fun带有一个指向成员函数的指针pmf，并返回一个mem_fun_t类型的对象。这个仿函数类容纳成员函数指针并且提供一个<code>operator()</code>,它调用指向传给<code>operator()</code>的对象上的成员函数。</p>
<p>针对Widget那个实例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ist&lt;Widget*&gt; lpw;</span><br><span class="line">for_each(lpw.<span class="built_in">begin</span>(), lpw.<span class="built_in">end</span>(),mem_fun(&amp;Widget::test));</span><br></pre></td></tr></table></figure><br>for_each接受一个mem_fun_t类型的对象，它持有一个test函数指针，对于lpw里面所有的Widget*指针，for_each使用调用mem_fun_t，随后该对象立刻在Widget*上调用test.</p>
<p>mem_fun_ref效果类似，它们也被称为函数对象适配器。</p>
<hr>
<h1 id="ptr-fun"><a href="#ptr-fun" class="headerlink" title="ptr_fun"></a>ptr_fun</h1><p>&nbsp;<br>ptr_fun增加了一些typedef，如果你不确定啥时候用它，就记得每一次都用它。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>仿函数</tag>
      </tags>
  </entry>
  <entry>
    <title>3.了解decltype技术</title>
    <url>/2018/06/25/%E4%BA%86%E8%A7%A3decltype%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>decltype是一项奇特的技术，它能够告诉你某个名称或表达式的类型，尽管有时候返回的结果令你抓耳挠腮。</p>
<hr>
<h1 id="decltype的使用"><a href="#decltype的使用" class="headerlink" title="decltype的使用"></a>decltype的使用</h1><p>&nbsp;<br>我们首先从最简单的情况开始分析，在此情况中decltype只会鹦鹉学舌般反馈类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i =<span class="number">0</span>;<span class="comment">//decltype(i) is const int</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Widget&amp;w)</span></span>;<span class="comment">//decltype(w) is const Widget&amp;,decltype(f) is bool(const Widget&amp;)</span></span><br><span class="line"><span class="keyword">if</span>(f(w))<span class="comment">//decltype(f(w)) is bool</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//decltype(v) is vector&lt;int&gt;</span></span><br><span class="line"><span class="keyword">if</span>(v[<span class="number">0</span>]==<span class="number">0</span>)...<span class="comment">//decltype(v[0] is int&amp;</span></span><br></pre></td></tr></table></figure><br>看起来一切都很正常。</p>
<hr>
<h2 id="decltype与返回值"><a href="#decltype与返回值" class="headerlink" title="decltype与返回值"></a>decltype与返回值</h2><p>在C++11中，decltype主要用于声明函数返回值依赖于其类型参数的函数模板。举例来说，我们的函数可能会操作一个带有索引的容器，在返回容器内部元素的值之前，我们需要验证一下使用者的身份，此函数的返回值类型显然应当与operator[]的返回值类型一致，此时应当使用decltype。</p>
<p>有人认为在容器类中，operator []总是返回T&amp;。对于deque来说这总是成立的，但对于vector来说，vector&lt;bool&gt;则并非返回一个bool&amp;，而是一个新对象。（代理类，这一问题详见Effective STL Item18及More Effective C++ Item30），这里我们强调的是，一个容器的operator []返回类型不仅仅与其元素类型有关，也与容器自身有关。</p>
<p>下面的实例展示了decltype的用法，它将在后期被进一步改进：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line">auto authAndAccess(Container&amp;c,Index i)-&gt;decltype(c[i])&#123;</span><br><span class="line">    authenticateUser();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数名前的auto与类型推衍毫无关联，它只是表示此处我们使用了C++11的尾置返回类型（C++ Primer P604）。我们的返回类型取决于c、i,因此我们不可能在没有遇到它们之前声明返回值类型，这即是尾置返回类型的特性与优势所在。</p>
<p>C++11允许使用auto推衍单语句lambda的返回值类型，C++14将其扩展至所有多语句lambda与函数。这意味着在刚才的实例中我们可以不使用尾置返回类型，仅使用auto来完成类型推衍：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp;c,Index i)</span></span>&#123;<span class="comment">//not quite correct</span></span><br><span class="line">    authenticateUser();</span><br><span class="line">    <span class="keyword">return</span> c[i];<span class="comment">//type deduction take place</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Item2中我们曾经说明auto用于函数返回值类型推衍时采用template function推衍法则，这一特点造成了上文实例可能推衍失败的可能，原因在于容器类operator[]的返回类型几乎都是T&amp;，但template function在作类型推衍时将忽略referenceness,如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">authAndAccess(d,<span class="number">5</span>) = <span class="number">10</span>;<span class="comment">//can not compile</span></span><br></pre></td></tr></table></figure><br>理论上来说，等式左侧应当是一个int&amp;,但实际上由于template function推衍法则，等式左侧被推衍为int。由于该int是一个函数的返回值，所以它是一个右值，这直接导致了本语句无法编译。</p>
<hr>
<h2 id="C-14中的decltype-auto"><a href="#C-14中的decltype-auto" class="headerlink" title="C++14中的decltype(auto)"></a>C++14中的decltype(auto)</h2><p>&nbsp;<br>为了保证函数功能正常，我们需要使用decltype来推衍函数返回值类型.C++14引入了decltype(auto)类型说明符，其功能为：auto用以说明当前类型需要被推衍，而decltype则代表了类型推衍所需要采用的法则，修改之后的authAndAccess:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c,Index i)</span></span>&#123;<span class="comment">//still require refinement</span></span><br><span class="line">    authenticateUser();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>decltype不仅仅可以用来作为返回值类型说明符，也可以用于在初始化语句中定义对象，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">const</span> Widget&amp; cw = w;</span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;<span class="comment">//auto type deduction: myWidget1's type is Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw;<span class="comment">//decltype deduction:myWidget2's type is const Widget&amp;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="authAndAccess的最终修正"><a href="#authAndAccess的最终修正" class="headerlink" title="authAndAccess的最终修正"></a>authAndAccess的最终修正</h1><p>&nbsp;<br>我们首先回顾一下authAndAccess的声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span>;</span><br></pre></td></tr></table></figure><br>容器对象的传递采用reference-non-const形式，如此即可保证用户可通过该函数修改容器内部元素。这种传递方式限制了rvalue的传入，因为rvalue无法被绑定至lvalue引用（除非是lvalue-reference-to-const）。</p>
<p>诚然，传递一个右值容器对象是一种罕见的情况。一个右值容器对象必然是一个临时对象，其在authAndAccess调用完成后必将销毁，那么返回其内部元素的引用也必将造成空悬。但这种情况未必不会发生，例如客户可能希望拷贝一个临时容器中的元素：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">makeStringDeque</span><span class="params">()</span></span>;<span class="comment">//Factory function</span></span><br><span class="line"><span class="keyword">auto</span> s = authAndAccess(makeStringDeque(),<span class="number">5</span>);<span class="comment">//can't compile</span></span><br></pre></td></tr></table></figure><br>为了解决这个问题，有些开发者也许会想到重载，不过那样我们需要撰写两个函数，这是没必要的，Item24将为我们介绍的universal reference可以同时绑定lvalue与rvalue：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span></span>;</span><br></pre></td></tr></table></figure><br>在这个template function中我们对容器类型一无所知，这也直接导致了我们对其索引对象的类型（Index)不甚明确。对未知类型对象采用值传递的方式可能会导致性能下降、slicing等诸多问题，但有时确实存在着pass-by-value的必要，因此我们坚持对Index对象采用pass-by-value。最终，我们采用Item25所建议的std::forward对函数作出修正：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)authAndAccess(Container&amp;&amp; c, Index i)&#123;</span><br><span class="line">    authenticateUser();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="decltype的特殊情况"><a href="#decltype的特殊情况" class="headerlink" title="decltype的特殊情况"></a>decltype的特殊情况</h1><p>&nbsp;<br>将decltype应用于某个名称将导致对此名称的类型推衍，名称是一种左值表达式，不过这不会影响decltype的行为。但是对于比名称更为复杂的左值表达式，decltype将保证类型推衍结果必然是一个左值引用。一般来说这不会造成多大影响，因为左值表达式自带一个引用符，举例来说，一个返回左值的函数即返回左值引用。</p>
<p>请注意下面的例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>x是变量的名称，因此decltype(x)的结果是int。但如果我们用一个小括号将x包起来形成<code>(x)</code>,它就变成了一个左值表达式，那么decltype((x))的结果则会变为int&amp;，但更麻烦的还在后面，有时候这种写法会直接导致崩溃，考虑下面两个函数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;<span class="comment">//return int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (x);<span class="comment">//return int&amp; to a local variable!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由此可见，表达式类型在一定程度上可能会影响decltype(auto)的推衍结果，Item4将会介绍确保每一次推衍结果都我们所愿的方法。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>decltype在作类型推衍时几乎总是不发生任何改变。</strong></li>
<li><strong>对于并非名称的左值表达式，decltype几乎总是返回T&amp;。</strong></li>
<li><strong>C++14支持decltype(auto),其表示以decltype法则作类型推衍。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型推衍</tag>
      </tags>
  </entry>
  <entry>
    <title>43.了解typename</title>
    <url>/2018/04/20/%E4%BA%86%E8%A7%A3typename/</url>
    <content><![CDATA[<h1 id="template声明式"><a href="#template声明式" class="headerlink" title="template声明式"></a>template声明式</h1><p>&nbsp;<br>在template声明式中使用class与typename有什么不同吗？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Widget</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br></pre></td></tr></table></figure><br>答案是没有不同。有的人喜欢用class，因为少打了字，有的人则习惯于使用typename，因为这暗示了用户参数并非一定要是一个class类型。<br>但这种相同仅仅只是在template声明式内，c++并不总是把class与template视为等价,有时候我们非得使用typename不可。</p>
<hr>
<h1 id="template内refer-to的名称"><a href="#template内refer-to的名称" class="headerlink" title="template内refer to的名称"></a>template内refer to的名称</h1><p>&nbsp;<br>假设有一个template function，接受一个STL容器为参数，容器内持有的对象可被赋值为int。进一步假设这个函数只是打印其第二元素值。我们暂且不去管这个函数有多么地无聊甚至不能编译，其实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span> <span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(container.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.<span class="built_in">begin</span>())</span></span>;</span><br><span class="line">        ++iter;</span><br><span class="line">        <span class="keyword">int</span> value = *iter;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显而易见，这段代码中有两个local变量iter和value。</p>
<h2 id="嵌套从属名称"><a href="#嵌套从属名称" class="headerlink" title="嵌套从属名称"></a>嵌套从属名称</h2><p>iter的类型是C::const_iterator,实际上它是什么取决于template参数C.<strong>template内出现的名字如果依赖于某个template参数，则称为从属名称。如果从属名称在class内程嵌套状(::)则称之为嵌套从属名称。</strong><br>value是一个int，不依赖于任何template参数，于是它叫做非从属名称。</p>
<hr>
<h3 id="嵌套从属名称的风险"><a href="#嵌套从属名称的风险" class="headerlink" title="嵌套从属名称的风险"></a>嵌套从属名称的风险</h3><p>嵌套从属名称可能会导致解析(parsing)困难。举例而言，我们如果写了一个比刚才那个更加愚蠢的程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">    C::const_iterator * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可能有人对这种写法并无异议:我们声明了一个local变量x，它是一个指针，指向C::const_iterator。但如果C中有一个static成员恰好被命名为const_iterator，又或者x恰好是一个global变量。那这个代码就是执行了一次相乘操作。这简直丧心病狂。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>C++对于这种歧义状态有一种解析规则：<strong>如果编译器在template中遭遇了一个嵌套从属名称，它便假设该名称并非类型，除非你主动告诉它这是类型。</strong>（这个情况有一个小小的例外）。<br>想要程序正确运行，上文中的实例应该改为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> C::const_iterator iter;</span><br></pre></td></tr></table></figure><br>任何时候你想在template内指涉一个嵌套从属类型名称，就必须在它之前放上一个typename.（再说一次，有一个小例外）另外，typename只被用来验明嵌套从属类型名称，其它名称没必要用它。</p>
<h3 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h3><p>typename不可以出现在base classes list内的嵌套从属类型名称之前，也不可以在member initialization list中作为base class修饰符。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&lt;T&gt;::Nested&#123;<span class="comment">// base classes list中禁止出现typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">        :Base&lt;T&gt;::<span class="title">Nested</span><span class="params">(x)</span></span>&#123;<span class="comment">//member initialization list中禁止出现typename</span></span><br><span class="line">            <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;<span class="comment">//需要typename</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="typename与typedef"><a href="#typename与typedef" class="headerlink" title="typename与typedef"></a>typename与typedef</h3><p>由于某些声明式实在太长，所以讲typedef与typename相结合可能是一种不错的主意：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>声明template参数时，class与typename意义相同。</li>
<li>必须用typename标识嵌套从属类型名称，但在base class lists &amp;&amp; member initialization list中禁止使用。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板与泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>50.了解new-handler</title>
    <url>/2018/04/24/%E4%BA%86%E8%A7%A3new-handler/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>当operator new无法满足某一个内存分配需求时，它会抛出异常，在其抛出异常之前，它会先调用一个客户制定的错误处理函数，一个所谓的new-handler。（实际上更复杂一些）</p>
<hr>
<h1 id="set-new-handler"><a href="#set-new-handler" class="headerlink" title="set_new_handler"></a>set_new_handler</h1><p>&nbsp;<br>为了指定这个“用以处理内存不足”的函数，用户必须调用set_new_handler，那是声明于&lt;new&gt;的一个标准库函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>｛</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然，new_handler是一个函数指针的typedef，该函数没有任何参数也不返回任何东西。set_new_handler则是接受一个new_handler参数并返回一个new_handler参数。set_new_handler尾端的throw()表明该函数理论上不会抛出异常，详见Effective C++ 30。</p>
<h2 id="set-new-handler的使用"><a href="#set-new-handler的使用" class="headerlink" title="set_new_handler的使用"></a>set_new_handler的使用</h2><p><strong>set_new_handler的参数是一个指针，指向operator new无法分配足够内存时需要被调用的函数，其返回值指向set_new_handler被调用前正在执行的那个函数。</strong>具体使用方法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; “Unable to satisfy request <span class="keyword">for</span> memory\n”；</span><br><span class="line">    <span class="built_in">abort</span>()；<span class="comment">//使程序异常中止</span></span><br><span class="line">｝</span><br><span class="line">int main()｛</span><br><span class="line">    set_new_handler(outOfMem);</span><br><span class="line">    <span class="keyword">int</span> *pBigDataArray = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10000000</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>就本例而言，如果无法创建如此大的数组，则outofmem就会被调用，于是程序在发出信息后abort。<br>当operator new无法满足内存申请时，它会不断调用new-handler函数，直到找到足够内存。</p>
<hr>
<h1 id="new-handler设计要求"><a href="#new-handler设计要求" class="headerlink" title="new-handler设计要求"></a>new-handler设计要求</h1><p>&nbsp;<br>一个设计良好的new-handler可以提供如下功能：</p>
<ul>
<li>让更多内存可被调用<br>一种实现方法是程序一开始执行时就分配一大块内存，而后当new_handler第一次被调用时，将它释放给程序使用。</li>
<li>安装另一个new-handler<br>如果当前无法获取更多内存，但又明确知道其他某个new-handler有这个能力，就应该主动使用set-handler进行替换。</li>
<li>卸载new-handler<br>将nullptr传递给set-new-handler。如果new-handler为nullptr，operator new会在分配内存不成功时抛出异常。</li>
<li>抛出bad_alloc（或派生自bad_alloc）的异常<br>这样的异常不会被operator new捕捉，因此会被传播到内存索求处。</li>
<li>不返回<br>直接调用abort或者exit。</li>
</ul>
<hr>
<h1 id="针对class定制new-handler"><a href="#针对class定制new-handler" class="headerlink" title="针对class定制new-handler"></a>针对class定制new-handler</h1><p>&nbsp;<br>或许你会希望不同的class以不同的new-handler来处理内存分配失败情况:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outOfMemory</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outOfMemory</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">X *px = <span class="keyword">new</span> X;<span class="comment">//分配失败时调用X::outOfMemory</span></span><br><span class="line">Y *py = <span class="keyword">new</span> Y;<span class="comment">//分配失败时调用Y::outOfMemory</span></span><br></pre></td></tr></table></figure><br>但c++并不支持class专属的new-handler.但这无关紧要，只需要令每一个class提供自己的set_new_handler和operator new即可。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设当前我们准备处理Widget class的内存分配失败情况。首先必须定义Widget专有的new—handler，于是我们先声明一个类型为new handler的static成员：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> new_handler currentHandler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>Static成员必须在class定义式之外被定义（除非是const的int，详见Effective C++ 3），因此：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">new_handler Widget::currentHandler = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><br>Widget中的set_new_handler函数会将其获得的new_handler保存，然后返回被替换的指针，如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">new_handler <span class="title">Widget::set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实例剖析"><a href="#实例剖析" class="headerlink" title="实例剖析"></a>实例剖析</h2><p>Widget的operator new做了如下事情：</p>
<ol>
<li>调用标准set_new_handler，告知A的错误处理函数。<br>执行完毕后，A的new_handler被安装为global new_handler.</li>
<li>调用global operator new，执行实际内存分配。<br>如果失败，global operator new会调用Widget的new_handler，因为它刚才被安装为global.如果最终确实无法分配足够内存，会抛出一个bad_alloc的异常。此时A的operator new必须恢复global new_handler，然后再传播该异常。为了保证原本的new-handler总是正确安装，应该将global new_handler视为资源，使用RAII.</li>
<li>如果global operator new能够分配足够的内存，A的operator new会返回一个指向分配所得的指针。<br>Widget的析构函数会管理global new_handler，它会自动将Widget的operator new被调用前的global new_handler恢复。</li>
</ol>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们首先从资源管理类开始：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerHolder</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(new_handler nh)</span>:<span class="title">handler</span><span class="params">(nh)</span> </span>&#123;&#125;</span><br><span class="line">    ~NewHandlerHolder() &#123;set_new_handler(handler);&#125;<span class="comment">//恢复global new_handler</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    new_handler handler;<span class="comment">//记录</span></span><br><span class="line">    <span class="comment">//阻止copy 详见Effective C++ 15</span></span><br><span class="line">    NewHandlerHolder(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">    NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>因此，有Widget::operator new实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(set_new_handler(currentHandler))</span></span>;<span class="comment">//安装Widget::new_handler</span></span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);<span class="comment">//分配内存或抛出异常</span></span><br><span class="line">    <span class="comment">//资源管理对象析构 global new_handler恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Widget使用方案如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;<span class="comment">//声明内存分配失败处理函数</span></span><br><span class="line">Widget::set_new_handler(outOfMem);</span><br><span class="line">Widget* pw = <span class="keyword">new</span> Widget;<span class="comment">//分配失败调用outOfMem</span></span><br><span class="line"><span class="built_in">string</span>* ps = <span class="keyword">new</span> <span class="built_in">string</span>;<span class="comment">//分配失败调用global new_handler</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="设计模板解决方案"><a href="#设计模板解决方案" class="headerlink" title="设计模板解决方案"></a>设计模板解决方案</h1><p>&nbsp;<br>我们通过观察可以发现，这一Widget::set_new_handler这一实现方案并不因class发生改变而改变，因此可以对实现复用。一种简单的做法是建立一个“mixin”风格的base class，这种bc允许dc继承某种特定能力—本实例中中是“设定class专属new_handler的能力”。然后将这个base class转换为template，这样每一个dc都将获得实体互异的class data复件。<br>该设计得bc让dc继承它们所需的set_new_handler与operator new，template则是为了保证每一个dc拥有一个实体互异的currentHandler成员变量。具体如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerHolderSupport</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">static</span> new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(new_handler p) <span class="keyword">throw</span>()&#123;</span><br><span class="line">    new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="literal">nullptr</span>;<span class="comment">//static对象定义</span></span><br></pre></td></tr></table></figure><br>有了这个class template，为Widget添加set_new_handler与operator new简直轻而易举：只需要令A继承自NewHandlerSupport&lt;Widget&gt;即可:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span>:<span class="keyword">public</span> NweHandlerSupport&lt;Widget&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><br>但是这种继承似乎不合逻辑,它们之间根本就不是is-a的关系，而且template的参数T根本没有被使用过。实际上它本来就没用，它只是用来区分不同的dc，template机制会为每一个dc自动生成一个static currentHandler。</p>
<p>class A继承自一个模版化的base class ，而后者又以A作为模板参数，这种技术被称为CRTP(curiously recuring template pattern)。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>set_new_handler允许客户指定一个函数，在内存无法分配时被调用。</li>
<li>Nothrow new只能保证内存分配时不会抛出异常，但是后续构造函数调用还是可能会抛出异常。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>8.了解不同意义的new与delete</title>
    <url>/2018/04/25/%E4%BA%86%E8%A7%A3%E4%B8%8D%E5%90%8C%E6%84%8F%E4%B9%89%E7%9A%84new%E4%B8%8Edelete/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>new操作符（new operator）与new操作（operator new）含义完全不同。</p>
<hr>
<h1 id="具体区别"><a href="#具体区别" class="headerlink" title="具体区别"></a>具体区别</h1><p>&nbsp;<br>考虑如下代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Memory Management"</span>);</span><br></pre></td></tr></table></figure><br>这里使用的是new操作符(new operator),它就像sizeof一样是内置的，无法改变其功能与含义。它的功能有以下两个：</p>
<ol>
<li>分配足够大的内存以便于容纳对象</li>
<li>调用构造函数初始化内存中的对象</li>
</ol>
<p>我们能够改变的是如何为对象分配内存。new操作符使用一个函数来完成内存分配工作，此函数名为operator new.</p>
<hr>
<h1 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h1><p>&nbsp;<br>operator new有声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>返回值类型是void*，因为此函数返回了一个raw指针指向未初始化的内存。size代表了分配多少字节。该函数允许重载，但是第一个形参应当保证为size.<br>类似于malloc，opertaor new只负责分配内存，它对构造函数一无所知。我们可以认为，当执行如下语句时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Memory Management"</span>);</span><br></pre></td></tr></table></figure><br>其行为应当类似于：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *memory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>));</span><br><span class="line"><span class="function">call <span class="title">string::string</span><span class="params">(<span class="string">"Memory Management"</span>)</span> on *memory</span>;<span class="comment">//初始化对象</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>*&gt;(memory);</span><br></pre></td></tr></table></figure><br>值得注意的是第二部涉及构造函数调用，程序员无法显式在内存中调用构造，因此如果我们想在heap上构建对象，就必须要使用new操作符。</p>
<hr>
<h1 id="placement-new（Effective-C-53）"><a href="#placement-new（Effective-C-53）" class="headerlink" title="placement new（Effective C++ 53）"></a>placement new（Effective C++ 53）</h1><p>&nbsp;<br>假定我们已经获取了一块raw内存，我们需要在这些内存中构造对象，我们可以使用一个特殊的operator new，它又被称为placement new，其构造实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> widgetSize);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="keyword">void</span> *<span class="built_in">buffer</span>,<span class="keyword">int</span> widgetSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>(<span class="built_in">buffer</span>) Widget(widgetSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数返回一个指针，指向一个Widget对象，对象在传递给函数的buffer里分配。<br>placement new的定义式大致如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> *location)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="operator-new与new-operator使用总结"><a href="#operator-new与new-operator使用总结" class="headerlink" title="operator new与new operator使用总结"></a>operator new与new operator使用总结</h1><ul>
<li>如果你需要在堆上建立一个对象，使用new操作符：它既分配内存又为对象调用构造函数。</li>
<li>如果你只需要分配内存，那你只要用operator new。</li>
<li>如果你希望在内存分配时自定义操作，那无疑需要重载operator new。</li>
<li>如果你需要在指定的raw 内存位置构建对象，那使用placement new。</li>
</ul>
<hr>
<h1 id="Deletion-and-Memory-Deallocation"><a href="#Deletion-and-Memory-Deallocation" class="headerlink" title="Deletion and Memory Deallocation"></a>Deletion and Memory Deallocation</h1><p>&nbsp;<br>为了避免内存泄漏,每一个动态内存分配必须与一个deallocation对应。delete operator 与operator delete的关系类似于new operator与operator new。<br>如果我们是用placement new在内存中建立对象，那我们应该避免在该内存中使用delete操作符。因为delete操作符调用operator delete，而后者并不知道该去哪里释放内存（Effecive C++ 53）。所以必须显式调用对象的析构函数来解除构造函数的影响：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在共享内存中分配和释放内存的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mallocShared</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeShared</span><span class="params">(<span class="keyword">void</span> *memory)</span></span>;</span><br><span class="line"><span class="keyword">void</span> *sharedMemory = mallocShared(<span class="keyword">sizeof</span>(Widget));</span><br><span class="line">Widget *pw = constructWidgetInBuffer(sharedMemory, <span class="number">10</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pw; <span class="comment">//结果不确定! 共享内存来自mallocShared, 而不是 operator new</span></span><br><span class="line">pw-&gt;~Widget();<span class="comment">//正确析构</span></span><br><span class="line">freeShared(pw); <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure><br>(此处内容类似于alloctor）</p>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>&nbsp;<br>如果我们不是一次建立一个对象，而是试图分配一个数组:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><br>此时调用的依然是new operator，不过较于之前有两点不同：</p>
<ol>
<li>内存分配函数不再是operator new，而是operator new[]，它也可以被重载。</li>
<li>new operator调用了n次构造函数。</li>
</ol>
<p>同理，delete也发生了改变。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>在试图定制new与delete的行为时，有准则如下：只能改变它们为完成功能所采用的方法，而不能更改它们可以完成什么功能。(You can modify how they do what they do, but what they do is fixed by the language.)</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>19.了解临时对象的来源</title>
    <url>/2018/04/27/%E4%BA%86%E8%A7%A3%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9D%A5%E6%BA%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>程序员习惯于把短暂需要的变量称为临时变量：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span>&amp; <span class="title">object1</span>, <span class="title">T</span>&amp; <span class="title">object2</span>)&#123;</span></span><br><span class="line">    T temp = object1;<span class="comment">//往往被称为临时对象</span></span><br><span class="line">    object1 = object2;object2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于c++而言，temp根本不是临时对象，它只是一个函数的局部对象。</p>
<hr>
<h1 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h1><p>&nbsp;<br>在c++中真正的临时对象是看不见的，它不出现在任何源码中。建立一个未命名的non-heap对象会产生临时对象，它一般只会出现在两种条件下：</p>
<ol>
<li>为了使函数成功调用而进行隐式转换时</li>
<li>函数返回对象时</li>
</ol>
<p>我们之所以需要关注临时对象，是因为构造和析构它们带来的成本会对程序的性能造成很大影响。</p>
<hr>
<h1 id="隐式转换所产生的临时对象"><a href="#隐式转换所产生的临时对象" class="headerlink" title="隐式转换所产生的临时对象"></a>隐式转换所产生的临时对象</h1><h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>以下是一个记录字符在字符串中出现次数的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">countChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[MAX_STRING_LEN];</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c &gt;&gt; setw(MAX_STRING_LEN) &gt;&gt; <span class="built_in">buffer</span>;<span class="comment">//避免缓存溢出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; countChar(<span class="built_in">buffer</span>, c) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><br>显然，countChar需要的是一个string对象，但实际传入的是一个字符数组（C API 字符串），因此编译器不得不建立一个string的临时对象，以buffer作为参数来初始化它，str被绑定到了这个临时对象，当函数返回时，临时对象释放。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这种类型转换在方便之余也会存在一些风险（More Effective C++ 5），此外，临时对象的构造与析构也是一笔很大的开销，修改方法无非两种：</p>
<ol>
<li>重新设计程序，禁止发生类型转换，详见More Effective C++ 5。</li>
<li>通过修改程序保证不再需要类型转换，详见More Effective C++ 21。</li>
</ol>
<p>仅仅在传值与传常量引用（reference-to-const）时会发生上述情况，因为c++禁止为非常量引用生成临时对象（如果允许存在非常量引用，在实际使用时无法改变真正传入的参数，一切操作均作用于临时对象）。</p>
<hr>
<h1 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h1><p>&nbsp;<br>返回对象会生成临时对象是很容易理解的，并且More Effective C++ 20给出了优化方案。</p>
<hr>
<h1 id="临时对象的发现"><a href="#临时对象的发现" class="headerlink" title="临时对象的发现"></a>临时对象的发现</h1><p>&nbsp;<br>训练自己发现临时对象的能力是很有必要的。任何时候只要看到常量引用参数,就存在建立一个临时对象绑定于其上的可能性。任何时候只要见到一个函数返回对象，就会明白必然存在一个临时对象被构造和析构。</p>
<hr>
<h1 id="关于常量引用的补充"><a href="#关于常量引用的补充" class="headerlink" title="关于常量引用的补充"></a>关于常量引用的补充</h1><p>&nbsp;<br>如果对一个常量进行引用，那么编译器首先建立一个临时变量，然后将该常量的值置入临时变量中，对该引用的操作就是对该临时变量的操作。对常量的引用可以用其它任何引用来初始化，但不能改变。<br>关于引用的初始化有两点值得注意：</p>
<ol>
<li>当初始化值是一个左值（可以取得地址）时，没有任何问题。</li>
<li>当初始化值不是一个左值时，则只能对一个const T&amp;（常量引用）赋值。</li>
</ol>
<p>常量引用的初始化过程为：首先将右值隐式转换到类型T，然后将这个转换结果存放在一个临时对象里，最后用这个临时对象来初始化这个引用变量。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>&amp; dr = <span class="number">1</span>;<span class="comment">//error 需要左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>&amp; cdr = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">//实际过程等价于</span></span><br><span class="line"><span class="keyword">double</span> temp = <span class="keyword">double</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>&amp; cdr = temp;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>31.了解各类排序算法</title>
    <url>/2018/04/15/%E4%BA%86%E8%A7%A3%E5%90%84%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>绝大多数人在听到排序之后只会想到sort，当然，sort是一个优秀的算法，只是我们有时候不一定非要用它。</p>
<hr>
<h1 id="部分排序"><a href="#部分排序" class="headerlink" title="部分排序"></a>部分排序</h1><p>&nbsp;<br>假设当前我们只需要找出某堆Widget中前20个质量最好的,剩下的不用管它，那么这个时候执行全排无疑是不必要的，我们所需要的仅仅只是<code>partial_sort</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">qualityCompare</span><span class="params">(<span class="keyword">const</span> Widget&amp; lhs, <span class="keyword">const</span> Widget&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回lhs的质量是不是比rhs的质量好</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//把质量最好的20个Widget按顺序放在容器前端</span></span><br><span class="line">partial_sort(widgets.<span class="built_in">begin</span>(), widgets.<span class="built_in">begin</span>() + <span class="number">20</span>,widgets.<span class="built_in">end</span>(),qualityCompare);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="无需有序排列的部分排序"><a href="#无需有序排列的部分排序" class="headerlink" title="无需有序排列的部分排序"></a>无需有序排列的部分排序</h1><p>&nbsp;<br>有时候需求比部分排序还要少，我们只需要找出前20个质量好的，根本不要求它们被找到后依次排好序，此时我们可以调用这个算法<code>nth_element</code>。<br>nth_element排序一个区间，在ri（用户指定）位置的元素<strong>是如果区间被完全排序会出现的元素</strong>，当nth_element返回时，在n以上的元素必然就是全排之后的前n个.具体使用如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nth_element(widgets.<span class="built_in">begin</span>(), widgets.<span class="built_in">begin</span>() + <span class="number">19</span>, widgets.<span class="built_in">end</span>(), qualityCompare);</span><br></pre></td></tr></table></figure><br>我怀疑partial_sort内部调用了nth_element，然后再对前n个进行了排序。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>这两种算法均不具备稳定，如果你需要稳定性，请使用stable_sort。STL并不包含partial_sort和nth_element的稳定版本。</p>
<h3 id="nth-element的额外用途：查找"><a href="#nth-element的额外用途：查找" class="headerlink" title="nth_element的额外用途：查找"></a>nth_element的额外用途：查找</h3><p>nth_element不仅仅能够帮我们找到区间顶部的n个元素，还能够轻易找出区间中值或者在指定百分点的元素：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Widget&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">(widgets.<span class="built_in">begin</span>())</span></span>; </span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt;::<span class="function">iterator <span class="title">end</span><span class="params">(widgets.<span class="built_in">end</span>())</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt;::iterator goalPosition;</span><br><span class="line">goalPosition = <span class="built_in">begin</span> + widgets.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">nth_element(<span class="built_in">begin</span>, goalPosition, <span class="built_in">end</span>,qualityCompare);<span class="comment">//此时goalPosition指向中值</span></span><br></pre></td></tr></table></figure><br>原理很简单，上文已经提及：在调用算法后，在ri（用户指定）位置的元素是如果区间被完全排序会出现的元素。</p>
<hr>
<h1 id="分割容器"><a href="#分割容器" class="headerlink" title="分割容器"></a>分割容器</h1><p>&nbsp;<br>有时候我们并不需要排序，我们只需要简单粗暴的根据某一个判定依据，把元素分成一堆，和另外一堆，这个时候partition来了，它重排区间中的元素，使满足某个标准的元素都在区间的开头。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasAcceptableQuality</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回w质量等级是否是2或更高;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回指向第一个不符合条件元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> goodEnd =partition(widgets.<span class="built_in">begin</span>(), widgets.<span class="built_in">end</span>(), hasAcceptableQuality);</span><br></pre></td></tr></table></figure><br>如果你需要稳定性，记得使用stable_partition.</p>
<hr>
<h1 id="上述算法对迭代器的要求"><a href="#上述算法对迭代器的要求" class="headerlink" title="上述算法对迭代器的要求"></a>上述算法对迭代器的要求</h1><p>&nbsp;<br><strong>算法sort，partial_sort，stable_sort和nth_element需要随机访问迭代器</strong>，那也就是说只能用于vector、string、deque与array。<br><strong>list的sort是稳定的</strong>，但如果想使用partial_sort或者nth_element，只能间接完成:</p>
<ul>
<li>拷贝list到一个vector或者别的支持随机访问迭代器的容器中</li>
<li>建立一个list::iterator的容器，对该容器使用算法，通过迭代器访问元素。（算法谓词完成解引用)</li>
</ul>
<p><strong>partition与stable_partition只需要双向迭代器</strong>，所以可以在任何容器上使用。</p>
<hr>
<h1 id="算法性能比较"><a href="#算法性能比较" class="headerlink" title="算法性能比较"></a>算法性能比较</h1><p>&nbsp;<br>以上算法性能由高到低可以排序为：<br>partition&gt;stable_partition&gt;nth_element&gt;partial_sort&gt;sort&gt;stable_sort</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>4.了解如何查看类型推衍结果</title>
    <url>/2018/06/25/%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%A1%8D%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>一般来说有三个阶段可以进行类型推衍结果查看：撰写期、编译期、运行期。</p>
<hr>
<h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><p>&nbsp;<br>IDE通常可以在完成解析的前提下帮你判断当前类型推衍所得到的结果，但对于较为复杂的类型可能会失效。</p>
<hr>
<h1 id="编译期诊断"><a href="#编译期诊断" class="headerlink" title="编译期诊断"></a>编译期诊断</h1><p>&nbsp;<br>最有效的让编译器显示其推衍结果的方法是故意错用这些类型，编译器所给出的错误信息将清楚地告诉你哪里发生了错误。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>&nbsp;<br>现有需要作类型推衍的变量x、y:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> theAnswer = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> x = theAnswer;</span><br><span class="line"><span class="keyword">auto</span> y = &amp;theAnswer;</span><br></pre></td></tr></table></figure><br>首先我们需要定义一个类以展示类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TD</span>;</span><span class="comment">//Type Displayer</span></span><br></pre></td></tr></table></figure><br>任何试图实例化该类的操作都将引发错误，因为TD并没有定义。如果需要查看x、y的推衍结果，我们只需要用其类型去实例化TD：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; xType;</span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; yType;</span><br></pre></td></tr></table></figure><br>以上操作会产生报错信息如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: aggregate &#39;TD&lt;int&gt; xType&#39; has incomplete type and cannot be defined</span><br><span class="line">error: aggregate &#39;TD&lt;const int *&gt; yType&#39; has incomplete type and cannot be defined</span><br></pre></td></tr></table></figure><br>至此完成了编译期类型判别。</p>
<hr>
<h1 id="运行期输出"><a href="#运行期输出" class="headerlink" title="运行期输出"></a>运行期输出</h1><p>&nbsp;<br>有人会想到使用typeid与std::type_info::name来输出对象格式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(x).name() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(y).name() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><br>但这种方法有一个缺陷，因为typeid必须作用于一个可以生成std::type_info对象的对象x或y，且type_info对象必须要有一个返回const char*的name成员函数。</p>
<p>对std::type_info::name的调用并不保证返回能够令你读懂的消息，据本书作者所言，微软公司提供的反馈较为直白。</p>
<p>即使已经得到了正确的类型，也可能会有一些其他问题存在。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; <span class="title">createVec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> vw = createVec();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!vw.empty())&#123;</span><br><span class="line">    f(&amp;vw[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了在运行期明确T与param的类型，我们可以定义f如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"T = "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"param = "</span> &lt;&lt; <span class="keyword">typeid</span>(param).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>微软编译器将给出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T &#x3D; class Widget const *</span><br><span class="line">param &#x3D; class Widget const *</span><br></pre></td></tr></table></figure><br>显然，这并非正确的结果，假若T为int型，那么param必然为const int&amp;才对。发生这样错误的原因在于std::type_info::name规格认为模板参数以值传递的方式传递给模板函数，这导致了referenceness与constness、volatileness被丢失。</p>
<p>此外，IDE所推衍得到的类型也未必可靠，至少有时候帮助不大，例如以下这个类型T：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::_Simple_types&lt;<span class="built_in">std</span>::_Wrap_alloc&lt;<span class="built_in">std</span>::_Vec_base_types&lt;Widget,</span><br><span class="line"><span class="built_in">std</span>::allocator&lt;Widget&gt; &gt;::_Alloc&gt;::value_type&gt;::value_type *</span><br></pre></td></tr></table></figure><br>但IDE却推断param的类型是：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::_Simple_types&lt;...&gt;::value_type *<span class="keyword">const</span> &amp;</span><br></pre></td></tr></table></figure><br>中间的…省略号省略了所有关于T类型。</p>
<hr>
<h1 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h1><p>&nbsp;<br>IDE与type_info::name可能会出错，但Boost不会出错，并且Boost库支持跨平台运行，使用它和使用标准库一样方便，以下将给出使用Boost完成类型推衍的过程：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"T= "</span> &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"param = "</span>&lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(param)&gt;().pretty_name() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它的工作方式是函数模板boost::typeindex::type_id_with_cvr接受一个类型参数并且在推衍结果中不移除const，volatile或reference（with_cvr）。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>你可以使用IDE、错误信息、Boost库来查看类型推衍。</strong></li>
<li><strong>上述工具可能会产生错误，因此熟练Item1-3所描述的法则才是最重要的。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型推衍</tag>
      </tags>
  </entry>
  <entry>
    <title>30.了解完美forward的不完美之处</title>
    <url>/2018/07/15/%E4%BA%86%E8%A7%A3%E5%AE%8C%E7%BE%8Eforward%E7%9A%84%E4%B8%8D%E5%AE%8C%E7%BE%8E%E4%B9%8B%E5%A4%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>完美forward是C++11的一大特性，但实际上在某些场合forward并不完美。</p>
<hr>
<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><p>&nbsp;<br>在提及完美转发之前，首先回顾一下转发的定义：一个函数将其参数传递给另一个函数，但关键在于第二个函数接受到的对象必然需要和第一个函数发出的是同一个。这直接排除了传值，因为传值传递的都是副本。指针也被排除，因为我们并不希望调用者试图传递指针。事实上，我们提到的转发一般只与引用有关。</p>
<p>完美转发意味着我们不仅仅转发对象，我们还转发它们的显著特征：type，左右值，以及const或volatile，这直接表明我们只能用universal reference，因为只有它能够对传入参数的左右值加以编码区分。</p>
<p>假设当前有一个转发实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T&gt;(param)); <span class="comment">// forward it to f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>转发函数在本质上具备通用性。例如，fwd模板接受任何类型的参数，并且它会转发任何类型的参数。这种通用性的逻辑扩展是：转发函数应当成为一个接受可变参数的函数模板，例如fwd的扩展形态应当为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...); <span class="comment">// forward them to f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种写法广泛见于智能指针工厂函数、std::make_shared、std::make_make_unique。</p>
<p>我们所说的完美转发失败指的是：接受同样的参数，f能够正确执行，fwd则表现地与f有所不同：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f( expression ); <span class="comment">// if this does one thing,</span></span><br><span class="line">fwd( expression ); <span class="comment">// but this does something else</span></span><br></pre></td></tr></table></figure><br>有些参数将造成这些现象，下文将依次探讨并给出解决方案。</p>
<hr>
<h1 id="Braced-initializers"><a href="#Braced-initializers" class="headerlink" title="Braced initializers"></a>Braced initializers</h1><p>&nbsp;<br>假定函数有声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure><br>在本案例中，当传入参数为大括号初始化器时，f与fwd表现不同：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// fine, "&#123;1, 2, 3&#125;" implicitly converted to std::vector&lt;int&gt;</span></span><br><span class="line">fwd(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// error! doesn't compile</span></span><br></pre></td></tr></table></figure><br>原因在于大括号初始化器是完美转发的一大失败案例。</p>
<p>在f中，编译器明确了解f需要接受的对象，因此编译器将通过{1，2，3}生成一个临时对象vector，将v绑定至其上。但fwd将推导出{1，2，3}的类型，并将其与f声明的形参相比较，完美转发将会在以下两点情况发生时失效：</p>
<ol>
<li><strong>类型推衍失败</strong><br>编译器无法推断出fwd接收参数的类型，编译失败。</li>
<li><strong>类型推衍错误</strong><br>这将触发f接纳了编译器推导得到的错误类型，更进一步地触发f函数的某些重载版本。</li>
</ol>
<p>在上述调用中，fwd无法推衍出{1，2，3}的类型，因为template并不能推衍出initializer_list,因此触发编译错误。</p>
<p>解决方案在Item2中即有所提及：auto能够推衍得到正确的initializer_list,因此我们可以：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">// il's type deduced to be std::initializer_list&lt;int&gt;</span></span><br><span class="line">fwd(il); <span class="comment">// fine, perfect-forwards il to f</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="0-or-NULL-as-null-pointers"><a href="#0-or-NULL-as-null-pointers" class="headerlink" title="0 or NULL as null pointers"></a>0 or NULL as null pointers</h1><p>&nbsp;<br>在Item8中我们曾经提及，当你传入0或NULL时，编译器将认为它们是一个整形数据而非一个指针，因此转发它们则等价于转发错误的类型（你原本想转发一个指针类型），解决方法十分简单：以nullptr代替它们。</p>
<hr>
<h1 id="Declaration-only-integral-static-const-data-members"><a href="#Declaration-only-integral-static-const-data-members" class="headerlink" title="Declaration-only integral static const data members"></a>Declaration-only integral static const data members</h1><p>&nbsp;<br>一般来说，我们并不需要在类中定义整型静态const数据成员，单单写出声明足以。原因在于编译器将对这些成员的值执行常量传播，因此无需为它们留出内存，考虑如下代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> MinVals = <span class="number">28</span>; <span class="comment">// MinVals' declaration</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line">… <span class="comment">// no def for MinVals</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; widgetData;</span><br><span class="line">widgetData.reserve(Widget::MinVals); <span class="comment">// use of MinVals</span></span><br></pre></td></tr></table></figure><br>编译器将会在所有出现MinVals的地方将其替换为28，但如果当前需要采用MinVals的地址（例如创建了一个指向MinVals的指针），那么MinVals将需要存储（以便指针指向某个东西），上述代码能够编译通过，但会在链接期报错。</p>
<p>那么，假设dangqian函数f被声明为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> val)</span></span>;</span><br></pre></td></tr></table></figure><br>那么使用fwd又会导致完美转发失效：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(Widget::MinVals); <span class="comment">// fine, treated as "f(28)"</span></span><br><span class="line">fwd(Widget::MinVals); <span class="comment">// error! shouldn't link</span></span><br></pre></td></tr></table></figure><br>虽然源代码中没有提及MinVals的地址，但fwd的参数是一个universal reference，编译器在生成代码时通常将引用视作指针，在程序的底层二进制码（以及硬件）中，指针和引用本质上是相同的，但我们并没有在内存中存储MinVal，因此导致了链接期失败。</p>
<p>解决方法很简单，我们不仅仅声明，而且去定义MinVal，这样便可以通过引用转发integral static const data member：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> Widget::MinVals; <span class="comment">// in Widget's .cpp file</span></span><br></pre></td></tr></table></figure><br>值得注意的是该定义并不执行任何初始化操作。</p>
<hr>
<h1 id="Overloaded-function-names-and-template-names"><a href="#Overloaded-function-names-and-template-names" class="headerlink" title="Overloaded function names and template names"></a>Overloaded function names and template names</h1><p>&nbsp;<br>假定当前f形参为某个函数指针：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> (*pf)(<span class="keyword">int</span>))</span></span>; <span class="comment">// pf = "processing function"</span></span><br></pre></td></tr></table></figure><br>当然，我们也可以用另一种语法来完成声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> pf(<span class="keyword">int</span>))</span></span>; <span class="comment">// declares same f as above</span></span><br></pre></td></tr></table></figure><br>更进一步地，假设当前存在重载函数processVal如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processVal</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processVal</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><br>我们可以很自然地将其传递给f：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(processVal); <span class="comment">// fine</span></span><br></pre></td></tr></table></figure><br>显然，传递至f是参数只有int的重载版本。</p>
<p>但如果将processVal传递给fwd，后者将会产生困惑：究竟传递哪个函数？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fwd(processVal); <span class="comment">// error! which processVal?</span></span><br></pre></td></tr></table></figure><br>函数模板自然也存在同样的问题，它并不代表某个函数，而是许多函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">workOnVal</span><span class="params">(T param)</span> </span>&#123; … &#125;</span><br><span class="line">fwd(workOnVal); <span class="comment">// error! which workOnVal instantiation?</span></span><br></pre></td></tr></table></figure></p>
<p>解决方案十分显然，手动明确传入的是何种重载或实例化即可。例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ProcessFuncType = <span class="keyword">int</span> (*)(<span class="keyword">int</span>);</span><br><span class="line">ProcessFuncType processValPtr = processVal;</span><br><span class="line">fwd(processValPtr); <span class="comment">// fine</span></span><br><span class="line">fwd(<span class="keyword">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal)); <span class="comment">// also fine</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Bitfields"><a href="#Bitfields" class="headerlink" title="Bitfields"></a>Bitfields</h1><p>&nbsp;<br>假定ipv4头可被建模如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IPv4Header</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint32_t</span> version:<span class="number">4</span>,IHL:<span class="number">4</span>,DSCP:<span class="number">6</span>,ECN:<span class="number">2</span>,totalLength:<span class="number">16</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>若f当前形参为size_t类型，那么以totalLength作为实参传入完全没毛病：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// function to call</span></span><br><span class="line">IPv4Header h;</span><br><span class="line">… </span><br><span class="line">f(h.totalLength); <span class="comment">// fine</span></span><br></pre></td></tr></table></figure><br>但fwd则可耻地失败了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fwd(h.totalLength); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><br>原因在于fwd的参数是一个引用，而h.totalLength是一个non-const bitfield。C++明确声明：“non-const引用禁止绑定至bitfield。”<strong>位域</strong>可以由机器字的任意部分组成（例如32位int的3-5位），但我们无法获取指向它们的指针，因此引用绑定到bitfield自然也不行。</p>
<p>解决方案是：创建一个副本以存储Bitfield的值，然后将其传递给fwd：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy bitfield value; see Item 6 for info on init. form</span></span><br><span class="line"><span class="keyword">auto</span> length = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line">fwd(length); <span class="comment">// forward the copy</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>12.了解异常的抛出</title>
    <url>/2018/04/25/%E4%BA%86%E8%A7%A3%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA/</url>
    <content><![CDATA[<h1 id="异常的抛出与函数传递参数"><a href="#异常的抛出与函数传递参数" class="headerlink" title="异常的抛出与函数传递参数"></a>异常的抛出与函数传递参数</h1><p>&nbsp;<br>从语法角度看，传递参数和捕获异常其简直一摸一样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;; </span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Widget w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Widget&amp; w)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(Widget *pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">const</span> Widget *pw)</span></span>;</span><br><span class="line"><span class="comment">//异常捕获</span></span><br><span class="line"><span class="keyword">catch</span> (Widget w) ... </span><br><span class="line"><span class="keyword">catch</span> (Widget&amp; w) ... </span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> Widget&amp; w) ... </span><br><span class="line"><span class="keyword">catch</span> (Widget *pw) ... </span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> Widget *pw) ...</span><br></pre></td></tr></table></figure><br>它们确实有相同点，但是也存在巨大差异。</p>
<ul>
<li>相同点在于：传递过程都是可以传值、传递引用、传递指针。</li>
<li>不同点在于：调用函数时，程序控制权终将返回调用处，但当你抛出异常时，控制权将永远回不到抛出异常的地方。</li>
</ul>
<hr>
<h1 id="异常与拷贝"><a href="#异常与拷贝" class="headerlink" title="异常与拷贝"></a>异常与拷贝</h1><p>&nbsp;<br>以如下函数举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream <span class="keyword">operator</span>&gt;&gt;(istream&amp; s, Widget&amp; w);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passAndThrowWidget</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Widget localWidget;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; localWidget;<span class="comment">//传递参数</span></span><br><span class="line">    <span class="keyword">throw</span> localWidget;<span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们传递参数时，其实是把w绑定到localwidget，任何施加于w的操作都施加于它。但throw则不同<strong>，无论通过传值还是引用，异常都会被拷贝</strong>，原因很简单，localwidget一旦离开了生存空间后析构函数就会被调用。如果我们把localwidget本身传递出去，catch只能接受到一个析构了的widget，因此异常抛出的对象必须被复制。</p>
<h2 id="static异常"><a href="#static异常" class="headerlink" title="static异常"></a>static异常</h2><p>即使对象是static，不会被析构，抛出异常的时候也会进行复制：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passAndThrowWidget</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Widget localWidget;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; localWidget;</span><br><span class="line">    <span class="keyword">throw</span> localWidget; <span class="comment">// 拷贝操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这表明哪怕是使用引用捕获异常，我们永远也无法通过catch来修改localwidget本身，仅仅只能修改对象的拷贝。这也证明了抛出异常与参数传递的第二个差异：抛出异常速度比参数传递要慢。</p>
<h2 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h2><p>当异常对象被拷贝时，拷贝操作是由对象的拷贝构造函数完成的。该拷贝构造函数是对象的静态类型所对应类的拷贝构造函数，而不是对象的动态类型对应类的拷贝构造函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWidget</span>:</span> <span class="keyword">public</span> Widget &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passAndThrowWidget</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SpecialWidget localSpecialWidget;</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; rw = localSpecialWidget;</span><br><span class="line">    <span class="keyword">throw</span> rw;<span class="comment">//抛出一个类型为Widget的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="catch中的异常"><a href="#catch中的异常" class="headerlink" title="catch中的异常"></a>catch中的异常</h1><p>&nbsp;<br>异常是其它对象的拷贝，这个事实影响到你如何在catch块中再抛出一个异常。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Widget&amp; w)&#123;<span class="comment">// 捕获 Widget 异常</span></span><br><span class="line">    ... <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="keyword">throw</span>; <span class="comment">// 重新抛出异常，让它继续传递</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Widget&amp; w)&#123;<span class="comment">// 捕获 Widget 异常</span></span><br><span class="line">    ... <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="keyword">throw</span> w; <span class="comment">// 传递被捕获异常的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这两个catch块中，第一个catch块重新抛出的是当前捕获的异常，第二个抛出的是当前捕获的异常的一个拷贝。<br>第一个块中抛出的类型不需要静态动态类型，因为它没有进行拷贝操作。<br>第二个块中重新抛出的是新异常，其类型必然是widget.<br>一般来说，推荐使用throw，这样不会改变异常的类型，也不用生成额外的异常临时变量了。（临时变量详见More Effective C++ 19）</p>
<hr>
<h1 id="异常的捕获方式"><a href="#异常的捕获方式" class="headerlink" title="异常的捕获方式"></a>异常的捕获方式</h1><p>&nbsp;<br>异常一般有传值、传引用、传指向const的引用三种：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Widget w) ... <span class="comment">// 通过传值捕获异常</span></span><br><span class="line"><span class="keyword">catch</span> (Widget&amp; w) ... <span class="comment">// 通过传递引用捕获异常</span></span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> Widget&amp; w) ... <span class="comment">//通过传递指向const的引用捕获异常</span></span><br></pre></td></tr></table></figure><br>通过比对我们又发现了一大差异，我们已经知道抛出的拷贝其实是一个临时变量，而在传递参数时临时变量无法被普通引用绑定，只能通过const reference。</p>
<h2 id="不同捕获方式之间的差异"><a href="#不同捕获方式之间的差异" class="headerlink" title="不同捕获方式之间的差异"></a>不同捕获方式之间的差异</h2><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><p>当我们声明这样的一个catch子句时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Widget w) ...<span class="comment">//传值捕获</span></span><br></pre></td></tr></table></figure><br>该表达式会建立<strong>两个</strong>被抛出对象的拷贝，一个是所有异常都必须建立的临时对象，另一个是把临时对象拷贝进w中。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>当我们声明使用引用捕获时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Widget&amp; w) ... <span class="comment">// 通过引用捕获</span></span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> Widget&amp; w) ... <span class="comment">//也通过引用捕获</span></span><br></pre></td></tr></table></figure><br>只会建立一个拷贝，该拷贝是一个临时对象，并且被引用绑定，但我们使用引用传递参数时则不会发生拷贝。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>对于指针而言，传递参数与传递异常差不多，都是一个指针的拷贝被传递，只不过要记得用指针传递异常时异常必须是全局的或者在堆中，否则catch子句只能通过指针去往一个已经被析构的地方。</p>
<hr>
<h1 id="异常与类型转换"><a href="#异常与类型转换" class="headerlink" title="异常与类型转换"></a>异常与类型转换</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>异常传递中不允许出现隐式转换，但传递参数时可以。</p>
<h2 id="异常传递中允许发生的转换"><a href="#异常传递中允许发生的转换" class="headerlink" title="异常传递中允许发生的转换"></a>异常传递中允许发生的转换</h2><p>第一种是派生类与基类间的转换。（is-a)<br>另一种就是允许从一个类型化指针转变为无类型指针，所以参数为const void*的catch语句能捕获任何类型的指针类型异常。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">void</span>*) ...</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="catch语句匹配"><a href="#catch语句匹配" class="headerlink" title="catch语句匹配"></a>catch语句匹配</h1><p>&nbsp;<br>传递函数与传递异常的差别还在于catch语句匹配不按最合适的，而是总是按照先后顺序，因此可能会发生派生类异常永远总是处理不到的情形：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (logic_error&amp; ex) &#123;<span class="comment">//base</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (invalid_argument&amp; ex) &#123;<span class="comment">//derived</span></span><br><span class="line">    ...<span class="comment">//永远不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虚函数采用的是最优匹配法，而异常处理采用的是最先适合法。但如果一个派生类的catch在一个基类的catch后面，通常编译器会发出警告。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>一个对象传递给函数,一个对象调用虚函,把一个对象做为异常抛出，它们之间有三个主要区别：</p>
<ul>
<li>异常在传递时总被拷贝，传值时被拷贝了两次</li>
<li>异常的类型转换很少（2种）</li>
<li>异常采用最先匹配法</li>
</ul>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>28.了解引用塌缩</title>
    <url>/2018/07/15/%E4%BA%86%E8%A7%A3%E5%BC%95%E7%94%A8%E5%A1%8C%E7%BC%A9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>众所周知，当一个左值或右值初始化universal reference时将触发类型推衍，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><br>T将会根据传递至param的类型完成推衍、编码。</p>
<p>编码机制十分简单：当传入左值时，T被推导为左值引用。当传入右值时，T被推断为non-reference。因此：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>; <span class="comment">// function returning rvalue</span></span><br><span class="line">Widget w; <span class="comment">// a variable (an lvalue)</span></span><br><span class="line">func(w); <span class="comment">// call func with lvalue; T deduced to be Widget&amp;</span></span><br><span class="line">func(widgetFactory()); <span class="comment">// call func with rvalue; T deduced to be Widget</span></span><br></pre></td></tr></table></figure><br>显然，传入对象性质决定了universal reference的性质，这也正是forward的工作原理。</p>
<hr>
<h1 id="引用塌缩"><a href="#引用塌缩" class="headerlink" title="引用塌缩"></a>引用塌缩</h1><p>&nbsp;<br>在更加深入地了解std::forward与universal refernce之前，我们首先复习一个基础知识：C++禁止出现引用的引用（原因无非是引用并非对象），因此编译器会对如下行为作出警告：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span>&amp; &amp; rx = x; <span class="comment">// error! can't declare reference to reference</span></span><br></pre></td></tr></table></figure><br>细想一下，当一个左值引用被传递给形参为universal reference的函数模板时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line">func(w); <span class="comment">// invoke func with lvalue;T deduced as Widget&amp;</span></span><br></pre></td></tr></table></figure><br>如果我们推衍出T为Widget&amp;，并以此实例化函数模板，则该模板可表示为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Widget&amp; &amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><br>这里存在一个引用的引用，这时候问题来了，编译器是如何将函数签名更改为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Widget&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><br>答案正是引用塌缩（reference collapsing）。尽管开发者们被禁止声明指向引用的引用，但编译器在特定环境下（例如模板实例化）可以默许这种行为的存在，并通过引用塌缩将其转为正确类型。</p>
<hr>
<h2 id="引用塌缩法则"><a href="#引用塌缩法则" class="headerlink" title="引用塌缩法则"></a>引用塌缩法则</h2><p>由于引用共存在两种（左值、右值），因此引用的引用共存在四种情况：l-l,l-r,r-l,r-r,引用塌缩将按照如下法则将引用的引用转换为单一引用：<strong>只要存在左值引用，则最终结果为左值引用，因此仅有r-r为右值引用</strong>。</p>
<hr>
<h1 id="引用塌缩与forward"><a href="#引用塌缩与forward" class="headerlink" title="引用塌缩与forward"></a>引用塌缩与forward</h1><p>&nbsp;<br>引用塌缩是std::forward工作的核心所在，考虑下述实例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span>&#123;</span><br><span class="line">    … <span class="comment">// do some work</span></span><br><span class="line">    someFunc(<span class="built_in">std</span>::forward&lt;T&gt;(fParam)); <span class="comment">// forward fParam to someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>std::forward的工作是当且仅当T被推衍为non-reference时，将fParam（一个左值）强制转换为右值，其实现可表示为（与标准库相比缺少了一些接口描述）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中，<code>typename remove_reference&lt;T&gt;::type&amp; param</code>保证了param必然以一个左值的身份接受强制转换。当T是一个左值（即类型推衍中T由一个左值初始化）时，T&amp;&amp;仍然是一个左值，因此param被转换为左值引用，返回一个左值。当T是一个non-reference（即类型推衍中T由一个右值初始化时），T&amp;&amp;为右值引用（r-r情况），此时左值引用param被转换为右值引用，而经函数返回的右值引用为右值，最终forward返回了右值。</p>
<p>在C++14中，forward可被更进一步简化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="引用塌缩的四大应用场景"><a href="#引用塌缩的四大应用场景" class="headerlink" title="引用塌缩的四大应用场景"></a>引用塌缩的四大应用场景</h1><h2 id="auto对象生成"><a href="#auto对象生成" class="headerlink" title="auto对象生成"></a>auto对象生成</h2><p>auto对象生成也将触发引用塌缩，其具体细节类似于模板实例化,假设当前存在声明与定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>; <span class="comment">// function returning rvalue</span></span><br><span class="line">Widget w; <span class="comment">// a variable (an lvalue)</span></span><br></pre></td></tr></table></figure><br>当定义w1为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure><br>此时等价于：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; &amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure><br>触发引用塌缩转为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; w1 = w;</span><br></pre></td></tr></table></figure><br>最终，w1为左值引用。</p>
<p>当定义w2为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = widgetFactory();</span><br></pre></td></tr></table></figure><br>由于T被推衍为non-reference，此时并未触发引用塌缩，w2为Widget&amp;&amp;。</p>
<p>时至今日我们终于能够完全理解universal reference，它并非一种新的引用，而是仅在符合2种条件的特定环境下的右值引用：</p>
<ol>
<li><strong>区分左右值的类型推衍</strong><br>在此条件下，左值将推衍T为T&amp;，右值则推衍T为non-reference。</li>
<li><strong>触发引用塌缩</strong></li>
</ol>
<h2 id="typedef与alias-declaration"><a href="#typedef与alias-declaration" class="headerlink" title="typedef与alias declaration"></a>typedef与alias declaration</h2><p>如果在typedef与alias declaration创建中出现引用的引用，则将触发引用塌缩，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果我们以一个左值引用实例化Widget：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&lt;<span class="keyword">int</span>&amp;&gt; w;</span><br></pre></td></tr></table></figure><br>此时RvalueRefToT将被表示为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp; &amp;&amp; RvalueRefToT;</span><br></pre></td></tr></table></figure><br>最终触发引用塌缩，RvalueRefToT被表示为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp; RvalueRefToT;</span><br></pre></td></tr></table></figure><br>这一结果表明Typedef的结果似乎可能并非我们所愿。</p>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>在decltype推衍中如果存在引用的引用，则将利用引用塌缩予以消除。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>引用塌缩触发于四种特定环境：模板实例化、auto类型生成、typedef与alias declaration以及decltype推衍。</strong></li>
<li><strong>在引用塌缩过程中，只要存在左值引用，则最终结果为左值引用，否则即为右值引用。</strong></li>
<li><strong>universal reference可视为特定环境下的右值引用。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>24.了解虚函数、多继承、虚基类、RTTI所带来的成本</title>
    <url>/2018/04/27/%E4%BA%86%E8%A7%A3%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%9F%BA%E7%B1%BB%E3%80%81RTTI%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%88%90%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>C++编译器必须实现语言的每一个特性，其实现细节由编译器来决定，不同的编译器以不同的方式实现语言特性。在多数情况下，开发者无需理解这些隐藏于代码背后的操作。然而某些特性的实现对<strong>对象大小</strong>和其<strong>成员函数执行速度</strong>有很大的影响，所以对于这些特性有一个基本的了解，知道编译器可能执行的操作，就较为重要。 </p>
<hr>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>&nbsp;<br>当调用虚函数时，所执行的代码必须与调用函数的对象的动态类型一致；指向对象的指针或引用的静态类型并不重要。<br>编译器为了高效地提供这种行为，通常会使用virtual table与virtual table pointers.此二者通常又被称为vtbl与vptr.</p>
<hr>
<h2 id="vbtl"><a href="#vbtl" class="headerlink" title="vbtl"></a>vbtl</h2><p>一个vbtl通常是一个函数指针数组（或链表）。只要某个类声明了虚函数或者继承了虚函数就会存在vtbl，vtbl中的元素是指向虚函数实现体的指针。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C1();</span><br><span class="line">    <span class="keyword">virtual</span> ~C1();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>C1的vtbl如下所示：<img src="http://static.zybuluo.com/zsmj2017/q161l1kwdi9q91p8fhojpmcb/image_1cc2pakm9rru1e2gtrp1p9016ob9.png" alt="image_1cc2pakm9rru1e2gtrp1p9016ob9.png-44.2kB"><br>显然，非虚函数不会存在于vtbl中。</p>
<h3 id="继承下的vbtl"><a href="#继承下的vbtl" class="headerlink" title="继承下的vbtl"></a>继承下的vbtl</h3><p>现有C2继承自C1，并且重定义了部分虚函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>:</span> <span class="keyword">public</span> C1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C2();<span class="comment">//非虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~C2(); <span class="comment">//重定义函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;<span class="comment">//重定义函数virtual     void f5(char *str); //新的虚函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>C2的vtbl如下所示：<img src="http://static.zybuluo.com/zsmj2017/0kn6vjye3wr12rdt8ytt12p5/image_1cc2po1k51uvcejs1585tht199lm.png" alt="image_1cc2po1k51uvcejs1585tht199lm.png-40.6kB"><br>可以看出，C2的vbtl里面包括了没有被C2重定义的C1的虚函数的指针。</p>
<p>vbtl体现了虚函数所需的第一个代价：<strong>每一个包含虚函数的类都需要空间来容纳vtbl，其大小与虚函数的数量成正比。</strong></p>
<h3 id="vtbl的位置"><a href="#vtbl的位置" class="headerlink" title="vtbl的位置"></a>vtbl的位置</h3><p>因为每一个类只需要一个vbtl拷贝，那把它放在哪个obj里呢？编译器厂商有两种做法：</p>
<ol>
<li>为所有可能需要vbtl的obj生成一个vbtl拷贝，连接程序然后删除多余的拷贝。最后的可执行文件或者程序库里只有一个vbtl实例。</li>
<li>采用启发式算法：只有obj包含该类的第一个非内联，非纯虚函数定义（也就是实现体）时才会生成vbtl.</li>
</ol>
<hr>
<h2 id="vptr"><a href="#vptr" class="headerlink" title="vptr"></a>vptr</h2><p>单有vbtl并不能实现虚函数，还需要vptr.这是一个指向vbtl的指针，隐藏在对象中，其位置只有编译器知道。这是虚函数的第二个代价：对象内需要额外的空间开销来存储指针。对于较小的对象而言，这笔买卖很不划算。<br>假设我们有一些C1与C2的对象，对象、vbtl、vptr的关系大致如下图所示：<br><img src="http://static.zybuluo.com/zsmj2017/zop4fglkufcfy0pw2hjfyor0/image_1cc2qaquhtk915b82dqco71mde13.png" alt="image_1cc2qaquhtk915b82dqco71mde13.png-106.9kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeACall</span><span class="params">(C1 *pC1)</span></span>&#123;</span><br><span class="line">    pC1-&gt;f1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了保证调用正确，编译器做出了如下操作：</p>
<ol>
<li>通过对象的vptr找到vtbl。</li>
<li>找到vbtl里面的指向被调用函数的指针。</li>
<li>调用该函数。</li>
</ol>
<p>假设存在索引i指向vbtl中的f1函数，那么上述代码的执行类似于：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*pC1-&gt;vptr[i])(pC1);<span class="comment">//pC1作为this指针作为形参</span></span><br></pre></td></tr></table></figure><br>从上述过程可以看出调用虚函数并不是性能的瓶颈，因为虚函数调用所花费的成本相对于普通函数调用相差无几。在实际运行中虚函数成为性能瓶颈的原因是无法内联，原因很简单，inline是编译到此处时替换，而虚函数的确认需要到运行期，这就是虚函数的第三个不足：无法内联从而降低性能。</p>
<hr>
<h1 id="多继承与虚基类"><a href="#多继承与虚基类" class="headerlink" title="多继承与虚基类"></a>多继承与虚基类</h1><p>&nbsp;<br>一旦多继承被引入，在对象里为寻找vptr而进行的偏移量计算会变得更复杂。在单个对象中会存在多个vptr（每一个基类对应一个），此外，此外，针对base class而形成的vtbl也被生成。这直接导致了空间成本进一步扩大，并且运行期调用成本也有了轻微的增长。<br>多继承导致了对虚基类的需求。在不使用虚基类的情况下，如果一个派生类有一个以上从基类的继承路径，基类的数据成员将通过所有路径产生多个拷贝存在于派生类中。<br>但虚基类本身亦存在使用成本，因为虚基类的实现经常使用指向虚基类的指针做为避免复制的手段，从而导致一个或者更多的指针被存储在对象里。</p>
<h2 id="钻石型继承体系（Effective-C-41）"><a href="#钻石型继承体系（Effective-C-41）" class="headerlink" title="钻石型继承体系（Effective C++ 41）"></a>钻石型继承体系（Effective C++ 41）</h2><p>考虑如下的继承关系：<br><img src="http://static.zybuluo.com/zsmj2017/2ayq58oo7nqcganao8f4x7ay/image_1cc2re6k51thn88j1av642r6351g.png" alt="image_1cc2re6k51thn88j1av642r6351g.png-35.1kB"><br>D对象的内部会呈现出这样的结构：<br><img src="http://static.zybuluo.com/zsmj2017/b91cwitnhk40eh3fzxobyddm/image_1cc2rods774enmju44g9s147g2d.png" alt="image_1cc2rods774enmju44g9s147g2d.png-79.7kB"><br>显然，对象内部有一个多余的指针，这也就是上文所说的虚基类的一大弊端。<br>当我们再加入vptr的概念，D对象的内部结构大概是这样：<br><img src="http://static.zybuluo.com/zsmj2017/3uscbl1vj2cpv228hmtdng4a/image_1cc2rrm7ap0hbc01a4819nj18pk3a.png" alt="image_1cc2rrm7ap0hbc01a4819nj18pk3a.png-166.3kB"><br>四个类只有3个vptr，这是因为编译器发现BD的vptr可以共享。</p>
<hr>
<h1 id="运行期类型识别（RTTI）"><a href="#运行期类型识别（RTTI）" class="headerlink" title="运行期类型识别（RTTI）"></a>运行期类型识别（RTTI）</h1><p>&nbsp;<br>RTTI能够让我们在运行时找到对象和类的相关信息，这样信息被存储在类型为type_info的对象里，我们可以通过typeid操作符来访问一个类的type_info对象.</p>
<p>一个类仅仅只需要一个RTTI的拷贝，但是必须有办法得到任何对象的类型信息。从语言规范角度而言：如果一个类型至少有一个虚函数，那我们保证可以获得一个对象动态类型信息。这似乎类似于vbtl，实际上，RTTI就是基于vbtl实现的。<br>具体来说，vbtl的索引0处可以包含一个指针，指向type_info对象：<br><img src="http://static.zybuluo.com/zsmj2017/myendjr6k114f880zr1pbltn/image_1cc2s78hs1cho1rhb13vft1npt83n.png" alt="image_1cc2s78hs1cho1rhb13vft1npt83n.png-40.5kB"><br>也就是说vbtl又多了一个需要被占用的空间。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Increases Size of Objects</th>
<th style="text-align:center">Increases Per-Class Data</th>
<th style="text-align:center">Reduces Inlining</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Virtual Functions</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">Multiple Inheritance</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">Virtual Base Classes</td>
<td style="text-align:center">Often</td>
<td style="text-align:center">Sometimes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">RTTI</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
</tbody>
</table>
</div>
<p>要记住理解是为了更好的使用，而非因噎废食。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>42.了解隐式接口与编译期多态</title>
    <url>/2018/04/20/%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="OOP中的接口与多态"><a href="#OOP中的接口与多态" class="headerlink" title="OOP中的接口与多态"></a>OOP中的接口与多态</h1><p>&nbsp;<br>面向对象编程以<strong>显式接口</strong>和<strong>运行期多态</strong>解决问题。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    <span class="keyword">virtual</span> ~Widget();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(WidgeT&amp; other)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">(Widget&amp; w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>()&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.normalize();</span><br><span class="line">        temp.swap(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于doSth中的w，我们可以这样分析：</p>
<ol>
<li>w被声明为Widget，因此w必须支持Widget接口。我们可以通过打开<code>Widget.h</code>观察接口，所以我们称这种接口为<strong>显式接口，即此类接口在源码中明确可见</strong>。</li>
<li>由于Widget的部分成员函数是virtual，因此w对那些函数的调用将表现出<strong>运行期多态，即于运行期根据w的动态类型决定调用哪个函数。</strong></li>
</ol>
<hr>
<h1 id="隐式接口与编译期多态"><a href="#隐式接口与编译期多态" class="headerlink" title="隐式接口与编译期多态"></a>隐式接口与编译期多态</h1><p>&nbsp;<br>Templates与泛型编程的世界，与面向对象有根本性的不同。在此世界中，显式接口和运行期多态仍然存在，但是重要性降低。反倒是隐式接口与编译期多态移到了前面。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">(T&amp; w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>()&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.normalize();</span><br><span class="line">        temp.swap(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>doSth现在变成了一个函数模板，对于doSth中的w，我们现在可以这样分析：</p>
<ol>
<li>w必须支持哪一种接口，由template function中执行于w身上的操作决定。以实例而言，size，copy构造函数，normalize等似乎是类型T必须支持的一组接口（其实不然）。<strong>这一组（必须能够编译）的表达式可以成为类型T必须支持的一组隐式接口。</strong></li>
<li>凡涉及w的任何函数调用，例如<code>operator&gt;</code>等等，都有可能造成template具现化。这样的具现行为发生在编译期<strong>，“以不同的template参数具现化function templates”会导致调用不同的函数，此即为编译期多态。</strong></li>
</ol>
<hr>
<h1 id="编译期多态与运行期多态的对比"><a href="#编译期多态与运行期多态的对比" class="headerlink" title="编译期多态与运行期多态的对比"></a>编译期多态与运行期多态的对比</h1><p>&nbsp;<br>编译期多态和运行期多态的差异，十分类似于“哪一个重载该被调用”（编译期）与“哪一个virtual函数该被绑定”（运行期）之间的差异。</p>
<hr>
<h1 id="显式接口与隐式接口的对比"><a href="#显式接口与隐式接口的对比" class="headerlink" title="显式接口与隐式接口的对比"></a>显式接口与隐式接口的对比</h1><h2 id="显式接口"><a href="#显式接口" class="headerlink" title="显式接口"></a>显式接口</h2><p>通常情况下<strong>显式接口由函数的签名式（函数名称、参数类型、返回类型）构成</strong>。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    <span class="keyword">virtual</span> ~Widget();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(WidgeT&amp; other)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>Widget的接口包括构造、析构函数，函数size,normalize,swap及其参数类型、返回类型、常量性。当然也包括编译器自动生成的函数，还有typedefs。</p>
<h2 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h2><p><strong>隐式接口并不基于函数签名式，而是由有效表达式组成。</strong></p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(w.<span class="built_in">size</span>()&gt;<span class="number">10</span> &amp;&amp; w!=sth);</span><br></pre></td></tr></table></figure><br>T的隐式接口看起来好像有这些约束：</p>
<ol>
<li>必须提供一个size函数，该函数返回一个整数值。</li>
<li>必须支持operator!=函数，用来比较两个T对象。</li>
</ol>
<p>然而，由于操作符重载带来的可能性，这两个约束都不需要满足。（手动滑稽）</p>
<h2 id="实例剖析"><a href="#实例剖析" class="headerlink" title="实例剖析"></a>实例剖析</h2><p>T似乎必须要有一个size函数，但这个函数可能是从base class继承得到的。size也没必要返回一个整数，甚至不需要返回一个数值类型。它只要返回一个类型为X的对象，这个对象配合int内置类型可以调用<code>operator&gt;</code>即可。甚至。。。它都无需获取一个X对象，只要获取一个能够隐式转换为X对象的Y对象即可。<br>同理，T也没必要支持operator!=。因为下面的情况也是可能的：<code>operator!=</code>接受一对类型为X与Y的对象，我们只要T可以转为X型，sth可以转为Y型即可。<br>更有甚者，也许连<code>operator&amp;&amp;</code>也已经被重载，左右两边已经变成了不知道什么类型，执行什么操作的东西。</p>
<h2 id="真正的约束条件"><a href="#真正的约束条件" class="headerlink" title="真正的约束条件"></a>真正的约束条件</h2><p>如果都按照上文的做法分析，似乎约束条件很难界定，但是实际上还是很简单的：<br>对于size之类的单个表达式可能约束条件很难界定，但对于整体约束条件却很好判断：</p>
<ol>
<li>if里面必须是一个bool.</li>
<li>其他隐式接口，诸如copy构造函数之类，必须确保对T型对象有效。</li>
</ol>
<p>加诸于template参数身上的隐式接口如同加诸于class对象身上的显式接口一样真实，而且两者都在编译期通过检查。你无法以一种与显式接口矛盾的方法来使用对象，你也无法在template中使用不支持隐式接口的对象，二者都将导致无法编译。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>classes与templates都支持接口与多态</li>
<li>classes的接口是显式的，以函数签名为中心，多态发生在运行期</li>
<li>templates的接口是隐式的，奠基于有效表达式。多态的实现则基于templates具现化和函数重载解析，发生于运行期。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板与泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>15.了解异常处理的成本</title>
    <url>/2018/04/26/%E4%BA%86%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%88%90%E6%9C%AC/</url>
    <content><![CDATA[<p>为了处理异常，程序必须做到：</p>
<ul>
<li>无论执行至何处，都应该明确此时如果抛出异常将释放哪个对象</li>
<li>知晓每一个入口点，以便从try块退出</li>
<li>对于每一个try，继续跟踪catch子句以及其能够捕获的异常类型</li>
</ul>
<p>如果你确保你的程序根本不使用异常，链接的程序库里也没有异常，那你可以使用不支持异常处理的方法进行编译，从而缩小程序尺寸和提高速度。</p>
<p>一般来说，每一个try块都降低了速度并且增大代码尺寸，因此应该避免使用无用的try块。同样的，异常明细的成本和try块相差不大。</p>
<p>总的来说，真正处理异常的开销仅仅发生于异常出现，（异常本身就是难于出现的）因此我们无需在效率上顾虑太多，遵循之前所提及的各项要求即可。（More Effective C++ 9~14）</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始学习velox源码（一）</title>
    <url>/2024/12/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0velox%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本系列是笔者学习velox源码的笔记，主要记录在学习velox源码时遇到的问题和解决方案。<br>本节是最基础也是最磨人的一节————搭建开发环境。</p>
<a id="more"></a>
<h1 id="git-clone-velox"><a href="#git-clone-velox" class="headerlink" title="git clone velox"></a>git clone velox</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:facebookincubator/velox.git</span><br></pre></td></tr></table></figure>
<p>本系列当前基于commit <code>ac5c15eb7627b42f8d41023215d1d4a7e69d45aa</code>。</p>
<h1 id="setup-macos-sh"><a href="#setup-macos-sh" class="headerlink" title="setup-macos.sh"></a>setup-macos.sh</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/setup-macos.sh</span><br></pre></td></tr></table></figure>
<p>执行该脚本会安装velox的依赖，包括<code>cmake</code>、<code>glog</code>、<code>gflags</code>、<code>fmt</code>、<code>folly</code>等。<br>笔者在安装时遇到了一些问题，解决方案可参考此isuue：<a href="https://github.com/facebookincubator/velox/issues/11701" target="_blank" rel="noopener">build issue</a></p>
<p>大致来看，分别是<code>ccache</code>安装失败和<code>folly</code>编译失败。</p>
<h1 id="use-clion-to-open-velox"><a href="#use-clion-to-open-velox" class="headerlink" title="use clion to open velox"></a>use clion to open velox</h1><p>本地ide使用的是<code>clion</code>，打开velox的根目录即可。<br>本地环境主要用于debug unit test, 因此cmake参数直接参考make unitest命令得到的cmake命令即可。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-DTREAT_WARNINGS_AS_ERRORS=1 -DENABLE_ALL_WARNINGS=1 -DVELOX_BUILD_MINIMAL="OFF" -DVELOX_BUILD_TESTING="ON" -DCMAKE_BUILD_TYPE=Debug -GNinja -DMAX_LINK_JOBS= -DMAX_HIGH_MEM_JOBS= -DVELOX_FORCE_COLORED_OUTPUT=ON</span><br></pre></td></tr></table></figure><br>Build dir也参考make unitest命令得到的build dir，即<code>_build/debug</code>。<br>此外，还需要额外关注环境变量<code>INSTALL_PREFIX</code>，这将指定velox优先从下载的依赖项中查找库文件。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INSTALL_PREFIX=&#123;Your-velox-code-repo&#125;/deps-install</span><br></pre></td></tr></table></figure></p>
<p>cmake设置大致如图：<img src="/images/clion-velox-debug-env-cmake.png" alt="clion-velox-debug-env-cmake"></p>
<p>此后，愉快地debug即可。</p>
]]></content>
      <categories>
        <category>velox</category>
      </categories>
      <tags>
        <tag>velox debug</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>1.仔细选择容器</title>
    <url>/2018/04/05/%E4%BB%94%E7%BB%86%E9%80%89%E6%8B%A9%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="可选容器："><a href="#可选容器：" class="headerlink" title="可选容器："></a>可选容器：</h1><blockquote>
<ul>
<li>标准STL序列容器：vector,list,sequence</li>
<li>标准STL关联容器：set,multiset,map,mutimap</li>
<li>非标准序列容器slist与rope<br>其中，slist是单向链表，rope为重型string</li>
<li>非标准关联容器hash_set,hash_mutiset,hash_map,hash_mutimap</li>
<li>vector<char>作为string的替代</li>
<li>标准非STL容器，诸如array,bitset，stack之类</li>
</ul>
</blockquote>
<hr>
<p>在选择容器时需要顾虑的有很多，vector，list，deque之间的选择也就不说了，大家都懂。</p>
<hr>
<p>根据内部元素物理地址的相互关联性，STL容器可以分为两类</p>
<blockquote>
<p>1.连续内存容器<br>2.基于节点的容器</p>
</blockquote>
<p>这两种容器其实也说得很多了，在这里要强调的是rope是连续的，而关联容器和散列容器是基于节点的。</p>
<hr>
<h1 id="选择容器时需要判断的一些依据"><a href="#选择容器时需要判断的一些依据" class="headerlink" title="选择容器时需要判断的一些依据"></a>选择容器时需要判断的一些依据</h1><blockquote>
<ul>
<li>是否需要在任意位置插入？<br>如果是则不可选择关联容器</li>
<li>容器内元素是否需要排序？<br>是则不可选择散列容器</li>
<li>是否必须是标准c++？<br>否则不可使用slist，rope与散列容器</li>
<li>迭代器是否有要求？<br>随机访问迭代器需要vector，string，deque.slist不可以使用双向迭代器</li>
<li>是否需要频繁插入删除？<br>是则选择基于节点</li>
<li>是否需要兼容c接口？<br>是则选择vector</li>
<li>是否对查找速度有要求？<br>是则选择散列容器，sorted vector以及标准关联容器</li>
<li>是否介意容器内部的引用计数？<br>是则需要避免string与rope</li>
<li>插入和删除如果失败是否需要回滚？<br>是则需要选择基于节点的容器，如果是区间形式的操作，那只能使用list.</li>
<li>是否需要尽可能少地让迭代器失效？<br>是则选择基于节点的容器（他们的插入和删除操作从来不会让迭代器，指针，或者引用失效）<br>deque的插入操作仅发生在末尾时，迭代器可能失效，但指针和引用不会失效，它是唯一会有这种情况的容器。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始学习velox源码（二）</title>
    <url>/2024/12/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0velox%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习velox orderby算子，其排序存在一个列转行的过程，其中行数据的表现形式是<code>RowContainer</code>。<br>本节主要描述<code>RowContainer</code>的layout和基础api。<br>笔者当前仅关注<code>SortBuffer</code>所需要关注的部分，对于<code>RowContainer</code>的其他部分（aggregate、join等），将在后续补充。</p>
<a id="more"></a>
<h1 id="RowContainer"><a href="#RowContainer" class="headerlink" title="RowContainer"></a>RowContainer</h1><p><code>RowContainer</code>是velox用于存储行数据的数据结构，当前用于<code>agg</code>、<code>hash join</code>、<code>orderby</code>三种场景。<br>其内存占用分为 定长部分 + 变长部分。<br>定长部分：total(sizeof(columnTypeKind)) + flag + 变长数据长度（若存在），由<code>`memory::AllocationPool</code>管理。<br>变长部分：变长数据，由<code>HashStringAllocator</code>管理。</p>
<p>相关源码位置：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">velox/exec/RowContainer.h</span><br><span class="line">velox/exec/RowContainer.cpp</span><br></pre></td></tr></table></figure></p>
<h1 id="Ctor"><a href="#Ctor" class="headerlink" title="Ctor"></a>Ctor</h1><p>在<code>SortBuffer</code>中，<code>RowContainer</code>的构造函数调用如下：<br>也就是只需要传入<code>keyTypes</code>，<code>dependentTypes</code>，<code>pool</code>三个参数即可。<br>其中<code>keyTypes</code>是key列（用于排序的列）类型，<code>dependentTypes</code>是非排序列类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RowContainer(</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt;&amp; keyTypes,</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt;&amp; dependentTypes,</span><br><span class="line">      memory::MemoryPool* pool)</span><br><span class="line">      : RowContainer(</span><br><span class="line">            keyTypes,</span><br><span class="line">            <span class="literal">true</span>, <span class="comment">// nullableKeys，列数据是否支持null</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Accumulator&gt;&#123;&#125;,</span><br><span class="line">            dependentTypes,</span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// hasNext</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// isJoinBuild</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// hasProbedFlag</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// hasNormalizedKey</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// collectColumnStats</span></span><br><span class="line">            pool) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>精简版构造函数与所需要关注的数据结构如下(去除了<code>agg</code>、<code>hash join</code>相关的部分)：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RowContainer::RowContainer(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt;&amp; keyTypes,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt;&amp; dependentTypes,</span><br><span class="line">    memory::MemoryPool* pool)</span><br><span class="line">    : keyTypes_(keyTypes),</span><br><span class="line">      stringAllocator_(<span class="built_in">std</span>::make_unique&lt;HashStringAllocator&gt;(pool)),</span><br><span class="line">      rows_(pool) &#123;</span><br><span class="line">  <span class="keyword">int32_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int32_t</span> nullOffset = <span class="number">0</span>; <span class="comment">// bit维度</span></span><br><span class="line">  <span class="keyword">bool</span> isVariableWidth = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; type : keyTypes_) &#123; <span class="comment">// 排序列排在前面，对缓存友好</span></span><br><span class="line">    typeKinds_.push_back(type-&gt;kind());</span><br><span class="line">    types_.push_back(type);</span><br><span class="line">    offsets_.push_back(offset);</span><br><span class="line">    offset += typeKindSize(type-&gt;kind());</span><br><span class="line">    nullOffsets_.push_back(nullOffset); <span class="comment">// bit维度</span></span><br><span class="line">    isVariableWidth |= !type-&gt;isFixedWidth(); <span class="comment">// 当前行是否存在可变长字段</span></span><br><span class="line">    ++nullOffset;</span><br><span class="line">    columnHasNulls_.push_back(<span class="literal">false</span>); <span class="comment">// 某一列是否存在null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已记录完所有key列offset，修正offset，使其至少和一个指针大小相等</span></span><br><span class="line">  offset = <span class="built_in">std</span>::max&lt;<span class="keyword">int32_t</span>&gt;(offset, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int32_t</span> firstAggregateOffset = offset;<span class="comment">// 此offset紧贴key列最后一个数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; type : dependentTypes) &#123;</span><br><span class="line">    types_.push_back(type);</span><br><span class="line">    typeKinds_.push_back(type-&gt;kind());</span><br><span class="line">    nullOffsets_.push_back(nullOffset);</span><br><span class="line">    ++nullOffset;</span><br><span class="line">    isVariableWidth |= !type-&gt;isFixedWidth();</span><br><span class="line">    columnHasNulls_.push_back(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Free flag.</span></span><br><span class="line">  nullOffsets_.push_back(nullOffset); <span class="comment">// free flag offset，表示这一行是否已被删除</span></span><br><span class="line">  freeFlagOffset_ = nullOffset + firstAggregateOffset * <span class="number">8</span>; <span class="comment">// 修正为bit维度</span></span><br><span class="line">  ++nullOffset;</span><br><span class="line">  flagBytes_ = bits::nbytes(nullOffsets_.back() + <span class="number">1</span>); <span class="comment">// flag占据了多少个字节，对于orderby来说，就是(列数 + 1(free flag))/8向上取整</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; nullOffsets_.size(); ++i) &#123; <span class="comment">// 修正flag offset为bit维度</span></span><br><span class="line">    nullOffsets_[i] += firstAggregateOffset * <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  offset += flagBytes_; <span class="comment">// 将flag占据的字节加入offset，由此看出，flag贴在key列后面</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; type : dependentTypes) &#123; <span class="comment">// 追加dependent offset</span></span><br><span class="line">    offsets_.push_back(offset);</span><br><span class="line">    offset += typeKindSize(type-&gt;kind());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isVariableWidth) &#123; <span class="comment">// 若当前行中存在可变长字段</span></span><br><span class="line">    rowSizeOffset_ = offset; <span class="comment">// 当前行总变长数据长度offset</span></span><br><span class="line">    offset += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>); <span class="comment">// 用于存储变长数据长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  fixedRowSize_ = bits::roundUp(offset, alignment_); <span class="comment">// 对齐之后的行长度， 默认按1对齐，最终将按此值申请行内存</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; offsets_.size(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 将data offset和null offset绑定，编码为一个uint64_t, 用于快速访问</span></span><br><span class="line">    <span class="comment">// 其中高32位为data offset，低32位为null offset</span></span><br><span class="line">    rowColumns_.emplace_back( </span><br><span class="line">        offsets_[i],</span><br><span class="line">        (nullableKeys_ || i &gt;= keyTypes_.size()) ? nullOffsets_[i]</span><br><span class="line">                                                 : RowColumn::kNotNullOffset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><p>根据上述构造函数，用于<code>orderby</code>的<code>RowContainer</code>的layout大致如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[key1][key2]...[keyN][padding](if needed)[flag][dependent1][dependent2]...[dependentN][variable length data](if needed)</span><br></pre></td></tr></table></figure></p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>假设当前行结构如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">key1: INT(4 bytes)</span><br><span class="line">dependent1: BIGINT(8 bytes)</span><br><span class="line">dependent2: SMALL(2 bytes)</span><br><span class="line">dependent3: REAL(4 bytes)</span><br><span class="line">dependent4: DOUBLE(8 bytes)</span><br><span class="line">dependent5: VARCHAR(16 bytes)</span><br></pre></td></tr></table></figure></p>
<p>则有offsets数组如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">offsets_: [0, 9, 17, 19, 23, 31]</span><br><span class="line">nullOffsets_: [64, 65, 66, 67, 68, 69, 70]</span><br></pre></td></tr></table></figure></p>
<p>数据布局图大致如下：<br><img src="/images/RowContainer-memory-layout.jpg" alt="RowContainer-layout"></p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="newRow"><a href="#newRow" class="headerlink" title="newRow"></a>newRow</h2><p>获取新行内存，返回一个<code>char*</code>指针，指向新行的内存地址。<br>此api未必触发内存分配与获取，可能会返回已删除的行 内存地址（即每一次erase并不真正释放内存）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">RowContainer::newRow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ++numRows_; <span class="comment">// 更新当前行计数</span></span><br><span class="line">  <span class="keyword">char</span>* row;</span><br><span class="line">  <span class="keyword">if</span> (firstFreeRow_) &#123; <span class="comment">// free list链表，orderby中用不到，但正好展示一下free flag的作用</span></span><br><span class="line">    row = firstFreeRow_;</span><br><span class="line">    VELOX_CHECK(bits::isBitSet(row, freeFlagOffset_)); <span class="comment">// 判断free flag是否为1</span></span><br><span class="line">    firstFreeRow_ = nextFree(row);</span><br><span class="line">    --numFreeRows_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    row = rows_.allocateFixed(fixedRowSize_, alignment_); <span class="comment">// 申请新行内存，fixedRowSize_为对齐后的行长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initializeRow(row, <span class="literal">false</span> <span class="comment">/* reuse */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="initializeRow"><a href="#initializeRow" class="headerlink" title="initializeRow"></a>initializeRow</h2><p>初始化行数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">RowContainer::initializeRow</span><span class="params">(<span class="keyword">char</span>* row)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rowSizeOffset_ != <span class="number">0</span>) &#123; <span class="comment">// 当前行存在定长字段</span></span><br><span class="line">    ::<span class="built_in">memset</span>(row, <span class="number">0</span>, fixedRowSize_); <span class="comment">// 将整行全部置为0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (rowSizeOffset_) &#123; <span class="comment">// 将变长部分初始化为0，疑似不需要这段逻辑？</span></span><br><span class="line">    variableRowSize(row) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  bits::clearBit(row, freeFlagOffset_); <span class="comment">// 将free flag置为0</span></span><br><span class="line">  <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>将列数据存储数据到行中。</p>
<p>调用方式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SelectivityVector <span class="title">allRows</span><span class="params">(input-&gt;size())</span></span>; <span class="comment">// 这里使用只是为了适配store api</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; <span class="title">rows</span><span class="params">(input-&gt;size())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; input-&gt;size(); ++row) &#123;</span><br><span class="line">  rows[row] = data_-&gt;newRow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span>* inputRow = input-&gt;as&lt;RowVector&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; columnProjection : columnMap_) &#123; <span class="comment">// columnMap_存储有列转行时的映射关系，因为行存储时key列排在前面</span></span><br><span class="line">  <span class="function">DecodedVector <span class="title">decoded</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      *inputRow-&gt;childAt(columnProjection.outputChannel), allRows)</span></span>;</span><br><span class="line">  data_-&gt;store(</span><br><span class="line">      decoded,</span><br><span class="line">      folly::Range(rows.data(), input-&gt;size()),</span><br><span class="line">      columnProjection.inputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口实现：<br>将<code>decoded</code>中的前<code>rows.size</code>个值存储到<code>rows</code>的<code>columnIndex</code>列中。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RowContainer::store</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> DecodedVector&amp; decoded,</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::Range&lt;<span class="keyword">char</span>**&gt; rows,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> column)</span> </span>&#123;</span><br><span class="line">  VELOX_CHECK_GE(decoded.size(), rows.size());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> isKey = column &lt; keyTypes_.size();</span><br><span class="line">  <span class="keyword">if</span> ((isKey &amp;&amp; !nullableKeys_) || !decoded.mayHaveNulls()) &#123;</span><br><span class="line">    VELOX_DYNAMIC_TYPE_DISPATCH( <span class="comment">// 无需关注null</span></span><br><span class="line">        storeNoNullsBatch,</span><br><span class="line">        typeKinds_[column],</span><br><span class="line">        decoded,</span><br><span class="line">        rows,</span><br><span class="line">        isKey,</span><br><span class="line">        offsets_[column]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> rowColumn = rowColumns_[column];</span><br><span class="line">    VELOX_DYNAMIC_TYPE_DISPATCH_ALL(</span><br><span class="line">        storeWithNullsBatch,</span><br><span class="line">        typeKinds_[column],</span><br><span class="line">        decoded,</span><br><span class="line">        rows,</span><br><span class="line">        isKey,</span><br><span class="line">        rowColumn.offset(),</span><br><span class="line">        rowColumn.nullByte(),</span><br><span class="line">        rowColumn.nullMask(),</span><br><span class="line">        column);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>宏展开后大致如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VELOX_DYNAMIC_TYPE_DISPATCH(TEMPLATE_FUNC, typeKind, ...) \</span></span><br><span class="line">  VELOX_DYNAMIC_TYPE_DISPATCH_IMPL(TEMPLATE_FUNC, , typeKind, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">[&amp;]() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (typeKinds_[column]) &#123;</span><br><span class="line">    <span class="keyword">case</span> ::facebook::velox::TypeKind::BOOLEAN: &#123;</span><br><span class="line">      <span class="keyword">return</span> storeNoNullsBatch&lt;::facebook::velox::TypeKind::BOOLEAN&gt;(</span><br><span class="line">          decoded, rows, isKey, offsets_[column]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ::facebook::velox::TypeKind::INTEGER: &#123;</span><br><span class="line">      <span class="keyword">return</span> storeNoNullsBatch&lt;::facebook::velox::TypeKind::INTEGER&gt;(</span><br><span class="line">          decoded, rows, isKey, offsets_[column]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ::facebook::velox::TypeKind::TINYINT: &#123;</span><br><span class="line">      <span class="keyword">return</span> storeNoNullsBatch&lt;::facebook::velox::TypeKind::TINYINT&gt;(</span><br><span class="line">          decoded, rows, isKey, offsets_[column]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VELOX_DYNAMIC_TYPE_DISPATCH_ALL(TEMPLATE_FUNC, typeKind, ...)          \</span></span><br><span class="line">  [&amp;]() &#123;                                                                      \</span><br><span class="line">    <span class="keyword">if</span> ((typeKind) == ::facebook::velox::TypeKind::UNKNOWN) &#123;                  \</span><br><span class="line">      <span class="keyword">return</span> TEMPLATE_FUNC&lt;::facebook::velox::TypeKind::UNKNOWN&gt;(__VA_ARGS__); \</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((typeKind) == ::facebook::velox::TypeKind::OPAQUE) &#123;            \</span><br><span class="line">      <span class="keyword">return</span> TEMPLATE_FUNC&lt;::facebook::velox::TypeKind::OPAQUE&gt;(__VA_ARGS__);  \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span><br><span class="line">      <span class="keyword">return</span> VELOX_DYNAMIC_TYPE_DISPATCH_IMPL(                                 \</span><br><span class="line">          TEMPLATE_FUNC, , typeKind, __VA_ARGS__);                             \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[&amp;]() &#123;</span><br><span class="line">  <span class="keyword">if</span> ((typeKinds_[columnIndex]) == ::facebook::velox::TypeKind::UNKNOWN) &#123;</span><br><span class="line">    <span class="keyword">return</span> storeNoNullsBatch&lt;::facebook::velox::TypeKind::UNKNOWN&gt;(</span><br><span class="line">        decoded,</span><br><span class="line">        rowIndex,</span><br><span class="line">        isKey,</span><br><span class="line">        row,</span><br><span class="line">        rowColumn.offset(),</span><br><span class="line">        rowColumn.nullByte(),</span><br><span class="line">        rowColumn.nullMask(),</span><br><span class="line">        columnIndex);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((typeKinds_[columnIndex]) == ::facebook::velox::TypeKind::OPAQUE) &#123;</span><br><span class="line">    <span class="keyword">return</span> storeNoNullsBatch&lt;::facebook::velox::TypeKind::OPAQUE&gt;(</span><br><span class="line">        decoded,</span><br><span class="line">        rowIndex,</span><br><span class="line">        isKey,</span><br><span class="line">        row,</span><br><span class="line">        rowColumn.offset(),</span><br><span class="line">        rowColumn.nullByte(),</span><br><span class="line">        rowColumn.nullMask(),</span><br><span class="line">        columnIndex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;]() &#123;</span><br><span class="line">      <span class="keyword">switch</span> (typeKinds_[columnIndex]) &#123;</span><br><span class="line">        <span class="keyword">case</span> ::facebook::velox::TypeKind::BOOLEAN: &#123;</span><br><span class="line">          <span class="keyword">return</span> storeNoNullsBatch&lt;::facebook::velox::TypeKind::BOOLEAN&gt;(</span><br><span class="line">              decoded,</span><br><span class="line">              rowIndex,</span><br><span class="line">              isKey,</span><br><span class="line">              row,</span><br><span class="line">              rowColumn.offset(),</span><br><span class="line">              rowColumn.nullByte(),</span><br><span class="line">              rowColumn.nullMask(),</span><br><span class="line">              columnIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ::facebook::velox::TypeKind::INTEGER: &#123;</span><br><span class="line">          <span class="keyword">return</span> storeNoNullsBatch&lt;::facebook::velox::TypeKind::INTEGER&gt;(</span><br><span class="line">              decoded,</span><br><span class="line">              rowIndex,</span><br><span class="line">              isKey,</span><br><span class="line">              row,</span><br><span class="line">              rowColumn.offset(),</span><br><span class="line">              rowColumn.nullByte(),</span><br><span class="line">              rowColumn.nullMask(),</span><br><span class="line">              columnIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>storeNoNullsBatch</code>有实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 即对每一行的第columnIndex列调用storeNoNulls</span></span><br><span class="line"><span class="keyword">template</span> &lt;TypeKind Kind&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">storeNoNullsBatch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> DecodedVector&amp; decoded,</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::Range&lt;<span class="keyword">char</span>**&gt; rows,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> isKey,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; rows.size(); ++i) &#123;</span><br><span class="line">    storeNoNulls&lt;Kind&gt;(decoded, i, isKey, rows[i], offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>storeNoNulls</code>实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;TypeKind Kind&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">storeNoNulls</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> DecodedVector&amp; decoded,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">vector_size_t</span> rowIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> isKey,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span>* row,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> T = <span class="keyword">typename</span> TypeTraits&lt;Kind&gt;::NativeType;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_same_v&lt;T, StringView&gt;)</span> </span>&#123; <span class="comment">// 针对变长数据，需要记录行变长数据总长度</span></span><br><span class="line">    <span class="function">RowSizeTracker <span class="title">tracker</span><span class="params">(row[rowSizeOffset_], *stringAllocator_)</span></span>;</span><br><span class="line">    stringAllocator_-&gt;copyMultipart(</span><br><span class="line">        decoded.valueAt&lt;T&gt;(rowIndex), row, offset); <span class="comment">// copy和存储stringview</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(row + offset) = decoded.valueAt&lt;T&gt;(rowIndex); <span class="comment">// 定长数据直接拷贝至对应位置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="listRows"><a href="#listRows" class="headerlink" title="listRows"></a>listRows</h2><p>提取各行地址至指定位置。</p>
<p>调用方式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sortedRows_.resize(numInputRows_);</span><br><span class="line">RowContainerIterator iter; <span class="comment">// 适配接口</span></span><br><span class="line">data_-&gt;listRows(&amp;iter, numInputRows_, sortedRows_.data());</span><br></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从iter位置开始，提取 maxRows行数据 &amp;&amp; 提取maxBytes字节数据 至 rows</span></span><br><span class="line"><span class="comment">// 返回实际提取行数</span></span><br><span class="line"><span class="comment">// 对于默认构造的迭代器，从头开始提取</span></span><br><span class="line"><span class="comment">// 并不执行实际的数据拷贝，只是将包含了 maxRows || maxBytes 行的行地址存储到rows中</span></span><br><span class="line">  <span class="function"><span class="keyword">int32_t</span> <span class="title">listRows</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      RowContainerIterator* iter,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int32_t</span> maxRows,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">uint64_t</span> maxBytes,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">char</span>** rows)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listRows&lt;ProbeType::kAll&gt;(iter, maxRows, maxBytes, rows);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int32_t</span> <span class="title">listRows</span><span class="params">(RowContainerIterator* iter, <span class="keyword">int32_t</span> maxRows, <span class="keyword">char</span>** rows)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> listRows&lt;ProbeType::kAll&gt;(iter, maxRows, kUnlimited, rows);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int32_t</span></span><br><span class="line">  listRows(</span><br><span class="line">      RowContainerIterator* iter,</span><br><span class="line">      <span class="keyword">int32_t</span> maxRows,</span><br><span class="line">      <span class="keyword">uint64_t</span> maxBytes,</span><br><span class="line">      <span class="keyword">char</span>** rows) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> totalBytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> numAllocations = rows_.numRanges();</span><br><span class="line">    <span class="keyword">int32_t</span> rowSize = fixedRowSize_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = iter-&gt;allocationIndex; i &lt; numAllocations; ++i) &#123;</span><br><span class="line">      <span class="keyword">auto</span> range = rows_.rangeAt(i);</span><br><span class="line">      <span class="keyword">auto</span>* data =</span><br><span class="line">          range.data() + memory::alignmentPadding(range.data(), alignment_);</span><br><span class="line">      <span class="keyword">auto</span> limit = range.size() -</span><br><span class="line">          (<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(data) -</span><br><span class="line">           <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(range.data()));</span><br><span class="line">      <span class="keyword">auto</span> row = iter-&gt;rowOffset;</span><br><span class="line">      <span class="keyword">while</span> (row + rowSize &lt;= limit) &#123; <span class="comment">// limit是当前内存块的有效范围，这里也能看出来行数据在内存中是连续存储的</span></span><br><span class="line">        rows[count++] = data + row; <span class="comment">// 存储当前行地址至rows（输出）</span></span><br><span class="line">        VELOX_DCHECK_EQ(</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(rows[count - <span class="number">1</span>]) % alignment_, <span class="number">0</span>);</span><br><span class="line">        row += rowSize;</span><br><span class="line">        <span class="keyword">auto</span> newTotalBytes = totalBytes + rowSize;</span><br><span class="line">        <span class="keyword">if</span> (bits::isBitSet(rows[count - <span class="number">1</span>], freeFlagOffset_)) &#123; <span class="comment">// 当前为已释放的行，跳过，--count保证了下次覆盖写入</span></span><br><span class="line">          --count;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        totalBytes = newTotalBytes;</span><br><span class="line">        <span class="keyword">if</span> (rowSizeOffset_) &#123; <span class="comment">// 添加变长数据的大小</span></span><br><span class="line">          totalBytes += variableRowSize(rows[count - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == maxRows || totalBytes &gt; maxBytes) &#123; <span class="comment">// 如果达到 maxRows 或 maxBytes 的限制，更新迭代器状态并返回</span></span><br><span class="line">          iter-&gt;rowOffset = row;</span><br><span class="line">          iter-&gt;allocationIndex = i;</span><br><span class="line">          <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      iter-&gt;rowOffset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iter-&gt;allocationIndex = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int32_t</span>&gt;::max(); <span class="comment">// 遍历了所有内存块，设置迭代器状态</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="extractColumn"><a href="#extractColumn" class="headerlink" title="extractColumn"></a>extractColumn</h1><p>将行数据按列提取，执行真正的数据拷贝。</p>
<p>调用方式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; columnProjection : columnMap_) &#123;</span><br><span class="line">    data_-&gt;extractColumn(</span><br><span class="line">        sortedRows_.data() + numOutputRows_, <span class="comment">// 当前已输出的行数</span></span><br><span class="line">        output_-&gt;size(),</span><br><span class="line">        columnProjection.inputChannel,</span><br><span class="line">        output_-&gt;childAt(columnProjection.outputChannel));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>声明：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 columnIndex 所对应列的值从 rows 中的每一行复制到 result 中。</span></span><br><span class="line"><span class="comment">// 若行中数据为null，则 result 中对应数据也为null。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extractColumn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rows,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> numRows,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> columnIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> VectorPtr&amp; result)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  extractColumn(</span><br><span class="line">      rows,</span><br><span class="line">      numRows,</span><br><span class="line">      columnAt(columnIndex),</span><br><span class="line">      columnHasNulls(columnIndex),</span><br><span class="line">      result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractColumn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rows,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> numRows,</span></span></span><br><span class="line"><span class="function"><span class="params">    RowColumn col,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> columnHasNulls,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> VectorPtr&amp; result)</span> </span>&#123;</span><br><span class="line">  extractColumn(rows, numRows, col, columnHasNulls, <span class="number">0</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">RowContainer::extractColumn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rows,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int32_t</span> numRows,</span></span></span><br><span class="line"><span class="function"><span class="params">  RowColumn column,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">bool</span> columnHasNulls,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int32_t</span> resultOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> VectorPtr&amp; result)</span> </span>&#123;</span><br><span class="line">VELOX_DYNAMIC_TYPE_DISPATCH_ALL(</span><br><span class="line">    extractColumnTyped,</span><br><span class="line">    result-&gt;typeKind(),</span><br><span class="line">    rows,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    numRows,</span><br><span class="line">    column,</span><br><span class="line">    columnHasNulls,</span><br><span class="line">    resultOffset,</span><br><span class="line">    result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基本上可以看做是store的逆操作。<br><code>extractColumn</code>执行宏展开后，大致如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VELOX_DYNAMIC_TYPE_DISPATCH_ALL(TEMPLATE_FUNC, typeKind, ...)          \</span></span><br><span class="line">  [&amp;]() &#123;                                                                      \</span><br><span class="line">    <span class="keyword">if</span> ((typeKind) == ::facebook::velox::TypeKind::UNKNOWN) &#123;                  \</span><br><span class="line">      <span class="keyword">return</span> TEMPLATE_FUNC&lt;::facebook::velox::TypeKind::UNKNOWN&gt;(__VA_ARGS__); \</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((typeKind) == ::facebook::velox::TypeKind::OPAQUE) &#123;            \</span><br><span class="line">      <span class="keyword">return</span> TEMPLATE_FUNC&lt;::facebook::velox::TypeKind::OPAQUE&gt;(__VA_ARGS__);  \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span><br><span class="line">      <span class="keyword">return</span> VELOX_DYNAMIC_TYPE_DISPATCH_IMPL(                                 \</span><br><span class="line">          TEMPLATE_FUNC, , typeKind, __VA_ARGS__);                             \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">  &#125;()</span><br><span class="line">[&amp;]() &#123;</span><br><span class="line">  <span class="keyword">if</span> ((result-&gt;typeKind()) == ::facebook::velox::TypeKind::UNKNOWN) &#123;</span><br><span class="line">    <span class="keyword">return</span> extractColumnTyped&lt;::facebook::velox::TypeKind::UNKNOWN&gt;(</span><br><span class="line">        rows,</span><br><span class="line">        rowNumbers,</span><br><span class="line">        rowNumbers.size(),</span><br><span class="line">        column,</span><br><span class="line">        columnHasNulls,</span><br><span class="line">        resultOffset,</span><br><span class="line">        result);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((result-&gt;typeKind()) == ::facebook::velox::TypeKind::OPAQUE) &#123;</span><br><span class="line">    <span class="keyword">return</span> extractColumnTyped&lt;::facebook::velox::TypeKind::OPAQUE&gt;(</span><br><span class="line">        rows,</span><br><span class="line">        rowNumbers,</span><br><span class="line">        rowNumbers.size(),</span><br><span class="line">        column,</span><br><span class="line">        columnHasNulls,</span><br><span class="line">        resultOffset,</span><br><span class="line">        result);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;]() &#123;</span><br><span class="line">      <span class="keyword">switch</span> (result-&gt;typeKind()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ::facebook::velox::TypeKind::BOOLEAN: &#123;</span><br><span class="line">          <span class="keyword">return</span> extractColumnTyped&lt;::facebook::velox::TypeKind::BOOLEAN&gt;(</span><br><span class="line">              rows,</span><br><span class="line">              rowNumbers,</span><br><span class="line">              rowNumbers.size(),</span><br><span class="line">              column,</span><br><span class="line">              columnHasNulls,</span><br><span class="line">              resultOffset,</span><br><span class="line">              result);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;TypeKind Kind&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractColumnTyped</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rows,</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::Range&lt;<span class="keyword">const</span> <span class="keyword">vector_size_t</span>*&gt; rowNumbers,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int32_t</span> numRows,</span></span></span><br><span class="line"><span class="function"><span class="params">      RowColumn column,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">bool</span> columnHasNulls,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int32_t</span> resultOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> VectorPtr&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rowNumbers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      extractColumnTypedInternal&lt;<span class="literal">true</span>, Kind&gt;(</span><br><span class="line">          rows,</span><br><span class="line">          rowNumbers,</span><br><span class="line">          rowNumbers.size(),</span><br><span class="line">          column,</span><br><span class="line">          columnHasNulls,</span><br><span class="line">          resultOffset,</span><br><span class="line">          result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      extractColumnTypedInternal&lt;<span class="literal">false</span>, Kind&gt;(</span><br><span class="line">          rows,</span><br><span class="line">          rowNumbers,</span><br><span class="line">          numRows,</span><br><span class="line">          column,</span><br><span class="line">          columnHasNulls,</span><br><span class="line">          resultOffset,</span><br><span class="line">          result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> useRowNumbers, TypeKind Kind&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractColumnTypedInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rows,</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::Range&lt;<span class="keyword">const</span> <span class="keyword">vector_size_t</span>*&gt; rowNumbers,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int32_t</span> numRows,</span></span></span><br><span class="line"><span class="function"><span class="params">      RowColumn column,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">bool</span> columnHasNulls,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int32_t</span> resultOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> VectorPtr&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Resize the result vector before all copies.</span></span><br><span class="line">    result-&gt;resize(numRows + resultOffset);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Kind == TypeKind::ROW || Kind == TypeKind::ARRAY ||</span></span></span><br><span class="line"><span class="function"><span class="params">        Kind == TypeKind::MAP)</span> </span>&#123;</span><br><span class="line">      extractComplexType&lt;useRowNumbers&gt;(</span><br><span class="line">          rows, rowNumbers, numRows, column, resultOffset, result);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">typename</span> KindToFlatVector&lt;Kind&gt;::HashRowType;</span><br><span class="line">    <span class="keyword">auto</span>* flatResult = result-&gt;as&lt;FlatVector&lt;T&gt;&gt;();</span><br><span class="line">    <span class="keyword">auto</span> nullMask = column.nullMask();</span><br><span class="line">    <span class="keyword">auto</span> offset = column.offset();</span><br><span class="line">    <span class="keyword">if</span> (!nullMask || !columnHasNulls) &#123;</span><br><span class="line">      extractValuesNoNulls&lt;useRowNumbers, T&gt;(</span><br><span class="line">          rows, rowNumbers, numRows, offset, resultOffset, flatResult);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      extractValuesWithNulls&lt;useRowNumbers, T&gt;(</span><br><span class="line">          rows,</span><br><span class="line">          rowNumbers,</span><br><span class="line">          numRows,</span><br><span class="line">          offset,</span><br><span class="line">          column.nullByte(),</span><br><span class="line">          nullMask,</span><br><span class="line">          resultOffset,</span><br><span class="line">          flatResult);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">bool</span> useRowNumbers, <span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractValuesNoNulls</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rows,</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::Range&lt;<span class="keyword">const</span> <span class="keyword">vector_size_t</span>*&gt; rowNumbers,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int32_t</span> numRows,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int32_t</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int32_t</span> resultOffset, <span class="comment">// 从第resultOffset列开始copy</span></span></span></span><br><span class="line"><span class="function"><span class="params">      FlatVector&lt;T&gt;* result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> maxRows = numRows + resultOffset;</span><br><span class="line">    VELOX_DCHECK_LE(maxRows, result-&gt;size());</span><br><span class="line">    BufferPtr valuesBuffer = result-&gt;mutableValues(maxRows);</span><br><span class="line">    [[maybe_unused]] <span class="keyword">auto</span> values = valuesBuffer-&gt;asMutableRange&lt;T&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* row; <span class="comment">// 当前行地址</span></span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(useRowNumbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rowNumber = rowNumbers[i];</span><br><span class="line">        row = rowNumber &gt;= <span class="number">0</span> ? rows[rowNumber] : <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        row = rows[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> resultIndex = resultOffset + i;</span><br><span class="line">      <span class="keyword">if</span> (row == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        result-&gt;setNull(resultIndex, <span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;setNull(resultIndex, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_same_v&lt;T, StringView&gt;)</span> </span>&#123;</span><br><span class="line">          extractString(valueAt&lt;StringView&gt;(row, offset), result, resultIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          values[resultIndex] = valueAt&lt;T&gt;(row, offset);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="estimateRowSize"><a href="#estimateRowSize" class="headerlink" title="estimateRowSize"></a>estimateRowSize</h1><p>预估值，用于指示每行大致占用了多少内存。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::optional&lt;<span class="keyword">int64_t</span>&gt; <span class="title">RowContainer::estimateRowSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (numRows_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::nullopt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int64_t</span> freeBytes = rows_.freeBytes() + fixedRowSize_ * numFreeRows_; <span class="comment">// free: 当前内存池空闲大小 + 已删除行占用的内存</span></span><br><span class="line">  <span class="keyword">int64_t</span> usedSize = rows_.allocatedBytes() - freeBytes +</span><br><span class="line">      stringAllocator_-&gt;retainedSize() - stringAllocator_-&gt;freeSpace(); <span class="comment">// used: 内存池分配大小 - 空闲大小 + (string allocator分配大小 - 空闲大小)(变长数据占用)</span></span><br><span class="line">  <span class="keyword">int64_t</span> rowSize = usedSize / numRows_; <span class="comment">// 估算得到一行平均需要占用多大字节</span></span><br><span class="line">  VELOX_CHECK_GT(</span><br><span class="line">      rowSize, <span class="number">0</span>, <span class="string">"Estimated row size of the RowContainer must be positive."</span>);</span><br><span class="line">  <span class="keyword">return</span> rowSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="freespace"><a href="#freespace" class="headerlink" title="freespace"></a>freespace</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回在不扩容的前提下，当前rowContainer还能存储</span></span><br><span class="line"><span class="comment">// 多少行数据 + 变长区内存池还能存储多少字节</span></span><br><span class="line">std::pair&lt;uint64_t, uint64_t&gt; freeSpace() const &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair&lt;<span class="keyword">uint64_t</span>, <span class="keyword">uint64_t</span>&gt;(</span><br><span class="line">      rows_.freeBytes() / fixedRowSize_ + numFreeRows_, <span class="comment">// 内存池剩余容量/行长度 + 已删除行数</span></span><br><span class="line">      stringAllocator_-&gt;freeSpace());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sizeIncrement"><a href="#sizeIncrement" class="headerlink" title="sizeIncrement"></a>sizeIncrement</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若当前需要追加存储N行 + 变长区还需要M字节，需要多少内存</span></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">RowContainer::sizeIncrement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">vector_size_t</span> numRows,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int64_t</span> variableLengthBytes)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Small containers can grow in smaller units but for spilling the practical</span></span><br><span class="line">  <span class="comment">// minimum increment is a huge page.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int32_t</span> kAllocUnit = memory::AllocationTraits::kHugePageSize;</span><br><span class="line">  <span class="keyword">int32_t</span> needRows = <span class="built_in">std</span>::max&lt;<span class="keyword">int64_t</span>&gt;(<span class="number">0</span>, numRows - numFreeRows_); <span class="comment">// 已删除的行内容可被复用</span></span><br><span class="line">  <span class="keyword">int64_t</span> needBytes =</span><br><span class="line">      <span class="built_in">std</span>::max&lt;<span class="keyword">int64_t</span>&gt;(<span class="number">0</span>, variableLengthBytes - stringAllocator_-&gt;freeSpace()); <span class="comment">// 变长区还需要扩容的大小</span></span><br><span class="line">  <span class="keyword">return</span> bits::roundUp(needRows * fixedRowSize_, kAllocUnit) +</span><br><span class="line">      bits::roundUp(needBytes, kAllocUnit); <span class="comment">// 若不足2MB（大页），按大页取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>velox</category>
      </categories>
      <tags>
        <tag>velox container</tag>
        <tag>RowContainer</tag>
      </tags>
  </entry>
  <entry>
    <title>34.了解算法对容器的要求</title>
    <url>/2018/04/16/%E4%BA%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>并非所有算法都可以用于任意区间。如果你违背了算法要求，编译器会提供给你一个复杂且难以理解的报错信息。</p>
<hr>
<h1 id="有序区间算法"><a href="#有序区间算法" class="headerlink" title="有序区间算法"></a>有序区间算法</h1><p>&nbsp;<br>以下算法只能作用于有序区间:</p>
<ul>
<li>binary_serach</li>
<li>lower_bound  upper_bound equal_range</li>
<li>set_union    set_intersection    set_difference  seT_symmetric_difference</li>
<li>merge    inplace_merge</li>
<li>includes</li>
</ul>
<p>另外，<code>unique</code>与<code>unique_copy</code>一般作用于有序区间，虽然它们对此不作要求。</p>
<h2 id="为何需要有序区间"><a href="#为何需要有序区间" class="headerlink" title="为何需要有序区间"></a>为何需要有序区间</h2><p>（建议阅读数据结构·向量篇，其练习几乎解答了下述所有问题）</p>
<ul>
<li>binary_search，lower_bound，upper_bound以及equal_range<br>上述算法均基于二分查找，因此必须提供有序区间。<br>其具体效率实际上取决于迭代器。如果不支持随机访问，其效率会由对数时间退化至线性时间。</li>
<li>set_union，set_intersection，set_difference，set_symmetric_difference<br>如果不提供有序区间，则它们无法在线性时间内完成工作。</li>
<li>merge与inplace_merge<br>提供了单遍合并排序。</li>
<li>includes<br>检测是否一个区间的所有对象也在另一个区间中，有序保证了其线性时间的效率</li>
<li>unique<br>其功能是去重，但为了保证元素值唯一，你必须保证这些相似的元素一个接着一个，这也就是排序的一种弱化形式。（22211333）</li>
</ul>
<hr>
<h1 id="确保算法的排序方式与容器的排序方式相同"><a href="#确保算法的排序方式与容器的排序方式相同" class="headerlink" title="确保算法的排序方式与容器的排序方式相同"></a>确保算法的排序方式与容器的排序方式相同</h1><h2 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//降序排列</span></span><br><span class="line"><span class="keyword">bool</span> a5Exists = binary_search(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//binary_search默认升序排列</span></span><br></pre></td></tr></table></figure>
<p>这段代码将直接导致未定义行为。</p>
<h2 id="正确使用方式"><a href="#正确使用方式" class="headerlink" title="正确使用方式"></a>正确使用方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> a5Exists =binary_search(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5.</span> greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="判同验证"><a href="#判同验证" class="headerlink" title="判同验证"></a>判同验证</h1><p>&nbsp;<br><strong>所有需要有序区间的算法通过等价来判断两个值是否相同，类似于关联容器。unique系列通过相等来判断。</strong></p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>21.令比较函数在等值情况下返回false（严格弱序化）</title>
    <url>/2018/04/12/%E4%BB%A4%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E5%9C%A8%E7%AD%89%E5%80%BC%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%94%E5%9B%9Efalse%EF%BC%88%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E5%8C%96%EF%BC%89/</url>
    <content><![CDATA[<h1 id="set崩坏惨案"><a href="#set崩坏惨案" class="headerlink" title="set崩坏惨案"></a>set崩坏惨案</h1><p>&lt;/br&gt;<br>假设存在一个set:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,less_equal&lt;<span class="keyword">int</span>&gt; &gt; s;<span class="comment">//以&lt;=排序</span></span><br><span class="line">s.insert(<span class="number">10</span>);</span><br><span class="line">s.insert(<span class="number">10</span>);<span class="comment">//再次试图插入</span></span><br></pre></td></tr></table></figure><br>显然我们在调用第二次insert之前，set必须判断10在不在里面。我们把首先插入的10记作10<sub>A</sub>，将后来想要插入的10记作10<sub>B</sub>.<br>set首先遍历自己找出在哪儿适合插入10<sub>B</sub>，并且最终比较10<sub>B</sub>与10<sub>A</sub>是否相同（基于等价的相同）。前文已经描述过，关联容器在判断相同时使用的是如下表达式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">!c.key_comp()(x, y) &amp;&amp; !c.key_comp()(y, x);</span><br></pre></td></tr></table></figure><br>那么针对本例中的set,有<code>相同判断式</code>（此式与<code>比较函数</code>并不相同，不要混淆）如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">!(<span class="number">10</span>A &lt;= <span class="number">10B</span>) &amp;&amp; !(<span class="number">10B</span> &lt;= <span class="number">10</span>A)</span><br></pre></td></tr></table></figure><br>显然<code>false&amp;&amp;false</code>是<code>false</code>，所以set认为10<sub>A</sub>与10<sub>B</sub>不相同，于是set里面有了两个10.(夭寿啦）。通过使用less_equal作为比较器，我们成功地破坏了set。（在实测中，编译器会在运行期报错，提示比较器无效）<br>上述实例中导致<code>相同判断式</code>失效最关键的原因在于<code>比较函数</code>对两个等值对象返回了true。<br><strong>在关联容器中必须牢记，对于两个相等的值，比较函数必须返回false.</strong></p>
<hr>
<h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p>&lt;/br&gt;<br>我们之前写过对指针的升序版本比较函数，如果我们现在需要一个降序版本（不用说，把之前的拿出来改一改）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringPtrGreater</span>:</span><span class="comment">//无效比较器</span></span><br><span class="line">    <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*,<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !(*ps1 &lt; *ps2);对原有排序原则取反 &lt;变成了&gt;=</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该比较器是无效的，因为它对相等的值返回true（基于&gt;=)真正的比较器如下：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringPtrGreater</span>:</span><span class="comment">//无效比较器</span></span><br><span class="line">    <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*,<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *ps1 &gt; *ps2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><h1 id="比较函数对等值对象必须返回false的原因"><a href="#比较函数对等值对象必须返回false的原因" class="headerlink" title="比较函数对等值对象必须返回false的原因"></a>比较函数对等值对象必须返回false的原因</h1><p>&lt;/br&gt;<br><strong>比较函数的返回值表明的是在此函数定义的排序方式下，一个值是否大于另一个。相等的值绝不该一个大于另一个，所以比较函数总应该对相等的值返回false。</strong></p>
<hr>
<h1 id="mutiset与mutimap同样适用的原因"><a href="#mutiset与mutimap同样适用的原因" class="headerlink" title="mutiset与mutimap同样适用的原因"></a>mutiset与mutimap同样适用的原因</h1><p>&lt;/br&gt;<br>有人会觉得该条款只对set与map有效，muti则不在此列，但实际上并非如此<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, less_equal&lt;<span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">s.insert(<span class="number">10</span>);</span><br><span class="line">s.insert(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><br>如果我们对s调用equal_range成员函数（标注所有与输入元素等值的元素的范围），但由于比较函数认为10<sub>A</sub>与10<sub>B</sub>并不相同，所以它们无法同时出现在范围内。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&lt;/br&gt;<br>从技术上说，比较函数应该严格遵守弱序化，其体现之一就是确保两个相等的值比较时返回false.</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
        <tag>关联容器</tag>
      </tags>
  </entry>
  <entry>
    <title>11.以deleted函数取代private undefined函数</title>
    <url>/2018/06/29/%E4%BB%A5deleted%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3private%20undefined%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在C++98中我们倾向于使用privtae undefined来禁止用户使用某个函数（例如copy constructor或者operator =）,C++11引入了新的解决方案。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>在C++98中，为了保证istream与ostream无法被拷贝，basic_ios有定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">basic_ios</span> :</span> <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    basic_ios(<span class="keyword">const</span> basic_ios&amp; ); <span class="comment">// not defined</span></span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios&amp;); <span class="comment">// not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这么做的原因可见Effective C++ Item6。</p>
<p>在C++11中，我们可以使用<code>=delete</code>来更好地完成这一任务：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">basic_ios</span> :</span> <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    basic_ios(<span class="keyword">const</span> basic_ios&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>C++11中的deleted function将问题发现的时间提前到了编译期，即任何试图调用函数函数的操作都将引发编译期错误，但private undefined function则可能由于友元调用等行为在连接期才会发现函数未定义从而报错（解决方法是使用mixin class uncopyable将报错时机提前至编译期）。</p>
<hr>
<h1 id="delete-function的访问类型"><a href="#delete-function的访问类型" class="headerlink" title="delete function的访问类型"></a>delete function的访问类型</h1><p>&nbsp;<br>我们倾向于将delete function设置为public，因为发生函数调用时编译首先会检查其访问类型，然后再判断其delete status。如果用户试图调用一个deleted private function，某些编译器可能会本末倒置地提示该函数不可访问，而非该函数不可使用。在修改历史遗留代码时应当考虑这一点，这样才能保证编译器的错误提示正确与直观。</p>
<hr>
<h1 id="delete-function的优势"><a href="#delete-function的优势" class="headerlink" title="delete function的优势"></a>delete function的优势</h1><h2 id="任何函数均可delete"><a href="#任何函数均可delete" class="headerlink" title="任何函数均可delete"></a>任何函数均可delete</h2><p>delete function的一大优点在于任何函数均可设为delete function，而只有成员函数才能被设为private。举例而言，假若我们有一个非成员函数，其接受一个int且返回一个bool:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br></pre></td></tr></table></figure><br>C++继承自C的特性使得可能某些对象可能会被隐性地转为int从而触发该函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isLucky(<span class="string">'a'</span>)) … <span class="comment">// is 'a' a lucky number?</span></span><br><span class="line"><span class="keyword">if</span> (isLucky(<span class="literal">true</span>)) … <span class="comment">// is "true"?</span></span><br><span class="line"><span class="keyword">if</span> (isLucky(<span class="number">3.5</span>)) … <span class="comment">// should we truncate to 3 before checking for luckiness?</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们需要isLucky仅仅针对int有效，那我们可以利用重载与delete function将其余函数定义为不可使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>; <span class="comment">// original function</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">char</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">bool</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject bools</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">double</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject doubles and floats</span></span><br></pre></td></tr></table></figure><br>需要注意的是最后一个重载可以同时阻止double与float发生隐式转换，因为相较于int，C++编译器更倾向于将float隐式转换为double。</p>
<hr>
<h2 id="禁止模板实例化"><a href="#禁止模板实例化" class="headerlink" title="禁止模板实例化"></a>禁止模板实例化</h2><p>delete function相较于private undefined function较优的另一点在于其可以禁止模板实例化。举例而言，假设当前有一个形参为内置指针的模板函数（尽管本书第4章建议使用智能指针）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br></pre></td></tr></table></figure><br>众所周知，指针类型有两种特殊情况：void* 与 char*。前者无法被解引用，也无法执行算数操作。后者则通常作为字符串的象征。我们认为processPointer函数模板需要对这两种指针进行特殊处理，即不针对这两种类型实例化函数，通过delete我们可以轻松实现所述功能:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">void</span>&gt;(<span class="keyword">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">char</span>&gt;(<span class="keyword">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><br>现在并没有万事大吉，因为如果void*与char*无法实例化模板，那么const void*与const char*理当也无法实例化模板才对，因此我们不辞劳苦地再写一次:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">const</span> <span class="keyword">void</span>&gt;(<span class="keyword">const</span> <span class="keyword">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">const</span> <span class="keyword">char</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><br>如果想要斩草除根的话，别忘了把const volatile void*、const volatile char*、std::wchar_t, std::char16_t,and std::char32_t之类的东西都定义为无效。</p>
<p>在C++98当中，如果某个类内含一个函数模板，那我们无法采用private undefined的形式对其进行禁止实例化。原因很简单，不可能针对某个特例化改变整个函数模板的访问级别，如下行为将无法通过编译：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123; … &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="comment">// error!</span></span><br><span class="line">    <span class="keyword">void</span> processPointer&lt;<span class="keyword">void</span>&gt;(<span class="keyword">void</span>*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>模板特例化理当出现在某个命名空间内，而非处于类范围内。使用delete function则无此烦恼，因为它们不需要不同的访问级别，并且可以处于类外被deleted:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123; … &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// still</span></span><br><span class="line"><span class="keyword">void</span> Widget::processPointer&lt;<span class="keyword">void</span>&gt;(<span class="keyword">void</span>*) = <span class="keyword">delete</span>; <span class="comment">// public,but deleted</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以认为private undefined function是deleted function尚未出现时C++98的权宜之计，我们应当尽可能使用deleted function将其替换掉。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>尽可能以deleted function取代private undefined function。</strong></li>
<li><strong>任何function均可被delete，其中包括非成员函数与模板实例化。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>21.以make_unique或make_shared取代直接使用new</title>
    <url>/2018/07/06/%E4%BB%A5make_unique%E6%88%96make_shared%E5%8F%96%E4%BB%A3%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8new/</url>
    <content><![CDATA[<h1 id="三大make函数"><a href="#三大make函数" class="headerlink" title="三大make函数"></a>三大make函数</h1><p>&nbsp;<br>C++11加入了make_shared,C++14加入了make_unique，如果你处于C++11环境也不必担心，因为make_unique很容易实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如你所见，make_unique只是将其参数完美转发给待创建对象的构造函数，并返回一个由原始指针初始化得到的unique_ptr。 这种实现形式并不支持数组或自定义删除器，但它至少表明实现make_unique并不困难。</p>
<p>std::make_unique和std::make_shared是三个make函数中的两个：接受任意参数集,并将它们完美转发给动态分配对象的构造函数，并返回指向该对象的智能指针。第三个make函数是std::allocate_shared,其作用类似于std::make_shared，不过它的第一个参数是一个用于动态内存分配的allocator对象。</p>
<hr>
<h1 id="make函数的优越性"><a href="#make函数的优越性" class="headerlink" title="make函数的优越性"></a>make函数的优越性</h1><h2 id="代码明晰程度"><a href="#代码明晰程度" class="headerlink" title="代码明晰程度"></a>代码明晰程度</h2><p>就算不看性能，光看代码也能看出make函数较为优越：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(<span class="built_in">std</span>::make_unique&lt;Widget&gt;())</span></span>; <span class="comment">// with make func</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; <span class="comment">// without make func</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;Widget&gt;())</span></span>; <span class="comment">// with make func</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; <span class="comment">// without make func</span></span><br></pre></td></tr></table></figure><br>显然，使用new的版本需要陈述两次对象类型，这违背了软件工程的基本原则：应尽量避免代码重复。源代码中的重复会增加编译时间，从而导致生成庞大的目标码，并且通常会使代码难以使用。它经常会生成不一致的代码，而这种不一致性是某些bug的起源所在。最后，使用make函数打字也省力一些。</p>
<hr>
<h2 id="异常安全性（可见Effective-C-Item-17）"><a href="#异常安全性（可见Effective-C-Item-17）" class="headerlink" title="异常安全性（可见Effective C++ Item 17）"></a>异常安全性（可见Effective C++ Item 17）</h2><p>make函数的优越性也与异常安全有关。假设我们当前有一个函数负责处理某些具备优先级的Widget：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><br>值传递std::shared_ptr看起来似乎很奇怪，但是Item41中解释说，如果processWidget总是复制std::shared_ptr（例如将其存储在某个跟踪已处理Widget的数据结构中），这是一个合理的选择。<br>更进一步地假设我们有一个计算优先级的函数:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>我们将其返回值与new操作得到的shared_ptr作为参数传递给processWidget:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget),computePriority()); <span class="comment">// potential resource leak</span></span><br></pre></td></tr></table></figure><br>为何可能会发生资源泄露与编译器将源代码转换为目标代码的过程有关。在运行期必须保证一个函数的参数在调用该函数前被明确evaluate，因此在调用processWidget之前，必须执行以下操作：</p>
<ol>
<li><strong>new Widget必然会执行，届时会在堆上创建一个Widget对象。</strong></li>
<li><strong>shared_ptr的构造函数必然会执行，其以new的返回值为初始值。</strong></li>
<li><strong>computePriority必然会执行。</strong></li>
</ol>
<p>编译器并不保证按照上述顺序执行程序。 显然，必须在调用std::shared_ptr构造函数之前执行”new Widget”，但是computePriority可以发生在任何时期，比如说在步骤1之前，又或者步骤1、2之间。假设编译器按照以下顺序执行程序：</p>
<ol>
<li><strong>执行new Widget</strong></li>
<li><strong>执行computePriority</strong></li>
<li><strong>执行std::shared_ptr构造函数</strong></li>
</ol>
<p>如果在运行时，computePriority抛出了异常，则步骤1中动态分配的Widget将被泄漏，因此它将永远无法被访问到。<br>若使用std::make_shared则可以完美避开上述问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::make_shared&lt;Widget&gt;(),computePriority()); <span class="comment">// no potential resource leak</span></span><br></pre></td></tr></table></figure><br>在上述代码运行时，将首先调用make_shared或computePriority。如果首先调用了make_shared，则动态分配的资源必然已被置入智能指针，此时computePriority抛出异常会导致shared_ptr发生析构，资源被合理释放。若是先调用computePriority，则make_shared不会执行，资源泄露无从谈起。make_unique亦是同理。</p>
<hr>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>std::make_shared相较于new而言效率更高，使用std::make_shared允许编译器生成更小，更快的代码，使用更精简的数据结构。若我们直接使用new operator:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure><br>显然，上述程序需要执行内存分配操作，但实际上它执行了两次内存分配。在Item19中我们曾经提及每个std::shared_ptr都指向一个control block，其中包含指向对象的引用计数。 此control block的内存在std::shared_ptr构造函数中分配。此外，new operator将为Widget对象分配一块内存，因此一共执行了两次内存分配。<br>我们现以make_shared函数替换new：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = <span class="built_in">std</span>::make_shared&lt;Widget&gt;();</span><br></pre></td></tr></table></figure><br>如此一来，一次内存分配足矣。std::make_shared一次性分配了Widget与control block的内存，这种优化减少了程序的静态大小（因为代码只包含一个内存分配调用），并且它增加了可执行代码的速度，因为内存只分配了一次。此外，使用std::make_shared不需要control block中的某些bookkeeping information，可能会减少程序的总内存占用量。std::allocate_shared效率分析亦类似于std::make_shared。</p>
<hr>
<h1 id="make函数的不足"><a href="#make函数的不足" class="headerlink" title="make函数的不足"></a>make函数的不足</h1><p>&nbsp;<br>尽管make函数无论是代码可读性、异常安全性、效率均优于new，但其存在使用条件，在某些情况下make函数无法使用。</p>
<h2 id="自定义删除器"><a href="#自定义删除器" class="headerlink" title="自定义删除器"></a>自定义删除器</h2><p>举例而言，make函数不支持自定义删除器，若当前存在删除器如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> widgetDeleter = [](Widget* pw) &#123; … &#125;;</span><br></pre></td></tr></table></figure><br>使用new来创建一个具备自定义删除器的智能指针很容易：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;Widget, decltype(widgetDeleter)&gt; upw(new Widget, widgetDeleter);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br></pre></td></tr></table></figure><br>make函数却不支持这种行为。</p>
<h2 id="大括号初始化器"><a href="#大括号初始化器" class="headerlink" title="大括号初始化器"></a>大括号初始化器</h2><p>make函数的第二个限制源于其实现的语法细节。在Item7中我们曾经明确说明，若一个对象存在参数为initializer_list类型的构造函数，那么当构造实参带有大括号时几乎必然会调用该函数，而带有小括号的构造实参则会调用其他构造函数。make函数负责将实参完美转发给智能指针的构造函数，但这些实参是带有大括号还是小括号make函数却一无所知。对于某些类型而言，构造时使用大括号还是小括号将导致完全不同的结果，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> upv = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">auto</span> spv = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><br>到底应该是生成一个内含10个元素，其值均为20的vector，还是生成内含10、20两个元素的vector？又或者说结果是不确定的？有一个好消息和一个坏消息在等着我们。<br>好消息是答案并非不确定：两个调用都将创建一个智能指针指向一个内含10个元素的vector，这意味着在make函数中完美转发使用小括号而不是大括号。坏消息是如果你要使用大括号实参构造指向对象，则必须直接使用new opertaor来完成。由此看来，使用make函数需要支持完美转发的大括号初始化，但Item30中将会提及，大括号初始化并不支持完美转发。但Item30描述了一种解决方案：使用auto类型推衍利用大括号初始化器创建std::initializer_list对象，然后通过make函数传递auto对象(显式地以initializer_list作为构造实参）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create std::initializer_list</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">// create std::vector using std::initializer_list ctor</span></span><br><span class="line"><span class="keyword">auto</span> spv = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure></p>
<p>对于unique_str而言，make函数仅在上述两个场景下存在些许问题，但对于shared_ptr而言，还有两个问题需要解决。         </p>
<h2 id="自定义内存管理"><a href="#自定义内存管理" class="headerlink" title="自定义内存管理"></a>自定义内存管理</h2><p>对于某些自定义了opertaor new与operator delete的class而言，使用全局new与delete似乎不太合适。一般而言，new与delete负责分配或释放指定大小（通常为sizeof(Widget))的内存，但shared_ptr并非如此，它所需要分配与释放的不仅仅是对象的大小，还需要加上一个control block的大小。因此，使用make函数创建具备自定义内存管理的对象是一个十分糟糕的想法。</p>
<p>std::make_shared的速度优势来源于在分配对象所需要的内存时control block所需要的内存也被一并放置，但我们所需要明确的是，当对象被析构时其所占内存并未立即释放，因为此时control block所占用的内存尚未被释放。</p>
<h2 id="内存释放延迟"><a href="#内存释放延迟" class="headerlink" title="内存释放延迟"></a>内存释放延迟</h2><p>正如之前指出，control block中含有两个引用计数相关信息，其中第二个被称为弱引用计数，当一个weak_ptr检查其是否处于空悬状态时，它通过检查第一个引用计数（而非若引用计数）来确保正确性，如果引用计数为0，weak_ptr即为空悬，否则不是。但control block所占用内存的释放与弱引用计数有关，也就是说，即使对象已经析构，但只要仍然存在一个weak_ptr指向它（弱引用计数不为0），该control block的内存便需要一直存在，直到最后一个指向shared_ptr的weak_ptr被析构。如果对象非常大，销毁最后一个shared_ptr与weak_ptr之间又存在着大量时间，那么可能在内存释放期间会出现延迟：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReallyBigType</span> &#123;</span> … &#125;;</span><br><span class="line"><span class="keyword">auto</span> pBigObj =<span class="built_in">std</span>::make_shared&lt;ReallyBigType&gt;();</span><br><span class="line">… <span class="comment">// create std::shared_ptrs and std::weak_ptrs to large object, use them to work with it</span></span><br><span class="line">… <span class="comment">// final std::shared_ptr to object destroyed here,but std::weak_ptrs to it remain</span></span><br><span class="line">… <span class="comment">// during this period, memory formerly occupied by large object remains allocated</span></span><br><span class="line">… <span class="comment">// final std::weak_ptr to object destroyed here;memory for control block and object is released</span></span><br></pre></td></tr></table></figure><br>使用new则可以完成瞬间内存释放。</p>
<hr>
<h1 id="在无法使用make函数时的替代"><a href="#在无法使用make函数时的替代" class="headerlink" title="在无法使用make函数时的替代"></a>在无法使用make函数时的替代</h1><p>&nbsp;<br>如果当前并不适合使用std::make_shared，我们需要考虑异常安全性问题。最好的解决方案方法是确保直接使用new时，立即将结果传递给智能指针构造函数，该语句不执行任何其他操作（即Effective C++ Item17所述）。仍以具备自定义删除其的Widget为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw,<span class="keyword">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cusDel</span><span class="params">(Widget *ptr)</span></span>; <span class="comment">// custom deleter</span></span><br></pre></td></tr></table></figure><br>以下为一个不具备异常安全性的调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget, cusDel),computePriority());</span><br></pre></td></tr></table></figure><br>如果我们将其改写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, cusDel)</span></span>;</span><br><span class="line">processWidget(spw, computePriority()); <span class="comment">// correct, but not optimal; see below</span></span><br></pre></td></tr></table></figure><br>这段代码具备异常安全性，因为即使spw构造失败（例如无法为control block分配内存），仍然能够通过自定义删除器析构刚刚构造的widget对象，只是其性能还可以被改善。</p>
<p>在刚才不具备异常安全性的程序中，我们试图将一个右值传递给ProcessWidget，但在异常安全的版本中，我们传递的是一个左值。因为processWidget中的参数pass-by-value，因此右值的构造只需要移动，而来自左值的构造需要复制，这一点对于std::shared_ptr可能会带来很大的差异，因为复制std::shared_ptr时其引用计数自增是原子操作，而移动std::shared_ptr则根本不需要关心引用计数。我们将原先的左值转为右值可以大幅度提升性能：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">move</span>(spw),computePriority());</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>与直接使用new相比，make函数不存在代码重复且具备异常安全性，std::make_shared和std::allocate_shared可以生成更快更短的目标码。</strong></li>
<li><strong>在需要自定义删除器及以大括号初始化时make函数无能为力。</strong></li>
<li><strong>对于shared_ptr,具备自定义内存管理与weak_ptr生存期比shared_ptr长的情况亦不可使用make函数。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>17.了解自动生成的特殊成员函数</title>
    <url>/2018/07/04/%E4%BA%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>按照官方说法，所谓特殊成员函数就是C++自动生成的函数。在C++98中有4种这样的函数（它们自动生成的条件可见Inside the C++ Object Model）：</p>
<ol>
<li><strong>default constructor</strong></li>
<li><strong>default destructor</strong></li>
<li><strong>default copy constructor</strong></li>
<li><strong>default copy assignment operator</strong></li>
</ol>
<p>一般而言，自动生成的此类特殊函数将隐式地具备public &amp;&amp; inline，并且为non-virtual（析构函数存在一个意外，如果该类继承自一个具备virtual destructor的基类，则自动生成的default destructor具备virtual属性）。</p>
<p>上述内容你可能已经完全掌握，但在C++11中它们发生了一些变化，了解这些新的规则对C++高效编程至关重要。</p>
<hr>
<h1 id="move-constructor-and-move-assignment"><a href="#move-constructor-and-move-assignment" class="headerlink" title="move constructor and move assignment"></a>move constructor and move assignment</h1><p>&nbsp;<br>C++11的特殊成员函数相较于C++98多出了两个新人：move constructor与move assignment，它们的签名如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    Widget(Widget&amp;&amp; rhs); <span class="comment">// move constructor</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs); <span class="comment">// move assignment operator</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>生成它们的规则类似于copy，move操作仅在它们需要时才被生成，其行为是对rhs的所有non-static data member执行move操作，此外，它们对rhs中的基类部分同样执行move操作。</p>
<p>严格意义上来说，move constructor与move assignment更像是一种请求，我们无法保证必然会发生move行为。这种原因很简单，C++98中大量的历史遗留类型并不支持move操作，，因此它们实际上通过copy操作完成了move行为。move行为的核心操作是对所有需要移动的数据执行std::move，并且在函数重载期内根据实际情况判断到底是使用copy还是move（Item23 将会对此进行详尽分析）。我们现在所需要了解的就是对所有能move的执行move，不能move的执行copy。</p>
<hr>
<h2 id="move操作的生成"><a href="#move操作的生成" class="headerlink" title="move操作的生成"></a>move操作的生成</h2><p>&nbsp;<br>类似于copy，自动生成move操作仅发生于你并未手动地声明它，但其生成条件和copy相比还是略有不同。</p>
<p>两个copy操作相互独立，也就是说声明其中的一个对另一个并无任何影响。如果你声明了一个copy constructor但没有声明copy assignment，那么编译器将会在需要的时候自动定义与声明copy assignment，反之亦是如此。</p>
<p>两个move操作并不独立，其中的任何一个被声明都会阻止编译器生成另外一个。理由很简单，如果你声明了一个移动构造函数，那你至少应当指出如何实现移动构造以及它与编译器默认memberwise move版本的不同之处。如果 memberwise move constructor并不适用于该类，那么几乎必然memberwise move assignment也不适用。同理，声明move assignment也会阻止move constructor的生成。</p>
<p>此外，move操作不会在任何显式声明了copy操作的类中生成。声明copy操作的原因是因为memberwise copy并不适用于该类，因此编译器会认为既然memberwise copy并不适合，那么memberwise move必然也不适合该类。这引发了另一个话题，如果一个类中声明了move操作，那么编译器将禁止自动生成copy操作，原因在于memberwise move无法适用的类想必也无法使用memberwise copy。这听起来可能会破坏C++98中的旧有程序，因为C++11中自动生成copy操作的条件似乎更加苛刻。但实则并非如此，C++98代码中不会出现move操作，因为C++98根本就不存在“move object”。遗留代码只有在经过符合C++11标准的修改之后才会具备移动语义。</p>
<hr>
<h1 id="三-五法则（C-Primer-P477）"><a href="#三-五法则（C-Primer-P477）" class="headerlink" title="三/五法则（C++ Primer P477）"></a>三/五法则（C++ Primer P477）</h1><p>&nbsp;<br>也许你曾经听说过一条被称为“Rule of Three”的指导方针，该指导方针规定，copy constructor，copy assignment opertaor或destructor的声明总应该一起出现，不允许出现任何遗漏。该原则的背景在于，手动声明copy操作几乎必然是因为当前类负责资源管理，而资源管理类又存在如下特征：</p>
<ol>
<li><strong>copy操作几乎不可能只使用一个（copy constructor中的行为也需要被应用于copy assignment opertaor之中）。</strong></li>
<li><strong>析构函数负责资源的释放。</strong></li>
</ol>
<p>一般来说需要管理的资源都是指内存，这也就是为何所有负责内存管理的标准库类均声明有这三件套的原因。</p>
<p>自定义destructor表明单纯的memberwise copy行为可能并不适用于该类，因此一旦存在用户自定义destructor，编译器将不会自发生成任何copy操作。在C++98被创建时这条规则尚未得到清楚认知，因此在C++98中用户自定义destructor并不会对编译器生成copy操作造成任何影响，在C++11中自定义destructor仍然不会限制copy操作的生成，但这次并非认知不明，而是出于担心破坏历史遗留代码的原因。</p>
<p>但“Rule of Three”规则依然有效，前文中我们已经明确带有自定义copy操作的类不会自动生成move操作，因此我们也可以推断，带有自定义destructor的class使用默认move操作也是不正确的行为（因为自定义destructor的存在表示当前类需要自定义copy操作）。因此，只有当下述三个条件成立时才会生成move操作：</p>
<ol>
<li><strong>class中没有任何自定义copy操作。</strong></li>
<li><strong>class中不存在另一个move操作的声明。</strong></li>
<li><strong>class中不存在自定义destructor。</strong></li>
</ol>
<hr>
<h1 id="default声明"><a href="#default声明" class="headerlink" title="=default声明"></a>=default声明</h1><p>&nbsp;<br>在某些情况下，类似的规则可能会延伸至copy操作，原因在于C++11很是抵制为含有自定义destructor或copy操作的class生成copy操作。因此如果你曾经依赖于使用编译器自动生成的特殊成员函数，你应当仔细检查并按照“Rule of Three”法则消去其相关性。如果你认为memberwise足以完成工作，那你可以在声明时直接以default注明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    ~Widget(); <span class="comment">// user-declared dtor</span></span><br><span class="line">    …</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp;) = <span class="keyword">default</span>; <span class="comment">// default copy ctor behavior is OK</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>=default</code>在多态基类中使用非常普遍。多态基类通常具有虚析构函数，因为如果它们不存在，则某些操作（例如通过基类指针或引用对派生类对象使用delete或typeid）会产生未定义或误导性的结果。除非一个类已经继承了其基类的虚析构函数，否则你最好显式地声明它。前文已述，自定义destructor会抑制move操作的生成，因此你必须使用<code>=default</code>显式说明自己需要memberwise copy。类似地，声明移动操作会禁用copy操作，因此如果需要复制性的话，则需要手动声明copy操作为<code>=default</code>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>; <span class="comment">// make dtor virtual</span></span><br><span class="line">    Base(Base&amp;&amp;) = <span class="keyword">default</span>; <span class="comment">// support moving</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(Base&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Base(<span class="keyword">const</span> Base&amp;) = <span class="keyword">default</span>; <span class="comment">// support copying</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Base&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此外，结果编译器愿意生成某些操作，也不妨碍我们在类中以<code>=default</code>显式地声明它们，尽管多打了几个字，但可以使接口更加清晰，同时避免一些微妙的错误。举例而言，当前存在一个表示字符串表的类，即一个允许通过整数ID快速查找字符串值的数据结构：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StringTable() &#123;&#125;</span><br><span class="line">    … <span class="comment">// functions for insertion, erasure, lookup,</span></span><br><span class="line">    <span class="comment">// etc., but no copy/move/dtor functionality</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看到该类并未声明copy操作、move操作等等，编译器将会在其需要时将其合成。但考虑如果你日后发现需要在构造和析构对象时做一个日志记录，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StringTable()  &#123; makeLogEntry(<span class="string">"Creating StringTable object"</span>); &#125; <span class="comment">// added</span></span><br><span class="line">    ~StringTable() &#123; makeLogEntry(<span class="string">"Destroying StringTable object"</span>); &#125; <span class="comment">// added</span></span><br><span class="line">    … <span class="comment">// other funcs as before</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; values; <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>析构函数的加入看起来没毛病，但实际上它导致了移动操作不再会被生成，但同时复制操作不受影响。因此，在我们启动移动操作时，实际上使用的copy操作，而我们却对此一无所知（赋值map造成了相当严重的性能下降，这一切只是因为引入了一个自定义destructor）。如果我们在之前曾经手动声明过<code>=default</code>，那一切都不会发生问题。</p>
<hr>
<h1 id="C-11中特殊函数的规则总结"><a href="#C-11中特殊函数的规则总结" class="headerlink" title="C++11中特殊函数的规则总结"></a>C++11中特殊函数的规则总结</h1><ul>
<li><strong>Default constructor</strong><br>和C++98一样，仅在不存在自定义constructor时自动生成。</li>
<li><strong>Destructor</strong><br>类似于C++98，唯一的区别在于编译器自动生成的destructor带有noexcept属性，并且与C++98一致的是，仅有基类destructor为virtual的情况下才会具备virtual属性。</li>
<li><strong>Copy constructor</strong><br>与C++98行为相同：复制构造所有的non-static data member。仅在class中不存在自定义copy constructor的情况下才会被生成。如果类中声明了移动操作，则不会生成copy constructor。不推荐在任何具备自定义copy操作或自定义destructor的class中依赖此函数。</li>
<li><strong>Copy assignment operator</strong><br>类似于copy constructor。</li>
<li><strong>Move constructor and move assignment operator</strong><br>为每一个non-static data member执行move操作。仅在类不包含自定义copy操作，move操作或析构函数时生成。</li>
</ul>
<p>规则中并没有任何关于模板成员函数阻止其他特殊成员函数生成的说明，因此，如果有一个Widget class如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    Widget(<span class="keyword">const</span> T&amp; rhs); <span class="comment">// construct Widget from anything</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; rhs); <span class="comment">// assign Widget from anything</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>编译器仍将为Widget生成copy和move操作（假设其生成条件已经具备），即使存在可以实例化生成copy操作与move操作的成员函数模板（当T为Widget时）。在某些情况下这种行为可能会产生相当严重的后果，我们将Item26中对其进行详细论述。</p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>22.以op=代替op</title>
    <url>/2018/04/27/%E4%BB%A5op=%E4%BB%A3%E6%9B%BFop/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>对于c++而言，运算符operator+、operator=、operator+=之间并没有任何关联，对于其他运算也同理，如果你期望使用效果犹如内置类型，那你必须自己实现。</p>
<hr>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>&nbsp;<br>为了确保operator+=与operator+之间存在正常的关系，建议根据operator+=实现出operator+：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Rational&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">    Rational&amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>+(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs) += rhs;<span class="comment">//返回值优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种方法将赋值形式作为了成员函数，维护性得到了提高，同时避免了operator+成为了类的友元。（提高封装性）</p>
<hr>
<h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><p>&nbsp;<br>赋值的效率高于单独形式，原因在于赋值返回引用，无需构建析构临时对象。<br>但需要记住，提供赋值的同时必须提供标准形式，以方便用户能够作出权衡，因为标准形式的可读性高于赋值，在大多数情况下，可读性很重要。<br>作为一个库编写者，必须给客户提供这两种操作。但作为使用者，我们必须明白赋值的效率更高。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 令operator=返回reference to *this</title>
    <url>/2018/04/09/%E4%BB%A4operator=%E8%BF%94%E5%9B%9E%E8%87%AA%E8%BA%AB%E7%9A%84reference/</url>
    <content><![CDATA[<p>operator= 的一大特点在于可以写成连锁形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">x=y=z=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><br>operator= 采用右结合律，所以上式被解析为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x=(y=(z=<span class="number">15</span>));</span><br></pre></td></tr></table></figure><br>为了实现这种连锁赋值，operator=必须返回一个reference指向操作符的左侧实参，这是实现operator=的协议要求：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该协议不仅仅适用于operator=，也适用于所有赋值相关操作，例如operator+=之类。（关于操作符的复合形式，其实现亦有特点，具体可见More Effective C++ 22）</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>10.以scoped enums代替unscoped enums</title>
    <url>/2018/06/28/%E4%BB%A5scoped%20enums%E4%BB%A3%E6%9B%BFunscoped%20enums/</url>
    <content><![CDATA[<h1 id="unscoped-enum与命名空间污染"><a href="#unscoped-enum与命名空间污染" class="headerlink" title="unscoped enum与命名空间污染"></a>unscoped enum与命名空间污染</h1><p>&nbsp;<br>通常，在大括号内声明某名称会导致该名称可见性仅限于大括号范围之内，但对于C++98中的枚举类型来说并非如此。这些枚举变量名的作用域等价于枚举所存在的作用域，因此直接导致别的变量再也无法使用这些名字：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;; <span class="comment">// black, white, red are in same scope as Color</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>; <span class="comment">// error! white already declared in this scope</span></span><br></pre></td></tr></table></figure><br>这种污染命名空间的行为被定义为：unscoped。C++11对此提出了解决方案scoped enums：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> black, white, red &#125;; <span class="comment">// black, white, red are scoped to Color</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>; <span class="comment">// fine, no other</span></span><br><span class="line">Color c = white; <span class="comment">// error! no enumerator named "white" is in this scope</span></span><br><span class="line">Color c = Color::white; <span class="comment">// fine</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white; <span class="comment">// also fine (and in accord with Item 5's advice)</span></span><br></pre></td></tr></table></figure><br>这种技法亦被称为enum classes。</p>
<hr>
<h1 id="scoped的强类型保证"><a href="#scoped的强类型保证" class="headerlink" title="scoped的强类型保证"></a>scoped的强类型保证</h1><p>&nbsp;<br>scoped enum除了不会污染命名空间之外还具备一大优势：其成员均为强类型枚举量。unsoped enum的成员总是可以被隐式转换为int型（并可以藉由此转为浮点型），例如下文的转换是完全有效的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;; <span class="comment">// unscoped enum</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; <span class="title">primeFactors</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> x)</span></span>; <span class="comment">// returning prime factors of x</span></span><br><span class="line">Color c = red;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123; <span class="comment">// compare Color to double (!)</span></span><br><span class="line">    <span class="keyword">auto</span> factors = primeFactors(c);<span class="comment">//compute prime factors of a color</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果将其转变为scoped enum，上述问题都将不复存在：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> black, white, red &#125;; <span class="comment">// enum is now scoped</span></span><br><span class="line">Color c = Color::red; <span class="comment">// as before, but with scope qualifier</span></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123; <span class="comment">// error! can't compare Color and double</span></span><br><span class="line">    <span class="keyword">auto</span> factors = <span class="comment">// error! can't pass Color to</span></span><br><span class="line">    primeFactors(c); <span class="comment">// function expecting std::size_t</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果你非要进行转换也不是不可以，只要你使用static_cast:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(c) &lt; <span class="number">14.5</span>) &#123; <span class="comment">// odd code, but it's valid</span></span><br><span class="line">    <span class="keyword">auto</span> factors = primeFactors(<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(c)); <span class="comment">// // suspect, but it compiles</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="forward—declartion"><a href="#forward—declartion" class="headerlink" title="forward—declartion"></a>forward—declartion</h1><p>&nbsp;<br>scoped enum似乎还有一大优点在于可以完成forward—declartion,即可以在不具备定义的情况下直接声明枚举类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color; <span class="comment">// error!</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span>;</span> <span class="comment">// fine</span></span><br></pre></td></tr></table></figure><br>但事实并非如此。在C++11中，unscoped enum亦可完成forward—declartion，但是需要一点点额外的工作。由于在C++语言中每一个枚举量都具备一个由编译器决定的整形底层类型，对于下述这个枚举量：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;;</span><br></pre></td></tr></table></figure><br>编译器可能会选择char作为其底层类型，因为只有三个值可以表示。但也有可能会出现枚举值范围很大的情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123; good = <span class="number">0</span>,failed = <span class="number">1</span>,incomplete = <span class="number">100</span>,corrupt = <span class="number">200</span>,indeterminate = <span class="number">0xFFFFFFFF</span>&#125;;</span><br></pre></td></tr></table></figure><br>此时编译器将会选择一个大于char的类型作为底层类型。</p>
<p>为了保证高效使用内存，编译器通常会选择最合适（最小）的数据类型作为底层类型。但在某些情况下，编译器会倾向于在保证速度的前提下使用较小内存。为了保证这种实现的可行性，C++98仅支持枚举定义而不支持枚举声明，这一特性使得编译器可以在使用枚举之前为每个枚举选择底层类型。</p>
<p>无法forward—declartion存在一定的缺陷，其中最显著的缺陷即在于编译依存性被显著提升。仍以Status enum为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123; good = <span class="number">0</span>,failed = <span class="number">1</span>,incomplete = <span class="number">100</span>,corrupt = <span class="number">200</span>,indeterminate = <span class="number">0xFFFFFFFF</span>&#125;;</span><br></pre></td></tr></table></figure><br>如果该枚举被定义于某个头文件中并且被#include多次，那么如果我们想要向其中增加一个新的状态，整个系统都需要被重新编译。C++11修复了这个问题，例如以下则是一个枚举声明以及将枚举类型作为参数的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">continueProcessing</span><span class="params">(Status s)</span></span>; <span class="comment">// use of fwd-declared enum</span></span><br></pre></td></tr></table></figure><br>如果Status的定义发生了改变，那么包含这个声明的头文件无需重新编译。此外，只要continueProcessing保持行为一致，continueProcessing的实现亦不需要重新编译。</p>
<hr>
<h2 id="手动指定enum底层类型"><a href="#手动指定enum底层类型" class="headerlink" title="手动指定enum底层类型"></a>手动指定enum底层类型</h2><p>&nbsp;<br>如果编译器需要在使用enum前了解其大小，C++11是如何做到完成forward—declartion的？答案十分简单：scoped enum的底层类型总是已知的，而unscoped enum则可以手动指定。</p>
<p>在默认情况下，scoped enum的底层类型是int：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>;</span> <span class="comment">// underlying type is int</span></span><br></pre></td></tr></table></figure><br>当然你也可以手动地指定其类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>:</span> <span class="built_in">std</span>::<span class="keyword">uint32_t</span>; <span class="comment">// underlying type for is std::uint32_t(from &lt;cstdint&gt;)</span></span><br></pre></td></tr></table></figure><br>无论如何，编译器总是在声明时即明确了scoped enum的底层类型。</p>
<p>unscoped enum也可以这样操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color: <span class="built_in">std</span>::<span class="keyword">uint8_t</span>; <span class="comment">// fwd decl for unscoped enum;</span></span><br></pre></td></tr></table></figure><br>甚至我们还可以在定义时指定其底层类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>:</span> <span class="built_in">std</span>::<span class="keyword">uint32_t</span> &#123; good = <span class="number">0</span>,</span><br><span class="line">                                   failed = <span class="number">1</span>,</span><br><span class="line">                                   incomplete = <span class="number">100</span>,</span><br><span class="line">                                   corrupt = <span class="number">200</span>,</span><br><span class="line">                                   audited = <span class="number">500</span>,</span><br><span class="line">                                   indeterminate = <span class="number">0xFFFFFFFF</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="unscoped-enum的可取之处"><a href="#unscoped-enum的可取之处" class="headerlink" title="unscoped enum的可取之处"></a>unscoped enum的可取之处</h1><p>&nbsp;<br>scoped enum可以避免污染命名空间，并且不易受到无意义隐式类型转换的影响，但它并非毫无可取之处：在C++11的std::tuple中起到了一定的作用。举例而言，我们现有一个tuple，它持有社交网站用户的姓名、电子邮件地址与信誉值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo = <span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;;<span class="comment">// type alias;</span></span><br></pre></td></tr></table></figure><br>作为一名开发者，我们需要关注很多东西，但这其中可能并不包括记住tuple的字段1对应着用户email。使用unscoped enum可以将名称与字段号关联，从此不必费心记忆：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> UserInfoFields &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;uiEmail&gt;(uInfo); <span class="comment">// ah, get value of email field</span></span><br></pre></td></tr></table></figure><br>通过隐式类型转换，我们将enum变为了std::get所需要的类型。如果你坚持使用scoped enum，那么效果可能会非常惨烈：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoFields</span> &#123;</span> uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure><br>当然，我们也可以编写一个形参为eunm且返回值为std::size_t的函数来降低语句复杂程度，但这稍微有点麻烦。std::get是一个模板，因此你所需要提供的值是一个模板参数（必须在编译期确定），那也就是说，该函数必须是一个constexpr函数。<br>实际上光是constexpr函数还不够，这个转换必须得是一个constexpr函数模板，因为它必须能够支持所有类型的enum，同样地，我们也需要对返回值进行泛型化处理。在泛型设计中我们将不再返回std::size_t，而是返回enum的底层类型（该操作通过std::underlying_type实现)。最后，我们将其声明为noexcept，因为它永远不会抛出异常，最终转换函数实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::underlying_type&lt;E&gt;::type</span><br><span class="line">toUType(E enumerator) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::underlying_type&lt;E&gt;::type&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在C++14中，toUType可以简化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">underlying_type_t</span>&lt;E&gt;</span><br><span class="line">toUType(E enumerator) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然我们也可以通过使用auto来更进一步地简化它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在具备了toUType后，tuple的使用如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;toUType(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure><br>看起来还是比使用unscoped enum麻烦多了，但至少它避免了命名空间污染与无意义的转换，这二者的破坏力都十分巨大，因此最好还是心甘情愿地多写几个字符吧。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;</p>
<ol>
<li><strong>C++98中的enum被称为unscoped enum。</strong></li>
<li><strong>scoped enum不会污染命名空间，仅在cast下才能完成转换。</strong></li>
<li><strong>scoped enum 与 unscoped enum都支持底层类型指定，scoped enum默认为int类型。</strong></li>
<li><strong>scoped enum支持forward declaration，unscoped enum需要指定其底层类型方可。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>46.以函数对象代替函数作为谓词</title>
    <url>/2018/04/21/%E4%BB%A5%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BB%A3%E6%9B%BF%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%B0%93%E8%AF%8D/</url>
    <content><![CDATA[<p>（本节内容已淘汰，笔者推荐配合lambda使用泛型算法）</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>14.以对象管理资源</title>
    <url>/2018/04/10/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假设我们有一个关于投资的继承体系，其基类为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span>...&#125;;</span><br></pre></td></tr></table></figure><br>我们惯用factory function来产生特定的对象，并且有责任释放该对象，现有某个f函数执行了该操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Inverstment* pInv = createInvestment();<span class="comment">//调用factory function</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序看起来没毛病，但是实际使用中可能会发生内存泄漏。原因可能但不仅仅如下：</p>
<ol>
<li>…处有了一个过早的return</li>
<li>delete位于某个循环或者判断内并未能执行到</li>
<li>…处抛出了一个异常</li>
</ol>
<p>我们泄漏的不仅仅只是内含投资对象的那一块内存，还包括任何它所保存的资源。</p>
<p>当然，完美的逻辑可以避免上述问题，但关键在于代码总是处于不断修改和升级的过程中，<strong>单纯依赖delete语句总被执行是不可能的</strong>。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&lt;/br&gt;<br><strong>为了确保资源总是被释放，我们需要将资源放进对象内。当控制流离开程序块时，该对象的析构函数则会自动释放那些资源。</strong></p>
<h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>许多资源被动态地分配于heap内,然后被用于单一区块或函数内。这些资源应该在控制流离开那个区块或者函数时被释放。标准库提供的auto_ptr正是针对这种形式而设计的。<br>auto_ptr是一个智能指针，其析构函数自动对其所指对象调用delete。（auto_ptr的具体描述及特性，详见C++ Primer）<br>其具体使用大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以对象管理资源的关键思路在于：</p>
<ol>
<li><strong>获得资源后立刻放入管理对象</strong>。<br>这也被称为“资源获取之日即是初始化之时”（resource acquisition initialization；RAII）<br>有时候我们也把拿到的资源用来赋值而不是初始化。但不管怎么说，每一笔资源总在获得之时就被立刻放入管理对象中。</li>
<li><strong>管理对象（managing object)运用析构函数确保资源释放</strong>。<br>除非管理对象析构函数里会抛出异常，否则资源总能被正确释放。针对唯一的这一种例外，Effective C++ 8 对此有详细的描述</li>
</ol>
<h3 id="auto-ptr的缺陷"><a href="#auto-ptr的缺陷" class="headerlink" title="auto_ptr的缺陷"></a>auto_ptr的缺陷</h3><p>如果通过copy构造函数或者copy assignment操作符来复制auto_ptr，那它们会变成null，新复制的智能指针将获得资源的唯一使用权。<br>这种诡异的复制行为直接导致STL容器不能使用auto_ptr(具体论述见Effective STL 8）</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>auto_ptr的替代方案是用引用计数型智能指针。也就是reference-counting smart pointer(RCSP)。它持续地追踪有多少对象指向某个资源，没人指向就释放资源。</p>
<h3 id="shared-ptr的缺陷"><a href="#shared-ptr的缺陷" class="headerlink" title="shared_ptr的缺陷"></a>shared_ptr的缺陷</h3><p>无法打破环状引用（例如两个没人用的对象彼此互指，编译器判断对象仍然处于使用状态）。</p>
<h2 id="智能指针的缺陷"><a href="#智能指针的缺陷" class="headerlink" title="智能指针的缺陷"></a>智能指针的缺陷</h2><p>智能指针的析构函数中做的是delete而非delete[]，这意味着在动态分配而得到的array身上用它们效果感人。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>])</span></span>;<span class="comment">//析构时只释放了一个</span></span><br></pre></td></tr></table></figure><br>但这个问题不大，Effective STL 13提及，应当尽可能使用vector与string替换动态数组。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&lt;/br&gt;<br>本节虽然大量提及了智能指针，但实际<strong>上RAII和智能指针并无关联</strong>，考虑Effective STL 12中提到的多线程实例，其中Lock对象也负责了资源的管理。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>13.以引用方式捕获异常</title>
    <url>/2018/04/26/%E4%BB%A5%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>异常有三种方式传递到catch子句：通过指针（by pointer），通过传值（by value）或通过引用（by reference）。</p>
<hr>
<h1 id="by-pointer"><a href="#by-pointer" class="headerlink" title="by pointer"></a>by pointer</h1><p>&nbsp;<br>用指针来传递异常理论上来说是效率最高的，因为只有它不用copy:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">exception</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> exception ex; <span class="comment">// 异常对象</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> &amp;ex; <span class="comment">// 抛出一个指针，指向 ex</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        someFunction(); <span class="comment">// 抛出一个 exception*</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (exception *ex) &#123; <span class="comment">// 捕获 exception*;</span></span><br><span class="line">        ... <span class="comment">// 没有对象被拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>逻辑上看起来没错，但老是有人忘了下述约定：<strong>定义异常对象时，必须确保程序控制权离开抛出指针的函数后对象仍然继续生存，否则catch的对象已被析构</strong>。具体来说，当我们用指针抛出异常，必须确保该异常是一个static对象或者位于heap中。<br>但这两种情况又引入了新的问题：你不知道该在何时删除它们。中的对象不删除必然会导致资源泄漏，而全局变量无法删除，否则程序行为将不可预测。<br>c++不鼓励通过指针传递异常，四大标准异常：bad_alloc、bad_cast(dynamic_cast失败）、bad_typeid(dynamic_cast操作空指针）、bad_exception(unexpected异常）均不是指向对象的指针，因此你必须通过值或引用来捕获。</p>
<hr>
<h1 id="by-value"><a href="#by-value" class="headerlink" title="by value"></a>by value</h1><p>&nbsp;<br>值捕获有两大缺陷：</p>
<ol>
<li>两次拷贝</li>
<li>slicing problem（由于拷贝静态类型引起）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">exception</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">what</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">runtime_error</span>:</span><span class="keyword">public</span> exception &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validation_error</span>:</span><span class="keyword">public</span> runtime_error &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">what</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (a validation 测试失败) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Validation_error();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        someFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (exception ex) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; ex.what(); <span class="comment">// 调用 exception::what(),而不是 Validation_error::what()</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传值模式在何时都只会调用基类函数，完全丧失了多态性质。</p>
<hr>
<h1 id="by-reference"><a href="#by-reference" class="headerlink" title="by reference"></a>by reference</h1><p>&nbsp;<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (a validation 测试失败) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Validation_error();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        someFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (exception&amp; ex) &#123;<span class="comment">//引用捕获</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; ex.what(); <span class="comment">//Validation_error::what(),</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>如果你通过引用捕获异常(catch by reference),有优点如下：</p>
<ol>
<li>无需担心对象已被析构或者不确定对象何时需要删除（by pointer缺点）</li>
<li>无需拷贝2次且丧失多态性质（by value缺点）</li>
</ol>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>21.以pass-by-refernce-to-const代替pass-by-value</title>
    <url>/2018/04/12/%E4%BB%A5pass-by-refernce-to-const%E4%BB%A3%E6%9B%BFpass-by-value/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br><strong>默认情况下c++以by value方式传递对象至函数</strong>。除非你另外指定，否则函数形参都是实参的副本，返回值也是一个副本。这些副本都由对象的copy构造函数生成，并同时需要析构。反复的构造与析构造就了大量的开销。</p>
<hr>
<h1 id="以pass-by-refernce-to-const代替pass-by-value的优势"><a href="#以pass-by-refernce-to-const代替pass-by-value的优势" class="headerlink" title="以pass-by-refernce-to-const代替pass-by-value的优势"></a>以pass-by-refernce-to-const代替pass-by-value的优势</h1><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>pass-by-refernce-to-const效率极高，因为没有任何构造、析构函数被调用。使用const则使用户不必担心传入的对象遭到任何更改。</p>
<h2 id="避免slicing"><a href="#避免slicing" class="headerlink" title="避免slicing"></a>避免slicing</h2><p>当一个derived class对象以by value的方式传递给base class对象，base class的构造函数会被调用，而derived class的特性却被切割，导致最终得到的就是一个base class对象。<br>pass-by-refernce-to-const 不会导致上述问题，这是由于动态绑定的原因。</p>
<hr>
<h1 id="内置类型与pass-by—reference"><a href="#内置类型与pass-by—reference" class="headerlink" title="内置类型与pass-by—reference"></a>内置类型与pass-by—reference</h1><p>&lt;/br&gt;<br>在编译器的底层实现中，reference往往以指针的形式表现出来，因此pass-by-refernce手法实际上传递的是一个指针。如果你有一个对象是内置类型，那可能用pass-by-value的效率更高一些，stl的迭代器和函数对象也是pass-by-value的效率更高。</p>
<hr>
<h1 id="小型对象与pass-by-reference"><a href="#小型对象与pass-by-reference" class="headerlink" title="小型对象与pass-by-reference"></a>小型对象与pass-by-reference</h1><p>&lt;/br&gt;<br>有读者误以为内置类型使用pass-by_value效率更高，就应该对所有的小型对象使用pass-by-value.这种思想是错误的，对象小并不意味着copy构造函数不昂贵（比如复制该对象需要复制其所有指向的东西，详情可见Effective STL 15）。就算它真的不昂贵，你也不能保证它以后还是不昂贵（未来时态编程 More Effective C++ 32)�，甚至有的时候不同的编译器都会改变type的大小。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>尽量以pass-by-refernce-to-const代替pass-by-value，前者是高效且正确的代名词。</li>
<li>规则1并不适用于内置类型，以及stl的迭代器与函数对象。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>37.令std::thread在所有路径上unjoinable</title>
    <url>/2018/07/18/%E4%BB%A4stdthread%E5%9C%A8%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E4%B8%8Aunjoinable/</url>
    <content><![CDATA[<h1 id="joinable与unjoinable"><a href="#joinable与unjoinable" class="headerlink" title="joinable与unjoinable"></a>joinable与unjoinable</h1><p>&nbsp;<br>每个std::thread对象都处于以下两种状态之一：joinable或unjoinable。joinable std::thread对应于正在运行或可能正在运行的底层异步执行线程。例如，对应于阻塞或等待调度的底层线程的std ::thread是joinable，与已完成运行的底层线程相对应的std::thread对象也可被认为是joinable。</p>
<p>显然，不属于上述情况的std::thread自然为unjoinable，一般而言有四种情况：</p>
<ol>
<li><strong>默认构造的std::thread</strong><br>此类std::thread没有执行函数，因此不对应于任何底层执行线程。</li>
<li><strong>已被move的std::thread</strong><br>move意味着用于对应当前std::thread的底层执行线程现在已对应于别的std::thread。</li>
<li><strong>已被joined的std::thread</strong><br>在joined之后，std::thread对象不再对应于已完成运行的底层执行线程。</li>
<li><strong>已被detached的std::thread</strong><br>detach意味着切断std::thread对象与其对应的底层执行线程之间的连接。</li>
</ol>
<p>std::thread的joinability之所以重要，是因为如果调用joinable线程的析构函数，则将导致当前执行程序意外终止。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设当前存在一个函数doWork，它以过滤器函数filter、最大值maxVal作为参数。doWork检查是否所有计算条件均已符合，然后将计算结果采用过滤器过滤一次。如果进行过滤非常耗时，并且确定是否满足doWork计算条件也很耗时，那么执行并发似乎是一个很好的选择。理论上我们应当采用任务式并发编程（参见Item35），但此项任务需要设定执行filter的线程的优先级，future无法提供这项操作，因此我们只能使用std::thread。实例代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tenMillion = <span class="number">10000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doWork</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; filter,<span class="keyword">int</span> maxVal = tenMillion&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goodVals; <span class="comment">// values that satisfy filter</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::thread t([&amp;filter, maxVal, &amp;goodVals]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)&#123; </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">if</span> (filter(i)) goodVals.push_back(i);</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">auto</span> nh = t.native_handle(); <span class="comment">// use t's native handle to set t's priority</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (conditionsAreSatisfied()) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        t.join(); <span class="comment">// let t finish </span></span></span></span><br><span class="line"><span class="function"><span class="params">        performComputation(goodVals);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// computation was performed</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// computation was not performed</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><br>在描述这段代码的问题之前，我们首先声明在C++14中，tenMillion的声明可以更具可读性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tenMillion = <span class="number">10'000'000</span>; <span class="comment">// C++14</span></span><br></pre></td></tr></table></figure><br>此外，我们似乎不应当在线程已经开始运行后设定优先级，但这并不影响本节的讨论，关于如何令线程暂停的讨论在Item39。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>如果conditionsAreSatisfied()返回true，上述程序一切正常。但如果它返回false或抛出异常，则std::thread对象t在doWork完成时处于joinable状态，这将导致程序意外终止（terminate），因为doWork完成后开始调用t的析构函数。</p>
<p>你可能会认为std::thread析构函数的行为不够合理，但实际上另外两种选择更糟：</p>
<ol>
<li><strong>隐式join</strong><br>在这种情况下，std::thread的析构函数将等待其底层异步执行线程完成。这听起来很合理，但可能导致难以追查的性能缺陷。举例而言，如果conditionsAreSatisfied（）已经返回false，那么doWork等待filiter执行结果是毫无意义的。</li>
<li><strong>隐式detach</strong><br>在这种情况下，std::thread的析构函数将切断std :: thread对象与其底层执行线程之间的连接，底层线程将继续运行。这听起来并不比隐式join合理，但它的破坏性更甚一筹。举例而言，doWork中goodVals是通过引用捕获的局部变量，它会被t中运行的lambda修改（通过push_back)。 那么，假设当lambda异步运行时，conditionsAreSatisfied（）返回false，doWork将返回false，并且其内部的局部变量（包括goodVals）将被销毁，因此底层线程上的执行方法将无以为继（确切的说，它将访问以前是goodVals但现在已经已经变成了别的对象的内存），这直接导致了雪崩。</li>
</ol>
<p>调用一个joinable std::thread的析构函数将引起严重后果，因此标准委员会禁止执行这种操作（一旦执行则触发terminate）。因此作为开发者，我们有责任确保如果使用std::thread对象，它将在所有执行路径保持unjoinable。但是覆盖所有的执行路径并非易事，它包括return、continue、break、goto或异常等能够跳出作用域的情况，这些情况意味着海量的路径。</p>
<p>如果你需要在所有出作用域的地方做某件事，最常见的方法就是将这件事放入到这个局部对象的析构函数中，这项技术被称为RAII（详见Effective C++ Item 13）。std::thread并不是一个RAII类，因为标准委员会拒绝在其析构时执行隐式join或detach，但他们也没想出更好的主意。</p>
<hr>
<h1 id="RAII-thread"><a href="#RAII-thread" class="headerlink" title="RAII thread"></a>RAII thread</h1><p>&nbsp;<br>幸运的是，自己写一个RAII thread并不困难。下述设计将允许调用者指定在销毁ThreadRAII对象时是否应调用join或detach：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRAII</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">DtorAction</span> &#123;</span> join, <span class="built_in">detach</span> &#125;;</span><br><span class="line">    ThreadRAII(<span class="built_in">std</span>::thread&amp;&amp; t, DtorAction a):action(a),t(<span class="built_in">std</span>::<span class="built_in">move</span>(t)) &#123;&#125;</span><br><span class="line">    ~ThreadRAII()&#123;</span><br><span class="line">        <span class="keyword">if</span> (t.joinable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == DtorAction::join) &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.<span class="built_in">detach</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DtorAction action;</span><br><span class="line">    <span class="built_in">std</span>::thread t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>以下该类的一些关键性介绍：</p>
<ol>
<li>构造函数只接受std::thread rvalue，因为我们想将传入的std::thread移动到ThreadRAII对象中（std::thread move-only)。</li>
<li>ThreadRAII提供了一个get成员函数来获取它对应的std::thread对象，这模仿了智能指针的get方法。提供get方法可以避免ThreadRAII实现所有的std::thread的接口。</li>
<li>ThreadRAII析构函数首先检查了std::thread是否是joinable，这一点十分必要，因为在unjoinable的std::thread对象上调用join或detach会导致未定义的行为。</li>
</ol>
<p>ThreadRAII的实际使用案例如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doWork</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; filter,<span class="keyword">int</span> maxVal = tenMillion)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goodVals;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::thread([&amp;filter, maxVal, &amp;goodVals]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)&#123; </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">if</span> (filter(i)) goodVals.push_back(i); &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">                    &#125;),</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadRAII::DtorAction::join</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> nh = t.<span class="built_in">get</span>().native_handle();</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">if</span> (conditionsAreSatisfied()) &#123;</span><br><span class="line">        t.<span class="built_in">get</span>().join();</span><br><span class="line">        performComputation(goodVals);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不难看出，我们选择了在ThreadRAII中调用join函数等待线程执行结束，因为上文提到使用detach可能会导致程序crash，难以调试，虽然join可能会导致性能下降，但权衡二者，似乎性能下降还在可接受范围之内。C++11和C++14没有实现线程中断的机制，该机制可以手动实现，但不在本书的讨论范围之内。</p>
<p>Item17中的三五法则解释了编译器不会为ThreadRAII生成移动操作，但ThreadRAII理应支持移动操作，因此我们可以利用default完成对它们的声明与定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRAII</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">DtorAction</span> &#123;</span> join, <span class="built_in">detach</span> &#125;; <span class="comment">// as before</span></span><br><span class="line">    ThreadRAII(<span class="built_in">std</span>::thread&amp;&amp; t, DtorAction a):action(a), t(<span class="built_in">std</span>::<span class="built_in">move</span>(t)) &#123;&#125;</span><br><span class="line">    ~ThreadRAII()&#123;… <span class="comment">// as before&#125;</span></span><br><span class="line">    ThreadRAII(ThreadRAII&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ThreadRAII&amp; <span class="keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125; <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// as before</span></span><br><span class="line">    DtorAction action;</span><br><span class="line">    <span class="built_in">std</span>::thread t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>确保std::thread在所有路径上unjoinable。</strong></li>
<li><strong>thread析构函数中执行join可能会导致性能下降。</strong></li>
<li><strong>thread析构函数中执行deatch可能会导致程序crash。</strong></li>
<li><strong>将std::thread声明为data member的最后一个成员(因为它一旦初始化就开始运行）。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>24.以non-member non-friend函数替换member函数</title>
    <url>/2018/04/13/%E4%BB%A5non-member%20non-friend%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假定现有一个class网页浏览器，其提供了一些清除cache，历史记录，或者cookies的成员函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可能有用户会试图一起执行这些操作，因此WebBrowser也提供这样一个member函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;<span class="comment">//调用三个成员函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当然，这个功能也可以由一个non-member函数完成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123;</span><br><span class="line">    wb.clearCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.removeCookies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么二者孰优孰劣？</p>
<hr>
<h1 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h1><p>&lt;/br&gt;<br>根据面向对象原则，数据及操作数据的函数应当尽量被捆绑到一起，所以说member函数似乎比non-member函数更能体现封装性。但是事实并非如此<strong>，member函数的封装性较低</strong>。另外，non-member函数可允许对WebBrowser相关机能有较大的packaging flexibility，而这导致了较低的编译相依度，增加了WebBrowser的可延伸性。</p>
<h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><p>如果某些东西被封装，这意味着它不再对外可见，因此我们也拥有了较大的弹性去改变它。因此，愈多东西被封装，我们能够改变它们的能力也就越大。<strong>封装让我们改变事物但只影响有限客户。</strong></p>
<h2 id="封装性的度量"><a href="#封装性的度量" class="headerlink" title="封装性的度量"></a>封装性的度量</h2><p>我们可以粗略地认为，<strong>有越多的函数可以访问某数据，该数据的封装性也就越低</strong>。<br>上节说过，成员变量应该是private，否则这意味着有无限的函数可以访问它。那么显然的，如果一个non-member和一个member实现相同的功能，那我们应该优先使用non-member函数，因为它可以访问的数据很相对较少，也就是拥有更好的封装性。</p>
<hr>
<h1 id="non-member-non-friend函数"><a href="#non-member-non-friend函数" class="headerlink" title="non-member non_friend函数"></a>non-member non_friend函数</h1><p>&lt;/br&gt;<br>以上论述需要注意两点：</p>
<ol>
<li>我们讨论的其实是non-member non-friend函数，因为friend函数与member函数具备相同的封装冲击性。所以从封装的角度而言，这里并非是在member函数与non-member函数之间选择，而是在member函数与non-member non-friend之间选择。</li>
<li>因为在意封装性从而让函数成为class的non-member，并不意味着它不可以是另一个class的member。<br>比如令令成为某个工具类的static member函数，只要它不是WebBrowser的一部分（或成为其friend），就不会影响WebBrowser的private成员封装性。</li>
</ol>
<h2 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h2><p>在C++中，比较自然的方法是令clearBrowser成为一个non-member函数并与WebBrowser处在同一个namespace内：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>namespace的一大优点在于它可以跨越多个源码文件。我们为了实现编译分离，可以在不同的头文件内声明各类函数，然后把他们放在同一个命名空间内。如果我们需要更多的non-member函数，那么我们只需要往namespace里面添加就好了。这种方式允许客户只对他们使用的那一小部分形成编译相依。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>35.优先选择任务式并发编程而非线程式并发编程</title>
    <url>/2018/07/17/%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E5%BC%8F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%80%8C%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%BC%8F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程式编程与任务式编程"><a href="#线程式编程与任务式编程" class="headerlink" title="线程式编程与任务式编程"></a>线程式编程与任务式编程</h1><p>&nbsp;<br>如果当前需要异步运行函数doAsyncWork，我们有两种基本操作。第一种利用std::thread创建线程然后在其上运行doAsyncWork，也就是线程式并发编程：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doAsyncWork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>;</span><br></pre></td></tr></table></figure><br>又或者你可以将doAsyncWork传递给std::async，也就是所谓的任务式并发编程：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(doAsyncWork); <span class="comment">// "fut" for "future"</span></span><br></pre></td></tr></table></figure><br>在上述调用中，传递给std::async的函数对象（doAsyncWork）被认为是一项任务。</p>
<p>任务式并发编程通常优于线程式并发编程，这一点在上述实例中已经有所体现。doAsyncWork存在一个返回值，我们可能在程序运行期间需要使用其返回值，但线程式并发编程无法直接获取这个值，而任务式并发编程则可以，因为std::async返回的future提供了get。此外，如果doAsyncWork抛出异常，我们也可以通过get访问该异常，而线程式并发编程则将直接崩溃（调用std::terminate)。</p>
<p>我们可以认为，线程式与任务式的最本质区别在于任务式具备更高的抽象层次，从而使得开发者不必关注线程管理细节。</p>
<hr>
<h2 id="线程特性"><a href="#线程特性" class="headerlink" title="线程特性"></a>线程特性</h2><p>在C++并发编程中，“thread”具备3大含义：</p>
<ol>
<li><strong>Hardware thread</strong><br>硬件线程是实际执行计算的线程，当代计算机架构为每个CPU核心提供一个或多个硬件线程。</li>
<li><strong>Software thread（OS thread or system thread）</strong><br>软件线程（也称为OS线程或者系统线程）是指那些由操作系统管理，在所有在硬件线程上执行任务的进程和任务。通常可以创建比硬件线程更多的软件线程，因为当软件线程被阻塞时（例如运行于IO以及等待mutex斥或condition variable），可以通过执行其他未阻塞的线程来提高吞吐量。</li>
<li><strong>std::thread</strong><br>std::thread是C++进程中的对象，它充当底层软件线程的句柄。一些std::thread对象表示“null”句柄(即不对应于任何软件线程）。造成这种现象的原因大致有四种：处于default construct state（没有需要执行的函数），已被移动至另一个线程（该std::thread对象便代表了底层软件线程的句柄），已经joined（要运行的函数已经完成）以及已被detached（它与其底层软件线程的联系已被切断）。</li>
</ol>
<hr>
<h2 id="线程式缺陷"><a href="#线程式缺陷" class="headerlink" title="线程式缺陷"></a>线程式缺陷</h2><p>软件线程是受限的资源，如果尝试创建超过系统可以提供的内容，则会抛出std::system_error异常，即使您要运行的函数不能抛出异常也是如此，也就是说即使doAsyncWork是noexcept：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doAsyncWork</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><br>如下语句也可能会抛出一个异常：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>; <span class="comment">// throws if no more threads are available</span></span><br></pre></td></tr></table></figure><br>作风优良的软件必须以某种方式处理这种可能性，但我们应当如何实现？一种方法是在当前线程上运行doAsyncWork，但这可能导致不平衡的负载，并且如果当前线程是GUI线程则又将引起响应性问题。另一个选择是等待一些现有的软件线程执行完毕，然后再次尝试创建一个新的std::thread，但现有的线程可能正在等待doAsyncWork应该执行的操作。</p>
<p>即使你没有将所有线程资源消耗殆尽，也可能会触发oversubscription（即处于ready-to-run的软件线程要多于硬件线程）。当发生这种情况时，线程调度程序（通常是OS的一部分）会对硬件线程上的软件线程进行时间分片。当某个线程的时间片用完时，硬件使用权将交付给另一个线程，完成context switch。context switch增加了系统的整体线程管理开销，并且当硬件线程需要运行的软件线程的上一个时间切片是在另外一个核时，这种切换会变得尤为昂贵。在这种情况下</p>
<ol>
<li><strong>CPU的缓存通常对新的软件线程帮助较少（只包含零丁有用的数据和指令）</strong></li>
<li><strong>新线程运行的内容可能会污染该核的缓存，因为老进程可能马上将回归该核继续执行</strong></li>
</ol>
<p>避免oversubscription十分困难，因为软件与硬件线程的最佳比率取决于软件线程的运行频率，并且该频率是时变而非定常的（例如，当程序从I/O密集区转向计算密集区时）。软件线程与硬件线程的最佳比例还取决于context switch的成本以及软件线程如何有效地使用CPU高速缓存。此外，硬件线程的数量和CPU缓存的具体细节（大小及其相对速度）取决于计算机架构，因此即使调整应用程序以避免oversubscription（同时仍保持硬件繁忙），也无法保证在同一平台下的其他计算机能够流畅运行。</p>
<hr>
<h1 id="std-async优势"><a href="#std-async优势" class="headerlink" title="std::async优势"></a>std::async优势</h1><p>&nbsp;<br>上述难以解决的问题最好交给专业人士解决，而std::async就是那个专业人士：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onus of thread mgmt is on implementer of the Standard Library</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(doAsyncWork);</span><br></pre></td></tr></table></figure><br>此调用将线程管理职责转移到C++标准库的实现者，因此，我们将再也不用担心线程耗尽而产生异常，因为这根本不会产生一个新线程。这一点十分重要，因为std::async以这种方式启动时（即Item38所说的默认启动方式），并不保证它一定会产生一个新线程。事实上，而当存在oversubscription或者线程耗尽时，它将运行调度器安排执行体(在这个例子中是doAsyncWork)在当前需要doAsyncWork返回结果的线程中运行。<br>如果你要自己模拟这个功能，这当然能够实现，只是这有可能会导致负载失衡或者GUI系统中的响应问题，并且这些问题不会仅仅因为你使用的是std::async而消失，只是在std::async中使用调度器帮你解决了这个问题。调度器显然比你更加了解当前机器的负载问题，因为它管理所有进程的线程，而非只了解运行你的代码的那个进程。即使使用std::async，GUI程序仍然会存在响应性问题，因为调度器并不明确哪些线程存在较高的响应需求。在这种情况下，我们应当将std::launch::async启动策略传递给std::async，这将确保要运行的函数真正运行于不同的线程之上（参见条款36）。</p>
<p>目前最先进的线程调度器采用system-wide线程池来避免oversubscription，并且它们还会通过work-stealing算法改善CPU核之间的负载平衡。C++标准并不强制使用线程池或work-stealing算法，而且说实话，某些C++11并发规范的技术层令使用它们比我们想象地更难。尽管如此，一些厂商仍然在其标准库实现中使用了这些技术，并且我们有理由相信会有越来越多的厂商加入他们。如果我们采用任务式并发编程，那些这些技术将自动为我们所用，反之，如果你采用std::thread，那你将不得不手动处理线程耗尽、在oversubscription、负载均衡等等问题。</p>
<hr>
<h1 id="std-thread优势"><a href="#std-thread优势" class="headerlink" title="std::thread优势"></a>std::thread优势</h1><p>&nbsp;<br>尽管任务式并发编程优势巨大，但我们在以下三种情况还是不得不使用std::thread:</p>
<ol>
<li><strong>需要获取底层线程实现的API</strong><br>C++并发API通常使用较低级别平台的特定API实现，通常是pthreads或Windows下的Threads。 目前这些API比C++提供的接口更为丰富。（比如C++没有线程优先级或affinities的概念。）std::thread对象通常具备native_handle成员函数以便于开发者访问底层实现API，而std::future没有对应的功能。</li>
<li><strong>需要针对特定应用完成线程优化</strong><br>具体实例可以是当前我们正在开发一款具有已知执行配置文档的服务器软件，该软件将被部署为某机器的唯一进程。</li>
<li><strong>需要实现C++并发API之外的线程技术</strong><br>例如实现一个线程池等等。</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>std::thread的API中没有直接提供获取执行函数的返回值的方法，如果执行函数中抛出异常，那么程序将立即终止。</strong></li>
<li><strong>基于线程编程需要手动处理线程耗尽、oversubscription、负载均衡以及平台适应性等问题。</strong></li>
<li><strong>通过默认方式调用std::async的任务式并发编程不存在以上任何缺点。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>38.仿函数类与值传递</title>
    <url>/2018/04/18/%E4%BB%BF%E5%87%BD%E6%95%B0%E7%B1%BB%E4%B8%8E%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>c与c++都不允许把函数作为参数传递给其他函数，所以我们传递给函数的是函数指针。比如下述的qsort声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> <span class="built_in">size</span>,<span class="keyword">int</span> (*cmpfcn)(<span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*))</span></span>;</span><br></pre></td></tr></table></figure><br>函数指针是值传递的。</p>
<hr>
<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>&nbsp;<br>STL函数对象是函数指针的一种抽象形式，所以按照惯例，函数对象也是按值传递的，最好的证明就是for_each算法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Functionfor_each</span>(<span class="title">InputIterator</span> <span class="title">first</span>,<span class="title">InputIterator</span> <span class="title">last</span>,<span class="title">Function</span> <span class="title">f</span>);</span><span class="comment">//pass-by-value</span></span><br></pre></td></tr></table></figure><br>显然，函数对象是一个copy，返回值也是一个copy.<br>其实函数对象不一定非要是值传递(显式地写为引用传递），但对于STL用户而言，这一条必须遵守，否则某些算法甚至无法编译。</p>
<h2 id="函数对象的特点"><a href="#函数对象的特点" class="headerlink" title="函数对象的特点"></a>函数对象的特点</h2><p>既然函数对象是值传递的，那它必须满足两条属性：</p>
<ul>
<li>足够小，易于copy</li>
<li>单态，否则拷贝时会造成割裂</li>
</ul>
<h2 id="函数对象的实现"><a href="#函数对象的实现" class="headerlink" title="函数对象的实现"></a>函数对象的实现</h2><p>因为不满足上述两条要求就不用仿函数类是愚蠢的，实际上我们有的是办法让大的或者是多态的函数对象以值传递的方式进入STL.<br>具体方法是：<strong>把所需的数据和虚函数从仿函数类中分离出来，放到新的类中；然后在仿函数类中包含一个指针，指向这个新类的对象。</strong><br>例如，我们需要建立一个包含了大量数据并且使用了多态性的函数子类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFC</span>:</span><span class="keyword">public</span> unary_function&lt;T, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Widget w;<span class="comment">//存有大量数据</span></span><br><span class="line">    Int x; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> <span class="keyword">const</span></span>; <span class="comment">//虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样把BPFC作为仿函数类是肯定不行的，正确做法<strong>是建立一个包含一个指向实现类的指针的小而单态的类，然后把所有数据和虚函数放到实现类</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFCImpl</span>:</span><span class="keyword">public</span> unary_function&lt;T, <span class="keyword">void</span>&gt; &#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Widget w; </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~BPFCImpl();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BPFC</span>&lt;T&gt;;</span><span class="comment">//友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFC</span>:</span><span class="keyword">public</span> unary_function&lt;T, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BPFCImpl&lt;T&gt; *pImpl;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        pImpl-&gt;<span class="keyword">operator</span>() (val);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然,虽然BPFC是小而单态的，但是其内部的指针在访问时具备了多态性，并且可以访问大量数据。这种技巧在设计模式中被称为Bridge，但我们一定更熟悉另一个名字：PIMPL；</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>函数对象总是通过值传递，因此他们必须小且单态。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>STL</tag>
        <tag>仿函数</tag>
      </tags>
  </entry>
  <entry>
    <title>9.使用alias declarations而非typedefs</title>
    <url>/2018/06/27/%E4%BD%BF%E7%94%A8alias%20declarations%E8%80%8C%E9%9D%9Etypedefs/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>想必没有人愿意反复写下诸如<code>std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt; &gt;</code>的类型名，本节将介绍如何在C++11中避免这种繁琐无聊的工作。</p>
<hr>
<h1 id="typedef与alias-declarations"><a href="#typedef与alias-declarations" class="headerlink" title="typedef与alias declarations"></a>typedef与alias declarations</h1><p>&nbsp;<br>C++98中的typedef可以有效帮助我们解决问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &gt; </span><br><span class="line">    UPtrMapSS;</span><br></pre></td></tr></table></figure><br>C++11提供的alias declarations也能发挥同样的作用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UPtrMapSS =</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &gt;;</span><br></pre></td></tr></table></figure><br>相对于前者，后者有一个压倒性的技术优势。</p>
<hr>
<h1 id="alias-declarations优势"><a href="#alias-declarations优势" class="headerlink" title="alias declarations优势"></a>alias declarations优势</h1><p>&nbsp;<br>在讲述真正的优势之前，首先提一下很多人认为在涉及函数指针类型时alias declarations更容易接受：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FP is a synonym for a pointer to a function </span></span><br><span class="line"><span class="comment">// taking an int and a const std::string&amp; and returning nothing</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>; <span class="comment">// typedef</span></span><br><span class="line"><span class="keyword">using</span> FP = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;); <span class="comment">// alias declaration</span></span><br></pre></td></tr></table></figure><br>但事实上，在函数指针类型方面二者并无明显优劣，而且很少有人花费很多时间处理函数指针类型，因此这并不是一个令人信服的理由来认为alias declarations强于typedef。</p>
<h2 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h2><p>alias declarations真正强于typedef的一点在于，前者可以被模板化(在这种情况下我们把它称为alias template),因此使用alias declarations则不必像传统的C++98那样将typedef嵌入模板中。举例而言，假若我们需要为一个具备自定义allocator的list定义别名，使用alias declaration可以写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt;; <span class="comment">// is synonym for std::list&lt;T,MyAlloc&lt;T&gt; &gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br></pre></td></tr></table></figure><br>为了达到同样的效果，typedef则必须写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br></pre></td></tr></table></figure><br>如果需要在模板中使用类型别名，那么typedef定义的别名还需要使用typename进行修饰：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type <span class="built_in">list</span>; <span class="comment">// as a data member</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果我们将MyAllocList定义为一个alias template，则不必需要各种修饰（诸如typename以及::type):<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MyAllocList&lt;T&gt; <span class="built_in">list</span>; <span class="comment">// no "typename",</span></span><br><span class="line">    … <span class="comment">// no "::type"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当编译器在处理Widget模板时遇到MyAllocList&lt;T&gt;，它会直接明确当前是一个类型，因为MyAllocList&lt;T&gt;是一个alias template。但当编译器在Widget模板中看到MyAllocList&lt;T&gt;::type（即使用嵌套的typedef）时,编译器无法确定它是否意味着一个类型（因为可能存在MyAllocList的特化)，因此需要加以typename修饰。这并非编译器无理取闹，因为真的可能会有一些人将type作为class的data member：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wine</span> &#123;</span> … &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAllocList</span>&lt;Wine&gt; &#123;</span><span class="comment">// MyAllocList specialization for when T is Wine</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">WineType</span> &#123;</span> White, Red, Rose &#125;;<span class="comment">// see Item10 for "enum class"</span></span><br><span class="line">    WineType type;<span class="comment">// type is a data member</span></span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="TMP中的alias-declarations"><a href="#TMP中的alias-declarations" class="headerlink" title="TMP中的alias declarations"></a>TMP中的alias declarations</h2><p>如果你使用过TMP（模板元编程）的话，你一定遇到过需要根据模板类型参数来来创建新类型的需求，例如，你可能想要将const std::string＆转换为std::string,又或者将Widget转换为const Widget或Widget＆（Item23与27讲给出一些TMP实例）。<br>C++11以type traits的形式提供了执行这些类型转换的必要工具，这一系列模板位于头文件&lt;type_traits&gt;中。该头文件内存在10多个type traits，并且并非所有都提供转换操作（具备转换功能的都提供了一个预见性接口）。如果你需要转换类型，只需要如下操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::remove_const&lt;T&gt;::type <span class="comment">// yields T from const T</span></span><br><span class="line"><span class="built_in">std</span>::remove_reference&lt;T&gt;::type <span class="comment">// yields T from T&amp; and T&amp;&amp;</span></span><br><span class="line"><span class="built_in">std</span>::add_lvalue_reference&lt;T&gt;::type <span class="comment">// yields T&amp; from T</span></span><br></pre></td></tr></table></figure></p>
<p>这里并非是传授如何在C++中使用type traits完成类型转换，我们应当把目光焦点放到上述代码最后的type之上。由于它们的性质原因，你在实际开发过程中在使用它们之前总需要冠上typename。C++11在设计type trits时将其设计为嵌套式typedef，这并非是因为嵌套式typedef比alias declarations更好用，而是由于历史遗留原因。C++14引入了新的别名模板，形如std::transformation_t,实际使用效果如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::remove_const&lt;T&gt;::type <span class="comment">// C++11: const T → T</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">remove_const_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br><span class="line"><span class="built_in">std</span>::remove_reference&lt;T&gt;::type <span class="comment">// C++11: T&amp;/T&amp;&amp; → T</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br><span class="line"><span class="built_in">std</span>::add_lvalue_reference&lt;T&gt;::type <span class="comment">// C++11: T → T&amp;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">add_lvalue_reference_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br></pre></td></tr></table></figure><br>即使你的编译器不支持C++14,那使用alias declaration对type traits进行封装也并非难事，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">remove_const_t</span> = <span class="title">typename</span> <span class="title">remove_const</span>&lt;T&gt;:</span>:type;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">remove_reference_t</span> = <span class="title">typename</span> <span class="title">remove_reference</span>&lt;T&gt;:</span>:type;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">add_lvalue_reference_t</span> =</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">add_lvalue_reference</span>&lt;T&gt;:</span>:type;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>typedef并不支持模板化，但alias declarations支持。</strong></li>
<li><strong>alias declarations不需要type、typename之类的后缀与修饰。</strong></li>
<li><strong>C++14引入了alias templates以取代C++11中的type traits转换。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>28.使用base将reverse_iterator转为iterator</title>
    <url>/2018/04/14/%E4%BD%BF%E7%94%A8base%E5%B0%86reverse_iterator%E8%BD%AC%E4%B8%BAiterator/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>我们可以通过reverse_iterator的base函数将其转为iterator，只是其结果可能和我们预想的存在出入。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>考虑如下程序:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>；i &lt; <span class="number">5</span>; ++ i) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator ri = <span class="built_in">find</span>(v.rbegin(), v.rend(), <span class="number">3</span>);<span class="comment">//ri指向3</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">i</span><span class="params">(ri.base())</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="转换关系图"><a href="#转换关系图" class="headerlink" title="转换关系图"></a>转换关系图</h2><p><img src="http://static.zybuluo.com/zsmj2017/3tt528o2ija2a4p7yasbbuwi/image_1cb13q24e2eq1tpbfst11rl12hjp.png" alt="image_1cb13q24e2eq1tpbfst11rl12hjp.png-14.2kB"><br>这张图清楚地展示了偏移量，但对我们解决实际问题毫无帮助。众所周知，insert与erase只接受iterator形式的参数，我们该如何通过base()来正确地完成这二者的操作呢？</p>
<hr>
<h1 id="base与insert、erase"><a href="#base与insert、erase" class="headerlink" title="base与insert、erase"></a>base与insert、erase</h1><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>我们假定需要在ri指出的位置插入一个99。<br>因为ri遍历的顺序是自右向左，而且insert会把新元素插入到ri位置，并且把原先ri位置的元素依次移动到符合遍历顺序的下一个位置，综上，插入后应该是这样：<img src="http://static.zybuluo.com/zsmj2017/a5vasjdb7fmvwx4yo0w76mrg/image_1cb14faq517l4kkhivjap118oi16.png" alt="image_1cb14faq517l4kkhivjap118oi16.png-3.8kB"><br>显然，99正对应着base的位置，事实上有结论如下：<br><strong>如果要在一个reverse指出的位置上插入新元素，直接使用base即可，对于insert而言，ri.base()就是ri对应的iterator.</strong></p>
<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><p>如果要删除3肯定不能使用base了，因为base指向4.<br>但也不是没有解决办法，ri的base指向4，(++ri).base()不就指向3了吗，所以说<strong>核心在于先自增</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.erase((++ri).base());</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>8.使用nullptr而非0或NULL</title>
    <url>/2018/06/27/%E4%BD%BF%E7%94%A8nullptr%E8%80%8C%E9%9D%9E0%E6%88%96NULL/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>首先需要明确一点：0是一个int，而非指针。C++在一个应该出现指针但只出现了0的环境下会把这个0看作为一个空指针，但这并不代表0与空指针等价。NULL也是一样，虽然它可能是int或者long。总之，0或NULL都不是指针。</p>
<hr>
<h1 id="0与NULL可能导致的二义性"><a href="#0与NULL可能导致的二义性" class="headerlink" title="0与NULL可能导致的二义性"></a>0与NULL可能导致的二义性</h1><p>&nbsp;<br>在C++98中，对整数型与指针类型进行重载可能会发生意外（即重载区别仅在一个函数的形参为类似int型，一个形参为pointer）。将0或NULL传递给这样的重载函数永远不会调用其指针重载版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// three overloads of f</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line">f(<span class="number">0</span>); <span class="comment">// calls f(int), not f(void*)</span></span><br><span class="line">f(<span class="literal">NULL</span>); <span class="comment">// might not compile, but typically calls f(int). Never calls f(void*)</span></span><br></pre></td></tr></table></figure><br>显然，如果将NULL定义为0L，那么本次函数调用具有二义性，原因在于从long到int、从long到bool以及从0L到void*具备同样的转换优先级。关于该调用，有趣之处在于，你以为你在执行f(the null pointer),实际上它意味着f（some kinds of intergral）。</p>
<p>这种违反直觉的行为直接导致C++98规定开发者应当避免以指针和整型类型作为重载参数。这项原则在C++11中仍然适用，因为尽管目前提倡以nullptr代替0与NULL，但仍有许多开发者孜孜不倦地使用后者。</p>
<hr>
<h1 id="Nullptr的优点"><a href="#Nullptr的优点" class="headerlink" title="Nullptr的优点"></a>Nullptr的优点</h1><h2 id="避免调用二义性"><a href="#避免调用二义性" class="headerlink" title="避免调用二义性"></a>避免调用二义性</h2><p>Nullptr的优势在于它不是一个整形，实际上它也不是一个指针类型，不过你可以认为它是一个可以指向任何类型的指针类型。nullptr的实际类型是std::nullptr_t，并且std::nullptr_t被定义为nullptr的类型（一个奇怪的循环）。std::nullptr_t类型可以隐式转换为所有原始指针类型，因此nullptr看起来像是一个可以指向所有类型的指针。<br>调用f(nullptr)时将直接触发指针重载版本，原因在于nullptr不可能转为任何整形：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(<span class="literal">nullptr</span>); <span class="comment">// calls f(void*) overload</span></span><br></pre></td></tr></table></figure></p>
<h2 id="提高代码清晰度"><a href="#提高代码清晰度" class="headerlink" title="提高代码清晰度"></a>提高代码清晰度</h2><p>在涉及到auto声明的变量时，使用nullptr可以提高代码清晰度，有实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = findRecord( <span class="comment">/* arguments */</span> );</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果我们不清楚findRecord的返回类型，我们可能在看代码时可能会困惑result究竟是一个指针还是一个整形，但下述代码则十分明晰：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = findRecord( <span class="comment">/* arguments */</span> );</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;<span class="comment">// result must be a pointer</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="template中的nullptr"><a href="#template中的nullptr" class="headerlink" title="template中的nullptr"></a>template中的nullptr</h1><p>nullptr在template中能够发挥更大的作用。假设当前有一些函数，它们只有在某些互斥量被锁定时才会被调用,每一个函数的形参都是一个指针类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw)</span></span>;    <span class="comment">// call these only when</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; upw)</span></span>; <span class="comment">// the appropriate</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f3</span><span class="params">(Widget* pw)</span></span>;                    <span class="comment">// mutex is locked</span></span><br></pre></td></tr></table></figure><br>现将以空指针作为实参完成函数调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex f1m, f2m, f3m; <span class="comment">// mutexes for f1, f2, and f3</span></span><br><span class="line"><span class="keyword">using</span> MuxGuard = <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt;; <span class="comment">// C++11 typedef; see Item 9</span></span><br><span class="line">… </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f1m)</span></span>; <span class="comment">// lock mutex for f1</span></span><br><span class="line">    <span class="keyword">auto</span> result = f1(<span class="number">0</span>); <span class="comment">// pass 0 as null ptr to f1</span></span><br><span class="line">&#125; <span class="comment">// unlock mutex</span></span><br><span class="line">… </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f2m)</span></span>; <span class="comment">// lock mutex for f2</span></span><br><span class="line">    <span class="keyword">auto</span> result = f2(<span class="literal">NULL</span>); <span class="comment">// pass NULL as null ptr to f2</span></span><br><span class="line">&#125;</span><br><span class="line">… </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f3m)</span></span>; <span class="comment">// lock mutex for f3</span></span><br><span class="line">    <span class="keyword">auto</span> result = f3(<span class="literal">nullptr</span>); <span class="comment">// pass nullptr as null ptr to f3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这明显造成了代码重复，因此我们决定对此过程执行模板化操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType,<span class="keyword">typename</span> MuxType,<span class="keyword">typename</span> PtrType&gt;</span><br><span class="line">auto lockAndCall(FuncType func,MuxType&amp; mutex,PtrType ptr) -&gt; decltype(func(ptr))&#123;// C++11</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> func(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType,<span class="keyword">typename</span> MuxType,<span class="keyword">typename</span> PtrType&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">lockAndCall</span><span class="params">(FuncType func, MuxType&amp; mutex,PtrType ptr)</span></span>&#123;<span class="comment">// C++14</span></span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> func(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你可能会这样调用模板函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> result1 = lockAndCall(f1, f1m, <span class="number">0</span>); <span class="comment">// error!</span></span><br><span class="line"><span class="keyword">auto</span> result2 = lockAndCall(f2, f2m, <span class="literal">NULL</span>); <span class="comment">// error!</span></span><br><span class="line"><span class="keyword">auto</span> result3 = lockAndCall(f3, f3m, <span class="literal">nullptr</span>); <span class="comment">// fine</span></span><br></pre></td></tr></table></figure><br>当0传入模板函数时，PtrType被推衍为int类型，此时func会发现int无法转为一个指针类型，进而编译失败。使用NULL也是类似的道理，PtrType被推衍为一个整数类型，无法转为func的参数类型。</p>
<p>总之，template类型推衍无法识别出0或NULL所具备的空指针身份，因此我们应当积极使用nullptr代替它们。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>应当尽可能以nullptr取代0与NULL。</strong></li>
<li><strong>应当避免对整数型与指针类型之间的重载。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>44.以成员函数代替同名算法</title>
    <url>/2018/04/20/%E4%BB%A5%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF%E5%90%8C%E5%90%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>有些容器提供了与泛型算法相同名称的成员函数，比如关联容器提供了count、find、lower_bound、upper_bound和equal_range，<br>而list提供了remove、remove_if、unique、sort、merge、reverse。<br>我们提倡使用成员函数代替同名算法，第一是因为它们的结合性更好，第二是因为它们更快。</p>
<hr>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>假设我们需要在一个容纳了百万元素的set中查找727的位置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set&lt;int&gt; s; &#x2F;&#x2F; 建立set，放入1,000,000个数据</span><br><span class="line">auto i &#x3D; s.find(727); &#x2F;&#x2F;使用find成员函数</span><br><span class="line">auto i &#x3D; find(s.begin(), s.end(), 727); &#x2F;&#x2F; 使用find算法</span><br></pre></td></tr></table></figure><br>find成员函数消耗对数时间，而泛型算法消耗线性时间。原因在于set基于红黑树，红黑树的查找操作只需要对数时间。（完全平衡树所需要的时间更短，但总体效率差于红黑树）</p>
<p>效率并不是唯一的差别，众所周知，<strong>STL算法判同基于相等，而关联容器是基于等价</strong>，因此查找算法可能会返回给你不同的结果。为了行为一致，我们应该更倾向于使用成员函数。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>泛型算法及其不适用于map与multimap，因为它们内部元素是pair，因此count成员函数只统计key匹配的pair数目，find等成员函数也是如此，但是泛型算法会使用相等性测试来统计具有相同键和值的pair对象的个数。如果你只希望检查key，那你只能在vector内部存pair代替关联容器。（Effective STL 23)</p>
<hr>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>&nbsp;<br>对于list而言，使用成员函数最大的提升在于效率。list的成员函数不进行任何拷贝，它们只是简单地操纵连接list节点的指针。算法和它所使用的时间复杂度相同，但是算法需要拷贝。<br>另外，list成员函数的行为可能与算法并不一样，list的remove或unique等函数无需执行erase.<br>sort算法不能用于list的双向迭代器，merge算法不能修改源范围，但list的同名成员函数可以。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>14.使用reverse避免重新分配</title>
    <url>/2018/04/10/%E4%BD%BF%E7%94%A8reverse%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>(本章内容笔者认为可通过合理的初始化完成）</p>
<p>vector与string可以动态增长，其增长操作大概等价于realloc，分为4个部分（关于具体实现，C++ Primer 以及 数据结构·向量篇 均有涉及）</p>
<ol>
<li>分配当前cap*2的内存</li>
<li>把元素拷贝到新内存起始处</li>
<li>销毁旧有对象</li>
<li>收回原内存</li>
</ol>
<p>这些步骤的开销极大，并且执行了这些后同时还需要更新现在正在使用的迭代器或者指针之类。reserve可以最大幅度避免这些开销。</p>
<p>在说reverse之前，首先复习4个vector或string的成员函数</p>
<blockquote>
<ul>
<li>size：当前容器内的元素个数</li>
<li>capacity：最大容纳个数</li>
<li>resize：强制将元素个数变为n个，调用构造或者析构，不影响cap.如果n&gt;cap,则realloc.</li>
<li>reserve：将cap改为至少n，如果n&lt;cap,无动作，否则realloc.同时不改变size.</li>
</ul>
</blockquote>
<p>为了避免大量的realloc操作，我们可以一旦建立容器就立刻reserve到一个合适的大小（为啥不好好初始化）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) v.push_back(i);</span><br></pre></td></tr></table></figure><br>上述操作大约会导致2到10次重新分配。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reserve(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) v.push_back(i);</span><br></pre></td></tr></table></figure><br>这则不会导致重新分配。</p>
<p>通常有两种情况可以使用reverse来避免重新分配：</p>
<ol>
<li>你了解容器最终大致的元素个数（不如好好初始化 然后赋值 不过一旦估算少了会越界）</li>
<li>保留你可能需要的最大空间，添加完成后修整掉多余的容量。（修整操作见Effective STL 17）</li>
</ol>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>12.使用override来修饰需要覆写的虚函数</title>
    <url>/2018/06/30/%E4%BD%BF%E7%94%A8override%E6%9D%A5%E4%BF%AE%E9%A5%B0%E9%9C%80%E8%A6%81%E8%A6%86%E5%86%99%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>OOP的最重要的特性即为多态，其具体表现为派生类中的虚函数实现override了基类的实现。本节将重点讨论使用override确保你真正完成了override操作。</p>
<hr>
<h1 id="override约束"><a href="#override约束" class="headerlink" title="override约束"></a>override约束</h1><p>&nbsp;<br>尽管override与overload长得很像，但实际上根本就不是一回事。下面将通过一个实例展示如何通过一个基类接口调用派生类函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>; <span class="comment">// base class virtual function</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>; <span class="comment">// overrides Base::doWork virtual" is optional here</span></span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Base&gt; upb = <span class="built_in">std</span>::make_unique&lt;Derived&gt;();</span><br><span class="line">upb-&gt;doWork(); <span class="comment">// call doWork through base class ptr derived class function is invoked</span></span><br></pre></td></tr></table></figure></p>
<p>发生需要满足以下要求：</p>
<ol>
<li><strong>基类函数必须为虚函数。</strong></li>
<li><strong>基类函数与派生类函数名称必须相同（析构函数除外）。</strong></li>
<li><strong>基类函数与派生类函数形参类型必须相同。</strong></li>
<li><strong>基类函数与派生类函数必须具备同样的constness。</strong></li>
<li><strong>基类函数与派生类函数返回值类型与异常规格必须匹配（至少可以转换？）</strong></li>
</ol>
<p>在这些基础之上，C++11又增加了一个新的要求：</p>
<ol>
<li><strong>基类函数与派生类函数的reference qualifier（引用限定符）必须相同。</strong><br>成员函数reference qualifier是C++11不太为人所熟知的特性之一，其功能为将成员函数的使用限定为左值或右值，它们的存在与virtual不具备关联性，以下为实例展示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   …</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>; <span class="comment">// this version of doWork applies only when *this is an lvalue</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>; <span class="comment">// this version of doWork applies only when *this is an rvalue</span></span><br><span class="line">&#125;;</span><br><span class="line">…</span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>; <span class="comment">// factory function (returns rvalue)</span></span><br><span class="line">Widget w; <span class="comment">// normal object (an lvalue)</span></span><br><span class="line">…</span><br><span class="line">w.doWork(); <span class="comment">// calls Widget::doWork for lvalues (i.e., Widget::doWork &amp;)</span></span><br><span class="line">makeWidget().doWork(); <span class="comment">// calls Widget::doWork for rvalues (i.e., Widget::doWork &amp;&amp;)</span></span><br></pre></td></tr></table></figure>
有关reference qualifier的介绍以后再说，这里需要强调的是，如果派生类需要override基类函数，那么它们需要具备同样的refernce qualifier，否则基类版本将依旧出现在派生类之中并且不会被override。</li>
</ol>
<hr>
<h1 id="override声明"><a href="#override声明" class="headerlink" title="override声明"></a>override声明</h1><p>&nbsp;<br>上述约束表明即使一个很小的失误也可能会导致override无法成功，并且编译器将不会对没有发生override的情况进行通知。例如下个实例中并没有发生override，你能够定位出是哪些地方出了问题吗？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>答案分别为：</p>
<ol>
<li><strong>mf1在基类中为const</strong></li>
<li><strong>mf2在基类中形参为int</strong></li>
<li><strong>mf3在基类中被限定为左值</strong></li>
<li><strong>mf4在基类中没有被声明为virtual</strong></li>
</ol>
<p>鉴于派生类中声明的virtual函数很容易无法覆写基类中对应的函数，并且编译器并不会对未发生override的行为发出警告，因此C++11提供了一种显式的声明方式表示当前函数需要override基类中对应的函数，其使用方式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上述代码将无法通过编译，因为编译器会认真地检查其是否如实override了基类版本，这正是我们想要的。真正能够通过编译的代码有形式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// adding "virtual" is OK,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="override优点"><a href="#override优点" class="headerlink" title="override优点"></a>override优点</h1><p>&nbsp;<br>使用override不仅仅能够让编译器告诉你某函数是否发生了override，还能够在你试图更改基类虚函数签名时观察到对派生类的影响。只需要在更改签名后查看有多少派生类函数编译失败，即可权衡更改签名是否值得。如果没有override声明，那你则不得不需要一个全面的单元测试以判断所有分支。</p>
<p>C++11引入的两个新关键词final与override均为contextual keywords，即只有在特定环境下才有其存在意义。以override来说，它仅出现于成员函数声明式末尾。这也就是说历史遗留代码中的名称override依然合法，不会触发标识符不合法的行为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warning</span> &#123;</span> <span class="comment">// potential legacy class from C++98</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">override</span><span class="params">()</span></span>; <span class="comment">// legal in both C++98 and C++11 with the same meaning</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="reference-qualifier"><a href="#reference-qualifier" class="headerlink" title="reference qualifier"></a>reference qualifier</h1><p>&nbsp;<br>如果你希望某个函数只接受左值或右值参数，那你完全可以这样声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Widget&amp; w)</span></span>; <span class="comment">// accepts only lvalue Widgets</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Widget&amp;&amp; w)</span></span>; <span class="comment">// accepts only rvalue Widgets</span></span><br></pre></td></tr></table></figure><br>reference qualifier的作用与之类似，其形参可以看作为*this，它通过判断*this的左右属性来进行决断，从某种意义而言，非常类似于const成员函数。</p>
<p>举例而言，我们的Widget类有一个std::vector数据成员，并且我们给用户提供了一个接口以确保用户可以直接访问它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;; <span class="comment">// see in Item9</span></span><br><span class="line">    <span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> values; &#125;</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然这个东西根本不能体现出一丝一毫的封装性，但我们先不管他，看看用户可能进行的操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> vals1 = w.data(); <span class="comment">// copy w.values into vals1</span></span><br></pre></td></tr></table></figure><br>由于w.data()返回一个左值引用，因此vals的类型被推衍为vector<double>,利用values初始化之。<br>假设我们当前有一个工厂函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>并且我们希望利用工厂函数生成的无名对象（临时对象）来初始化一个vector：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> vals2 = makeWidget().data(); <span class="comment">// copy values inside the Widget into vals2</span></span><br></pre></td></tr></table></figure><br>和上一次不同的是，本次设计不应当执行copy操作，因为从临时对象中获取数据使用move更好，但由于data返回一个左值引用，所以拷贝依然会发生。显然这里存在可以优化之处，但试图让编译器给你优化是不切实际的。因此我们需要使用reference qualifier来限定当widget为右值时data()返回值也应当是一个右值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    …</span><br><span class="line">    <span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> values; &#125; <span class="comment">// for lvalue Widgets,return lvalue</span></span><br><span class="line">    <span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">move</span>(values); &#125; <span class="comment">// for rvalue Widgets,return rvalue</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一切大功告成。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;</p>
<ol>
<li><strong>将需要覆写的函数声明为override。</strong></li>
<li><strong>reference qualifier可以针对对象的左右值属性实现重载。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>48.使用traits classes表现类型信息</title>
    <url>/2018/04/23/%E4%BD%BF%E7%94%A8traits%20classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&nbsp;<br>STL主要由“容器、迭代器、算法”的templates构成，但也覆盖了若干工具性templates，其中有一个名为advance，用来将迭代器移动若干距离：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> Dist&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter,DistT d)</span></span>;</span><br></pre></td></tr></table></figure><br>理论上来说这种操作肯定是执行<code>iter+=d</code>操作到达指定位置，但事实上，只有random access迭代器才支持+=操作，其它功能略弱的迭代器只能反复执行自增或者自减以达到同样的效果。</p>
<hr>
<h1 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h1><p>&nbsp;<br>我们首先回顾一下STL中迭代器的分类：</p>
<ol>
<li>input与output迭代器<br>它们只能向前移动，一次一步，用户只能读取/涂写它们所指的东西，显然这是在模仿输入输出文件的读写指针。istream_iterator与ostream_iterator是这一类迭代器的代表。<br>由于这两类都只能向前移动，并且最多读写一次，所以他们只适合“一次性操作算法”。</li>
<li>forward迭代器<br>这类迭代器能完成input与output迭代器所做的任何事，并且可以读或写其所指物一次以上。所以它们可执行多次性算法。STL并未提供SingleLinked List，但不难想象，这类容器的迭代器就是forward迭代器。</li>
<li>Bidirection迭代器<br>比上一类更加强大，支持双向移动。STL中list,map,set(以及它们的multi版本）的迭代器就属于这一分类。</li>
<li>random access迭代器<br>在Bidirection迭代器的基础上支持了算术操作，也就是说可以在常量时间内前后移动任意距离。这种操作类似于指针算术，而它也确实以内置指针为榜样。vector，deque，string的迭代器便是这种类型。</li>
</ol>
<p>对于这5种分类，C++标准程序库分别提供专属的卷标结构（tag struct）加以确认：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>:</span><span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span><span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span><span class="keyword">public</span> bidirection_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><br>它们之间的关系是自上而下的标准的public继承，即：forward迭代器都必然是一个input迭代器，诸如此类。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>将目光拉回至advance函数。既然不同的迭代器具有不同的性质，那我们自然会想到：针对不同的迭代器，advance内部执行不同的操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> Dist&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT &amp;it,Dist d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iter is <span class="built_in">random</span> accesss iterator)&#123;</span><br><span class="line">        it+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(...) ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种做法必须首先判断当前迭代器是否为random access迭代器，也就是说需要取得类型的某些信息。<strong>这就是traits的工作：允许你在编译期获取某些类型信息。</strong></p>
<hr>
<h1 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h1><p>&nbsp;<br>Traits并非是c++的某个关键词或者一个事先定义好的构件；这是一种技术，也是c++程序员共同遵循的协议。其内置要求之一是<strong>：对于内置类型与用户自定义类型的表现必须一样好</strong>。举例而言，即如果上述advance接受的是一个指针与一个int参数，它必须仍然可以有效运作。</p>
<h2 id="Traits的实现"><a href="#Traits的实现" class="headerlink" title="Traits的实现"></a>Traits的实现</h2><p>Traits必须可以施加于内置类型，表明我们不应该使用“在自定义类型里附加信息”的技术，因为原始指针无法附加信息。<br>标准技术是把它放进一个template及一个或者多个特化版本中。针对迭代器的版本名为iterator_traits:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>;</span><span class="comment">//处理迭代器分类信息</span></span><br></pre></td></tr></table></figure><br>iterator_traits是一个struct。习惯上我们总是定义traits为structs，但它们又往往被称为traits classes。</p>
<h2 id="Traits的运作方式"><a href="#Traits的运作方式" class="headerlink" title="Traits的运作方式"></a>Traits的运作方式</h2><p>仍以迭代器为例，iterator_traits的运作机理是，<strong>针对每一个类型IterT，在struct iterator_traits中必然声明了某个typedef名为iterator_category.这个typedef用来确认IterT的迭代器分类。</strong></p>
<hr>
<h2 id="实现iterator-traits"><a href="#实现iterator-traits" class="headerlink" title="实现iterator_traits"></a>实现iterator_traits</h2><h3 id="自定义用户类型"><a href="#自定义用户类型" class="headerlink" title="自定义用户类型"></a>自定义用户类型</h3><p>iterator_traits以两个部分来实现上述要求。<br>首先，它要求每个“用户自定义的迭代器类型”必须嵌套一个typedef，名为iterator_category，用以确认当前的卷标结构。举例而言，deque的迭代器可能如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>而list的迭代器可双向行进，所以它们应当这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category；</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>至于iterators_traits，则是被动响应iterator class的嵌套式typedef：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>上述设计对自定义类型而言没问题，但对指针则行不通，因为指针不可能嵌套typedef，因此iterators_traits为指针类型提供了一个偏特化版本，如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;IterT *&gt;&#123;</span><span class="comment">//偏特化</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_cagetory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设计一个traits classes需要以下步骤：</p>
<ol>
<li>确认若干个你希望将来可以取得的信息（例如对迭代器的分类category）</li>
<li>为该信息提供名称（如iterator_category）</li>
<li>提供一个template与一组特化版本</li>
</ol>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>有了iterator_traits后我们似乎可以执行先前的伪代码了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> Dist&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; it,Dist d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::iterator_cagetory)==</span><br><span class="line">        <span class="keyword">typeid</span>(<span class="built_in">std</span>::random_access_iterator_tag))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在先不去考虑无法编译的问题。正如我们所知，IterT是在编译期获知，所以iterator_traits&lt;IterT&gt;::iterator_category也可以在编译期间确定，关键在于if语句发生在运行期，怎么把它移动到编译期执行呢？</p>
<p><strong>我们所需要的是一个能在编译期完成if…else操作的条件式，C++恰巧有某种特性支持这种行为：重载。</strong></p>
<p>当我们重载某个函数f，我们必须详细叙述各个重载件的参数类型。当你调用f，编译期便根据实参选择最恰当的重载件。这简直为我们的问题量身定制。针对advance函数，我们所需要做的就是产生两版重载函数，内含advance的真正操作，但各自接受不同类型的iterator_category对象。具体如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> Dist&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doadvance</span><span class="params">(IterT &amp;iter,Dist d,<span class="built_in">std</span>::random_access_iterator_tag)</span></span>&#123;</span><br><span class="line">    iter+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> Dist&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doadvance</span><span class="params">(IterT &amp;iter,Dist d,<span class="built_in">std</span>::bidirectional_iterator_tag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(d++) --iter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> Dist&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doadvance</span><span class="params">(IterT &amp;iter,Dist d,<span class="built_in">std</span>::input_iterator_tag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Negative distance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为forward_iterator_tag继承自input_iterator_tag，所以无需为它定义一个重载函数，这也是public继承的一大优点：针对base class编写的代码用于derived class身上一样有效。</p>
<p>最终，advance函数的实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> Dist&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT &amp;iter,Dist d)</span></span>&#123;</span><br><span class="line">    doadvance(iter,d,<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="如何使用traits-classes"><a href="#如何使用traits-classes" class="headerlink" title="如何使用traits classes"></a>如何使用traits classes</h2><ol>
<li>建立一组重载函数或函数模板（doadvance），彼此之间的差异仅在于各自的traits参数，令每个函数实现码与其接受的traits信息相匹配。</li>
<li>建立一个控制函数或函数模板（advance），它调用上述函数并传递traits class所提供的信息。</li>
</ol>
<hr>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ol>
<li>traits class使得“类型相关信息”在编译期可用，它们以templates和偏特化完成实现。</li>
<li>整合重载技术后我们可以在编译期执行ifelse测试。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>迭代器</tag>
        <tag>模板与泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>18.以独立语句将newed对象置入智能指针</title>
    <url>/2018/04/11/%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假设我们有一个函数用来揭示处理程序的优先权，另一个用来在根据优先级处理某个动态分配的对象。很自然地，我们认为需要使用RAII管理资源：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw,<span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><br>其执行操作如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="keyword">new</span> Widget,priority());</span><br></pre></td></tr></table></figure><br>上述代码不能通过编译，因为到<strong>shared_ptr的构造函数是explict构造函数</strong>，无法通过隐式转换构造，因此必须写为如下类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget),priority());</span><br></pre></td></tr></table></figure><br><strong>遗憾的是，尽管我们使用了RAII,但它照样可能导致资源泄漏。</strong></p>
<hr>
<h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><p>&lt;/br&gt;<br>在调用process函数之前，编译器必须完成以下三件事：</p>
<ol>
<li>调用priorty()；</li>
<li>执行new Object；</li>
<li>调用shared_ptr构造函数</li>
</ol>
<p>毫无疑问，2必然在3之前发生，关键在于<strong>无法确定1何时发生，也无法确定其是否会抛出异常</strong>。<br>举例而言，如果发生的顺序是213，并且在调用priorty()的时候抛出了一个异常，那new Widget返回的指针会遗失，因为在资源被创建和资源被转换为资源管理对象两个时间点间发生了异常干扰。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&lt;/br&gt;<br>解决方法很简单，就是分开执行：</p>
<ol>
<li>以独立语句初始化RAII对象</li>
<li>将RAII对象作为参数传入函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">processWidget(pw,priority());</span><br></pre></td></tr></table></figure>
<p>其能够正确实现的根本原因在于：编译器仅在单一语句内拥有决定执行先后次序的自由度。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&lt;/br&gt;<br>以独立语句将newed对象存入智能指针中,否则抛出的异常可能会导致资源泄漏。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>30.使用算法前确保目标区间足够大</title>
    <url>/2018/04/15/%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E5%89%8D%E7%A1%AE%E4%BF%9D%E7%9B%AE%E6%A0%87%E5%8C%BA%E9%97%B4%E8%B6%B3%E5%A4%9F%E5%A4%A7/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>我们习惯了STL容器的自动扩张，因此可能会写下一些愚蠢的程序，举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transmogrify</span><span class="params">(<span class="keyword">int</span> x)</span></span>;<span class="comment">//产生一个自变量是x的因变量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">... <span class="comment">// 把数据放入values</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line"><span class="comment">//对values中的所有元素使用函数，将结果插入res尾部</span></span><br><span class="line">transform(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(),results.<span class="built_in">end</span>(),transmogrify);</span><br></pre></td></tr></table></figure><br>在本例中，transform调用了*res.end()，也就是说我们试图对一个不存在的对象赋值。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h2><h3 id="插入于结尾处"><a href="#插入于结尾处" class="headerlink" title="插入于结尾处"></a>插入于结尾处</h3><p>transform的结果放入结尾应该<strong>使用back_inserter来产生指向res末尾的迭代器</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results; </span><br><span class="line">transform(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), back_inserter(results), transmogrify);</span><br></pre></td></tr></table></figure></p>
<h3 id="插入于最前端"><a href="#插入于最前端" class="headerlink" title="插入于最前端"></a>插入于最前端</h3><p>如果你试图在最前端插入，当然可以<strong>用front_inserter</strong>，只是这样支持的容器只剩了list与deque.<br>如果依次添加到最前面，那么最终顺序与values对应的顺序不一致（正好相反），解决方法也简单，调用反向迭代器即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">transform(values.rbegin(), values.rend(),front_inserter(results), transmogrify);</span><br></pre></td></tr></table></figure></p>
<h3 id="在任意位置插入"><a href="#在任意位置插入" class="headerlink" title="在任意位置插入"></a>在任意位置插入</h3><p><strong>inserter迭代器允许你强制算法把结果插入在任何位置</strong>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;<span class="comment">// results已经有一些数据</span></span><br><span class="line">transform(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), inserter(results, results.<span class="built_in">begin</span>()+results.<span class="built_in">size</span>()/<span class="number">2</span>), transmogrify);</span><br></pre></td></tr></table></figure></p>
<h2 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h2><p>每一次都只插入了一个对象，因此可能会造成线性表频繁的复制与扩容。对于复制没有什么优化思路，但至少<strong>可以使用reserve来减少再分配所带来的开销</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">...</span><br><span class="line">results.reserve(results.<span class="built_in">size</span>() + values.<span class="built_in">size</span>());</span><br><span class="line">transform(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), </span><br><span class="line">inserter(results, results.<span class="built_in">begin</span>() + results.<span class="built_in">size</span>() / <span class="number">2</span>),</span><br><span class="line">transmogrify); <span class="comment">//无需扩容</span></span><br></pre></td></tr></table></figure></p>
<h2 id="替换而非插入"><a href="#替换而非插入" class="headerlink" title="替换而非插入"></a>替换而非插入</h2><p>有时候我们要做的操作并不是插入而是替换，但这并不影响我们是否需要判断results的大小，解决方法要么resize，要么clear之后使用插入迭代器：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//resize法</span></span><br><span class="line"><span class="keyword">if</span> (results.<span class="built_in">size</span>() &lt; values.<span class="built_in">size</span>())&#123; <span class="comment">//确保大小</span></span><br><span class="line">    results.resize(values.<span class="built_in">size</span>()); </span><br><span class="line">&#125;</span><br><span class="line">transform(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(),results.<span class="built_in">begin</span>(), transmogrify);</span><br><span class="line"><span class="comment">//clear之后插入</span></span><br><span class="line">results.<span class="built_in">clear</span>(); </span><br><span class="line">results.reserve(values.<span class="built_in">size</span>()); <span class="comment">// 扩容优化</span></span><br><span class="line">transform(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(),back_inserter(results),transmogrify);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br><strong>当我们使用一个要求指定目的区间的算法时，务必要确保目的区间已经足够大或者在算法执行时可以增加大小</strong>。如果需要增加大小，记得使用插入迭代器。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>40.仿函数类的适配性</title>
    <url>/2018/04/19/%E4%BB%BF%E5%87%BD%E6%95%B0%E7%B1%BB%E7%9A%84%E9%80%82%E9%85%8D%E6%80%A7/</url>
    <content><![CDATA[<p>（本节内容未能理解，建议结合STL源码剖析阅读，另外，我还是习惯于使用lambda）</p>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设现有一个存放widget*的list，以及一个判断式判断widget*指向的对象是否有趣：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;Widget*&gt; widgetPtrs;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInteresting</span><span class="params">(<span class="keyword">const</span> Widget *pw)</span></span>;</span><br></pre></td></tr></table></figure><br>如果我们想要查找第一个有趣的widget，直接调用find_if即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = find_if(widgetPtrs.<span class="built_in">begin</span>(), widgetPtrs.<span class="built_in">end</span>(),isInteresting);</span><br><span class="line"><span class="keyword">if</span> (i != widgetPtrs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    ...<span class="comment">//i指向了目标对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但问题在于，如果我想要找第一个不有趣的Widget，常规写法遭到了编译失败：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i =find_if(widgetPtrs.<span class="built_in">begin</span>(), widgetPtrs.<span class="built_in">end</span>(),not1(isInteresting)); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>为了保证成功编译与运行，我们必须对判断式使用ptr_fun：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = find_if(widgetPtrs.<span class="built_in">begin</span>(), widgetPtrs.<span class="built_in">end</span>(),not1(ptr_func(isInteresting)));</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="ptr-fun与适配性"><a href="#ptr-fun与适配性" class="headerlink" title="ptr_fun与适配性"></a>ptr_fun与适配性</h1><p>&nbsp;<br><strong>ptr_fun所做的事情就是使一些typedef生效</strong>。作为一个低级的函数指针，isInteresting不具备not1所需要的typedef。<br><strong>四个标准函数适配器(not1,not2,bind1st，bind2nd）都需要存在某些typedef，我们称缺乏typedef的对象不可适配。</strong><br>这里只提及缺乏typedef但并没有描述那些typedef是什么，这是因为<strong>除非你需要设计自己的适配器，否则你都可以通过继承一个base sturct来获得它们</strong>。<strong>接受一个参数的谓词继承unary_function，两个的则是接受binary_function</strong>。</p>
<hr>
<h1 id="仿函数模板类"><a href="#仿函数模板类" class="headerlink" title="仿函数模板类"></a>仿函数模板类</h1><p>&nbsp;<br><code>unary_function</code>和<code>binary_function</code>是模板，所以必须要指定模板参数.其继承形式大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeetsThreshold</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::unary_function&lt;Widget, <span class="keyword">bool</span>&gt;&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> T threshold;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MeetsThreshold(<span class="keyword">const</span> T&amp; threshold);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetNameCompare</span>:</span><span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;Widget, Widget, <span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget&amp; lhs, <span class="keyword">const</span> Widget&amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看出,<strong>operator()的返回值被作为了最后一个模板参数。</strong><br>一般来说，我们习惯于把无状态类记为struct（也许是为了少打那个public），有数据的类则记为class.<br><strong>可以看到，operator()的参数是const Widget，但给模板的参数却是Widget，你只需要记得这么做就好了。但如果是指针，一定要记住const不能少，模板参数必须和实参一样。</strong></p>
<p>如果给了一个仿函数类多种调用形式，那必然会减少可适配性。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>仿函数</tag>
      </tags>
  </entry>
  <entry>
    <title>关于对象——C++对象模式</title>
    <url>/2018/04/30/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在C++对象中，data member分为两种：</p>
<ol>
<li>static</li>
<li>non-static</li>
</ol>
<p>function member分为三种：</p>
<ol>
<li>static</li>
<li>non-static</li>
<li>virtual</li>
</ol>
<p>已知Point class声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> xval);</span><br><span class="line">    virtaul ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">float</span> _x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们应该以何种策略塑模出data member及function member？</p>
<hr>
<h1 id="简单对象模型"><a href="#简单对象模型" class="headerlink" title="简单对象模型"></a>简单对象模型</h1><p>&nbsp;<br>简单对象模型是了尽量降低C++编译器的复杂程度而开发出来的，并且因此付出了空间损耗增加与执行效率降低的代价。在这个简单模型中，一个object是一组slots，每一个slot指向了一个memeber：<img src="http://static.zybuluo.com/zsmj2017/dcq0fkabxo9wlkwm4ha9hdjl/image_1ccagmliuke41hre8hg1ru1dcb9.png" alt="image_1ccagmliuke41hre8hg1ru1dcb9.png-64.7kB"><br>在该简单对象模型中，member本身不并在对象内，仅有指向member的指针才位于对象内，这样保证了对象内部只需要存放一种数据类型：指针。显然，对象的大小等于member数量*指针大小。<br>尽管这种模型并不应用于实际生产，不过这种理念倒是被做成了某种设计手法：pimpl，或者Bridge设计模式。</p>
<hr>
<h1 id="表格驱动式对象模型"><a href="#表格驱动式对象模型" class="headerlink" title="表格驱动式对象模型"></a>表格驱动式对象模型</h1><p>&nbsp;<br>为了保证所有classes的objects均具有一致的表达方式，另一种对象模型的做法是：将所有与members相关的信息抽离出来，放在一个member data table与member function table之中。member data table直接持有数据，member function table则是一系列slots，每一个slots指向一个member function：<img src="http://static.zybuluo.com/zsmj2017/dh59t0dveor3rkm4k7qozymg/image_1ccahehmvd6eeqqsd01qc18um.png" alt="image_1ccahehmvd6eeqqsd01qc18um.png-49.9kB"><br>虽然这种模型也没有应用于直接生产，但member function table的观念却成为了支撑virtual function的一个有效方案。</p>
<hr>
<h1 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h1><p>&nbsp;</p>
<h2 id="不考虑继承"><a href="#不考虑继承" class="headerlink" title="不考虑继承"></a>不考虑继承</h2><p>C++对象模型由简单对象模型演化而来，并对内存空间及存储时间做出了优化。<br>在此模型中，non-static data members被配置于object之内，static data members则被存储于所有objects之外。static or non-static function members也都被存储于objects之外。<br>virtual function以两个步骤实现：</p>
<ol>
<li>每一个clss产生一堆指向virtual functions的指针，用一个表格存放之，该表格也被成为虚函数表（vtbl）。虚函数表的第一个slot存放着当前class所对应的type_info object。（RTTI）</li>
<li>每一个object内部都存有指向vtbl的指针vptr，vptr的setting与resetting由构造、析构、拷贝赋值运算符自动完成。</li>
</ol>
<p><img src="http://static.zybuluo.com/zsmj2017/wrecuasind275og00uan84nb/image_1ccaikqsb150q9tr18s6e7gh0t13.png" alt="image_1ccaikqsb150q9tr18s6e7gh0t13.png-58.5kB"><br>该模型的优势主要在于空间与存储时间的效率，但缺陷也很明显：non-static data members一旦有所修改，应用程序就需要重新编译。在编译弹性方面，上一小节所提及的双表格模型就做的很好。</p>
<hr>
<h2 id="加入继承"><a href="#加入继承" class="headerlink" title="加入继承"></a>加入继承</h2><p>C++支持单一继承与多重继承，甚至，继承关系也可以指定为virtual（可以理解为共享）：<br><img src="http://static.zybuluo.com/zsmj2017/3d4qvzmzr7i73j3o5ib9maag/image_1ccaj89ql1qrvmpd1f0v1bmk14a61g.png" alt="image_1ccaj89ql1qrvmpd1f0v1bmk14a61g.png-14.6kB"><br>在虚继承的情况下，base class无论在继承体系中被派生多少次，其永远只会存在一个实体（subobject），例如iostream中就只有一个virtual ios base class的实体。</p>
<h2 id="derived-class塑模base-class实体"><a href="#derived-class塑模base-class实体" class="headerlink" title="derived class塑模base class实体"></a>derived class塑模base class实体</h2><p>在简单对象模型中，每一个base class可以被derived class object内的slot指出，该体系的缺点是：因为间接性导致空间和存取时间需要额外开销，优点在于class object不会因其base class发生改变而受到影响。</p>
<p>base class table模型：base class table被产出后，表中的每一个slot内含一个base class地址，就如同vtbl内含virtual function的地址一般。每一个class含有一个bptr，指向其base class table。该体系的缺点在于：因为间接性导致空间和存取时间需要额外开销。优点在于每一个class object对于继承都有一致的表现方式：每一个class object的固定位置都有一个base table指针，与base classes的大小或数目无关。此外，无需改变class objects本身，就可以放大、缩小、或更改base class table。</p>
<p>下图展示了ios继承体系在base class table下的对象模型：<img src="http://static.zybuluo.com/zsmj2017/9u4zcjj5hfkph5cda9aje9c1/image_1ccb2lsns1aulp3q1dth1dh0d299.png" alt="image_1ccb2lsns1aulp3q1dth1dh0d299.png-228.8kB"><br>不管哪一种对象模型，“间接性”总是随着继承体系深度的增长而增加，也就是存取操作的时间会增长。当然，derived class可以多放置一些指针，指向继承体系中的每一个base class，但这付出了空间成本。</p>
<p>C++最初采用的对象模型不具备任何间接性：base class subobject的data member被直接置于derived class中，这保证了高效存取，缺点在于base class一旦发生改动，整个继承体系都必须重新编译。<br>virtual base class的导入增加了间接性，其原始模型是在class objects中为每一个有关联的virtual base class加上一个指针。其他模型无非是两种情况：导入一个virtual base class table，又或者扩充vtbl，在其中放入virtual base class的地址。</p>
<hr>
<h1 id="对象模型如何影响程序"><a href="#对象模型如何影响程序" class="headerlink" title="对象模型如何影响程序"></a>对象模型如何影响程序</h1><p>&nbsp;<br>不同对象模型，会导致如下两个结果：</p>
<ol>
<li>现有程序必须修改</li>
<li>必须加入新的程序</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假设现有class X，定义有copy constructor，virtual destructor，以及一个virtual function foo，考虑如下函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    X *px = <span class="keyword">new</span> X;</span><br><span class="line">    xx.foo();</span><br><span class="line">    px-&gt;foo();</span><br><span class="line">    <span class="keyword">delete</span> px;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该函数可能会在内部被转化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(X &amp;_result)</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造_result并取代local xx</span></span><br><span class="line">    _result.X::X();</span><br><span class="line">    <span class="comment">//转化new语句</span></span><br><span class="line">    px = _new(<span class="keyword">sizeof</span>(X));</span><br><span class="line">    <span class="keyword">if</span>(px)</span><br><span class="line">        px-&gt;X::X();</span><br><span class="line">    <span class="comment">//执行非虚函数</span></span><br><span class="line">    foo(&amp;_result);</span><br><span class="line">    <span class="comment">//执行虚函数</span></span><br><span class="line">    （*px-&gt;vtbl[<span class="number">2</span>])(px);</span><br><span class="line">    <span class="comment">//转化delete语句</span></span><br><span class="line">    <span class="keyword">if</span>(px)&#123;</span><br><span class="line">        (*px-&gt;vtbl[<span class="number">1</span>](px));</span><br><span class="line">        _delete(px);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需要摧毁local object xx</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这就是对象模型将实际代码转化后的一个可能实例，其解释可见后续诸章，下图给出了部分注解：<img src="http://static.zybuluo.com/zsmj2017/u26nsqg4ilx8hibbk83hobft/image_1ccb4gg0fogo1ee2fm6k1enrmm.png" alt="image_1ccb4gg0fogo1ee2fm6k1enrmm.png-250.6kB"></p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>9.使用析构函数防止资源泄漏</title>
    <url>/2018/04/25/%E4%BD%BF%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%98%B2%E6%AD%A2%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<p>(本节内容重点描述RAII，详见Effective C++ 14。)</p>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设目前我们需要为某宠物店编写软件，工作是读取宠物店建立的档案文件，然后对动物进行适当处理。<br>合理方案是建立一个pure abstract class<br>“ALA”(adorable little animal)。然后为小狗小猫建立派生类，一个virtual函数processAdoption负责处理各个不同种类的小动物:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ALA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processAdoption</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Puppy</span>:</span><span class="keyword">public</span> ALA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kitten</span>:</span> <span class="keyword">public</span> ALA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>​<br>我们通过从文件中读取到的信息建立一个puppy或kitten对象,这很适合工厂模式（虚构造函数）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ALA * <span class="title">readALA</span><span class="params">(istream&amp; s)</span></span>;</span><br></pre></td></tr></table></figure><br>程序的核心部分如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dataSource) &#123;</span><br><span class="line">        ALA *pa = readALA(dataSource);</span><br><span class="line">        pa-&gt;processAdoption();</span><br><span class="line">        <span class="keyword">delete</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>每一次读取完必须删除pa，如果不删除堆对象会导致资源泄漏。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>倘若processAdoption函数抛出了异常，这将直接导致后续语句被跳过，pa没有被删除，资源泄漏由此产生。<br>一提到异常，大多数人的第一反应是使用try catch去捕获：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dataSource) &#123;</span><br><span class="line">        ALA *pa = readALA(dataSource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pa-&gt;processAdoption();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">            <span class="keyword">delete</span> pa;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虽然问题确实解决了，但是我们却使得原有程序冗余且低效，反正无论如何我们都要执行清除操作，何必要写多次呢？</p>
<hr>
<h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><p>&nbsp;<br>我们可以把总被执行的delete放入process函数内的局部对象的析构函数里，当process返回时局部对象被释放，因此delete操作也完成了。<br>具体方法是用一个smart-ptr.本次实例使用auto_ptr代替raw指针：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dataSource) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">auto_ptr</span>&lt;ALA&gt; <span class="title">pa</span><span class="params">(readALA(dataSource))</span></span>;</span><br><span class="line">        pa-&gt;processAdoption();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然这是一个标准的RAII，用一个对象存储需要被自动释放的资源。</p>
<hr>
<h2 id="RAII实例"><a href="#RAII实例" class="headerlink" title="RAII实例"></a>RAII实例</h2><p>RAII并非只是适用于智能指针或者堆对象，其本意是用对象来管理一切可能存在泄漏的资源的分配与释放。以一个可能发生资源泄漏的GUI程序举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayInfo</span><span class="params">(<span class="keyword">const</span> Information&amp; info)</span></span>&#123;</span><br><span class="line">    <span class="function">WINDOW_HANDLE <span class="title">w</span><span class="params">(createWindow())</span></span>;</span><br><span class="line">    ...<span class="comment">//在w对应的window中显示信息</span></span><br><span class="line">    destroyWindow(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果在w对应的window中显示信息时，一个异常被抛出，w所对应的window将被丢失，就象其它动态分配的资源一样。<br>解决方法是建立一个类，构造函数接受资源，析构函数释放资源：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowHandle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WindowHandle(WINDOW_HANDLE handle): w(handle) &#123;&#125;</span><br><span class="line">    ~WindowHandle() &#123; destroyWindow(w); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">WINDOW_HANDLE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w; &#125; <span class="comment">// see below</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WINDOW_HANDLE w;</span><br><span class="line">    <span class="comment">//防止拷贝</span></span><br><span class="line">    WindowHandle(<span class="keyword">const</span> WindowHandle&amp;);</span><br><span class="line">    WindowHandle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> WindowHandle&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>使用了RAII的display函数如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayInfo</span><span class="params">(<span class="keyword">const</span> Information&amp; info)</span></span>&#123;</span><br><span class="line">    <span class="function">WindowHandle <span class="title">w</span><span class="params">(createWindow())</span></span>;</span><br><span class="line">    ...<span class="comment">//在w对应的window中显式信息;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>资源应当被封装在对象内，遵循该原则可以避免在异常发生时泄漏资源。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>关于对象——前言</title>
    <url>/2018/04/30/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><p>&nbsp;<br>在C语言中，“数据”及“处理数据的操作”是分开声明的，这种处理方式被称为procedural：一组“分布在各个以功能为导向的函数中”的算法驱动和处理外部数据。</p>
<h2 id="C-struct实例"><a href="#C-struct实例" class="headerlink" title="C struct实例"></a>C struct实例</h2><p>假设我们当前存在一个struct Point3d：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point3d</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line">&#125; Point3d;</span><br></pre></td></tr></table></figure><br>如果我们需要打印该Point3d，则必须定义这样一个函数：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point3d_print</span><span class="params">(<span class="keyword">const</span> Point3d *pd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%f,%f,%f)"</span>,pd-&gt;x,pd-&gt;y,pd-&gt;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>又或者为了追求效率，直接使用函数宏：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Point3d_print(pd)   printf(<span class="meta-string">"(%f,%f,%f)"</span>,pd-&gt;x,pd-&gt;y,pd-&gt;z);</span></span><br></pre></td></tr></table></figure><br>同样地，某个点的特定坐标可以直接存取：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Point3d pt;</span><br><span class="line">pt.x = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">//宏操作</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SetX(p,xval) (p.x)=(xval);</span></span><br><span class="line">SetX(pt,<span class="number">0.0</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>C++中实现Point3d可能会使用独立的“抽象数据类型”（abstract data type,ADT)来实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="keyword">const</span> Point3d &amp;pt)&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p>又或者以一个两层到三层的继承体系完成：<img src="http://static.zybuluo.com/zsmj2017/wqlsxrhsul1mirhq8dtrp1xk/image_1ccad3v788kbnc78s3bg4bfb9.png" alt="image_1ccad3v788kbnc78s3bg4bfb9.png-9.4kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>:</span><span class="keyword">public</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h2><p>我们甚至可以更进一步地抽象，将坐标值类型甚至坐标数量参数化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...<span class="comment">//内含数组或容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>&nbsp;<br>仅从Point来看，C与C++处理问题的方式截然不同，这并非是语言间的区别，而是过程式与面向对象的差别。<br>从软件工程的角度而言，封装性比全局数据要好，但也付出了编写和使用上的代价。</p>
<hr>
<h1 id="封装的成本"><a href="#封装的成本" class="headerlink" title="封装的成本"></a>封装的成本</h1><p>&nbsp;<br>从Point的角度而言，封装并未带来任何成本：</p>
<ol>
<li>data<br>所有的数据均存储于Object内，就如同struct中的情况一样。</li>
<li>member function<br>成员函数虽然包含于class的声明之内，但却不会出现在object中。每一个non-inline成员函数都只会生成一个函数实体。</li>
</ol>
<p>C++在内存布局以及存储时间上的额外负担主要由virtual引起：</p>
<ul>
<li>virtual function<br>实现函数执行期绑定。</li>
<li>virtual base class<br>实现“多次出现在继承体系中的base class在派生类中只存在一个可共享的实体”。</li>
</ul>
<p>一般而言，我们没有理由认为C++就一定会比C庞大且迟缓。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>32.使用init捕获将对象移动到闭包中</title>
    <url>/2018/07/16/%E4%BD%BF%E7%94%A8init%E6%8D%95%E8%8E%B7%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8%E5%88%B0%E9%97%AD%E5%8C%85%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>可能在某时你会发现无论是按值捕获还是按引用捕获均非最佳选择。例如C++11无法将一个move-only对象（std::unique_ptr、std::future)移动进入闭包.又或者当前存在一个copy成本极高但move成本极低的对象（例如STL中的大部分容器），C++11也无法将其移动进入闭包。</p>
<p>这项C++14引入的新功能被称为init capture，它几乎可以完成C++11捕获表单可以执行的所有操作，以及更多功能，唯一的缺点是它无法表现地如同默认捕获，但前一节我们介绍了最好不要使用它们。此外，init捕获的语法略显冗长，因此如果C++11中别的捕获模式已经能够完成任务，我们没有必要去使用init捕获。</p>
<hr>
<h1 id="init捕获"><a href="#init捕获" class="headerlink" title="init捕获"></a>init捕获</h1><p>&nbsp;<br>init捕获可以帮助我们指定</p>
<ol>
<li><strong>由lambda所生成的closure class中data meber的名称</strong></li>
<li><strong>该data member的初始化表达式</strong></li>
</ol>
<p>下述实例将展示如何通过init捕获将std::unique_ptr移动入闭包：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// some useful type</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidated</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isProcessed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isArchived</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> pw = <span class="built_in">std</span>::make_unique&lt;Widget&gt;(); <span class="comment">// create Widget</span></span><br><span class="line">… <span class="comment">// configure *pw</span></span><br><span class="line"><span class="keyword">auto</span> func = [pw = <span class="built_in">std</span>::<span class="built_in">move</span>(pw)]&#123; <span class="keyword">return</span> pw-&gt;isValidated()&amp;&amp; pw-&gt;isArchived(); &#125;;</span><br></pre></td></tr></table></figure><br>其中<code>[pw = std::move(pw)]</code>即为init捕获。“=”左侧是指闭包类中data member的名称，右侧是其初始化表达式。有趣的是，“=”左侧与右侧具备不同的作用域，左侧的作用域为closure class，右侧为lambda定义区。在上述实例中，“=”左侧的名称pw为closure class中的data member，而右侧的名称pw意味着lambda上文中刚刚创建的std::unique_ptr。最终，利用std::move将上文中的std::unique_ptr初始化closure class中的data member。lambda体中的代码处于closure class的作用域内，因此pw代表闭包类数据成员。</p>
<p>在以pw初始化data member之前，我们可能会对堆中的Widget作出修改，这也正对应着注释部分的configur *pw。如果我们当前无需修改，则可省去局部对象pw，直接以make_unique返回值初始化data member：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw = <span class="built_in">std</span>::make_unique&lt;Widget&gt;()]&#123; <span class="keyword">return</span> pw-&gt;isValidated()&amp;&amp; pw-&gt;isArchived(); &#125;;</span><br></pre></td></tr></table></figure><br>init捕获又被称为广义捕获。</p>
<hr>
<h1 id="在C-11中实现移动捕获"><a href="#在C-11中实现移动捕获" class="headerlink" title="在C++11中实现移动捕获"></a>在C++11中实现移动捕获</h1><p>&nbsp;<br>我们明确的是，lambda是一种生成类的方法，那么我们自然可以在C++11中避开lambda直接生成自己需要的class，因此，刚才C++14所写的代码可以被转换为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsValAndArch</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IsValAndArch</span><span class="params">(DataType&amp;&amp; ptr)</span>:<span class="title">pw</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(ptr))</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType pw;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> func = IsValAndArch(<span class="built_in">std</span>::make_unique&lt;Widget&gt;());</span><br></pre></td></tr></table></figure><br>虽然多打了很多字，但它至少证明了C++11也能支持移动捕获。</p>
<p>如果你非要既使用C++11的lambda，又需要移动捕获，那你得按照以下步骤行事：</p>
<ol>
<li><strong>将要捕获的对象移动到std::bind生成的函数对象中</strong></li>
<li><strong>给lambda一个对“捕获”对象的引用</strong></li>
</ol>
<p>假设当前我们需要创建一个局部对象std::vector，将一组适当的值放入其中，然后将其移动到闭包中。上述行为在C++14中很容易实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data; <span class="comment">// object to be moved into closure</span></span><br><span class="line">… <span class="comment">// populate data</span></span><br><span class="line"><span class="keyword">auto</span> func = [data = <span class="built_in">std</span>::<span class="built_in">move</span>(data)]&#123; <span class="comment">/* uses of data */</span> &#125;;<span class="comment">// C++14 init capture</span></span><br></pre></td></tr></table></figure><br>在C++11中，同等的实现需要被写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data; <span class="comment">// as above</span></span><br><span class="line">… <span class="comment">// as above</span></span><br><span class="line"><span class="keyword">auto</span> func =<span class="built_in">std</span>::bind([](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; data)&#123; <span class="comment">/* uses of data */</span> &#125;,<span class="built_in">std</span>::<span class="built_in">move</span>(data));</span><br></pre></td></tr></table></figure><br>类似于lambda表达式，std::bind生成函数对象。std :: bind的第一个参数是一个可调用对象，后续参数表示要传递给该对象的值。bind对象在传递参数给第一个可调用对象时，采用左值拷贝构造，右值移动构造的方式。需要注意的是，（）中是一个左值引用，原因在于bind将data传递至闭包后，data是一个左值。此外，为了防止修改数据，我们将一个const-refernce绑定至data，这是因为lambda生成的class默认operator()为const。</p>
<p>由于bind对象内含其所有实参的副本，因此其生命周期与闭包的生命周期一致。总而言之，利用bind模拟移动捕获的要点有三：</p>
<ol>
<li><strong>在C++11中，无法将一个对象移动进入闭包，但可以将其移动进入一个bind对象。</strong></li>
<li><strong>在模拟过程中，我们只需要把对象移动进入bind对象，然后以引用形式将其传递给闭包</strong></li>
<li><strong>因为bind对象的生命周期与闭包的生命周期相同，所以可以将bind对象中的对象视为处于闭包中</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于对象——对象的差异</title>
    <url>/2018/05/01/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<h1 id="C-设计范式"><a href="#C-设计范式" class="headerlink" title="C++设计范式"></a>C++设计范式</h1><p>&nbsp;<br>C++程序设计模型支持三种programming paradigms：</p>
<ol>
<li><strong>procedursal model</strong><br>过程式编程模型，想必各位已经很熟悉了。</li>
<li><strong>abstract data type model</strong><br>该模型所谓的“抽象”是和一组表达式（public接口）一起提供，而其运算定义符隐而未明：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> girl = <span class="string">"Anna"</span>;</span><br><span class="line"><span class="keyword">String</span> daughter;</span><br><span class="line"><span class="comment">//String::operator=();</span></span><br><span class="line">daughter = girl;</span><br></pre></td></tr></table></figure></li>
<li><strong>object-oriented model</strong><br>在此模型中有一些彼此相关的类型，通过一个abstract base class（提供通用接口）被封装起来。</li>
</ol>
<hr>
<h2 id="多范式混用带来的危害"><a href="#多范式混用带来的危害" class="headerlink" title="多范式混用带来的危害"></a>多范式混用带来的危害</h2><p>纯粹以某一种paradigm编程有助于保证整体行为的稳定性与正确性，如果混合使用了多种paradigm，可能会造成意料之外的后果。</p>
<h3 id="sliced"><a href="#sliced" class="headerlink" title="sliced"></a>sliced</h3><p>假设当前有Library_material与其派生类book，继承体系如下：<img src="http://static.zybuluo.com/zsmj2017/kpwejudzjo3c65urfy0o2dfc/image_1cccoqo1e1le9ners7a1o6bvln9.png" alt="image_1cccoqo1e1le9ners7a1o6bvln9.png-8.4kB"><br>考虑如下代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ADT paradigm</span></span><br><span class="line">Library_material thing1;</span><br><span class="line">Book book;</span><br><span class="line">thing1 = book;<span class="comment">//本意是重绑定</span></span><br><span class="line">thing1.checkin();<span class="comment">//本意是调用虚函数</span></span><br><span class="line"><span class="comment">//OO paradigm</span></span><br><span class="line">Library_material thing2 = &amp;book;</span><br><span class="line">thing2.checkin();<span class="comment">//book::checkin();</span></span><br></pre></td></tr></table></figure><br>多态性是OO paradigm的重要特性，ADT paradigm不具备此特性，如果在使用时混用二者，极易造成sliced并且产生意外后果。</p>
<hr>
<h2 id="OO-paradigm-与-ADT-paradigm"><a href="#OO-paradigm-与-ADT-paradigm" class="headerlink" title="OO paradigm 与 ADT paradigm"></a>OO paradigm 与 ADT paradigm</h2><p>在OO中，程序员需要处理一个个未知实体，它的类型虽然有所界定，却具备无穷可能。实体的类型受限于继承体系，但继承体系的深度与广度没有限制。原则上，被指定的Object的真实类型在每一个特定动作执行前无法确认，只有通过pointer或reference才能够完成这一系列操作。但在ADT中，程序员处理的是一个拥有固定且单一形态的实体，其所有特性在编译时期就已被完全定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无法确定px rx的动态类型</span></span><br><span class="line">Library_material *px = sth;</span><br><span class="line">Libraay_material &amp;rx = *px;</span><br><span class="line"><span class="comment">//静态类型已知</span></span><br><span class="line">Library_material dx = *px;</span><br></pre></td></tr></table></figure></p>
<p>多态的实现要求此object必须经由pointer或reference存取，但pointer与reference的操作并不总是构成多态（例如其指向对象不在继承体系中）。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>C++以下列方法支持多态：</p>
<ol>
<li><strong>一组隐式转换操作</strong>，例如把一个derived class指针转为指向base class的指针。</li>
<li><strong>virtual function机制</strong></li>
<li><strong>经由dynamic_cast与typeid运算符</strong></li>
</ol>
<p>多态的主要用途是经由一个共同的接口来影响类型的封装，该接口通常被定义在一个abstract base class中，通过多态性，我们得以保证当类型发生修改时，程序代码无需改变。</p>
<hr>
<h1 id="object的大小"><a href="#object的大小" class="headerlink" title="object的大小"></a>object的大小</h1><p>&nbsp;<br>究竟一个object需要占用多少内存？一般而言，object的内存占用由三部分组成：</p>
<ol>
<li><strong>所有non-static data member所占大小</strong></li>
<li><strong>为了支持virtual而产生的额外开销（vptr)</strong></li>
<li><strong>齐位所带来的额外占用</strong></li>
</ol>
<hr>
<h1 id="指针类型差异"><a href="#指针类型差异" class="headerlink" title="指针类型差异"></a>指针类型差异</h1><p>&nbsp;<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ZooAnimal *px;</span><br><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">Array&lt;<span class="keyword">String</span>&gt; *pta;</span><br></pre></td></tr></table></figure><br>这三种指针有什么不同吗？<br>以内存需求的角度而言，这三种指针并无不同，都需要足够的内存来放置一个机器地址。“指向不同类型的指针的差异”（ZooAnimal*、int*等等），既不在于指针表示法，也不在于内容（地址）不同，而在于其寻址得到的object类型不同。<strong>“指针类型”的主要功能是：教导编译器如何解释某个特定地址中的内存内容及其大小：</strong></p>
<ol>
<li>一个指向地址1000的int*，在地址空间上将涵盖1000~1003（32位及其上整数是4-bytes）</li>
<li>如果String基于传统实现，那么地址空间上将涵盖1000~1015（4+8+4）<br><img src="http://static.zybuluo.com/zsmj2017/hxvwhnvv26o14j3v9ypya7x2/image_1cccrhqma1r9fh2q10iq1tv76ccm.png" alt="image_1cccrhqma1r9fh2q10iq1tv76ccm.png-38.9kB"></li>
</ol>
<p>那如果现存在一个地址为1000但类型为void*的指针呢？我们无法了解其指向的具体对象，也无法判断它具体如何覆盖地址空间。</p>
<p>所以说，cast只是一种编译器指令，它并不改变真正的地址，只是影响编译器如何去解读地址。</p>
<hr>
<h1 id="引入多态之后的指针"><a href="#引入多态之后的指针" class="headerlink" title="引入多态之后的指针"></a>引入多态之后的指针</h1><p>&nbsp;<br>现有继承体系如下：<br><img src="http://static.zybuluo.com/zsmj2017/py02unmde374jpfcshw5rtag/image_1cccs68dq1ipbudv235mn51blk13.png" alt="image_1cccs68dq1ipbudv235mn51blk13.png-7.3kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span>:</span>:<span class="keyword">public</span> ZooAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bear();</span><br><span class="line">    ~Bear();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span></span>;<span class="comment">//继承得到的virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>;<span class="comment">//特有</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">enum</span> Dances &#123;...&#125;;</span><br><span class="line">    Dances dances_known;</span><br><span class="line">    <span class="keyword">int</span> cell_block;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Bear <span class="title">b</span><span class="params">(<span class="string">"Yogi"</span>)</span></span>;</span><br><span class="line">Bear *pb = &amp;b;</span><br><span class="line">Bear &amp;rb = *pb;</span><br></pre></td></tr></table></figure><br>b、pb、rb的内存需求何如？<br>pointer与refernce只需要一个字长的大小，Bear object 需要24 bytes（ZooAnimal的16 bytes + Bear自有的8 Bytes）：<img src="http://static.zybuluo.com/zsmj2017/rgs4zkg04ebquw17yptke0wy/image_1cccspl1t15h52ss1jintkinfe1g.png" alt="image_1cccspl1t15h52ss1jintkinfe1g.png-118.1kB"></p>
<hr>
<h2 id="pointer-to-base-与-pointer-to-derived"><a href="#pointer-to-base-与-pointer-to-derived" class="headerlink" title="pointer to base 与 pointer to derived"></a>pointer to base 与 pointer to derived</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal *pz = &amp;b;</span><br><span class="line">Bear *pb =&amp;b;</span><br></pre></td></tr></table></figure>
<p>一个Bear*与一个ZooAnimal*有何区别？<br>它们都指向了b的第一个byte，其差别在于pz只涵盖了b中的ZooAnimal subobject部分，pb则是涵盖了整个Bear object。除了Base部分之外，你无法调用任何Bear的专属member，唯一例外是virtual机制。当我们写下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pz-&gt;rotate();</span><br></pre></td></tr></table></figure><br>pz的类型将在编译期检查以下两点：（显式接口）</p>
<ol>
<li>该接口是否存在于base内</li>
<li>该接口的access level是否为public</li>
</ol>
<p>在运行期，pz所指向的object决定了rotate的调用实体。类型信息的封装并不存在于pz中，而是存在于vbtl的首元素。</p>
<p>考虑如下情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal za =b;<span class="comment">//sliced</span></span><br><span class="line">za.rotate();<span class="comment">//ZooAnimal::rotate()</span></span><br></pre></td></tr></table></figure><br>为什么调用的并不是Bear的函数实体？此外，如果初始化函数复制了object，为什么vptr没有发生变化指向新的vbtl？<br>关于第二个问题，编译器给出的答案是：如果某个object含有一个或以上一个以上的vptrs，这些vptrs的内容不会在初始化或赋值时发生改变。<br>对于第一个问题，答案是：za并不也不可能是一个Bear，它只能是一个ZooAnimal。有这么一种似是而非的观念：OO程序设计并不支持对object的直接处理。例如在如下继承体系中：<br><img src="http://static.zybuluo.com/zsmj2017/2pbbm8vb7rco2v5txrp29912/image_1cccuduvklms16ro1dbk88bpl51t.png" alt="image_1cccuduvklms16ro1dbk88bpl51t.png-10.7kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ZooAnimal za;</span><br><span class="line">ZooAnimal *pza;</span><br><span class="line">Bear b;</span><br><span class="line">Panda *pp = <span class="keyword">new</span> Panda;</span><br><span class="line">pza =&amp;b;</span><br></pre></td></tr></table></figure><br>其内存布局可能如下：<br><img src="http://static.zybuluo.com/zsmj2017/wn90fd46c6v7t8jn695sul8v/image_1cccukhnsius1so1q1e18281jmf2a.png" alt="image_1cccukhnsius1so1q1e18281jmf2a.png-216.3kB"><br>我们只需要认定，pointer与reference的类型决定了该段内存被如何解析。但如果你试图改变object za的大小，比如将整个Bear Object赋给它，那就直接引发了sliced，于是多态便不再呈现。</p>
<hr>
<h1 id="OO与OB"><a href="#OO与OB" class="headerlink" title="OO与OB"></a>OO与OB</h1><p>&nbsp;<br>C++通过pointer与reference来实现多态，这种程序设计风格被称为面向对象。<br>C++也支持ADT程序风格，现如今它们被称为OB（object-based）。OB提供封装的非多态形式，也不支持类型扩充，其典型实例就是STL中的各类容器。OB比OO更具备空间紧凑性，且提供更快的速度，但其缺点在于缺乏设计弹性。<br>在OO与OB之间存在着取舍，在我们使用之前必须分析当前应用领域的实际需求。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>24.分清universal reference与rvalue reference</title>
    <url>/2018/07/12/%E5%88%86%E6%B8%85universal%20reference%E4%B8%8Ervalue%20reference/</url>
    <content><![CDATA[<h1 id="T-amp-amp-的两种含义"><a href="#T-amp-amp-的两种含义" class="headerlink" title="T&amp;&amp;的两种含义"></a>T&amp;&amp;的两种含义</h1><p>&nbsp;<br>如果需要声明类型T的右值引用，我们应当撰写T&amp;&amp;。但当我们在某些源码中看到T&amp;&amp;，这并不代表它们是rvalue reference：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">// rvalue reference</span></span><br><span class="line">Widget&amp;&amp; var1 = Widget(); <span class="comment">// rvalue reference</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">// not rvalue reference</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// rvalue reference</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">// not rvalue reference</span></span><br></pre></td></tr></table></figure><br>事实上，“T &amp;&amp;”有两种不同的含义。当其具备ravlue reference的含义时，它们只与rvalues绑定，以识别可被移动的对象。<br>“T&amp;&amp;”的另一个含义是既可作为rvalue reference亦可作为lvalue reference。这种引用看起来像右值引用，但其行为却类似于左值引用，它的双重性质允许它绑定到rvalues（如rvalue引用）以及lvalues（如左值引用）。此外，它也可以绑定到const或non-const对象，volatile对象或non-volatile对象，甚至兼具const与volatile的对象。由于这种引用几乎可以绑定一切对象，因此作者将其称为universal reference。</p>
<hr>
<h1 id="universal-reference"><a href="#universal-reference" class="headerlink" title="universal reference"></a>universal reference</h1><p>&nbsp;<br>universal reference出现在两种情况下。最常见的是函数模板参数，例如:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">// param is a universal reference</span></span><br></pre></td></tr></table></figure><br>也可能出现在auto类型推衍之中，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">// var2 is a universal reference</span></span><br></pre></td></tr></table></figure><br>显然，上述实例都离不开类型推衍。也就是说，如果当前场景内不存在类型推衍，那你看到的T&amp;&amp;必然是右值引用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">// no type deduction;param is an rvalue reference</span></span><br><span class="line">Widget&amp;&amp; var1 = Widget(); <span class="comment">// no type deduction;var1 is an rvalue reference</span></span><br></pre></td></tr></table></figure><br>由于universal reference依旧是一个reference，因此必须对它们执行初始化操作，并且其初始化操作决定了其表现类型：以右值初始化则表现为右值引用，反之则为左值引用。作为函数形参的universal reference初始化操作发生于调用时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">// param is a universal reference</span></span><br><span class="line">Widget w;</span><br><span class="line">f(w); <span class="comment">// lvalue passed to f; param's type is Widget&amp; (i.e., an lvalue reference)</span></span><br><span class="line">f(<span class="built_in">std</span>::<span class="built_in">move</span>(w)); <span class="comment">// rvalue passed to f; param's type is Widget&amp;&amp; (i.e., an rvalue reference)</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="universal-refernce的判断"><a href="#universal-refernce的判断" class="headerlink" title="universal refernce的判断"></a>universal refernce的判断</h1><p>&nbsp;<br>对于universal reference而言，类型推衍是必要而非充分条件，引用必须被声明为“T&amp;&amp;”形式才能够触发universal reference，试看刚才的实例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// param is an rvalue reference</span></span><br></pre></td></tr></table></figure><br>在调用f时会执行类型推衍，但是param的类型声明的形式并非“T &amp;&amp;”，而是“std::vector&lt;T&gt; &amp;&amp;”。 我们之前强调过，universal reference必须是“T &amp;&amp;”才行，因此，param是一个右值引用，如果尝试将左值传入，编译器将会报错：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">f(v); <span class="comment">// error! can't bind lvalue to rvalue reference</span></span><br></pre></td></tr></table></figure><br>即使只有一个const修饰符也足以取消universal reference：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>; <span class="comment">// param is an rvalue reference</span></span><br></pre></td></tr></table></figure></p>
<p>你可能会认为模板中的参数“T &amp;&amp;”必然是universal reference，但事实并非如此，因为模板也并非一定触发类型推衍，考虑std::vector中的push_back成员函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt; // <span class="title">from</span> <span class="title">C</span>++</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span> <span class="comment">// Standards</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>尽管该函数中出现了“T &amp;&amp;”这种形式，但由于成员函数在模板实例化之后才会存在，因此在实例化之前该成员函数可视为无效，假若我们当前对该模板执行实例化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; v;</span><br></pre></td></tr></table></figure><br>这直接导致该模板被实例化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>&lt;Widget, allocator&lt;Widget&gt;&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Widget&amp;&amp; x)</span></span>; <span class="comment">// rvalue reference</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，push_back的成员函数总是一个右值引用，根本不会触发类型推衍。</p>
<p>相比之下，std::vector中的emplace_back成员函数则确实触发了类型推衍：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt; // <span class="title">still</span> <span class="title">from</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span> <span class="comment">// C++</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// Standards</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">emplace_back</span>(<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在该声明中。Args作为一个独立于类型T的参数包，将会在实例化之中仍然执行类型推衍，因此它是一个universal reference，此外这个实例还说明了universal refernce并非一定为“T &amp;&amp;”，也有可能是“Type &amp;&amp;”：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> MyTemplateType&gt; <span class="comment">// param is a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(MyTemplateType&amp;&amp; param)</span></span>; <span class="comment">// universal reference</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="universal-refernce与auto"><a href="#universal-refernce与auto" class="headerlink" title="universal refernce与auto"></a>universal refernce与auto</h1><p>&nbsp;<br>C++11和C++14中经常会出现“auto &amp;&amp;”，这也代表了universal reference。在C++14中，lambda可以声明auto&amp;&amp;参数，以一个记录函数运行执行时间的lambda为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> timeFuncInvocation =[](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params)&#123;</span><br><span class="line">    start timer;</span><br><span class="line">    <span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params));</span><br><span class="line">    <span class="built_in">stop</span> timer <span class="keyword">and</span> record elapsed time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在该lambda中，func是一个可以绑定到任何可调用对象(无论左值右值）的universal reference， args是一个universal reference参数包，它可以绑定到任意类型、任意数量的对象，由于universal reference的存在，timeFuncInvocation几乎可以完成任何函数调用。（Item30说明了为什么是几乎任何）。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>如果参数为“Type &amp;&amp;”形式且触发了类型推衍，又或者存在“auto &amp;&amp;”，则当前为universal reference。</strong></li>
<li><strong>如果不满足上一条，则为右值引用。</strong></li>
<li><strong>universal refernce被左值初始化时表现为左值，被右值初始化时表现为右值。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>8.切勿创建包含auto_ptr的容器对象</title>
    <url>/2018/04/08/%E5%88%87%E5%8B%BF%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%ABauto_ptr%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>Contain of auto_ptr (COAP)被禁止使用，其代码无法编译。原因很简单，COAP无法移植，再究其根本，在于auto_ptr被复制后，它所指向的对象的所有权被移交给lhs，而自身被置为nullptr,其特性可以用代码表述如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; <span class="comment">// pw1指向一个Widget</span></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">pw2</span><span class="params">(pw1)</span></span>; <span class="comment">// pw2指向pw1的Widget,pw1被设为nullptr</span></span><br><span class="line">pw1 = pw2; <span class="comment">// pw1现在再次指向Widget，pw2被设为nullptr</span></span><br></pre></td></tr></table></figure><br>举一个COAP的例子，它建立一个包含auto_ptr&lt;Widget&gt;的vector,然后对这个vector内部元素排序，其排序指标是一个谓词：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">widgetAPCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;Widget&gt;&amp; lhs,<span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;Widget&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *lhs &lt; *rhs; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">auto_ptr</span>&lt;Widget&gt; &gt; widgets; </span><br><span class="line">sort(widgets.<span class="built_in">begin</span>(), widgets.<span class="built_in">end</span>(),widgetAPCompare);<span class="comment">//无法编译</span></span><br></pre></td></tr></table></figure><br>这段代码看起来很合理，但实际上不行，原因在于在排序过程中widget中的一个或多个auto_ptr被置为null.之所以会这样，是快排的锅。快排的基本思想在于把容器内的某个元素作为pivot elements，然后对大于和小于等于该元素的其他元素递归调用排序。其方法看起来像这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>，<span class="title">class</span> <span class="title">Compare</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,<span class="title">RandomAccessIterator</span> <span class="title">last</span>,<span class="title">Compare</span> <span class="title">comp</span>)&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;RandomAccessIterator&gt;::value_type ElementType;</span><br><span class="line">    RandomAccessIterator i;</span><br><span class="line">    ... <span class="comment">// 让i指向主元</span></span><br><span class="line">    <span class="function">ElementType <span class="title">pivotValue</span><span class="params">(*i)</span></span>;<span class="comment">//将主元拷贝到一个局部变量中</span></span><br><span class="line">    ...<span class="comment">//接着排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个typename挺有讲究，强调了后面是一个类型，但我们不管，重点在于那个拷贝，它把auto_ptr的值放到了一个局部临时中，随着临时对象生命周期结束，对象也被析构了，真是倒了血霉。</p>
<p>所以说，不要搞包含auto_ptr的容器，其他智能指针配合容器倒是可以用用。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于对象——关键词所带来的差异</title>
    <url>/2018/05/01/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E8%AF%8D%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<p>（本节内容重在阐述struct与class关键词的区别，以及一些旧式技巧）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>C++本可以更加简洁与优雅，如果不需要去努力维系与C的兼容性的话。</p>
<hr>
<h1 id="关键词的困扰"><a href="#关键词的困扰" class="headerlink" title="关键词的困扰"></a>关键词的困扰</h1><p>&nbsp;<br>“何时应该用struct取代class？”<br>作者认为，在了解struct与class的区别之后，你可以把struct认为默认public的class，甚至你可以认为struct只是为了帮助C语言开发者尽快地适应C++。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>35.区分接口继承与实现继承</title>
    <url>/2018/04/18/%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>public继承概念其实由两部分组成<strong>：函数接口(function interface)继承与函数实现(function implementation)继承。</strong>这两种继承的差异类似于函数声明与函数定义的差异。</p>
<hr>
<h1 id="接口继承与实现继承"><a href="#接口继承与实现继承" class="headerlink" title="接口继承与实现继承"></a>接口继承与实现继承</h1><h2 id="具体含义"><a href="#具体含义" class="headerlink" title="具体含义"></a>具体含义</h2><p>public继承体系下derived class无非存在以下三种可能：</p>
<ol>
<li>只继承base class成员函数的接口（也就是声明）</li>
<li>同时继承接口与实现，并且能够覆写(override)它们所继承的实现</li>
<li>同时继承接口与实现，但不允许覆写任何东西</li>
</ol>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>以下有一个绘图程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ellipse</span>:</span><span class="keyword">public</span> shape &#123;&#125;</span><br></pre></td></tr></table></figure><br>可以看到抽象类shape内部共有三个声明方式各不相同的函数，draw是一个pure virtual函数，error是一个impure virtual函数，objectID是个non-virtual函数。</p>
<hr>
<h2 id="函数声明对继承的影响"><a href="#函数声明对继承的影响" class="headerlink" title="函数声明对继承的影响"></a>函数声明对继承的影响</h2><h3 id="pure-vitual"><a href="#pure-vitual" class="headerlink" title="pure vitual"></a>pure vitual</h3><p>pure virtual函数有两个最突出的特性：</p>
<ul>
<li><strong>必须被任何继承了它们的具象class重新声明</strong></li>
<li>通常在abstract class中没有定义</li>
</ul>
<p>综上，有结论如下：<strong>声明一个pure virtual的目的是为了让derived classes只继承函数接口</strong>。它等价于在对一个具象derived class要求：“你必须提供该函数，但我并不干涉你如何实现。”</p>
<p>实际上，pure virtual函数也可以有定义，但你只能通过“调用时明确指出其class名称”来调用它，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shape *ps = <span class="keyword">new</span> shape；</span><br><span class="line">ps—&gt;shape::draw();</span><br></pre></td></tr></table></figure><br>这种写法一般仅有一个用途：为impure virtual函数提供更平常更安全的缺省实现。</p>
<hr>
<h3 id="impure-virtual"><a href="#impure-virtual" class="headerlink" title="impure virtual"></a>impure virtual</h3><p>impure virtual函数的目的在于：<strong>让derived class继承该函数的接口与缺省实现。</strong>它等价于在告诉derived class的设计者，“你必须支持该函数，如果你不想自定义的话，那当前存在一个缺省版本。”</p>
<h4 id="隐含风险与解决方案"><a href="#隐含风险与解决方案" class="headerlink" title="隐含风险与解决方案"></a>隐含风险与解决方案</h4><p>允许impure virtual函数同时指定函数声明和函数缺省行为带有一定的风险。</p>
<h5 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h5><p>假定航空公司共有AB两种飞机，二者以相同方式飞行，因此继承体系如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span>&#123;</span>...&#125;;<span class="comment">//机场</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; derstination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">    ...<span class="comment">//缺省，将飞机飞往目的地</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span><span class="keyword">public</span> Airplane &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span><span class="keyword">public</span> Airplane &#123;...&#125;;</span><br></pre></td></tr></table></figure><br>截至目前为止，这个继承体系是完全正确的。但假设该航空公司又购买了一款新式飞机C，其飞行方式与AB不同。但由于急着令飞机上线，忘记了重定义其fly函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span><span class="keyword">public</span> Airplane &#123;...&#125;;</span><br><span class="line">Airplane* pa = <span class="keyword">new</span> ModelC;</span><br><span class="line">pa-&gt;fly(airport);</span><br></pre></td></tr></table></figure><br>上述程序试图用AB飞机的飞行方式来驱动C，无疑会造成雪崩。</p>
<h5 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h5><p>此问题的发生并不在于Airplane::fly()具备缺省行为，而在于ModelC在未表明自己需要的情况下就继承了该缺省行为。因此我们的程序应该完成这个功能：“<strong>提供缺省实现给derived class，但只有他们明确要求继承该缺省实现时才会继承”</strong></p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="protected-defaultFly"><a href="#protected-defaultFly" class="headerlink" title="protected defaultFly"></a>protected defaultFly</h6><p>此方法的原理在于切断“virtual函数接口”与“缺省实现”之间的连接。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>=<span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;<span class="comment">//函数以protected姿态封装</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">    ...<span class="comment">//缺省，将飞机飞往目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此时，fly已经被改为一个pure virtual函数，仅仅提供飞行接口。其缺省行为以独立的defaultFly登场，如果想要调用缺省行为，则在继承而来的fly接口中使用inline调用即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span><span class="keyword">public</span> Airplane&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">        defaultFly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">    ...<span class="comment">//自定义飞行模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="定义pure-virtual函数"><a href="#定义pure-virtual函数" class="headerlink" title="定义pure virtual函数"></a>定义pure virtual函数</h6><p>有人认为不应该定义defaultFly以污染命名空间，但接口和缺省实现也确实应该分开，于是他们巧妙地通过定义pure virtual函数来避免了这一尴尬：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>=<span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//缺省行为</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span><span class="keyword">public</span> Airplane&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">        Airplane::fly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">    ...<span class="comment">//自定义飞行模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="non-virtual"><a href="#non-virtual" class="headerlink" title="non-virtual"></a>non-virtual</h3><p>该函数的不变性(invariant)凌驾于特异性(specialization),因此它表示无论derived class表现地多么奇特，该函数行为都不可改变。<strong>声明non-virtual是为了令derived class继承函数的接口及一份强制实现。</strong></p>
<hr>
<h2 id="继承时易犯的错误"><a href="#继承时易犯的错误" class="headerlink" title="继承时易犯的错误"></a>继承时易犯的错误</h2><ul>
<li>将所有函数声明为non-virtual<br>除非你的class不作为base class,否则别这样作死，该用virtual就用，别过多担心其带来的效率问题。（除非在profiler发现真的是它们影响了效率）</li>
<li>将所有函数声明为virtual<br>除非你在写interface class，否则该有不变性就应该大胆地说出来。</li>
</ul>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>接口继承不同于实现继承。在public继承下，dc总是继承bc的接口。</li>
<li>pure virtual只继承接口。</li>
<li>impure virtual为继承指定接口及default实现。</li>
<li>non-virtual继承指定接口，并强制性继承实现。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>5.区间成员函数优于与之对应的单元素成员函数</title>
    <url>/2018/04/07/%E5%8C%BA%E9%97%B4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BC%98%E4%BA%8E%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%95%E5%85%83%E7%B4%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果我们试图将一个vector1内全部元素替换为vector2的后半部分，最好的办法是这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.assign(v2.<span class="built_in">begin</span>() + v2.<span class="built_in">size</span>() / <span class="number">2</span>, v2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>assign是一个很好用的函数，当我们想把容器复制到另一个类型相同的容器，operator=是一个好选择，但如果我们试图在不同的容器之间进行拷贝，或者给容器一组全新的值时，assign更优。</p>
<hr>
<h1 id="区间函数"><a href="#区间函数" class="headerlink" title="区间函数"></a>区间函数</h1><p>区间成员函数的特点是<strong>其形参是一对表示区间的迭代器</strong>。如果不用这种区间，我们往往需要编写循环，但这样效率很低。如果拒绝编写循环，我们可能会使用泛型算法来前言中提到的问题，比如说copy算法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环写法</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; v1, v2;</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ci = v2.<span class="built_in">begin</span>() + v2.<span class="built_in">size</span>() / <span class="number">2</span>;ci != v2.<span class="built_in">end</span>();++ci)&#123;</span><br><span class="line">    v1.push_back(*ci);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//copy算法</span></span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line">copy(v2.<span class="built_in">begin</span>() + v2.<span class="built_in">size</span>() / <span class="number">2</span>, v2.<span class="built_in">end</span>(), back_inserter(v1));</span><br></pre></td></tr></table></figure><br>但是实际上copy里面必然也包含循环，而且，所有利用插入迭代器(inserter,back_inserter,front_inserter)来限定目标区间的copy调用，其实都应该替换为对应区间版本函数的调用，比如上文的copy，可以替换为利用区间的insert版本<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1.insert(v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>() + v2.<span class="built_in">size</span>() / <span class="number">2</span>, v2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>与copy相比，代码略微简洁，但是最关键的是它直截了当地指出了发生的事情：插入。<br>STL滥用copy的情况应该被避免，所以再次重申：<strong>通过利用插入迭代器的方式来限定目标区间的copy调用，不如直接被替代为对区间成员函数的调用。</strong><br>区间成员函数在可阅读性上的优点可以被总结为：</p>
<blockquote>
<ol>
<li>代码简洁</li>
<li>意图清晰直接</li>
</ol>
</blockquote>
<hr>
<h1 id="性能优劣分析"><a href="#性能优劣分析" class="headerlink" title="性能优劣分析"></a>性能优劣分析</h1><p>我们会发现单元素成员函数比使用区间成员函数需要更多地调用allocator，更频繁地复制，以及更多的冗余操作。举例如下：<br>假定我们需要将一个int数组复制到vector的前端，如果使用insert函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> data[numValues]; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">v.insert(v.<span class="built_in">begin</span>(), data, data + numValues);</span><br></pre></td></tr></table></figure><br>如果通过循环显式地调用insert：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">insertLoc</span><span class="params">(v.<span class="built_in">begin</span>())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">    insertLoc = v.insert(insertLoc, data[i]);</span><br><span class="line">    ++insertLoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里值得注意的是，每一次都需要在insert后更新insertLoc，否则会出现2点问题，<br><strong>1. insertLoc失效，其插入行为不可预料</strong><br><strong>2. 即便不失效，插入总是发生在begin处，即倒着把data插入到最前面.</strong></p>
<p>如果使用copy算法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(data, data + numValues, inserter(v, v.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure><br>当copy模版被实例化后，其代码与基于循环的代码几乎完全相同。因此，我们在分析效率时，只需要分析循环那个版本。<br>总的说来，一共有3处影响了效率。</p>
<ol>
<li>不必要的函数调用<br>n个元素的插入必然调用了n次插入操作，而insert只有一次调用，虽然内联能解决这个问题，但编译器不一定会给你内联。</li>
<li>将v中已有的元素频繁地向后移动<br>如果内部元素是自定义类型，则会造成频繁地使用赋值操作运算符和拷贝构造函数（之前都是赋值，最后一个拷贝）<br>假设原有容器中有m个元素，需要插入n个元素，一共需要m<em>n次调用：（m-1）</em>n次赋值操作符，n次拷贝构造函数。而insert总是一步到位地将现有元素直接放到最终位置。总代价包括m次移动，n次拷贝构造函数。<br>虽然insert几乎总是一次性地移动所有元素到位，但其实它是建立在已知两个迭代器之间距离的基础上，而这个功能是由前向迭代器提供的。也就是说，当传入区间的是输入迭代器例如istream_iterator之类，insert就失去了性能上的优势</li>
<li>多次扩容<br>我们都知道如果你插入时vector的容量已满，它会进行扩容，此时又会复制一大波元素到新的位置。如果插入次数很多，那么扩容的次数也很多，因此，造成了大量的浪费。insert因为已知需要多少容量，因此减少了浪费。<br>以上说法对于vector和string同样有效。deque内存管理方式不同，所以内存重复分配的话题对它无效，但是反复移动与多次调用的结论仍然有效。list使用区间形式也有其优势，减少函数调用次数的优势依然存在，虽然list无需反复移动和构造，也不存在内存分配，但是存在对节点的next与prev指针重复多余的操作。一般而言，每一次插入都会导致节点的next与prev赋值一次，但如果我们提前知道插入了多少节点，就避免了重复指针赋值。</li>
</ol>
<hr>
<h1 id="哪些函数支持区间操作"><a href="#哪些函数支持区间操作" class="headerlink" title="哪些函数支持区间操作"></a>哪些函数支持区间操作</h1><h2 id="区间构造"><a href="#区间构造" class="headerlink" title="区间构造"></a>区间构造</h2><p>所有标准容器都提供这种形式的构造函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">container::container(InputIterator <span class="built_in">begin</span>,InputIterator <span class="built_in">end</span>);</span><br></pre></td></tr></table></figure><br>但如果传给构造函数的是istream_iterator或者istreambuf_iterator时，c++的分析机制会把这条语句解释为函数声明,而不是新建对象。</p>
<h2 id="区间插入"><a href="#区间插入" class="headerlink" title="区间插入"></a>区间插入</h2><p>所有标准序列容器都提供这种形式的insert：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::insert</span><span class="params">(iterator <span class="built_in">position</span>, InputIterator <span class="built_in">begin</span>,InputIterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>关联容器使用比较函数来决定元素要放在哪里，所以不能指定位置:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::insert</span><span class="params">(lnputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>对于插入，不要忘了很多函数其实做着与insert一样的事情，当你看到反复的push_back或者push_infront时，不妨提供给他们区间形式的insert版本。</p>
<h2 id="区间删除"><a href="#区间删除" class="headerlink" title="区间删除"></a>区间删除</h2><p>STL容器都支持区间删除，但是关联与非关联的返回值不同。<br>序列容器如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">container::erase</span><span class="params">(iterator <span class="built_in">begin</span>, iterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>关联容器如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::erase</span><span class="params">(iterator <span class="built_in">begin</span>, iterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>据说因为关联容器返回一个迭代器（指向被删除元素之后的元素）会造成难以负担的性能影响，所以关联容器不反回迭代器。</p>
<h2 id="区间赋值"><a href="#区间赋值" class="headerlink" title="区间赋值"></a>区间赋值</h2><p>所有标准列容器都提供了区间形式的assign：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::assign</span><span class="params">(InputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>区间函数的三大优点：</p>
<ol>
<li>代码简洁</li>
<li>目的明确</li>
<li>效率更高</li>
</ol>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>52.内存管理定式</title>
    <url>/2018/04/24/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9A%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>上一节描述了何时需要自定义operator new与operator delete，但并没有描述自定义时应当遵循何种规则。实际上这些规则并不难奉行，只是不太直观。</p>
<hr>
<h1 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h1><p>&nbsp;<br>operator new共有四个要求：</p>
<ol>
<li>返回正确的值</li>
<li>内存不足时必须调用new-handling函数</li>
<li>考虑0内存需求</li>
<li>避免掩盖global new（虽然这更偏近class接口要求）。</li>
</ol>
<hr>
<h2 id="operator-new-返回值"><a href="#operator-new-返回值" class="headerlink" title="operator new 返回值"></a>operator new 返回值</h2><p>一般而言，operator new返回值很简单，分配成功则返回一个指向那块内存的指针，反之则遵循Effective C++ 50的约定，并抛出一个bad_alloc异常。</p>
<p>其实也不是特别简单，因为它实际上不只一次尝试分配内存，并在每一次失败后都调用new-handling函数。这里假设new-handling也许能够释放一些内存，当只有指向new-handling函数的指针是nullptr时，operator new才会抛出异常。</p>
<hr>
<h2 id="0内存需求"><a href="#0内存需求" class="headerlink" title="0内存需求"></a>0内存需求</h2><p>c++规定，<strong>即使客户需要0bytes，也必须提供合法指针而不得返回nullptr</strong>。为了满足约定，有伪代码实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">0</span>) <span class="built_in">size</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        ...<span class="comment">//尝试分配内存</span></span><br><span class="line">        <span class="keyword">if</span>(分配成功）</span><br><span class="line">        <span class="keyword">return</span> （一个指向分配内存的指针）；</span><br><span class="line">        new_handler globalHandler = set_new_handler(<span class="literal">nullptr</span>);</span><br><span class="line">        set_new_handler(globalHandler);</span><br><span class="line">        <span class="keyword">if</span>(globalHandler)</span><br><span class="line">            *globalHandler();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中不太科学的地方就是将new-handling函数指针设置为nullptr后又迅速恢复了它，这是因为我们别无他法来获取当前的new-handling函数。这种操作技巧在单线程下拙劣且有效，多线程环境可能需要某种lock来确保new_handling函数背后的某种数据结构不遭破坏。</p>
<hr>
<h1 id="operator-new与继承体系"><a href="#operator-new与继承体系" class="headerlink" title="operator new与继承体系"></a>operator new与继承体系</h1><p>&nbsp;<br>在上述实例中我们没有考虑过继承。一般而言，定制内存管理器的常见理由是针对某个class的对象进行优化，而不是对其derived class对象作出优化。也就是说，针对class X而设计的operator new其行为只是刚好为sizeof（X）的对象而设计。众所周知，dc对象一般要大于bc对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;...&#125;;<span class="comment">//未声明operator new</span></span><br><span class="line">Derived* p = <span class="keyword">new</span> Derived;<span class="comment">//调用Base::operator new</span></span><br></pre></td></tr></table></figure><br>针对继承，我们有补救措施如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>!=<span class="keyword">sizeof</span>(Base))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);<span class="comment">//std::operator new</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看起来这种实现似乎没有考虑size==0的情况，但是实际上它考虑了，因为所有独立式对象必须有大小（见Effective C++ 40）因此sizeof(bc)无论如何都不会为0。</p>
<hr>
<h1 id="operator-new-1"><a href="#operator-new-1" class="headerlink" title="operator new[]"></a>operator new[]</h1><p>&nbsp;<br>如果我们需要实现new[],我们要做的事情只有一个：分配一块raw memory。因为我们既不知道这个array具体有多少元素，也不知道其元素的大小（因为dc的对象往往比bc的对象大），另外传递给new[]的size_t参数未必就是真正的元素个数，因为实际上array会有一部分负责存放其元素个数，它们也需要占据内存。</p>
<hr>
<h1 id="operator-delete"><a href="#operator-delete" class="headerlink" title="operator delete"></a>operator delete</h1><p>&nbsp;<br>operator delete的情况简单一些，你只需要记住“删除nullptr永远安全即可”：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    ...<span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当其作为class的member函数时，它只需要像new操作一样，检查一下sizeof是否有误即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>!=<span class="keyword">sizeof</span>(Base))&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemry)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>operator new内部有一个死循环，并在其中尝试分配内存，如果它不能分配，则调用new-handler，同时它应该能够处理0 bytes申请。class member版本则应该处理“比正确大小大或者小的申请”。</li>
<li>operator delete应该在收到nullptr时不做任何事，class版本还应该处理“比正确大小大或者小的申请”。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>同步并发操作——使用同步操作简化代码</title>
    <url>/2020/03/13/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>使用本节描述的技巧编码，开发者可以更多地将注意力集中至同步操作本身——使用函数式编程技法实现并发编程。</p>
<p>相较于在多个线程间直接共享数据，每个任务均拥有自己的数据似乎更为优雅，并且可将任务结果广播至其它线程——这需要使用future实现。</p>
<a id="more"></a>
<hr>
<h1 id="使用future的函数式编程"><a href="#使用future的函数式编程" class="headerlink" title="使用future的函数式编程"></a>使用future的函数式编程</h1><p>&nbsp;<br>函数式编程(functional programming)指的是一种编程范式，在该范式下，函数结果仅依赖于传入参数，并不依赖外部状态，其命名与数学概念相关。简而言之，若函数输入相同，则函数输出相同。C++标准库中很多与数学相关的函数都有这个特性，例如sin,cos,sqrt以及简单算术运算。</p>
<p>如果不存在任何试图修改共享数据的行为，数据竞争也就不复存在，那么诸如mutex之类的数据保护机制也无需使用。因此，HasKell这类函数式语言日益流行于并发编程。由于大多数操作都仅具备只读性，因此开发者仅需要关心存在写入的操作。</p>
<p>future是我们攻克函数式并发编程的最后一个难点。我们可以在线程间传递future，以此来保证某一次计算结果取决于另一次计算结果，并且无需任何对共享数据的显式访问。</p>
<hr>
<h2 id="快排实例"><a href="#快排实例" class="headerlink" title="快排实例"></a>快排实例</h2><h3 id="函数式快排"><a href="#函数式快排" class="headerlink" title="函数式快排"></a>函数式快排</h3><p>下图是一张快排实例图。<br><img src="http://static.zybuluo.com/zsmj2019/e5r8d5ks0f6byo41atcomapj/WX20200311-123528@2x.png" alt="WX20200311-123528@2x.png-186.3kB"><br>快排的函数式编程实例如下文所示，需要注意的是，其返回值是一个<code>list</code>，而非像<code>std::sort</code>一样就地排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(input.empty())&#123;</span><br><span class="line">    <span class="keyword">return</span> input;     </span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; result;</span><br><span class="line">  result.splice(result.<span class="built_in">begin</span>(),input,input.<span class="built_in">begin</span>());</span><br><span class="line">  T <span class="keyword">const</span>&amp; pivot=*result.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">auto</span> divide_point=<span class="built_in">std</span>::partition(input.<span class="built_in">begin</span>(),input.<span class="built_in">end</span>(),[&amp;](T <span class="keyword">const</span>&amp; t)&#123;<span class="keyword">return</span> t&lt;pivot;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lower_part;</span><br><span class="line">  lower_part.splice(lower_part.<span class="built_in">end</span>(),input,input.<span class="built_in">begin</span>(),divide_point);</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(sequential_quick_sort(<span class="built_in">std</span>::<span class="built_in">move</span>(lower_part)))</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(sequential_quick_sort(<span class="built_in">std</span>::<span class="built_in">move</span>(input)))</span></span>;</span><br><span class="line">  result.splice(result.<span class="built_in">end</span>(),new_higher);<span class="comment">// end is the pivot</span></span><br><span class="line">  result.splice(result.<span class="built_in">begin</span>(),new_lower);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们通过splice操作指定input的首个元素为基准点（由于并非选取了最优基准点，因此比较次数与交换次数相有所提升，但为了选取最优基准点引入的list遍历操作也同样耗时）。由于我们知道基准点必然出现在res中，因此使用splice将其添加进来是合理的。在lambda（比较函数）中，我们采取引用捕获的方式以避免不必要的拷贝。接着使用<code>partition</code>确保了list被按照大小分为2部分，并同样通过splice将其拆分为两个list，接着递归执行排序。最终，我们通过splice操作将排序完成的两个区间拼接在一起，至此快排完成。</p>
<hr>
<h3 id="并发函数式快排"><a href="#并发函数式快排" class="headerlink" title="并发函数式快排"></a>并发函数式快排</h3><p>以下是使用了<code>future</code>的并发函数式快排实例。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; <span class="title">parallel_quick_sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; input)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(input.empty())&#123;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; result;</span><br><span class="line">  result.splice(result.<span class="built_in">begin</span>(),input,input.<span class="built_in">begin</span>());</span><br><span class="line">  T <span class="keyword">const</span>&amp; pivot=*result.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">auto</span> divide_point=<span class="built_in">std</span>::partition(input.<span class="built_in">begin</span>(),input.<span class="built_in">end</span>(),[&amp;](T <span class="keyword">const</span>&amp; t)&#123;<span class="keyword">return</span> t&lt;pivot;&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lower_part;</span><br><span class="line">  lower_part.splice(lower_part.<span class="built_in">end</span>(),input,input.<span class="built_in">begin</span>(),divide_point);</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &gt; <span class="title">new_lower</span><span class="params">(<span class="built_in">std</span>::async(&amp;parallel_quick_sort&lt;T&gt;,<span class="built_in">std</span>::<span class="built_in">move</span>(lower_part)))</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(parallel_quick_sort(<span class="built_in">std</span>::<span class="built_in">move</span>(input)))</span></span>;</span><br><span class="line">  result.splice(result.<span class="built_in">end</span>(),new_higher);</span><br><span class="line">  result.splice(result.<span class="built_in">begin</span>(),new_lower.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和上个实例相比，二者最大的区别是本例使用<code>std::async</code>在另一个线程排序lower_part，upper_part则与原来一致。使用<code>std::async</code>的一大优势在于充分利用了硬件并发性，举例而言，如果向下执行3次递归，则将启动八个线程执行计算任务，如果执行10次递归（当list规模在1000左右时），将启动1024个线程执行计算。如果当前待执行的任务已经超出了硬件并发资源，则子任务（spawn_task）将被同步执行。这些子任务将在调用get()的线程中运行，从而避免于事无补地将任务传递至另一个线程。需要注意的是，若无std::launch::async的显式指定，std::async将为每一个任务启动一个新线程（即使当前已经超出了硬件最大并发量），有关std::async的启动机制，具体可见<a href="https://xander.wiki/post/61b11a8d.html">https://xander.wiki/post/61b11a8d.html</a> 。此外，由于new_lower是一个future，因此我们必须通过get来等待后台任务运行完成，接着执行splice。get的返回值是一个右值，可以直接move。最后，在此实例中<code>std::partition</code>依然是同步的，因此可以继续改进。</p>
<p>除了使用<code>std::async</code>自动生成<code>spawn_task</code>,开发者也可以通过简单封装<code>std::packaged_task</code>与<code>std::thread</code>,撰写自己的<code>spawn_task()</code>（如下述代码所示）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span> A&gt; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::result_of&lt;<span class="title">F</span><span class="params">(A&amp;&amp;)</span>&gt;::type&gt; <span class="title">spawn_task</span><span class="params">(F&amp;&amp; f,A&amp;&amp; a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::result_of&lt;F(A&amp;&amp;)&gt;::type result_type;</span><br><span class="line">  std::packaged_task&lt;result_type(A&amp;&amp;)&gt;  task(std::move(f)));     </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;     </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(task),<span class="built_in">std</span>::<span class="built_in">move</span>(a))</span></span>;     </span><br><span class="line">  t.<span class="built_in">detach</span>();     </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法相较于<code>std::async</code>并无优势可言（并且会导致大量的<code>massive oversubcription</code>），但却为“将精密事务迁移入由线程池维护的队列”——这一任务铺平了康庄大道（我们将在第九章详细论述）。</p>
<h1 id="CSP编程范式"><a href="#CSP编程范式" class="headerlink" title="CSP编程范式"></a>CSP编程范式</h1><p>&nbsp;</p>
<p>函数式编程并非是规避共享数据竞争的唯一途径，CSP(Communicating Sequential Processes)范式具备同样的能力。在此编程范式中，线程完全独立的，不再共享数据，但依旧支持线程间通信。</p>
<h2 id="通过信息传递机制实现同步"><a href="#通过信息传递机制实现同步" class="headerlink" title="通过信息传递机制实现同步"></a>通过信息传递机制实现同步</h2><p>CSP范式的理念很简单：如果不再存在共享数据，那么开发者可以通过[某一线程]对传入信息的响应方式来推断线程状态。在此情形下，每一个线程实际上都是一个状态机：线程将根据接受到的信息更新自身状态，并将一条或多条信息发送至别的线程，这些行为完全取决于线程自身的初始状态。</p>
<p>由于C++ thread共享地址空间，因此无法从语言层面保证不存在共享数据，开发者必须从实现层面上保证这一点。当然，消息队列必须为各线程所共享，但细节可以被封装至库内。</p>
<h3 id="设计实例"><a href="#设计实例" class="headerlink" title="设计实例"></a>设计实例</h3><p>设想现在正在为一台ATM机撰写程序，我们不仅需要处理与使用者的交互，还需要处理与银行后台系统的交互，同样，我们还需要操作物理设备以便让使用者能够自如地完成插卡，取钱，拔卡等操作。</p>
<p>该系统的一种实现方式是拆分任务，使其在三个独立的线程上运行：一个操作物理设备，一个处理ATM逻辑，一个与银行后台通信。这些线程完全可以仅通过信息传递完成通信，根本不需要共享数据。举例而言，当使用者按下按键后，操作物理设备的线程将发送信息至处理ATM逻辑的线程，后者又将发送信息至前者，指示应该吐出多少钱。</p>
<p>ATM 逻辑可以抽象为一个状态机，该线程内部维护一个状态，并根据下一次传入的信息更新自身状态，并反复循环，下图即为一次简单的状态流转。<br><img src="http://static.zybuluo.com/zsmj2019/xmg1nmjyq6q4v07r1pefkq0g/WX20200311-204143@2x.png" alt="WX20200311-204143@2x.png-288.2kB"><br>表征ATM逻辑的类具备一些展现自身状态的成员函数。每一个成员函数都与特定的传入信息相关，并根据传入信息更新内部状态，与此同时，每一种信息类型都表现为一种特定的结构体。具体而言，ATM机等待插卡的逻辑可以简化为下述代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card_inserted</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> account; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">atm</span> &#123;</span></span><br><span class="line">  messaging::receiver incoming;</span><br><span class="line">  messaging::sender bank;</span><br><span class="line">  messaging::sender interface_hardware;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (atm::*state)();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> account; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> pin;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">waiting_for_card</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interface_hardware.send(display_enter_card()); </span><br><span class="line">    incoming.wait().</span><br><span class="line">      handle&lt;card_inserted&gt;([&amp;](card_inserted <span class="keyword">const</span>&amp; msg)&#123;</span><br><span class="line">        <span class="comment">// handle仅接受类型为card_inserted的信息</span></span><br><span class="line">        <span class="comment">// 别的信息传入将导致丢弃</span></span><br><span class="line">        account=msg.account; </span><br><span class="line">        pin=<span class="string">""</span>;</span><br><span class="line">        interface_hardware.send(display_enter_pin()); </span><br><span class="line">        state=&amp;atm::getting_pin;</span><br><span class="line">        <span class="comment">// 执行结束后更新状态</span></span><br><span class="line">        <span class="comment">// run()内将执行新状态函数</span></span><br><span class="line">      &#125; </span><br><span class="line">    );</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getting_pin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    state=&amp;atm::waiting_for_card; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;*state)(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span>(messaging::close_queue <span class="keyword">const</span>&amp;) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p><code>getting_pin</code>的设计要较为复杂一些，有简化版实例如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atm::getting_pin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  incoming.wait()</span><br><span class="line">  <span class="comment">// 存在三种可传入信息</span></span><br><span class="line">  <span class="comment">// 因此handle呈链状</span></span><br><span class="line">  <span class="comment">// 每一次对handle的调用都会将消息类型特化为模板参数</span></span><br><span class="line">  .handle&lt;digit_pressed&gt;([&amp;](digit_pressed <span class="keyword">const</span>&amp; msg)&#123; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">const</span> pin_length=<span class="number">4</span>;</span><br><span class="line">    pin+=msg.digit;</span><br><span class="line">    <span class="comment">// 密码尚未输入完时不会改变状态，因此可以持续输入</span></span><br><span class="line">    <span class="keyword">if</span>(pin.length()==pin_length) &#123;</span><br><span class="line">      bank.send(verify_pin(account,pin,incoming));</span><br><span class="line">      state=&amp;atm::verifying_pin; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  )</span><br><span class="line">  .handle&lt;clear_last_pressed&gt;([&amp;](clear_last_pressed <span class="keyword">const</span>&amp; msg)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pin.empty()) &#123;</span><br><span class="line">      pin.resize(pin.length()<span class="number">-1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  )</span><br><span class="line">  .handle&lt;cancel_pressed&gt;([&amp;](cancel_pressed <span class="keyword">const</span>&amp; msg)&#123; </span><br><span class="line">    state=&amp;atm::done_processing; </span><br><span class="line">  &#125; </span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上文可见，代码中根本不存在同步和并发，ATM logic和系统的其他组件分别运行在独立的线程上。这种设计手法被称为Actor model——系统内存在多个运行于独立线程上的actor，每一个都通过发送和接受消息来处理当前任务，除了直接通过信息传入的状态外，彼此没有任何共享状态。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>同步并发操作——使用future等待一次性事件</title>
    <url>/2019/04/21/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%9C%9F%E6%9C%9B%E7%AD%89%E5%BE%85%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本节我们将讨论线程应当以何种方式处理一次性事件，即线程仅需要被notice一次。</p>
<a id="more"></a>
<h1 id="future"><a href="#future" class="headerlink" title="future"></a>future</h1><p>&nbsp;<br>C++标准库将这种一次性事件建模为<code>future</code>。当线程需要等待某个特定的一次性事件时，它将持有表征该事件的future。随后，线程将以一个较短的时间周期检查事件是否触发。当然，检查期间也会执行其他任务。又或者，线程可以在等待任务期间可以先执行一些别的任务，直到对应的任务触发(此时future的状态变为ready)，此后，future将无法被重置。</p>
<p>C++标准库提供了两种future：unique_future<code>std::future&lt;&gt;</code>与shared future<code>std::shared_future&lt;&gt;</code>，它们都位于头文件<code>&lt;future&gt;</code>内。一个<code>std::future</code>实例与一个指定事件相关联，而多个<code>std::shared_future</code>可以共享共一个事件，并在事件完成后同时ready，共享与事件相关的任何数据。如果事件不存在关联数据，则可以使用<code>std::future&lt;void&gt;</code>与<code>std::shared_future&lt;void&gt;</code>。</p>
<p>尽管future被广泛应用于线程间通信，但future对象本身并不提供同步访问。若当前存在多个线程需要访问同一个future对象，那么必须使用互斥量或类似的同步机制对数据访问进行保护。但<code>std::shared_future</code>存在一个特例：多个线程可以访问自己的<code>std :: shared_future</code>副本而无需同步。</p>
<p>最基础的一次性事件是获取线程函数返回值，由于std::thread`并没有提供一个简单的返回任务结果的接口，因此我们将使用future来实现。</p>
<hr>
<h1 id="带有返回值的后台任务"><a href="#带有返回值的后台任务" class="headerlink" title="带有返回值的后台任务"></a>带有返回值的后台任务</h1><p>&nbsp;<br>假设当前存在一个耗时颇久的计算任务，其结果并不需要立即获得，显然，该任务应当作为后台进程。</p>
<p>开发者可以使用<code>std::async</code>来启动当前无需立即得到结果的异步任务，<code>std::async</code>返回一个持有函数返回值的<code>std::future</code>对象，调用<code>get()</code>成员函数可以得到返回结果(调用后，当前线程将阻塞至future状态变为ready)。标准使用案例如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; the_answer=<span class="built_in">std</span>::async(find_the_answer_to_ltuae);</span><br><span class="line">  do_other_stuff();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"The answer is "</span>&lt;&lt;the_answer.<span class="built_in">get</span>()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类似于<code>std::thread</code>，future也支持调用者通过添加额外的参数向其内置任务传递参数。</p>
<ol>
<li>若第一个参数是指向一个成员函数的指针，第二个参数提供有该类的具体对象(无论是直接传入，通过指针还是包装于<code>std::ref</code>中)，剩余的参数将视作成员函数参数。</li>
<li>若不满足条件1，第二个及其之后的参数将视作传入函数或可调用对象的参数。<br>若传入参数为右值，异步任务中的拷贝将直接通过移动构造函数完成创建，因此<code>std::async</code>支持将<code>move only</code>对象作为参数传入。具体使用如下所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">X x; </span><br><span class="line"><span class="keyword">auto</span> f1 = <span class="built_in">std</span>::async(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">"hello"</span>);<span class="comment">// 调用p-&gt;foo(42,"hello") p为成员函数指针</span></span><br><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">std</span>::async(&amp;X::bar,x,<span class="string">"goodbye"</span>);<span class="comment">// tmpx.bar("goodbye") tmpx是x的拷贝副本 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span>)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">Y y; </span><br><span class="line"><span class="keyword">auto</span> f3=<span class="built_in">std</span>::async(Y(),<span class="number">3.141</span>);<span class="comment">// tempy(3.141) tempy由y移动构造函数生成</span></span><br><span class="line"><span class="keyword">auto</span> f4=<span class="built_in">std</span>::async(<span class="built_in">std</span>::ref(y),<span class="number">2.718</span>);<span class="comment">// y(2.718)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>; </span><br><span class="line"><span class="built_in">std</span>::async(baz,<span class="built_in">std</span>::ref(x)); <span class="comment">// 调用baz(x) </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">move_only</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  move_only();</span><br><span class="line">  move_only(move_only&amp;&amp;)</span><br><span class="line">  move_only(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;);</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">auto</span> f5=<span class="built_in">std</span>::async(move_only()); <span class="comment">// 调用tempm，tempm由std::move(move_only())移动构造生成</span></span><br></pre></td></tr></table></figure>
值得注意的是，<code>std::async</code>并不保证任务被异步执行，更进一步地说，<code>std::async</code>的默认启动策略既可能启动一个新线程运行任务，但该任务也可能仅在future被调用<code>get()</code>或<code>wait()</code>时才会运行。为了明确任务启动策略，开发者可向<code>std::async</code>传入一个额外参数类型<code>std::lunch</code>，它是一个<code>enum class</code>，所含枚举量如下：</li>
<li><code>std::launch::async</code>，意味着函数必然将运行于另一个线程之上（即异步运行）</li>
<li><code>std::launch::defered</code>，函数的执行被推迟至调用<code>get</code>或<code>wait</code>时。当调用<code>get</code>或<code>wait</code>时，函数将同步执行（即阻塞调用程序，直到函数完成运行）。如果一直不调用<code>get</code>或<code>wait</code>，f将永不执行。</li>
</ol>
<p>其使用如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f6=<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,Y(),<span class="number">1.2</span>); <span class="comment">// 在新线程上执行 </span></span><br><span class="line"><span class="keyword">auto</span> f7=<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred,baz,<span class="built_in">std</span>::ref(x)); <span class="comment">// 在 wait()或get()调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f8=<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred | <span class="built_in">std</span>::launch::async, baz,<span class="built_in">std</span>::ref(x)); <span class="comment">// 默认启动策略</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="任务与期望"><a href="#任务与期望" class="headerlink" title="任务与期望"></a>任务与期望</h1><p>&nbsp;<br><code>std::async</code>并非是future与任务关联的唯一方式，开发者也可以将task包装至<code>std::packaged_task</code>或<code>std::promise</code>。前者的抽象级别更高。</p>
<h2 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h2><p><code>std::packaged_task</code>将一个future绑定至函数或可调用对象。当<code>std::packaged_task</code>对象被调用时，它将调用相关函数或可调用对象，将future状态置为就绪，并将返回值存储于其中。</p>
<p><code>std::packaged_task</code>常用于构建线程池的结构单元或管理其他任务，如在任务所在线程运行任务(同步)，或在某后台线程中按顺序运行所有任务。如果当前存在一个粒度较大的操作，并且该操作可分解为独立的子任务时，则可将各子任务包装于<code>std::packaged_task</code>中，并将该实例传递给任务调度器或线程池。这种操作对任务的细节进行了抽象，调度器仅处理<code>std::packaged_task</code>实例，而非处理单独的函数。</p>
<p><code>std::packaged_task</code>的模板参数是一个函数签名，如<code>void()</code>或<code>int(string&amp;,double)</code>。<code>std::packaged_task</code>的构造函数必须传入一个函数或可调用对象，它们的形参与返回值必须能够隐式转为模板参数，即不需要严格地一致。</p>
<p>以下是一个<code>std::packaged_task</code>的模板偏特化实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">packaged_task</span>&lt;std::string(std::vector&lt;char&gt;*,int)&gt; &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable&amp;&amp; f)</span></span>; <span class="comment">// f的形参必须能隐式转为std::vector&lt;char&gt;*,int</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">get_future</span><span class="params">()</span></span>;<span class="comment">// f的返回值必须能隐式转为std::string</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;*,<span class="keyword">int</span>)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::packaged_task</code>是一个可调用对象，它可以被封装至<code>std::function</code>中，可以作为线程函数传递给<code>std::thread</code>，可以作为另一个函数的实参(该函数接受一个可调用对象)，甚至可以被直接调用。当<code>std::packaged_task</code>作为函数对象被调用时，提供至其<code>operator()</code>的参数被传递至其内部包含的函数，返回值将作为异步运行结果存储于<code>get_future</code>提供的<code>std::future</code>中。</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>许多GUI框架都利用某个特定的更新线程完成界面更新，因此当某个线程需要更新当前界面时，它将发送信息至更新线程，敦促后者完成界面更新操作。通过<code>std::packaged_task</code>我们可以实现该需求，并且杜绝了发送自定义信息的需要。具体实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex m; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gui_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!gui_shutdown_message_received()) &#123; </span><br><span class="line">    get_and_process_gui_message(); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">void</span>()&gt; task; </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; </span><br><span class="line">      <span class="keyword">if</span>(tasks.empty()) </span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      task = <span class="built_in">std</span>::<span class="built_in">move</span>(tasks.front());</span><br><span class="line">      tasks.pop_front();</span><br><span class="line">    &#125; <span class="comment">// 此处互斥量的锁被释放</span></span><br><span class="line">    task();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将任务置入队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; res = task.get_future();</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  tasks.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(task));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段程序十分易懂：GUI线程将反复循环，直至收到一条关闭图形界面的命令。在循环过程中，该线程将轮询界面消息(时间点1)，处理诸如用户点击或当前存在于队列内的任务，当前队列内不存在任务时则继续循环。若当前队列内存在任务，则使用<code>std::move</code>提取该任务，随后释放锁并执行任务。此时future与任务相关，当任务执行完毕后其状态将被置为ready。</p>
<p>将任务置入队列也很简单：首先利用传入参数f创建一个task，并通过该task的成员函数<code>get_future</code>获取future对象，在将task推入队列后返回该future。若当前明确需要了解任务是否完成，函数调用方可等待future，否则直接丢弃。</p>
<p>在该实例中我们使用了<code>std::packaged_task&lt;void()&gt;</code>，这表明我们期待传入参数是一个无参数无返回值函数或可调用对象(若其存在返回值，则该返回值将被丢弃)。</p>
<hr>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>对于一些packaged_task不能解决的问题，如任务为非简单调用或存在多个不同来源的任务，我们可以通过<code>std::promise</code>来显式地设定future。</p>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>若当前存在一个需要处理大量网络连接的应用程序，一个线程对应一个连接的设计非常易于实现。但是该方案仅适用于网络连接较少的情况，随着连接数的增加(亦即线程数的增加)，操作系统资源被大量消耗，并且可能引发较多的上下文切换(线程数目超过硬件核心数)，最终导致程序性能下降。为了避免上述问题，在网络连接较多时，通常一个线程会处理多个网络连接。</p>
<p>对于需要处理多个网络连接的线程而言，来自不同网络连接的数据包将会被乱序处理，同样地，需要被发送的数据包也将被乱序发送。在大多数情况下，应用程序的其他线程不是在等待数据发送成功，就是在等待数据接收成功。</p>
<p><code>std::promise&lt;T&gt;</code>与<code>std::future&lt;T&gt;</code>相关联，它将为上述疑难杂症提供如下机制：数据等待线程可以由futur阻塞，而数据发送线程可通过<code>promise</code>设定相关值，并将future状态置为ready。类似于<code>packaged_task</code>，future对象可通过<code>get_future</code>成员函数显式获得。当<code>std::promise</code>调用<code>set_value</code>成员函数设定相关值完毕后，future对象状态将被置为<code>ready</code>，并可用于检索存储值。若你在调用<code>set_value</code>前析构<code>std::promise</code>，将会存储一个异常。</p>
<p>下述代码展示了如何利用<code>std::promise</code>与<code>std::future</code>完成单线程处理多网络连接。在此实例中，开发者使用<code>std::promise&lt;bool&gt;</code>与<code>std::future&lt;bool&gt;</code>表征数据块的成功传输，与future相关的数据是简单的bool量：成功/失败。对于数据传入，该量则为数据包的有效负载。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_connections</span><span class="params">(connection_set&amp; connections)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!done(connections))&#123; </span><br><span class="line">    <span class="keyword">for</span>(connection_iterator connection=connections.<span class="built_in">begin</span>(),<span class="built_in">end</span>=connections.<span class="built_in">end</span>(); connection!=<span class="built_in">end</span>; ++connection) &#123; </span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;has_incoming_data())&#123; </span><br><span class="line">        data_packet data=connection-&gt;incoming();   </span><br><span class="line">        <span class="built_in">std</span>::promise&lt;payload_type&gt;&amp; p = connection-&gt;get_promise(data.id); </span><br><span class="line">        p.set_value(data.payload); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;has_outgoing_data())&#123; </span><br><span class="line">        outgoing_packet data= connection-&gt;top_of_outgoing_queue(); </span><br><span class="line">        connection-&gt;send(data.payload); </span><br><span class="line">        data.promise.set_value(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>process_connections</code>将持续循环至处理完毕，每一次循环都将遍历当前所有连接，检索传入数据或发送当前队列顶端数据。在本实例中，我们假设所有传入数据均具备属性<code>ID</code>与<code>payload</code>。</p>
<hr>
<h1 id="利用future存储异常"><a href="#利用future存储异常" class="headerlink" title="利用future存储异常"></a>利用future存储异常</h1><p>&nbsp;<br>当-1作为实参被传入下述程序时将发生异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square_root</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;<span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(“x&lt;<span class="number">0</span>”); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若当前该函数被异步调用，将会导致什么结果？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">double</span>&gt; f=<span class="built_in">std</span>::async(square_root,<span class="number">-1</span>); </span><br><span class="line"><span class="keyword">double</span> y=f.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><br>该问题的答案是：异常将代替返回值，被存储至future中（此时future被置位为ready）。当future对象调用<code>get</code>成员函数时，该异常将被重新抛出（C++标准并没有明确规定抛出原始异常还是其副本，具体实现由各编译器决定）。被封装至<code>std::packaged_task</code>内的函数或可调用对象抛出异常也是如此。</p>
<p><code>std::promise</code>同样会将异常存储于future中，但除此之外，它还提供有显式接口。若开发者明确当前需要存储异常，则可以直接通过<code>set_exception</code>成员函数完成需求。显然，<code>set_exception</code>一般出现在catch语句中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::promise&lt;<span class="keyword">double</span>&gt; some_promise; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  some_promise.set_value(calculate_value()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(...) &#123; </span><br><span class="line">  some_promise.set_exception(<span class="built_in">std</span>::current_exception()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里使用了<code>std::current_exception</code>来检索当前异常，存在一种替代方案：使用<code>std::copy_exception()</code>直接存储新的异常而不抛出：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">some_promise.set_exception(<span class="built_in">std</span>::copy_exception(<span class="built_in">std</span>::logic_error(<span class="string">"foo "</span>)));</span><br></pre></td></tr></table></figure><br>显然，在明确异常类型的前提下，这种写法不仅使得try catch代码块更加直观，也给了编译器更大的优化空间。</p>
<p>另一种存储异常的方法是：在调用<code>std::promise</code>的set成员函数之前析构<code>std::promise</code>对象，亦或在调用<code>std::packaged_task</code>中的任务之前析构<code>std::packaged_task</code>。在future状态为ready之前析构<code>std::promise</code>将导致析构函数存储一个<code>std::future_error</code>异常，其错误码为<code>std::future_errc::broken_promise</code>。</p>
<hr>
<h1 id="shared-future"><a href="#shared-future" class="headerlink" title="shared_future"></a>shared_future</h1><p>&nbsp;<br>尽管<code>std::future</code>可以处理所有在线程间数据转移的必要同步，但对<code>std::future</code>成员函数的调用并不彼此同步，也就是说在多线程下没有保护措施地访问一个future对象将导致数据竞争和未定义行为。这由<code>std::future</code>的特性决定：<code>std::future</code>独享同步结果的所有权，在<code>get</code>成员函数调用后将不会存在任何可获取的值。</p>
<p>如果当前存在多个线程等待同一个事件，那么我们应当使用<code>std::shared_future</code>。顾名思义，<code>std::future</code>是一个<code>move only object</code>，而<code>std::shared_future</code>可被拷贝。但<code>std::shared_future</code>也不具备调用成员函数时的同步性，因此在使用时必须以锁保护。</p>
<p>使用<code>std::shared_future</code>的首选方案是将其副本传递给每一个需要使用的线程，如此则可保证所有线程均可在其内部通过<code>std::shared_future</code>安全访问结果，使用实例如下图所示。<br><img src="http://static.zybuluo.com/zsmj2019/nld57wa0ysra9ccrvjky2yot/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-28%20%E4%B8%8A%E5%8D%889.12.54.png" alt="屏幕快照 2019-04-28 上午9.12.54.png-302.9kB"></p>
<p><code>std::shared_future</code>的一大潜在用途是实现复杂表格中的并行运行。每个单元个均具备计算结果，并且该值可被其他单元格引用，因此公式内部可使用<code>std::shared_future</code>对象表征单元格计算结果。在堆所有单元格公式执行并行计算后，所有可被计算的结果将直接计算，而尚存在依赖的单元格计算线程将被阻塞，直到相关数据准备就绪。这种方案最大程度地利用了当前可用的硬件并发。</p>
<p>某些<code>std::shared_future</code>由<code>std::future</code>构造而来，由于后者不具备拷贝属性，因此在构造时我们应当使用<code>std::move</code>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(p.get_future())</span></span>; </span><br><span class="line">assert(f.valid()); <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">sf</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(f))</span></span>; </span><br><span class="line">assert(!f.valid()); <span class="comment">// true</span></span><br><span class="line">assert(sf.valid()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br>由于右值具备隐式的移动操作，因此我们可以直接使用<code>get_future</code>返回值构造<code>std::shared_future</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; p; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">sf</span><span class="params">(p.get_future())</span></span>;</span><br></pre></td></tr></table></figure><br>当然了，也可以不必这么麻烦，<code>std::future</code>的成员函数<code>share</code>可以直接创建一个<code>std::shared_future</code>，并将所有权直接传递给它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;SomeIndexType, SomeDataType, SomeComparator, SomeAllocator&gt;::iterator&gt; p; </span><br><span class="line"><span class="keyword">auto</span> sf = p.get_future().share();</span><br></pre></td></tr></table></figure><br><code>share</code>的存在使得<code>auto</code>成为可能，从而避免打出大量错综复杂的类型名。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>右值引用、移动语义、完美转发</title>
    <url>/2018/07/11/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<p>移动语义使编译器可以用移动操作来替换花销较大的复制操作。与拷贝构造函数和拷贝赋值运算符类似，开发者可以自由定制移动操作的一切行为。移动语义还允许创建move-only类型，例如std::unique_ptr，std::future和std::thread。</p>
<p>完美转发使得编写形参为任意参数的函数模板成为可能，并且能够在转发参数时确保接收函数与发送函数保持一致。</p>
<p>Rvalue引用是将这两个不同的特性联系在一起的粘合,它是使移动语义和完美转发成为可能的底层语言机制。</p>
<p>对这些功能的体验越多，开发者就越意识到这些功能妙用无穷。移动语义，完美转发和右值引用的世界比它们展示出来的更加微妙。举例而言，std::move不移动任何东西，完美转发并不完美。移动操作并不总是拷贝制开销更低; tyep&amp;&amp; 也并不总是代表右值引用等等。</p>
<p>在本章需要明确的是，参数必然是一个左值，即使它被声明为一个右值形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; w)</span></span>;</span><br></pre></td></tr></table></figure><br>即w是一个左值，即使其类型为rvalue-reference-to-Widget。</p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>同步并发操作——限制等待时间</title>
    <url>/2019/05/07/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E9%99%90%E5%88%B6%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在本章前文所述的各项等待操作中，线程阻塞的时间并不确定，但在实际应用中存在这样的需求：限制线程等待时间——在线程等待特定的一段时间后，开发者既可以向用户发出“该事件仍未完成”的提示，也可以接受由于用户放弃等待从而关闭线程的命令。</p>
<p>判断程序运行超时有两种方式：</p>
<ol>
<li>duration-based<br>该方式需要用户指定一段时间，例如30ms。</li>
<li>absolute<br>该方式需要用户提供一个时间点，例如17:30:15.045987023 UTC on November 30, 2011。</li>
</ol>
<p>大多数等待函数均支持这两种方式，处理<code>duration-based</code>的后缀为<code>_for</code>，处理<code>absolute</code>的后缀为<code>_until</code>。举例而言，<code>std::condition_variable</code>的成员函数<code>wait_for()</code>和<code>wait_until()</code>。此外，这些函数具备2种重载，第一种重载形式等待着信号触发或虚假唤醒，另一种则在唤醒时检查谓词，并仅在结果为<code>true</code>的情况下返回，或直接超时返回。更多相关信息可见本节末尾的图表。</p>
<a id="more"></a>
<h1 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h1><p>&nbsp;<br>在探讨超时之前，有必要先了解一下时间在C++中的表现形式，首先从<code>clock</code>开始。<br>对C++标准库而言，<code>clock</code>意味着时间信息源，具体来说，<code>clock</code>是一个类，提供了4种不同的信息：</p>
<ol>
<li>当前时间</li>
<li>时间类型</li>
<li>时钟节拍</li>
<li>时钟是否稳定（由时钟节拍确定）</li>
</ol>
<h2 id="当前时间"><a href="#当前时间" class="headerlink" title="当前时间"></a>当前时间</h2><p>当前时间可通过调用该类的静态成员函数<code>now</code>获得，如<code>std::chrono::system_clock::now()</code>将返回系统时钟当前时间。</p>
<h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p>时间类型由<code>time_point</code>中的<code>typedef</code>指定，因此<code>some_clock::now()</code>的类型为<code>some_clock::time_point</code>。</p>
<h2 id="时钟节拍"><a href="#时钟节拍" class="headerlink" title="时钟节拍"></a>时钟节拍</h2><p>时钟节拍被指定为1/x(x取决于硬件)秒。若当前时钟一秒有25个节拍，则其一个时钟周期为<code>std::ratio&lt;1, 25&gt;</code>。若时钟的时钟节拍每2.5秒一次，则时钟周期则可表示为<code>std::ratio&lt;5, 2&gt;</code>。时钟周期通常会在数据手册中给出，但如果当前并不知悉，则可以通过多次运行特定程序的方法求解平均值（这种方法并不保证精确性）。</p>
<h2 id="时钟稳定性"><a href="#时钟稳定性" class="headerlink" title="时钟稳定性"></a>时钟稳定性</h2><p>若时钟节拍均匀分布（无论该速率与时钟周期匹配与否）且无法调整，则称该时钟为稳定时钟，在此类情况下，时钟类中的<code>is_steady</code>静态数据成员为<code>true</code>，否则为<code>false</code>。通常情况下我们可以认为<code>std::chrono::system_clock</code>不稳定，因为该时钟可被调整（即使这种调整是为了抑制本地时钟漂移而自发进行的）。</p>
<p>对时钟的调整行为可能导致一个问题：当前调用<code>now</code>返回的时间要早于之前调用<code>now</code>返回的时间。（举例而言，做手机app的耗时监控，在app启动后用户调整了时间，从而导致计算错误，此时应当使用绝对时间）。</p>
<p>时钟的稳定性对于超时计算而言非常重要，因此C++标准库提供了<code>std::chrono::steady_clock</code>。<code>std::chrono::system_clock</code>代表了系统时钟的“实际时间”，并且提供了可将时间点转化为<code>time_t</code>类型的接口；<code>std::chrono::high_resolution_clock</code>提供了具备最高分辨率（即最小的时钟周期）的时钟。上述时钟及其相关工具均位于头文件<code>&lt;chrono&gt;</code>中。</p>
<hr>
<h1 id="Durations"><a href="#Durations" class="headerlink" title="Durations"></a>Durations</h1><p>&nbsp;<br>时延是本节最简单的内容：它们由<code>std::chrono::duration&lt;&gt;</code>函数模板进行处理(位于<code>std::chrono</code>命名空间内)。第一个模板参数是一个时延外在表现的类型(如int，long或double)，第二个模板参数是制定部分，表示每一个单元所用秒数。举例而言，当存在分钟级时延需要存储于<code>short</code>类型中时，可以写成<code>std::chrono::duration&lt;short,std::ratio&lt;60,1&gt;&gt;</code>，因为一分钟包含60秒。若需要将毫秒级时延存储于<code>double</code>类型中时，则写作<code>std::chrono::duration&lt;short,std::ratio&lt;1,1000&gt;&gt;</code>，原因在于一秒包含1000毫秒。</p>
<p>在隐式转换下，时延转换不存在截断（即可由时转为秒，但不可由秒转为时）。我们可以通过显式操作<code>std::chrono::duration_cast&lt;&gt;</code>来完成转换(具备截断）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>; </span><br><span class="line"><span class="built_in">std</span>::chrono::seconds s= <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(ms); <span class="comment">// s = 54</span></span><br></pre></td></tr></table></figure></p>
<p>时延支持算术操作，因此开发者可以对它进行加减乘除操作。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>*seconds(<span class="number">1</span>) == seconds(<span class="number">5</span>) == minutes(<span class="number">1</span>) - seconds(<span class="number">55</span>)</span><br></pre></td></tr></table></figure><br>此外，可以通过成员函数<code>count</code>获取时延中的单元数量，如<code>std::chrono::milliseconds(1234).count()</code>是1234。</p>
<p>为了方便起见，在C++1 中引入的<code>std::chrono_literals</code>命名空间内有许多预定义字面值后缀操作符，因此后续可以直接写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals; </span><br><span class="line"><span class="keyword">auto</span> one_day=<span class="number">24</span>h;</span><br><span class="line"><span class="keyword">auto</span> half_an_hour=<span class="number">30</span><span class="built_in">min</span>;</span><br><span class="line"><span class="keyword">auto</span> max_time_between_messages=<span class="number">15</span>ns; <span class="comment">// ==  std::chrono::nanoseconds(15)</span></span><br></pre></td></tr></table></figure>
<h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>假设开发者期待在35ms内一个<code>future</code>对象状态就绪，以便于执行相关操作，那么该需求可被写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f=<span class="built_in">std</span>::async(some_task); </span><br><span class="line"><span class="keyword">if</span>(f.wait_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">35</span>)) == <span class="built_in">std</span>::future_status::<span class="built_in">ready</span>) </span><br><span class="line">  do_something_with(f.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><br>所有的<code>wait</code>函数均返回一个状态，用以指示当前时间已经耗尽或者说等待事件已经发生。在刚才的代码实例中，由于我们调用的是<code>future</code>的程序函数<code>wait_for</code>，因此它存在三种返回状态：</p>
<ol>
<li>std::future_status::timeout 时延耗尽</li>
<li>std::future_status::ready future 已就绪</li>
<li>std::future_status::deferred future 任务被延迟</li>
</ol>
<p>计算时延所使用的是系统内部提供的稳定时钟，因此无论系统时钟<code>system_clock</code>发生怎样的调整，线程耗时总是35毫秒。当然，由于难以预料的系统调度和操作系统间不同的时钟精度，从调用该线程到返回该线程的时间可能要远长于35毫秒。</p>
<hr>
<h1 id="time-point"><a href="#time-point" class="headerlink" title="time_point"></a>time_point</h1><p>&nbsp;<br>时钟的时间点可以用<code>std::chrono::time_point&lt;&gt;</code>类模板实例来表示。模板的第一个参数用来指定所要使用的时钟，第二个参数表示时延的计量单位(<code>std::chrono::duration&lt;&gt;</code>的特例化 )。一个时间点的值就是以一个时间戳(epoch)作为起点的时间的长度(其必然为指定时延的倍数)。时间戳是时钟的基本属性，但它既不可直接查询也不并非由C++标准指定。通常采用的时间戳为1970年1月1日00:00，或运行应用程序的计算机启动时。不同的时钟实例可能共享一个时间戳，也可能具备各自独立的时间戳。虽然我们并不了解当前使用的是何种时间戳，但开发者可通过对指定<code>time_point</code>类型使用<code>time_since_epoch()</code>来获取时延值，该时延值即为当前时间距离时间戳的距离。</p>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>举例而言，<code>std::chrono::time_point&lt;std:: chrono::system_clock, std::chrono::minutes&gt;</code>表示当前时间点与系统时钟相关联，且其时延计量单位为分钟。我们可以自由地通过对一个时间点执行算术运算，从而获取另一个时间点，如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::high_resolution_clock:: now() + <span class="built_in">std</span>::chrono::nanoseconds(<span class="number">500</span>)</span><br></pre></td></tr></table></figure><br>我们也可以在两个时间点之间执行算术运算（二者需要共享一个时钟），从而获取时间差。这常见于代码块的计时需求：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=<span class="built_in">std</span>::chrono::high_resolution_clock::now(); </span><br><span class="line">do_something(); </span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">stop</span>=<span class="built_in">std</span>::chrono::high_resolution_clock::now(); </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;”do_something() took “&lt;&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>,<span class="built_in">std</span>::chrono::seconds&gt;(<span class="built_in">stop</span>-start).count()&lt;&lt;” seconds”&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><br>应当尽量避免在计时代码块中调整<code>std::chrono::time_point</code>所指定的时钟，因为这将导致计时错误。</p>
<p>假设当前存在一个事件，而我们至多等待该事件500毫秒，则有程序如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> done; </span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> timeout = <span class="built_in">std</span>::chrono::steady_clock::now() + <span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>); </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; </span><br><span class="line">  <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.wait_until(lk,timeout) == <span class="built_in">std</span>::cv_status::timeout)</span><br><span class="line">    	<span class="keyword">break</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Functions-that-accept-timeouts"><a href="#Functions-that-accept-timeouts" class="headerlink" title="Functions that accept timeouts"></a>Functions that accept timeouts</h1><p>&nbsp;<br>开发者经常需要为特定的线程添加延迟，让它们休眠一段指定时间或休眠至特定时间点，而这两个需求的实现依赖于函数<code>std::this_thread::sleep_for()</code>与<code>std::this_thread::sleep_until()</code>。</p>
<p>显然，休眠只是超时（timeout）处理的一种形式，在上文中，超时配合条件变量与期望一起使用。超时甚至可以在尝试获取一个互斥锁时(前提是该互斥锁支持timeout)使用，传统的<code>std::mutex</code>与<code>std::recursive_mutex</code>并不支持超时，但<code>std::timed_mutex</code>与<code>std::recursive_timed_mutex</code>则可以。它们具备了名为<code>try_lock_for</code>与<code>try_lock_until</code>的成员函数。下表则更具体地展示了支持timeout的函数，并给出了它们所需参数与返回值。</p>
<p><img src="http://static.zybuluo.com/zsmj2019/0gqjv6v3rep0hvrwgvxkzawj/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-23%20%E4%B8%8B%E5%8D%8811.09.46.png" alt="屏幕快照 2019-06-23 下午11.09.46.png-457.7kB"></p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>12. 在operator=中处理自赋值</title>
    <url>/2018/04/09/%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>我们在重载operator=时需要注意自我赋值的情况。可能有人会认为这种情况很少发生，因为很少有人会写诸如w=w的句子。但实际上,代码中出现a[i]=a[j]（i==j),或者<em>p=</em>q（指向同一对象）的例子屡见不鲜。<br>事实上，只要你使用了pointers或者references，而且它们被用来指向多个相同类型的对象，我们就需要考虑 是否会出现自赋值的情况。确切地说，<strong>只要有多个对象来自同一个继承体系</strong>，比如一个指针指向base class类型，而另一个指向derived class类型。<strong>它们完全可能指向的是同一个对象</strong>。</p>
<hr>
<h1 id="不处理自赋值情况的风险"><a href="#不处理自赋值情况的风险" class="headerlink" title="不处理自赋值情况的风险"></a>不处理自赋值情况的风险</h1><p>&nbsp;<br>如果我们在class中手动地进行了资源管理，那么自赋值的处理不当可能会带来一些问题。举例而言:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span>...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);<span class="comment">//如果是自赋值，pb指向的对象已经释放</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序<strong>既不具备异常安全性，也直接导致了“在停止使用资源前意外地释放了它”</strong>。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="证同测试"><a href="#证同测试" class="headerlink" title="证同测试"></a>证同测试</h2><p>其原理很简单：在函数最前端放上这样一句话：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(this&#x3D;&#x3D;&amp;rhs) return *this;</span><br></pre></td></tr></table></figure><br>这个解决方案保证了自赋值安全性，但是不具备异常安全性。在这句话中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pb=<span class="keyword">new</span> Bitmap(*rhs.pb);<span class="comment">//已通过证同测试，此时已经执行delete</span></span><br></pre></td></tr></table></figure><br>如果new导致了一个异常（内存不足或者copy构造函数抛出异常），那么pb始终会指向一块被删除的Bitmap。我们无法安全地删除pb,甚至读取它。</p>
<h2 id="手动保证异常安全"><a href="#手动保证异常安全" class="headerlink" title="手动保证异常安全"></a>手动保证异常安全</h2><p>因为只要解决了异常安全性，那么自赋值安全性就会必然得到解决，所以我们倾向于使用足够完美的逻辑避免异常的发生，其原理也很简单：在赋值pb前别删pb<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitnap * porig = pb；</span><br><span class="line">pb =<span class="keyword">new</span> bitmap(rhs.pb);</span><br><span class="line"><span class="keyword">delete</span> porig;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><br>这样的好处不言自明，如果pb没能正确赋值，其对象也没有被析构。（异常发生时跳出了operator=函数，因此没有执行delete porig）。如果正确赋值，pb指向的对象被释放。</p>
<h2 id="copy-amp-amp-swap"><a href="#copy-amp-amp-swap" class="headerlink" title="copy&amp;&amp;swap"></a>copy&amp;&amp;swap</h2><p>还有一个十分灵巧的operator=撰写技巧：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widegt&amp; rhs)</span></span>;<span class="comment">//彻底交换数据</span></span><br><span class="line">&#125;</span><br><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果operator=接受的参数是by value而非by reference，那我们连temp都可以省略:</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>确保自赋值安全性。其技术包括比较lhs与rhs的地址，先做backup，以及copy-and-swap</li>
<li>确定任何操作一个以上的对象的函数，如果其操作对象是同一个对象时，还能保持正确性。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>22.在使用Pimpl时，记得在实现文件中定义special function</title>
    <url>/2018/07/11/%E5%9C%A8%E4%BD%BF%E7%94%A8Pimpl%E6%97%B6%EF%BC%8C%E8%AE%B0%E5%BE%97%E5%9C%A8%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89special%20function/</url>
    <content><![CDATA[<h1 id="Pimpl技术"><a href="#Pimpl技术" class="headerlink" title="Pimpl技术"></a>Pimpl技术</h1><p>&nbsp;<br>Pimpl技术在Effective C++中多有涉及，详见Effective C++ Item31。</p>
<h2 id="Pimpl声明"><a href="#Pimpl声明" class="headerlink" title="Pimpl声明"></a>Pimpl声明</h2><p>举例而言，假设Widget定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// in header "widget.h"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3; <span class="comment">// Gadget is some user-defined type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>因为Widget的数据成员是std::string，std::vector和Gadget，这意味着Widget客户端程序必须#include&lt;string&gt;，&lt;vector&gt;和gadget.h。</p>
<p>在C++ 98中应用Pimpl Idiom可以让Widget用原始指针替换其数据成员，该指针指向已声明但尚未定义的结构：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// still in header "widget.h"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    ~Widget(); <span class="comment">// dtor is needed—see below</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span> <span class="comment">// declare implementation struct</span></span><br><span class="line">    Impl *pImpl; <span class="comment">// and pointer to it</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>已声明但未定义的类型称为incomplete类型,Widget::Impl就是这种类型。使用不完整类型可以做的事情非常少，但至少可以声明一个指向它的指针。由于Widget不再涉及std::string，std::vector和Gadget，因此客户端代码不再需要#include上述头文件。这不仅仅加快了编译速度，这也意味着如果这些头文件的某些内容发生变化，Widget客户端不会受到影响（编译分离）。</p>
<hr>
<h2 id="Pimpl实现"><a href="#Pimpl实现" class="headerlink" title="Pimpl实现"></a>Pimpl实现</h2><p>Pimpl Idiom关于data member分配和释放代码在实现文件中，对于widget.cpp中的Widget，有：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span> <span class="comment">// in impl. file "widget.cpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gadget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123; <span class="comment">// definition of Widget::Impl</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line">Widget::Widget():pImpl(<span class="keyword">new</span> Impl)&#123;&#125;</span><br><span class="line">Widget::~Widget()&#123; <span class="keyword">delete</span> pImpl; &#125;</span><br></pre></td></tr></table></figure><br>我们可以看到，原先的头文件依存性仍然存在，只不过现在由Widget.cpp执行#include语句，Widget.cpp仅由其实现者使用，而Widget.h由客户端代码使用，这保证了编译分离性质，此外，Widget析构必须释放impl对象，这是pimpl的必要条件。但上述都是C++98中的实现，现在看来，原始指针似乎过于粗糙了一些，因此我们理当追随时代的进步，以std::unique_ptr取代raw pointer:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// in "widget.h"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Impl&gt; pImpl; <span class="comment">// use smart pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>实现文件如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span> <span class="comment">// in "widget.cpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gadget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line">Widget::Widget():pImpl(<span class="built_in">std</span>::make_unique&lt;Impl&gt;())&#123;&#125; <span class="comment">// C++14</span></span><br></pre></td></tr></table></figure><br>显然。智能指针的引入至少帮助我们省去了写析构函数的烦恼。<br>上述代码可以编译，但客户端代码在使用时会出现问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line">Widget w; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><br>一般来说，报错内容关于无法将sizeof或delete应用于incomplete type。但众所周知，unique_ptr支持incomplete type且Pimpl是unique_ptr大展身手的最佳场景之一，让上述代码能够工作很容易，但我们需要加深对该问题的理解。</p>
<hr>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&nbsp;<br>问题之所以会产生在于析构Widget时存在问题。根据Item17所述的通用规则，编译器应当在用户并未声明析构函数时为我们生成析构函数。在该析构函数中，编译器插入代码以调用Widget的数据成员pImpl的析构函数。pImpl是一个std::unique_ptr&lt;Widget::Impl&gt;，即使用默认删除器的std :: unique_ptr。默认删除器是一个在std ::unique_ptr内的原始指针上使用delete的函数,其会使用C++11中的static_assert确保原始指针并未指向一个incomplete类型。当编译器生成用于析构Widget的代码时，它会遇到一个失败的static_assert，而这正是导致错误的原因。</p>
<hr>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>&nbsp;<br>要解决上述问题，只需要确保在生成析构std::unique_ptr&lt;Widget::Impl&gt;的代码时，Widget::Impl是一个complete类型。一个类型将会在编译器看到其定义时变为complete，且我们在widget.cpp中定义了Widget::Impl。 那么，成功编译的关键在于让编译器在Impl已被声明后，在Widget.cpp中看到Widget的析构函数（在其中编译器会生成析构unique_ptr的代码）已被定义。那么解决方案来了：在Widget.h中声明析构函数，但不作出定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// as before, in "widget.h"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    ~Widget(); <span class="comment">// declaration only</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// as before</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在定义了Widget::Impl后在Widget.cpp中定义析构函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span> <span class="comment">// as before, in "widget.cpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gadget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line">Widget::Widget():pImpl(<span class="built_in">std</span>::make_unique&lt;Impl&gt;())&#123;&#125;</span><br><span class="line">Widget::~Widget()&#123;&#125;</span><br></pre></td></tr></table></figure><br>上述程序已经很好地完成了需求，如果你想要强调析构函数只需为默认生成的即可，你可以使用<code>=default</code>修饰之：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget::~Widget() = <span class="keyword">default</span>; <span class="comment">// same effect as above</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Pimpl与move"><a href="#Pimpl与move" class="headerlink" title="Pimpl与move"></a>Pimpl与move</h1><p>&nbsp;<br>使用Pimpl Idiom的类简直与move操作天生一对，在底层unique_ptr上执行move操作既高效又优雅。但正如Item 17所述，Widget中的析构函数声明阻止了编译器生成移动操作，因此如果要移动支持，则必须自己声明这些函数。鉴于默认生成的move操作没毛病，因此你可能会这样声明它们：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// still in "widget.h"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    ~Widget();</span><br><span class="line">    Widget(Widget&amp;&amp; rhs) = <span class="keyword">default</span>; <span class="comment">// right idea, wrong code!</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="keyword">default</span>; </span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// as before</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种方法导致的问题与产生问题的根本原因都类似于之前。编译器生成的move operator=需要在重新分配之前销毁pImpl指向的对象，但在Widget头文件中，pImpl指向不完整的类型。而移动构造函数的问题在于编译器通常会生成代码以在移动构造函数内部出现异常时析构pImpl，但析构pImpl需要Impl为complete。</p>
<p>由于这个问题与之前完全一样，因此它们的解决方案也一样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// still in "widget.h"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    ~Widget();</span><br><span class="line">    Widget(Widget&amp;&amp; rhs); <span class="comment">// declarations</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs); <span class="comment">// only</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// as before</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // as before,in "widget.cpp"</span></span></span><br><span class="line">… </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123; … &#125;; <span class="comment">// as before</span></span><br><span class="line">Widget::Widget():pImpl(<span class="built_in">std</span>::make_unique&lt;Impl&gt;())&#123;&#125;</span><br><span class="line">Widget::~Widget() = <span class="keyword">default</span>; <span class="comment">// as before</span></span><br><span class="line">Widget::Widget(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Pimpl与copy"><a href="#Pimpl与copy" class="headerlink" title="Pimpl与copy"></a>Pimpl与copy</h1><p>&nbsp;<br>编译器不会为具备move-only data member的class生成copy操作，因此我们应当手动完成声明（就算编译器真的完成了拷贝，它针对unique_ptr执行的也是浅拷贝（仅仅复制指针），而我们需要的是深拷贝（复制unique_ptr所指向的对象））。</p>
<p>照样画葫芦，我们在头文件中对copy操作完成声明,在原文件中完成定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// still in "widget.h"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    … <span class="comment">// other funcs, as before</span></span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs); <span class="comment">// declarations only</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// as before</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span> <span class="comment">// as before,</span></span></span><br><span class="line">… <span class="comment">// in "widget.cpp"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123; … &#125;; <span class="comment">// as before</span></span><br><span class="line">Widget::~Widget() = <span class="keyword">default</span>; <span class="comment">// other funcs, as before</span></span><br><span class="line">Widget::Widget(<span class="keyword">const</span> Widget&amp; rhs):pImpl(<span class="built_in">std</span>::make_unique&lt;Impl&gt;(*rhs.pImpl))&#123;&#125;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    *pImpl = *rhs.pImpl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>值得注意的是，我们在copy操作中调用的是impl所具备的copy操作，从而确保了拷贝的正确性，此外，在构造函数中使用了make_unique以取代new。</p>
<hr>
<h1 id="Pimpl与shared-ptr"><a href="#Pimpl与shared-ptr" class="headerlink" title="Pimpl与shared_ptr"></a>Pimpl与shared_ptr</h1><p>&nbsp;<br>unique_ptr应用于Pimpl十分自然，这体现了资源的独占性，但如果我们将shared_ptr应用于Pimpl，则不必理会本小节所提倡的“将special function在头文件中声明，源文件中定义”，也就是说，下述代码是完全正确的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// in "widget.h"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    … <span class="comment">// no declarations for dtor or move operations</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Impl&gt; pImpl; <span class="comment">// std::shared_ptr instead of std::unique_ptr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>客户端执行下述程序并不会报错：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w1;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">w2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(w1))</span></span>; <span class="comment">// move-construct w2</span></span><br><span class="line">w1 = <span class="built_in">std</span>::<span class="built_in">move</span>(w2); <span class="comment">// move-assign w1</span></span><br></pre></td></tr></table></figure><br>造成这一行为的原因很简单：unique_ptr的删除器是自身的一部分，而shared_ptr不是。为了保证高效性，unique_ptr删除器必须保证raw pointer为complete，而shared_ptr无需这种保证。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>Pimpl可以保证编译分离。</strong></li>
<li><strong>Pimpl中若是使用unique_ptr，则必须在头文件中声明special function，在源文件中定义special function。</strong></li>
<li><strong>第2条规则并不适用于shared_ptr</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>33.在容器元素为指针时谨慎使用remove</title>
    <url>/2018/04/16/%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E4%B8%BA%E6%8C%87%E9%92%88%E6%97%B6%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8remove/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设我们在管理一些动态分配的Widgets*：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCertified</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//是否达标</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget*&gt; v;</span><br><span class="line">v.push_back(<span class="keyword">new</span> Widget);<span class="comment">//在容器中存放指针</span></span><br></pre></td></tr></table></figure><br>最终需要删除所有没有通过检测的widget，所以下述写法似乎是十分自然的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于谓词使用,详见Effective STL 41</span></span><br><span class="line">v.erase(remove_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),not1(mem_fun(&amp;Widget::isCertified))), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>Effective STL 7 告诉过我们删除容器内部的指针其实并没有析构对象本身，那是对的，但在这里内存泄漏在调用remove时就已经发生了。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>假设在未调用remove_if之前，容器构成如下：<br><img src="http://static.zybuluo.com/zsmj2017/uijyg4ee1n6hdz9l1sxtrbny/image_1cb5uru2u1ft11g8v1s3nm5h1h1l9.png" alt="image_1cb5uru2u1ft11g8v1s3nm5h1h1l9.png-43kB"><br>那么在调用之后，容器变成了这样:<br><img src="http://static.zybuluo.com/zsmj2017/sgu0vmyrrq3f8z39zowhg30z/image_1cb5utkms19gu1r2lfl71lm61h5tm.png" alt="image_1cb5utkms19gu1r2lfl71lm61h5tm.png-44.7kB"><br>其实在这里我们就可以清楚地看到，我们再也无法通过某个指针来获取BC了，原本指向它们的指针被覆盖，BC将永远无法释放。<br>在调用erase之后，容器变成了这样：<br><img src="http://static.zybuluo.com/zsmj2017/zx95h2tvdsh16252bwy183r6/image_1cb5uva5s1req8537v7blb1m2013.png" alt="image_1cb5uva5s1req8537v7blb1m2013.png-28.4kB"><br>一般来说，在含有指针的容器中使用remove，remove_if或者unique不太合适。partition算法比较适合这类场景。（因为不存在覆盖的情况）</p>
<hr>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="依然erase-remove"><a href="#依然erase-remove" class="headerlink" title="依然erase_remove"></a>依然erase_remove</h2><p>我们可以先删除所有要删除的指针，并把它们设置为空，然后再抹除元素内所有空指针：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delAndNullifyUncertified</span><span class="params">(Widget*&amp; pWidget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pWidget-&gt;isCertified()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> pWidget;</span><br><span class="line">        pWidget = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),delAndNullifyUncertified);</span><br><span class="line">v.erase(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),[](Widget* pWidget)&#123;<span class="keyword">return</span> pWidget;&#125;),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>通过智能指针我们可以直接erase_remove:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">shared_ptr</span>&lt;Widget&gt; SPW; <span class="comment">// RCSPW = “RCSP to Widget”</span></span><br><span class="line"><span class="built_in">vector</span>&lt;SPW&gt; v;</span><br><span class="line">v.push_back(RCSPW(<span class="keyword">new</span> Widget));</span><br><span class="line">v.erase(remove_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),not1 (mem_fun(&amp;Widget::isCertified))), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>上述程序通过编译的前提是你的智能指针类型就必须可以隐式转换为相应的raw pointer。因为容器持有智能指针，但被调用的成员函数需要的是raw pointer。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>7.在创建对象时区分()与{}</title>
    <url>/2018/06/27/%E5%9C%A8%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8C%BA%E5%88%86()%E4%B8%8E%7B%7D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>C++11中提供了许多初始化方法，以至于多的有点混乱。一般来说，初始化可以由小括号、等号、大括号完成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> z&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><br>也可以等号与大括号并用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> z = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><br>在本节接下来的内容中我们将不叙述这种并用的初始化方法，因为C++往往习惯于将其与仅使用大括号的情形等价。</p>
<hr>
<h1 id="Braced-initialization"><a href="#Braced-initialization" class="headerlink" title="Braced initialization"></a>Braced initialization</h1><p>&nbsp;</p>
<p>使用等号进行初始化经常会给C++新手带来困扰，因为这看起来像是一个赋值操作，但实际情况并非如此。对于内置类型而言可能没啥关系，但对于用户自定义类型而言，区分初始化与赋值是十分必要的，因为二者调用了完全不同的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w1; <span class="comment">// call default constructor</span></span><br><span class="line">Widget w2 = w1; <span class="comment">// not an assignment; calls copy ctor</span></span><br><span class="line">w1 = w2; <span class="comment">// an assignment; calls copy operator=</span></span><br></pre></td></tr></table></figure><br>C++ 98中尽管初始化语法不少，但仍然存在一些无法初始化的情况，例如没法在初始化时指定容器内部的元素值等等。C++11为了解决上述问题，引入了”uniform initialization”的概念：一个初始化表达式应该可以用于任何地方并且可以表达一切。由于该语法基于大括号（brace)，作者也将其称为”Braced initialization”，其使用实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;; <span class="comment">// v's initial content is 1, 3, 5</span></span><br></pre></td></tr></table></figure><br>大括号亦可用于指定非静态数据成员的默认初始值,C++11引入的这项新功能与operator=初始化语法共存，但小括号则不行:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">0</span> &#125;; <span class="comment">// fine, x's default value is 0</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>; <span class="comment">// also fine</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// error!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另一方面，无法被拷贝的对象只能够使用大括号或小括号初始化，无法通过operator=初始化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// fine</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai3 = <span class="number">0</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><br>将”Braced initialization”称为”uniform initialization”是十分自然的，因为只有brace可以在任何C++初始化表达式中正常使用。</p>
<hr>
<h2 id="Braced-initialization特性"><a href="#Braced-initialization特性" class="headerlink" title="Braced initialization特性"></a>Braced initialization特性</h2><h3 id="禁止narrow-conversion"><a href="#禁止narrow-conversion" class="headerlink" title="禁止narrow conversion"></a>禁止narrow conversion</h3><p>Braced initialization的特性之一在于其禁止在初始化过程中对内置类型作隐式narrow conversion，如果变量不能保证准确表达初始化器内部值，那么该代码将无法完成编译：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x, y, z;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">int</span> sum1&#123; x + y + z &#125;; <span class="comment">// error! sum of doubles may not be expressible as int</span></span><br></pre></td></tr></table></figure><br>使用圆括号和operator=进行初始化则不会检查是否触发narrow conversion，因为这可能会对历史遗留代码造成破坏：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2</span><span class="params">(x + y + z)</span></span>; <span class="comment">// okay (value of expression truncated to an int)</span></span><br><span class="line"><span class="keyword">int</span> sum3 = x + y + z; <span class="comment">// ditto</span></span><br></pre></td></tr></table></figure></p>
<h3 id="避免vexing-parse"><a href="#避免vexing-parse" class="headerlink" title="避免vexing parse"></a>避免vexing parse</h3><p>Braced initialization还有一大特性在于其对C++的vexing parse免疫。C++ vexing parse可以解释为：当你试图使用默认构造函数来构造对象时，却发现自己只是声明了一个函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>; <span class="comment">//vexing parse!declares a function named w2 that returns a Widget!</span></span><br></pre></td></tr></table></figure><br>但如果你使用大括号进行初始化操作，则不会被认为是一个函数声明:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w3&#123;&#125;; <span class="comment">// calls Widget ctor with no args</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="Braced-initialization缺陷"><a href="#Braced-initialization缺陷" class="headerlink" title="Braced initialization缺陷"></a>Braced initialization缺陷</h2><p>&nbsp;<br>Braced initialization并非完美无缺，它的存在也可能会导致一些你意料之外的错误。例如在Item2中我们曾经提及，auto会将经由Braced initialization初始化的变量推断为一个std::initializer_list.如此说来，可能你越喜欢auto，你对Braced initialization的兴趣就越少。</p>
<h3 id="构造函数匹配"><a href="#构造函数匹配" class="headerlink" title="构造函数匹配"></a>构造函数匹配</h3><p>在调用构造函数时，只要不涉及std::initializer_list,小括号和大括号几乎没有区别：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b); <span class="comment">// ctors not declaring</span></span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d); <span class="comment">// std::initializer_list params</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// also calls first ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// also calls second ctor</span></span><br></pre></td></tr></table></figure><br>但如果一个或多个构造函数声明其形参为std::initializer_list类型，则使用Braced initialization初始化对象时会几乎<strong>必然会调用形参类型为std::initializer_list的构造函数</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d); <span class="comment">// as before</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; il); <span class="comment">// added</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// uses parens and, as before,calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// now calls std::initializer_list ctor(10 and true convert to long double)</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// uses parens and, as before,calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// now calls std::initializer_list ctor(10 and 5.0 convert to long double)</span></span><br></pre></td></tr></table></figure><br>显然，这里发生了严重的匹配错误，不仅如此，甚至拷贝和移动构造函数也可能会被std::initializer_list带偏：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d); <span class="comment">// as before</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; il); <span class="comment">// as before</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// convert to float</span></span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Widget <span class="title">w5</span><span class="params">(w4)</span></span>; <span class="comment">// uses parens, calls copy ctor</span></span><br><span class="line">Widget w6&#123;w4&#125;; <span class="comment">// call std::initializer_list ctor</span></span><br><span class="line">               <span class="comment">// (w4 converts to float, and float converts to long double)</span></span><br><span class="line"><span class="function">Widget <span class="title">w7</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(w4))</span></span>; <span class="comment">// uses parens, calls move ctor</span></span><br><span class="line">Widget w8&#123;<span class="built_in">std</span>::<span class="built_in">move</span>(w4)&#125;; <span class="comment">// calls std::initializer_list ctor (for same reason as w6)</span></span><br></pre></td></tr></table></figure><br>braced initializers与形参为std::initializer_list的ctor具备最高匹配度，当ctor无法被调用时，编译器甚至不会去理会别的构造函数(即使在类型上十分符合）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d); <span class="comment">// as before</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">bool</span>&gt; il); <span class="comment">// element type is now bool</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line">Widget w&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// error！narrowing conversions are prohibited inside braced initializers</span></span><br></pre></td></tr></table></figure><br>只有在无法将braced initializer内的实参转换为std::initializer_list中的参数时编译器才会去调用其他构造函数(我认为本例是无法转换，而上一个例子说的是大括号内含有禁止narrow conversion语义，二者并不冲突），例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d); <span class="comment">// as before</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; il);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// uses parens, still calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// uses braces, now calls first ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// uses parens, still calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// uses braces, now calls second ctor</span></span><br></pre></td></tr></table></figure></p>
<p>最后，我们讨论一种极端情况:Widget同时具备无参构造函数与带有std::initializer_list的构造函数，当我们写下<code>Widget w{}</code>时，调用的是哪一个呢？答案是调用无参构造函数，原因在于空大括号意味着没有参数，而非一个空的std::initializer_list对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(); <span class="comment">// default ctor</span></span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; il); <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line">Widget w1; <span class="comment">// calls default ctor</span></span><br><span class="line">Widget w2&#123;&#125;; <span class="comment">// also calls default ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">()</span></span>; <span class="comment">// most vexing parse! declares a function!</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们需要调用形参类型为std::initializer_list的构造函数，我们应当明确地指出参数为一个空std::initializer_list：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>; <span class="comment">// calls std::initializer_list ctor with empty list</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;; <span class="comment">// ditto</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h3><p>作为类的开发者，我们应当明确：<strong>如果在类中存在形参为std::initializer_list的构造函数，那么客户在使用Braced initialization时只会看到initializer_list版本</strong>，因此，我们应当合理设计构造函数，以便客户不至于产生误解。</p>
<p>如果你曾经的设计中不存在以std::initializer_list为参数的构造函数，当你添加了它之后，原本运行良好的客户端应用程序可能会匹配至新的构造函数然后发生雪崩。虽然别的重载函数更新后也会发生这种情况，但带有std::initializer_list的构造函数破坏性大得多，因为他并非与其他构造函数竞争，而是以一种近乎overshadow的方式抹杀了其余构造函数的存在（当然，如果不能发生转换它还是会乖乖交出构造权）。总之，在类中加入此类重载构造函数需要审慎。</p>
<p>作为类的使用者，我们应当在创建对象时谨慎选择初始化方式。大多数人会从()、{}中选出一种作为惯用方式，并且只有在情非得已时才会去使用另外一种。这两种初始化方式并无优劣之分，因此我们应当选择一种作为自己开发的惯用方式，并在日常使用中不断加深对它的理解。</p>
<p>如果你是一个模板的作者，可能你会发现自己并不确定在创建对象时应当使用哪一种初始化方式。例如，假设我们想从任意数量的参数中创建任意类型的对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Ts&gt;<span class="comment">// type of object to create,types of arguments to use</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">    create local T object from params...</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有两种方法可将上述伪代码实现（std::forward可见Item25）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">localObject</span><span class="params">(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...)</span></span>; <span class="comment">// using parens</span></span><br><span class="line">T localObject&#123;<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...&#125;; <span class="comment">// using braces</span></span><br></pre></td></tr></table></figure><br>考虑以下调用程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">…</span><br><span class="line">doSomeWork&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><br>如果doSomeWork在创建localObject时使用小括号，那么将创建一个包含10个元素的std::vector。如果doSomeWork使用大括号，则结果是一个包含2个元素的std::vector。只有调用者而非开发者才知道哪一个是他想要的（正确的）结果。</p>
<p>上述讨论正是标准库函数std :: make_unique和std :: make_shared所面临的问题（见Item21），这两个函数最终决定在template内部使用小括号，并在接口文档中加以注明。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>Braced initialization是使用最为广泛的初始化语法，它可以防止narrow conversion，并且不受vexing parse的影响。</strong></li>
<li><strong>在构造函数重载解析期间，即使其他构造函数具备更高的匹配度， Braced initialization也不会放过任何一个与std :: initializer_list发生匹配的可能（除非真的无法转换）。</strong></li>
<li><strong>即使是同样的参数，使用大括号和小括号进行初始化可能结果会天差地别（例如std::vector)。</strong></li>
<li><strong>在template中创建对象时使用大括号还是小括号会很令人纠结。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>10.在构造函数中防止资源泄漏</title>
    <url>/2018/04/25/%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E9%98%B2%E6%AD%A2%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设我们正在开发一个多媒体电话簿，它不仅可以存储姓名地址号码外，还能存储照片和声音。该类具体形式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Image(<span class="keyword">const</span> <span class="built_in">string</span>&amp; imageDataFileName);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioClip</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AudioClip(<span class="keyword">const</span> <span class="built_in">string</span>&amp; audioDataFileName);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;; <span class="comment">//存储号码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookEntry</span> &#123;</span> <span class="comment">//条目</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BookEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address = <span class="string">""</span>,</span><br><span class="line">              <span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName = <span class="string">""</span>,<span class="keyword">const</span> <span class="built_in">string</span>&amp; audioClipFileName = <span class="string">""</span>);</span><br><span class="line">    ~BookEntry();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPhoneNumber</span><span class="params">(<span class="keyword">const</span> PhoneNumber&amp; number)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> theName;</span><br><span class="line">    <span class="built_in">string</span> theAddress;</span><br><span class="line">    <span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    Image *theImage;</span><br><span class="line">    AudioClip *theAudioClip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>因为条目必须存在姓名，所以不存在默认构造函数(More Effective C++ 3）。<br>对于条目的构造和析构函数，有具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BookEntry::BookEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName,Const <span class="built_in">string</span>&amp; audioClipFileName)</span><br><span class="line">            :theName(name), theAddress(address),theImage(<span class="literal">nullptr</span>), theAudioClip(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (imageFileName != <span class="string">""</span>) &#123;</span><br><span class="line">        theImage = <span class="keyword">new</span> Image(imageFileName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (audioClipFileName != <span class="string">""</span>) &#123;</span><br><span class="line">        theAudioClip = <span class="keyword">new</span> AudioClip(audioClipFileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BookEntry::~BookEntry()&#123;</span><br><span class="line">    <span class="keyword">delete</span> theImage;</span><br><span class="line">    <span class="keyword">delete</span> theAudioClip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这一切看起来运作良好，但如果函数中出现了异常…</p>
<hr>
<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2><p>&nbsp;<br>如果BookEntry的构造函数正在执行中，突然发生异常：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (audioClipFileName != <span class="string">""</span>) &#123;</span><br><span class="line">    theAudioClip = <span class="keyword">new</span> AudioClip(audioClipFileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>异常的抛出原因，可能是operator new不能够分配足够内存，也可能是audio的构造函数自己抛出了异常。不管如何，这个异常将传递到建立BookEntry对象的地方。<br>假设建立audio时抛出了异常（且控制权此时在Entry构造函数外），那么已经构建好的image对象该由谁来删除呢？无疑该资源应该由Entry的析构函数释放，但在实际情况中，Entry析构函数并未被调用，原因很简单：C++只能对完全构造的对象进行析构，只有一个对象的构造函数完全运行完毕，这个对象才被定义为完全构造。<br>也许有人会想到使用try—catch主动处理异常：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBookEntryClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BookEntry *pb = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pb = <span class="keyword">new</span> BookEntry(<span class="string">"Addison-Wesley Publishing Company"</span>,</span><br><span class="line">                           <span class="string">"One Jacob Way, Reading, MA 01867"</span>);</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> pb;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这并没有什么用，因为new操作并没有完成，pb依旧是一个nullptr，delete只不过删了一个空指针而已。</p>
<p>c++禁止为尚未完成构造的对象进行析构，因为允许该操作需要记录构造函数执行了多少步，这会造成额外的开销。</p>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>&nbsp;<br>为了解决资源泄漏这一问题，处理方法是在构造函数中捕获所有异常，捕获后执行清除操作，最后再重新抛出异常让它继续传递：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BookEntry::BookEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName,Const <span class="built_in">string</span>&amp; audioClipFileName)</span><br><span class="line">            :theName(name), theAddress(address),theImage(<span class="literal">nullptr</span>), theAudioClip(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (imageFileName != <span class="string">""</span>) &#123;</span><br><span class="line">            theImage = <span class="keyword">new</span> Image(imageFileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (audioClipFileName != <span class="string">""</span>) &#123;</span><br><span class="line">            theAudioClip = <span class="keyword">new</span> AudioClip(audioClipFileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> theImage; </span><br><span class="line">        <span class="keyword">delete</span> theAudioClip;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>非指针成员在构造函数被调用之前就完成了初始化，属于完全构造，因此会被自动释放。<br>显然，catch语句块中的清除操作几乎与析构函数一摸一样，为了避免代码重复，我们定义一个私有的helper function，让构造函数与析构函数都调用它，如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BookEntry::cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> theImage;</span><br><span class="line">    <span class="keyword">delete</span> theAudioClip;</span><br><span class="line">&#125;</span><br><span class="line">BookEntry::BookEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName,Const <span class="built_in">string</span>&amp; audioClipFileName)</span><br><span class="line">            :theName(name), theAddress(address),theImage(<span class="literal">nullptr</span>), theAudioClip(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        cleanup();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BookEntry::~BookEntry()&#123;</span><br><span class="line">    cleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="异常产生于构造函数调用之前"><a href="#异常产生于构造函数调用之前" class="headerlink" title="异常产生于构造函数调用之前"></a>异常产生于构造函数调用之前</h1><p>&nbsp;<br>假设image与audio是一个const指针，因此它们必须通过初始化列表来完成初始化(不允许赋值）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BookEntry::BookEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName,Const <span class="built_in">string</span>&amp; audioClipFileName)</span><br><span class="line">            :theName(name), theAddress(address),</span><br><span class="line">            theImage(imageFileName != <span class="string">""</span>? <span class="keyword">new</span> Image(imageFileName): <span class="literal">nullptr</span>),</span><br><span class="line">            theAudioClip(audioClipFileName != <span class="string">""</span>? <span class="keyword">new</span> AudioClip(audioClipFileName): <span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><br>倘若常量指针初始化时抛出了异常….这一次情况发生在构造函数被调用之前，所以无法在构造函数中使用try catch语句。</p>
<hr>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="新建初始化函数"><a href="#新建初始化函数" class="headerlink" title="新建初始化函数"></a>新建初始化函数</h3><p>我们可以在私有成员函数中，用一些函数返回指针指向初始化过的image与audio：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Image * <span class="title">initImage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName)</span></span>;</span><br><span class="line">    <span class="function">AudioClip * <span class="title">initAudioClip</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; audioClipFileName)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">BookEntry::BookEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName,Const <span class="built_in">string</span>&amp; audioClipFileName)</span><br><span class="line">            :theName(name), theAddress(address),</span><br><span class="line">            theImage(initImage(imageFileName),theAudioClip(initAudioClip(audioClipFileName))</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// theImage首先初始化，初始化失败也不会有内存泄漏，无需考虑异常</span></span><br><span class="line">Image * BookEntry::initImage(<span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName)&#123;</span><br><span class="line">    <span class="keyword">if</span> (imageFileName != <span class="string">""</span>) <span class="keyword">return</span> <span class="keyword">new</span> Image(imageFileName);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化失败必须要保证Image资源被释放</span></span><br><span class="line">AudioClip * BookEntry::initAudioClip(<span class="keyword">const</span> <span class="built_in">string</span>&amp;audioClipFileName)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (audioClipFileName != <span class="string">""</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AudioClip(audioClipFileName);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> theImage;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法的缺点在于原本属于构造函数的代码却分散在各个函数中，维护极为不易，并且对象增加了新成员后代码也需要重新编写。</p>
<h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>我们可以运用RAII思想，把audio与image指向的对象作为资源托管给smart-ptr：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;Image&gt; theImage;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;AudioClip&gt; theAudioClip;</span><br><span class="line">&#125;;</span><br><span class="line">BookEntry::BookEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> <span class="built_in">string</span>&amp; address,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">string</span>&amp; imageFileName,<span class="keyword">const</span> <span class="built_in">string</span>&amp; audioClipFileName)</span><br><span class="line">            :theName(name), theAddress(address),</span><br><span class="line">            theImage(imageFileName != <span class="string">""</span>? <span class="keyword">new</span> Image(imageFileName): <span class="literal">nullptr</span>),</span><br><span class="line">            theAudioClip(audioClipFileName != <span class="string">""</span>? <span class="keyword">new</span> AudioClip(audioClipFileName): <span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><br>如此一来，audio构造出现异常时，image已经是一个完成构造的完全体，可以被直接清除，同时所有资源均由对象托管，析构函数无需执行任何工作。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>16.在资源管理类中提供对原始资源的访问</title>
    <url>/2018/04/10/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>资源管理类是排除资源泄漏的壁垒，是良好设计系统的根本性质。但有许多api直接指涉资源，有时不得不绕过资源管理对象直接访问原始资源。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>举例而言，假设有一个shared_ptr保存了factory函数生成的资源，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">spInv</span><span class="params">(createInvestment())</span></span>;</span><br></pre></td></tr></table></figure><br>但现在API如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Investment* pi)</span></span>;</span><br></pre></td></tr></table></figure><br>我们肯定没法把spInv传入进去，因为该函数需要的是Investment*指针，而不是shared_ptr&lt;Investment&gt;类型的对象。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&lt;/br&gt;<br>有两个做法可以把RAII对象转换为原始资源：<strong>显式转换和隐式转换</strong>。</p>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><p>shared_ptr与auto_ptr都提供一个get成员函数，用来执行显式转换。<strong>该函数返回智能指针内部的原始指针（的副本）</strong>。我们可以写作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">daysHeld(spInv.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><br>另外，智能指针并非仅有显式转换，它们重载了解引用操作符（operator*，operator-&gt;),这两种操作符执行了隐式转换。（我以为是调用了get().opertaor*，inline之后调用成本也不是很高，不过生成的文件可能变大了)</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>对于需要频繁转换的RAII classes来说，不断调用get()未免繁琐，因此我们可以提供一个隐式转换操作符。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">explict <span class="title">Widget</span><span class="params">(WidegtHandle wh)</span>:<span class="title">w</span><span class="params">(wh)</span> </span>&#123;&#125;</span><br><span class="line">    ~Widget() &#123;<span class="built_in">release</span>(w);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">WidegtHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> w;&#125;<span class="comment">//隐式转换</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetHandle w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如此一来，在API中直接可以将RAII对象作为参数传入。<br>这样有时候会发生崩盘，比如原意是拷贝一个RAII对象，但实际上却（发生隐式转换）拷贝了资源。</p>
<hr>
<h1 id="转换接口的合理性"><a href="#转换接口的合理性" class="headerlink" title="转换接口的合理性"></a>转换接口的合理性</h1><p>&lt;/br&gt;<br>是否应该提供转换，以及哪一种转换取决于你是否需要转换或者转换的频率。要记住一切操作都是为了令接口更加灵活且不易被误用。<br>你可能会认为转换接口与封装发生了矛盾。但事实并非如此，RAII对象负责资源管理，而非起封装数据的作用。作为类的设计者，我们有责任隐藏用户不需要了解的内容，同时提供给用户一切他们需要的东西。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>APIs往往要求访问原始资源，所以每一个RAII class应该提供一个获取原始资源的函数。</li>
<li>显式转换比较安全，但隐式转换对客户比较方便，当然也更容易出错。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>18.在进行独占式资源管理时使用std::unique_ptr</title>
    <url>/2018/07/04/%E5%9C%A8%E8%BF%9B%E8%A1%8C%E7%8B%AC%E5%8D%A0%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E6%97%B6%E4%BD%BF%E7%94%A8unique_ptr/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>unique_ptr的大小与原始指针相同（在大多数情况），操作起来也类似，这意味着你可以某些内存吃紧与实时性较高的场合(例如嵌入式？）中使用它们。</p>
<hr>
<h1 id="unique-ptr定义"><a href="#unique-ptr定义" class="headerlink" title="unique_ptr定义"></a>unique_ptr定义</h1><p>&nbsp;<br>std::unique_ptr代表着独占语义。任何一个非空unique_ptr总是唯一拥有其指向资源。对unique_ptr执行移动操作将导致资源所有权从源指针传递到目标指针（源指针被置为null),unique_ptr不允许copy操作，因为这会导致存在两个指针指向同一份资源，与独占性相违。由此可见，unique_ptr是一种move_only type，在它析构时，默认将对其所拥有的原始指针执行delete操作。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>&nbsp;<br>一般来说，unique_ptr常用于作为工厂函数的返回类型（当然，工厂函数并非std::unique_ptrs的唯一常见用例,它们也经常作为Pimpl手法的实现机制而得到使用，具体可见Item22）。<br>假设当前有一个代表投资的继承体系如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/jhth2nfbeiqo5j2vqsn0u6pg/image_1chigac1e1b531m0r1cs5o81bmj9.png" alt="image_1chigac1e1b531m0r1cs5o81bmj9.png-17.6kB"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span> … &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span>:</span><span class="keyword">public</span> Investment &#123; … &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bond</span>:</span><span class="keyword">public</span> Investment &#123; … &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealEstate</span>:</span><span class="keyword">public</span> Investment &#123; … &#125;;</span><br></pre></td></tr></table></figure>
<p>工厂函数将在堆上生成一个对象并返回一个指向它的指针，调用者负责在不再需要时删除该对象。这正是std::unique_ptr的职责所在：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="comment">// return std::unique_ptr</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; <span class="comment">// to an object created</span></span><br><span class="line">makeInvestment(Ts&amp;&amp;... params); <span class="comment">// from the given args</span></span><br></pre></td></tr></table></figure><br>调用者可在某作用域内使用工厂函数返回值如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">auto</span> pInvestment = makeInvestment(arguments); <span class="comment">// std::unique_ptr&lt;Investment&gt;</span></span><br><span class="line">    …</span><br><span class="line">&#125;<span class="comment">// destroy *pInvestment</span></span><br></pre></td></tr></table></figure><br>但也可以在所有权迁移场景中使用unique_ptr,例如将工厂函数的返回值置入容器，而容器元素又在其后成为了某个对象的data member，其后该对象被销毁。当发生这种情况时，对象的std::unique data member也将被销毁，并且其销毁将导致工厂函数所返回的资源被释放。如果在上述过程中出现了异常或逻辑错误（函数过早返回或循环由于break退出），那么管资源的std::unique_ptr最终将调用其析构函数,释放其托管的资源。</p>
<p>在默认情况下，该资源释放将通过使用delete完成，但在构造过程中，std::unique_ptr对象可以配置自定义删除器：任意函数、函数对象、lambda等等。在unqie_ptr析构之时，这些删除器将负责完成资源的释放操作。举例而言，如果makeInvestment所创建的对象不应该直接删除，而应首先完成日志记录操作，makeInvestment可实现如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment) &#123;makeLogEntry(pInvestment);<span class="keyword">delete</span> pInvestment;&#125;;<span class="comment">//lambda</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt;</span><br><span class="line">makeInvestment(Ts&amp;&amp;... params)&#123;</span><br><span class="line">    std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; pInv(nullptr, delInvmt);</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* a Stock object should be created */</span>)&#123;</span><br><span class="line">        pInv.reset(<span class="keyword">new</span> Stock(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* a Bond object should be created */</span> )&#123;</span><br><span class="line">        pInv.reset(<span class="keyword">new</span> Bond(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* a RealEstate object should be created */</span> )&#123;</span><br><span class="line">        pInv.reset(<span class="keyword">new</span> RealEstate(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="实现剖析"><a href="#实现剖析" class="headerlink" title="实现剖析"></a>实现剖析</h2><ol>
<li>delInvmt是工厂函数返回对象的自定义删除器，其接受指向应被销毁的对象的原始指针，然后执行销毁该对象所需的操作。 在本例中，销毁操作时调用makeLogEntry然后应用delete。使用lambda表达式创建delInvmt十分便捷，但实际上它并不止便捷那么简单。</li>
<li>当需要使用自定义删除器时，必须将其类型指定为std::unique_ptr的第二个模板类型参数。因此在本例中makeInvestment的返回类型是std::unique_ptr&lt;Investment，decltype(delInvmt)&gt;。</li>
<li>将原始指针（例如从new得到的资源）对std::unique_ptr进行赋值将无法编译，因为这一行为构成了从原始指针到智能指针的隐式转换，C++11禁止这种隐式转换，因此使用reset成员函数。</li>
<li>每次调用new时，我们都使用std::forward来实现完美转发makeInvestment获得的参数（见Item25）。这一行为使得调用者提供的所有信息都可被正在创建的对象的constructor所采纳。</li>
<li>为了保证删除器能够正确完成析构操作，基类必须具备virtual析构函数（因为我们是通过一个指向基类的指针来执行delete）：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   … <span class="comment">// essential</span></span><br><span class="line">   <span class="keyword">virtual</span> ~Investment(); <span class="comment">// design</span></span><br><span class="line">   … <span class="comment">// component!</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="C-14提供的工厂函数实现"><a href="#C-14提供的工厂函数实现" class="headerlink" title="C++14提供的工厂函数实现"></a>C++14提供的工厂函数实现</h1><p>&nbsp;<br>C++14支持返回值类型推衍，因此C++14中工厂函数的实现可如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)&#123;makeLogEntry(pInvestment);<span class="keyword">delete</span> pInvestment;&#125;; </span><br><span class="line">    std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; pInv(nullptr, delInvmt);</span><br><span class="line">    <span class="keyword">if</span> ( … )&#123;</span><br><span class="line">        pInv.reset(<span class="keyword">new</span> Stock(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( … )&#123;</span><br><span class="line">        pInv.reset(<span class="keyword">new</span> Bond(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( … )&#123;</span><br><span class="line">        pInv.reset(<span class="keyword">new</span> RealEstate(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="自定义删除器对unique-ptr的影响"><a href="#自定义删除器对unique-ptr的影响" class="headerlink" title="自定义删除器对unique_ptr的影响"></a>自定义删除器对unique_ptr的影响</h1><p>&nbsp;<br>前文曾经提及，当使用默认删除器（即delete）时，可以合理地假设std::unique_ptr对象与原始指针的大小相同。但一旦存在自定义删除器，那么该假设一般不再成立。如果删除器是函数指针类型，含有自定义删除器的std::unique_ptr大小往往从1个word增长至2个word。如果删除器是函数对象，那么unique_ptr增长的大小视函数中状态的多少而定。无状态函数对象（例如没有捕获的lambda表达式）不会导致unique_ptr的大小发生变化，这意味着当自定义删除器可实现为函数或无捕获的lambda表达式时，lambda更为可取：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt1 = [](Investment* pInvestment)&#123;makeLogEntry(pInvestment);<span class="keyword">delete</span> pInvestment;&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">decltype</span>(delInvmt1)&gt;</span><br><span class="line">makeInvestment(Ts&amp;&amp;... args);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delInvmt2</span><span class="params">(Investment* pInvestment)</span></span>&#123;<span class="comment">// function object</span></span><br><span class="line">    makeLogEntry(pInvestment);</span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment,<span class="keyword">void</span> (*)(Investment*)&gt;</span><br><span class="line">makeInvestment(Ts&amp;&amp;... params);</span><br></pre></td></tr></table></figure>
<p>具有状态的函数对象删除器可能会生产较大的unique_ptr对象。如果你发现自定义删除器std::unique_ptrs大到了不可接受的程度，则可以考虑更改删除器类型。</p>
<hr>
<h1 id="unique-ptr与数组"><a href="#unique-ptr与数组" class="headerlink" title="unique_ptr与数组"></a>unique_ptr与数组</h1><p>&nbsp;<br>std::unique_ptr存在两种形式，一种用于单个对象（std::unique_ptr&lt;T&gt;）,另一种用于数组（std::unique_ptr&lt;T[]&gt;）。因此，对于std::unique_ptr指向的实体类型从不存在任何歧义。std::unique_ptr的API视当前使用情况而定。例如，指向单一对象时unique_ptr没有operator[]，而指向数组时则缺少operator*和operator-&gt;。</p>
<p>但指向数组的unique_ptr并无必要，因为STL中的容器比数组好用太多，std::unique_ptr&lt;T[]&gt;唯一有存在价值的情况就是当你使用类C的API时，它会返回一个原始指针，指向你独占的堆数组。</p>
<hr>
<h1 id="unique-ptr与shared——ptr"><a href="#unique-ptr与shared——ptr" class="headerlink" title="unique_ptr与shared——ptr"></a>unique_ptr与shared——ptr</h1><p>&nbsp;<br>std::unique_ptr最吸引人的特性之一是它可以轻松高效隐式地转换为std::shared_ptr:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; sp = makeInvestment( arguments );</span><br></pre></td></tr></table></figure>
<p>这即是std::unique_ptr适合作为工厂函数返回类型的关键原因所在。工厂函数无法知道调用者是否希望对返回的对象使用独占语义，或者共享语义。通过返回std::unique_pt，工厂函数得以保证当调用者需要实现共享语义时可以轻松从unique_ptr转换得到shared_ptr。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>std::unique_ptr是一种小型、快速、move-only的智能指针，其在管理资源时具备独占语义。</strong></li>
<li><strong>在默认情况下，资源释放通过delete完成，但用户亦可自定义删除器。存有状态的删除器和函数指针会增加std::unique_ptr对象的大小。</strong></li>
<li><strong>将std::unique_ptr转换为std::shared_ptr十分容易。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>47.在需要类型转换时请为模板定义非成员函数</title>
    <url>/2018/04/23/%E5%9C%A8%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>Effective C++ 25已经描述过为何仅有non-member函数才有能力对所有实参执行隐式转换。本节我们将类型转换拓展到template范围。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>在上一次的实例中，我们以Rational class与<code>operator*</code>讨论了在所有实参身上执行隐式转换。本次实例则将它们模板化。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">const</span> T&amp; numerator = <span class="number">0</span>,<span class="keyword">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> rational&lt;T&gt; &amp;lhs,<span class="keyword">const</span> rational&lt;T&gt; &amp;rhs) &#123;&#125;</span><br></pre></td></tr></table></figure><br>我们预期以下代码也会通过编译，因为它们在非模板时确实编译成功了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="keyword">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="keyword">int</span>&gt; result = oneHalf *<span class="number">2</span>;<span class="comment">//error 编译失败</span></span><br></pre></td></tr></table></figure><br>我们应该能够意识到，模板化的Rational中的某些东西似乎与non-template版本不同。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>在非模板情况下，编译器知道我们尝试去调用接受两个Rational参数的operator*，但在这里，编译器不知道我们想调用哪个函数。<br>它在试图想出什么函数可以被名为operator*的template具现化出来。它知道它们应该可以具现出某个名为operator*且接受两个rational&lt;T&gt;参数的函数，但为了完成这一具现化行为，必须先算出T是什么。编译器无法做到。</p>
<h2 id="实参推导"><a href="#实参推导" class="headerlink" title="实参推导"></a>实参推导</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="keyword">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="keyword">int</span>&gt; result = oneHalf *<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>operator*的第一参数被声明为rational&lt;T&gt;,而传递给operator*的第一实参oneHalf是Rational&lt;int&gt;,那可以肯定T是int.关键在于第二实参接受的应该是一个Rational&lt;int&gt;,但实际传入的却是int。T的推导无法确定。<br>template实参推导过程中并不考虑隐式类型转换。这就是报错的关键。尽管隐式转换在函数调用过程中的确被使用，但在能调用一个函数之前，它必须已经存在（已被推导出并具现化）。</p>
<hr>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="friend声明"><a href="#friend声明" class="headerlink" title="friend声明"></a>friend声明</h2><p>template class内的friend声明式可以指涉某个特定函数，那意味着class Rational&lt;T&gt;可以声明operator*是它的一个friend函数。class templates并不依赖于template实参推导（实参推导仅发生在function templates身上），所以编译器总是能在class rational&lt;T&gt;具现化时得知T.因此，令Rational&lt;T&gt; class 声明适当的operator*为其friend函数，可以简化整个问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp;lhs,<span class="keyword">const</span> Rational&lt;T&gt;&amp;rhs);</span><br></pre></td></tr></table></figure><br>当oneHalf被声明为一个Rational&lt;T&gt;时，rational&lt;int&gt;则被具现化，而作为具现化的一部分，operator*也完成了自动声明,后者作为一个non-template function，编译器可以在调用时使用隐式转换。</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>friend声明帮助我们完成了编译，但上述代码并不能连接，原因很简单，只有声明是而没有定义式。我们也无法在class外部完成operator* template定义，因为既然在Rational template中声明，就必须在其中定义。因此必须把函数本体移动到声明式中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> Rational(lhs.numerator()*rhs.numerator(),</span><br><span class="line">                        lhs.denominator()*rhs.denominator());<span class="comment">//返回值优化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>至此，编译并连接成功，混合式计算正常运行。</p>
<hr>
<h1 id="解决方案剖析"><a href="#解决方案剖析" class="headerlink" title="解决方案剖析"></a>解决方案剖析</h1><p>&nbsp;<br>这项技术的关键点在于：我们使用friend并不是因为我们想访问non-public成员。我们为了让类型转换可以用于所有实参，需要一个non-member函数。为了令它自动具现化，我们需要它位于class内部。综合二者，我们得到了friend.</p>
<p>众所周知，定义在class内部的函数都申请inline，包括friend函数。为了避免可能带来的高成本，一般而言，我们会令它不做任何事情，只是调用class外的一个辅助函数。</p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>Rational是一个template意味着上述的辅助函数通常也是一个template。我们定义了Rational的头文件代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rational</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMutiply</span><span class="params">(<span class="keyword">const</span> Rational&lt;T&gt; &amp;,......)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> doMutiply(lhs,rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>当我们编写一个class template，而它提供的“与此template相关”函数需要“所有参数支持隐式转换时”，请将那些函数定义为friend函数,并在class template中定义它们。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板与泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>19.在进行共享式资源管理时使用std::shared_ptr</title>
    <url>/2018/07/05/%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E6%97%B6%E4%BD%BF%E7%94%A8stdshared_ptr/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>有人认为C++的手动内存回收机制过于原始，这钟说辞相当正确，但是否存在一种方式，可以保证C++既可以自动完成内存回收，又能够明确它们释放的时间？</p>
<hr>
<h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>&nbsp;<br>std::shared_ptrs所指向的对象，其生命周期由这些共享其所有权的指针共同管理，不存在某个特定的std::shared_ptr拥有该对象。同时，所有指向该对象的std:: shared_ptrs都将保证在该对象不再需要时对其进行销毁。当指向对象的最后一个std :: shared_ptr停止指向那里时（例如该std::shared_ptr被销毁或被指向另一个对象），此时该std::shared_ptr会析构它指向的对象。类似于内存回收机制，客户端无需关心管理对象的生命周期，但这种行为同时也兼具析构函数的特点，即对象销毁时间是确定的。</p>
<p>std::shared_ptr通过查询资源的引用计数来判断它是否是指向该资源的最后一个sp指针，当执行构造函数时<strong>通常</strong>会导致引用计数自增，析构时自减，执行copy assignment operator同时执行二者（原有资源引用计数自减，新资源引用计数自增）。当std::shared_ptr在执行递减后发现当前引用计数为0，则表明此时不再有任何std::shared_ptrs指向该资源，那么shared_ptr则会执行析构。</p>
<hr>
<h1 id="引用计数对性能的影响"><a href="#引用计数对性能的影响" class="headerlink" title="引用计数对性能的影响"></a>引用计数对性能的影响</h1><p>&nbsp;<br>shared_ptr中的引用计数对性能存在如下影响：</p>
<ol>
<li><strong>shared_ptr大小是原始指针的两倍</strong><br>原因在于shared_ptr持有两个指针，一个指针指向资源，另一个指向引用计数。</li>
<li><strong>必须动态分配引用计数的内存</strong><br>理论上引用计数与资源相关联，但资源自身对此却一无所知，因此，资源不会存储引用计数（这也意味着任何对象，甚至是内置类型的对象也可由shared_ptr管理）。无论哪种方式，引用计数都存储为动态分配的数据。动态分配需要成本，Item21阐明当使用std::make_shared创建std::shared_ptr时可以避免该开销，但并非任何情况都可以使用make_shared。总之，无论采取何种方式，引用计数都必须存储于动态分配的内存中。</li>
<li><strong>引用计数的自增与自减行为必须是atomic</strong><br>不同的线程之中可能同时存在着reader与writer。举例而言，线程A中，指向某资源的std::shared_ptr正在执行析构函数（引用计数自减），而在线程B中，存在一个shared_ptr被复制（引用计数自增）。atomic操作通常慢于non-atomic操作，因此即使引用计数大小通常只是一个word，我们也应当认为其读取和写入操作成本较高。</li>
</ol>
<hr>
<h1 id="shared-ptr的创建"><a href="#shared-ptr的创建" class="headerlink" title="shared_ptr的创建"></a>shared_ptr的创建</h1><p>&nbsp;<br>在前文中我们提到，shared_ptr在创建时<strong>通常</strong>会自增引用引用，那为什么不是<strong>总是</strong>自增引用计数呢？原因在于move constructor。在执行移动构造时，源shared_ptr会被置为null，而引用计数不需要发生任何改变。因此，移动std::shared_ptrs比复制它们要快：move construct优于copy construct，move assignment优于copy assignment。</p>
<hr>
<h1 id="shared-ptr的删除器"><a href="#shared-ptr的删除器" class="headerlink" title="shared_ptr的删除器"></a>shared_ptr的删除器</h1><p>&nbsp;<br>类似于unique_ptr，shared_ptr也使用delete作为默认删除器，并且支持自定义删除器行为，不过对于这一特性，shared_ptr的设计与unique_ptr的设计颇有不同。对于unique_ptr而言，删除器是智能指针的一部分，但对于shared_ptr而言并非如此：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget *pw)&#123;makeLogEntry(pw);<span class="keyword">delete</span> pw;&#125;;</span><br><span class="line">std::unique_ptr&lt;Widget, decltype(loggingDel)&gt; upw(new Widget, loggingDel);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br></pre></td></tr></table></figure>
<p>std::shared_ptr设计具备更高的灵活性。 考虑当前存在两个std::shared_ptr&lt;lWidget&gt;，每个都有一个不同类型的自定义删除器（其原因可能是自定义删除器是一个lambda）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> customDeleter1 = [](Widget *pw) &#123; … &#125;; <span class="comment">// custom deleters,</span></span><br><span class="line"><span class="keyword">auto</span> customDeleter2 = [](Widget *pw) &#123; … &#125;; <span class="comment">// each with a different type</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter1)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw2</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter2)</span></span>;</span><br></pre></td></tr></table></figure><br>因为pw1和pw2具备相同的类型，因此它们可以放在同一个容器之中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;&gt; vpw&#123; pw1, pw2 &#125;;</span><br></pre></td></tr></table></figure><br>pw1与pw2也可以相互赋值，并且可以都能够作为实参传递给一个形参类型为 std::shared_ptr&lt;Widget&gt;的函数。对于自定义删除器类型不同的std::unique_ptrs，上述操作均无法实现，因为自定义删除器的类型会影响std::unique_ptr的类型。此外，自定义删除器不会更改std::shared_ptr对象的大小。无论采用何种删除器，std::shared_ptr对象的大小始终为两个指针大小。但std::shared_ptr如何在不使用任何额外内存的情况下引用任意大小的删除器？</p>
<hr>
<h1 id="control-block"><a href="#control-block" class="headerlink" title="control block"></a>control block</h1><p>&nbsp;<br>事实上shared_ptr仍然需要额外的内存以放置与使用删除器，只是这块内存并非std::shared_ptr对象的一部分。它位于堆上，或者是allocator分配的内存所在的位置（如果shared_ptr使用了自定义allocator）。前文曾经提到，std::shared_ptr对象包含一个指向引用计数的指针，但实际上该指针其实指向的是一个更大的数据结构control block，引用计数是它的一部分。std::shared_ptrs所管理的每个对象都具备一个control block。除引用计数之外，control block还包含自定义删除程序的副本（如果拟制定了自定义删除器的话）。如果你在定义shared_ptr时指定了自定义分配器，则control block也包含该副本。control block还可以包含附加数据(见Item21），但这一节我们先不做理会。我们可以设想与std::shared_ptr &lt;T&gt;对象相关联的内存看起来如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/ke8earnwfpuaib3hf17ieral/image_1chk5vpusl9c187q1pa7o9p16si1p.png" alt="image_1chk5vpusl9c187q1pa7o9p16si1p.png-48kB"></p>
<hr>
<h2 id="control-block创建规则"><a href="#control-block创建规则" class="headerlink" title="control block创建规则"></a>control block创建规则</h2><p>&nbsp;<br>理论上而言，对象的controol block应当由第一个指向该对象的std::shared_ptr设置，但在实际情况中，构建std::shared_ptr的函数不可能明确是否已经存在其他std::shared_ptr已指向该对象，因此control block有如下创建规则：</p>
<ol>
<li><strong>std::make_shared（见Item21）总是创建一个control block</strong><br>它生成一个需要被指向的新对象，因此在调用std::make_shared时肯定没有该对象的控制块。</li>
<li><strong>当std::shared_ptr的构造源是唯一所有权指针（即std::unique_ptr或std::auto_ptr）时，创建一个control block</strong><br>唯一所有权指针并不需要control block，因此需要创建，此外，当shread_ptr被构建完毕后，唯一所有权指针将会被置为null。</li>
<li><strong>当以原始指针作为实参调用std::shared_ptr构造函数时，创建一个control block</strong><br>如果你想通过一个已有control block的对象创建一个std::shared_ptr，你可能会将std::shared_ptr或std ::weak_ptr（见Item20）作为实参传递给shared_ptr的构造函数，而不是使用原始指针。事实上，当它们作为实参构造shared_ptr时不会构造control block。</li>
</ol>
<p>这些规则可能会触发一些不良后果，假设你以一个原始指针创建了多个shared_ptr，那么将会产生多个control block，从而触发多次析构：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget; <span class="comment">// pw is raw ptr</span></span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw1</span><span class="params">(pw, loggingDel)</span></span>; <span class="comment">// create control block for *pw</span></span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw2</span><span class="params">(pw, loggingDel)</span></span>; <span class="comment">// create 2nd control block for *pw!</span></span><br></pre></td></tr></table></figure><br>为动态创建的对象分配一个原始指针是一种不良行为，这完全违背了本章的主旨：以智能指针取代原始指针。但这充其量只是一种不正确的编程风格，因为它至少没有主动引起未定义行为。在刚才的代码示例中，一个对象有两个相关联的control block，这必然会导致该对象会被析构两次，在第二次析构时将会导致未定义行为。</p>
<p>刚代码示例至少蕴含两个启示：</p>
<ol>
<li><strong>应当尽量避免使用原始指针创建shared_ptr</strong><br>上述程序之所以不使用make_shared，是因为我们使用了自定义删除器的原因。</li>
<li><strong>如果一定要以原始指针初始化shared_ptr，则直接以new表达式初始化之</strong><br>如果示例中的代码被重写为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Widget,loggingDel)</span></span>;</span><br></pre></td></tr></table></figure>
当我们需要创建第二个shared_ptr时，则通常会选择使用copy construct：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw2</span><span class="params">(spw1)</span></span>; <span class="comment">// spw2 uses same control block as spw1</span></span><br></pre></td></tr></table></figure>
如此则不会产生任何问题。</li>
</ol>
<hr>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>&nbsp;<br>假设我们的程序使用std::shared_ptrs来管理Widget对象，并且我们有一个数据结构来跟踪被处理的Widgets：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; &gt; processedWidgets;</span><br></pre></td></tr></table></figure><br>进一步地假设Widget具备一个负责处理的成员函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>process一种可能的实现方式如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    … <span class="comment">// process the Widget</span></span><br><span class="line">    processedWidgets.emplace_back(<span class="keyword">this</span>); <span class="comment">// add it to list of processed Widgets</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>关于emplace_back可见Item42.此实现的最大错误在于将this,也就是原始指针作为参数传入容器，从而直接导致关于某Wideget可能存在多个control block。</p>
<hr>
<h2 id="解决方案-std-enable-shared-from-this"><a href="#解决方案-std-enable-shared-from-this" class="headerlink" title="解决方案(std::enable_shared_from_this)"></a>解决方案(std::enable_shared_from_this)</h2><p>&nbsp;<br>std::shared_ptr早已考虑到这种情况，并为之提供了API，只是名字有点奇怪：std::enable_shared_from_this。如果你希望std::shared_ptrs管理的类能够通过this指针安全地创建std::shared_ptr，那么你必须令你的class继承此基类模板，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>std::enable_shared_from_this是一个基类模板,它的类型参数始终是派生类的名称,基类决定于派生类这一行为十分奇怪，但这段代码完全合法，甚至存在一个与之相关的设计模式Curiously Recurring Template Pattern (CRTP)。（实际上在Effective C++ Item49中已有涉及）</p>
<p>std::enable_shared_from_this定义了一个成员函数，它可为当前对象创建一个std::shared_ptr，但该函数不会造成重复的control block。该成员函数名为shared_from_this，其隐含实参为*this，返回由*this初始化的shared_ptr,其使用示例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// as before, process the Widget</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// add std::shared_ptr to current object to processedWidgets</span></span><br><span class="line">    processedWidgets.emplace_back(shared_from_this());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="shared-from-this实现"><a href="#shared-from-this实现" class="headerlink" title="shared_from_this实现"></a>shared_from_this实现</h2><p>&nbsp;<br>shared_from_this会查找当前对象的control block，并创建一个引用该control block的新std::shared_ptr。显而易见，该函数要求当前必须已经存在一个shared_ptr指向该对象，如果不存在（即当前对象并无相关control block），则其行为未定义（事实上会抛出一个异常）。</p>
<p>为了防止客户在尚未存在std::shared_ptr指向*this之前调用shared_from_this，继承自std::enable_shared_from_this的类通常将其构造函数声明为private，并让客户通过调用返回std::shared_ptrs的工厂函数来创建对象，举例而言，Widget的实现可能如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">create</span><span class="params">(Ts&amp;&amp;... params)</span></span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>; <span class="comment">// as before</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    … <span class="comment">// ctors</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="shared-ptr使用成本"><a href="#shared-ptr使用成本" class="headerlink" title="shared_ptr使用成本"></a>shared_ptr使用成本</h1><p>&nbsp;<br>control block的大小通常只有几个word，不过自定义删除器和分配器可能会令它较大一些。一般而言，control block的实现比人们想象地更加复杂，它可能会用到继承甚至虚函数的概念（确保对象可被正确析构），这意味着使用std::shared_ptrs也需要付出虚函数所带来的那些成本（详见More Effective C++ Item24）。</p>
<p>在介绍了如此之多的细节后，你可能会对shared_ptr所产生的control block如此复杂难用而感到不满，但实际上针对它们所完成的那些功能，使用shared_ptr绝对物超所值。此外，当你处于典型应用环境（无自定义删除器及allocator）时，control block的大小约为3个word，并且它通常会被合并到对象所占用的内存空间之中（详见Item21）。</p>
<p>解引用std::shared_ptr并不比解引用原始指针所消耗的成本更高。执行需要引用计数的操作（例如copy construct,copy assignment operator，destructor）需要一到两个atomic 操作，但这些操作仅仅相对于non-atomic而言开销较多。conrtrol block中虽然蕴含虚函数，但虚函数的使用频率并不高（实际上仅在析构时才会被使用）。在付出了上述代价后，你收获了内存回收机制，甚至比它还要更加出色一点，我认为这是相当值得的。</p>
<hr>
<h1 id="shared-ptr与unique-ptr"><a href="#shared-ptr与unique-ptr" class="headerlink" title="shared_ptr与unique_ptr"></a>shared_ptr与unique_ptr</h1><p>&nbsp;<br>如果你发现当前资源是独占式的，std::unique_ptr相对于shared_ptr无疑是更好的选择，它的性能与原始指针相差无几，并且从std::unique_ptr到std::shared_ptr的转变十分方便。但这种情况反之却并不成立，一旦你将资源的生命周期管理转换为std::shared_ptr，就再也无法收回成命。也就是说，unique_ptr到shared_ptr总是允许的，但发生转变之后就再也不能后悔了（即使当前对象的引用计数为1你也不能将其转交给unique_ptr)。</p>
<p>shared_ptr与unique_ptr的另一点不同是它无法指向数组，也就是说没有std::shared_ptr&lt;T[]&gt;。有人会想到使用自定义删除器来执行数组删除（即delete []），这种程序可以编译，但毫无价值。首先，std::shared_ptr不提供operator[]，因此索引到数组需要基于指针算术。另一方面，std::shared_ptr支持单一对象的派生类指针到基类指针之间的转换，但其无法应用于数组之中。STL存在如此之多的容器，使用数组无疑是一种较为不智的设计。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>std::shared_ptr为C++开发者提供了接近内存回收机制般的便利。</strong></li>
<li><strong>相较于unique_ptr，shared_ptr对象通常较大，并且引入了control block与atomic操作（并且导致了性能下降）。</strong></li>
<li><strong>自定义删除器对shared_ptr的类型并无任何影响。</strong></li>
<li><strong>应当尽量避免以原始指针初始化shared_ptr</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>39.判断式必须为纯函数</title>
    <url>/2018/04/19/%E5%88%A4%E6%96%AD%E5%BC%8F%E5%BF%85%E9%A1%BB%E4%B8%BA%E7%BA%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>&nbsp;<br>在开始本节内容之前，有基础概念如下：</p>
<ul>
<li>判断式是返回bool或者返回值可以隐式转化为bool的东西.举例而言，默认谓词即为判断式.</li>
<li>纯函数是返回值只依赖参数的函数，参数不改变则返回值不变（不具备状态），<strong>纯函数中所有的数据只有两种：参数、常量。</strong></li>
<li>一个判断式类是一个仿函数类，它的成员函数operator()返回0或者1，STL算法可以接受一个真正的判断式或一个判断式对象作为谓词。</li>
</ul>
<hr>
<h1 id="为什么判断式必须为纯函数"><a href="#为什么判断式必须为纯函数" class="headerlink" title="为什么判断式必须为纯函数"></a>为什么判断式必须为纯函数</h1><p>&nbsp;<br>前文说过，函数对象在STL算法中pass-by-value。判断式作为一个函数对象，存在另一个设计特性：<strong>STL可能会先拷贝它们，然后在需要的时候使用它们的拷贝。</strong>这个设计特性的直接反映就是：判别式函数必须是纯函数。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>下述的判断式类功能为：仅在第三次调用时返回true.<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadPredicate</span>:</span><span class="keyword">public</span> unary_function&lt;Widget, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BadPredicate(): timesCalled(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget&amp;)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++timesCalled == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> timesCalled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>看起来似乎没毛病。于是我们用它来作为谓词抹除容器内的第三个元素：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br><span class="line">vw.erase(remove_if(vw.<span class="built_in">begin</span>(),vw.<span class="built_in">end</span>(),BadPredicate()), vw.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>事实上调用完成后不仅仅会抹除第三个元素，第六个元素也会被抹除。</p>
<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2><p>上述问题的产生原因在于remove_if的实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FwdIterator, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function">FwdIterator <span class="title">remove_if</span><span class="params">(FwdIterator <span class="built_in">begin</span>, FwdIterator <span class="built_in">end</span>, Predicate p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">begin</span> = find_if(<span class="built_in">begin</span>, <span class="built_in">end</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FwdIterator next = <span class="built_in">begin</span>;</span><br><span class="line">        <span class="keyword">return</span> remove_copy_if(++next, <span class="built_in">end</span>, <span class="built_in">begin</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，判断式p的copy先被传递给find_if，再被传递给remove_copy_if.<br>首先，我们构造了一个匿名判断类对象，并用它初始化了判断类对象p,然后p被拷贝到findif中（time被初始化为0），然后调用了3次以后，<strong>p的拷贝</strong>的time增长为3，返回true.控制权回归remove_if，然后remove_copy_if拷贝了p，此时time为0，（而不是3），因此到第六个元素的时候又触发了true。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最简单的方法是把operator()函数声明为const，如此一来，你的编译器不会通过任何改变任何数据成员的指令。<br>但这是不够的，因为const成员函数还是能改变mutable成员，非const局部静态对象，非const类静态对象、命名空间中的非const对象，以及非const的全局对象。<br>总的来说，<strong>一个行为正常的判断类operator()必然是const的，但还有更严格的要求：必须是纯函数。</strong></p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>仿函数</tag>
      </tags>
  </entry>
  <entry>
    <title>44.处理模板化基类内的名称</title>
    <url>/2018/04/21/%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假定我们需要撰写一个程序，它需要传递信息至不同的公司。信息或者是明文，或者是密码。如果我们在编译期可以确定发送至哪家公司，就可以采用基于template的解决方案:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span>...&#125;;<span class="comment">//保存信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;typenmae Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">        <span class="comment">//根据info产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.sendCleartext(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然这种处理方案是合理的。<br>但如果我们希望在每次发送信息时完成记录，我们通过派生一个derived class来完成这种行为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span><span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;<span class="comment">//避免遮蔽名称</span></span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">        sendClear(info);<span class="comment">//试图调用base class函数,无法编译</span></span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这段程序逻辑上无误，但编译器会拒绝编译，并给出sendClear不存在这样的错误信息。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>报错原因在于，当编译器遭遇class template LoggingMsgSender定义式时，并不了解其基类，因为此时基类尚未被具现化。<br>再具体一些，我们假定有CompanyZ坚持使用加密通讯：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">//不提供sendClear</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>那一般化的MsgSender template对CompanyZ并不合适，因为该template提供了sendClear。因此我们针对CompanyZ做出了一个特化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">//全特化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&lt;CompanyZ&gt;&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在完成了全特化后，我们再次考虑derived class LoggingMsgSender:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span><span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">        sendClear(info);<span class="comment">//如果参数为CompanyZ，该函数不存在</span></span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如今我们可以清楚地看出编译器拒绝调用的原因<strong>：base class template可能被特化，且特化版本可能不具备与一般性版本一致的接口。</strong>编译器拒绝在templated base classes内寻找继承而来的名称，面向对象的规则在泛型编程中依然不再适用。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li>使用<code>this-&gt;</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span><span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;sendClear(info);<span class="comment">//假设继承了sendClear，隐式接口</span></span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>使用using<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span><span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<span class="comment">//假设存在</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">        sendClear(info);</span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
值得注意的是，这里使用using与Effective C++ 34中的作用并不相同，这里的情况并非发生了名称遮蔽，而是主动要求编译器前往base class内部查找对象函数。</li>
<li>使用作用域运算符明确指出该名称<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span><span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">        MsgSender&lt;Company&gt;::sendClear(info);</span><br><span class="line">        <span class="comment">//log sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
第三种方法不建议使用，<strong>因为如果名称是一个virtual函数，这种做法关闭了virtual绑定行为。</strong></li>
</ol>
<hr>
<h1 id="解决方案剖析"><a href="#解决方案剖析" class="headerlink" title="解决方案剖析"></a>解决方案剖析</h1><p>&nbsp;<br>上述的三种方法其实都是在做同一件事：<strong>对编译器承诺“base class template的任何特化版本都将支持其一般版本所提供的接口”。</strong><br>面对“指涉base class mrmbers”的无效references，编译器的诊断可能在早期（当解析dc template的定义式时），也可能发生在晚期（当template被特定实参具现化时）。c++一般惯于较早诊断，这也就是为什么“当base classes从templates中被具现化时”，它假设它对base classes的内容一无所知的原因。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板与泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>同步并发操作——等待事件或条件</title>
    <url>/2019/04/20/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6%E6%88%96%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在线程运行过程中经常发生如下场景：线程A需要等待线程B完成某操作。有三种方案可以解决这一需求：</p>
<ol>
<li><p>反复检查共享标志位(例如mutex)，直到某线程完成操作后将其置位。<br>这将造成两点浪费：首先，线程不得不耗费宝贵的运行时间循环检查数据；其次，如果mutex被线程A上锁（它需要锁住互斥量以查看被其保护的标志位），那么其他线程将无法获得该锁，甚至连已完成任务的线程B也无法锁住互斥量以重置该标志位。</p>
</li>
<li><p>使用<code>std::this_thread::sleep_for()</code>令线程在等待间隙短暂休眠</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag; </span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_flag</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; </span><br><span class="line">  <span class="keyword">while</span>(!flag) &#123; </span><br><span class="line">    lk.unlock();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>)); <span class="comment">// 休眠100ms </span></span><br><span class="line">    <span class="comment">//....此时可以保证其他线程获取该锁，重置flag</span></span><br><span class="line">    lk.lock();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案2优于方案1，但缺憾在于开发者无法确定休眠时间取多少合适。过少的休眠时间等于没有，过多的休眠时间又会造成任务必须等待线程苏醒。尽管休眠时间过长很少会对程序运行产生直接影响，但在对实时性较高的场景中（例如游戏画面绘制），这意味着一场灾难。</p>
</li>
<li><p>使用C++标准库提供的工具<br>最基本的处理等待事件机制为条件变量(condition variable)。从本质而言，条件变量的存在与事件或条件相关联，并且必须存在一些等待该变量被满足的线程。若当前执行线程确定条件已被满足，那么它将通知一个或多个等待该条件变量被满足的线程，以便唤醒它们接着执行任务。</p>
</li>
</ol>
<a id="more"></a>
<h1 id="等待条件达成"><a href="#等待条件达成" class="headerlink" title="等待条件达成"></a>等待条件达成</h1><p>&nbsp;<br>C++标准库提供了了两种条件变量的实现：<code>std::condition_variable</code>与<code>std::condition_variable_any</code>,它们都位于头文件<code>&lt;condition_variable&gt;</code>内。</p>
<p>二者均需要与互斥量配合，不同之处在于<code>std::condition_variable</code>仅限于与<code>std::mutex</code>搭配使用，而<code>std::condition_variable_any</code>则可以与任何满足最低标准的互斥量一起工作，这也是<code>_any</code>后缀的由来。当然，灵活性会带来性能上的损耗，因此除非必要，我们应当尽可能使用<code>std::condition_variable</code>。以下将展示如何使用<code>std::condition_variable</code>实现条件唤醒：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue; </span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(more_data_to_prepare()) &#123; </span><br><span class="line">    data_chunk <span class="keyword">const</span> data = prepare_data(); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_queue.push(data);</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    data_chunk data=data_queue.front(); </span><br><span class="line">    data_queue.pop(); </span><br><span class="line">    lk.unlock();<span class="comment">// 时间点1</span></span><br><span class="line">    <span class="built_in">process</span>(data); </span><br><span class="line">    <span class="keyword">if</span>(is_last_chunk(data)) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先存在一个用于在两个线程间传递数据的队列。当数据准备就绪时，准备数据的线程调用<code>std ::lock_guard</code>锁定保护队列的互斥锁，并将数据推送到队列中。接着该线程调用<code>std:: condition_variable</code>的成员函数<code>notify_one()</code>来通知可能存在的等待线程。</p>
<p>接下来我们将目光移至<code>data_processing_thread</code>。该线程首先执行对互斥量的锁定(使用的是unique_lock而非lock_gurad,具体原因将在下文提及)。接着线程调用<code>condition_variable</code>的成员函数<code>wait</code>。该函数接收一个lock对象与一个lambda表达式，当lambda表达式返回false时，<code>wait</code>将解锁互斥量，并将当前线程置于阻塞或等待状态。当其他线程调用<code>notify_one()</code>通知条件变量时，执行线程从睡眠中苏醒，重新获取互斥锁并检查执行条件(lambda表达式)。若当前条件满足，从<code>wait()</code>返回（互斥量保持锁定）。若不满足，则线程将解锁互斥量并继续等待。这也就是我们使用<code>unique_lock</code>的原因——我们需要随时加锁解锁的灵活性。如果线程处于休眠状态时互斥锁保持锁定，则数据准备线程将无法锁定互斥锁并把数据添加到队列中，此时等待线程的条件也将永远不会被满足。</p>
<p><code>unique_lock</code>的存在不仅为了满足<code>wait</code>内频繁加锁与解锁的需要，若当前存在待处理数据，但此时处理操作尚未开始(如代码中时间点1)，开发者同样需要调用<code>unlock</code>，原因在于处理数据可能非常耗时。在前文中我们曾经提及，持有锁的时间过长将造成种种负面影响。</p>
<hr>
<h1 id="使用条件变量构建线程安全队列"><a href="#使用条件变量构建线程安全队列" class="headerlink" title="使用条件变量构建线程安全队列"></a>使用条件变量构建线程安全队列</h1><p>&nbsp;<br>使用队列在线程之间传输数据是一种常见行为，既然如此，我们完全可以在队列内部实现同步，从而降低触发条件竞争的可能性。因此，本节将致力于使用条件变量构建通用型线程安全队列。</p>
<p>首先观察一下C++标准库中<code>queue</code>的对外接口：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">deque</span>&lt;T&gt; &gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(<span class="keyword">const</span> Container&amp;)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(Container&amp;&amp; = Container())</span></span>; </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">explicit</span> <span class="title">queue</span>(<span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">queue</span>(<span class="title">const</span> <span class="title">Container</span>&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">queue</span>(<span class="title">Container</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">queue</span>(<span class="title">queue</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">queue</span>&amp; q)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; x)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt; </span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace</span>(<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>忽略构造、赋值、交换后，值得注意的接口有以下三种：</p>
<ol>
<li>查询接口(<code>empty()</code>，<code>size()</code>)</li>
<li>数据接口(<code>front()</code>，<code>back()</code>)</li>
<li>修改接口(<code>push()</code>，<code>pop()</code>，<code>emplace()</code>)</li>
</ol>
<p>类似于stack，queue的接口同样存在固有条件竞争，因此需要将<code>front()</code>与<code>pop()</code>合并至一个接口内。在前文queue的使用场景中，我们注意到接收线程常常需要等待数据，因此我们将<code>pop()</code>接口改为两种不同的操作方式：<code>try_pop()</code>与<code>wait_and_pop()</code>。前者尝试从队列中弹出值，并总是立即返回(带有<code>isSuccess</code>标志)；后者则持续等待至目标弹出。综上，<code>threadsafe_queue</code>接口如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // for std::shared_ptr</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue(); </span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp;); </span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>; <span class="comment">// delete assign</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span>; <span class="comment">// 传入引用作为输出</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>; <span class="comment">// 若失败则返回nullptr</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue; </span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue() &#123;&#125; </span><br><span class="line">  threadsafe_queue(threadsafe_queue <span class="keyword">const</span>&amp; other) &#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>; </span><br><span class="line">    data_queue=other.data_queue; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.push(new_value);</span><br><span class="line">    data_cond.notify_one(); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    value=data_queue.front(); </span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt; (data_queue.front()))</span></span>; </span><br><span class="line">    data_queue.pop(); </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty()) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=data_queue.front();</span><br><span class="line">    data_queue.pop(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty()) </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;(); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt; (data_queue.front()))</span></span>; </span><br><span class="line">    data_queue.pop(); <span class="keyword">return</span> res; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>wait_and_pop</code>的使用方法如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">threadsafe_queue&lt;data_chunk&gt; data_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">    data_queue.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    data_chunk data; </span><br><span class="line">    data_queue.wait_and_pop(data); </span><br><span class="line">    <span class="built_in">process</span>(data); </span><br><span class="line">    <span class="keyword">if</span>(is_last_chunk(data)) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="notify-one的不足与notify-any"><a href="#notify-one的不足与notify-any" class="headerlink" title="notify_one的不足与notify_any"></a>notify_one的不足与notify_any</h1><p>&nbsp;<br><code>notify_one()</code>的不足在于，它将触发当前正在执行<code>wait()</code>的<strong>一个</strong>线程检查其状态并从<code>wait()</code>返回，但开发者无法精准地通知到某个<strong>指定</strong>进程，即使该进程正处于等待状态。</p>
<p>若存在几个线程正在等待同一事件，并且它们都需要对该事件作出响应（应用场景如共享数据初始化或多个线程等待共享数据更新）。此时我们可以调用<code>notify_all()</code>这一成员函数，顾名思义，这将导致当前所有正在执行<code>wait()</code>的线程检查它们正在等待的条件。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>14.审慎使用异常明细</title>
    <url>/2018/04/26/%E5%AE%A1%E6%85%8E%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E6%98%8E%E7%BB%86/</url>
    <content><![CDATA[<p>（本节内容在Effective C++ 30中亦有涉及）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>异常明细明确描述了一个函数可能抛出的异常，如果说函数抛出了一个不能存在于异常明细范围里的异常，系统将在运行时检测到该错误，并且自动地调用特殊函数unexpected。<br>unexpected默认机制是调用terminate，而terminate缺省行为是调用abort.也就是说，一旦违反了异常明细，程序将立刻终止，所有资源（甚至包括局部变量）都未得到释放。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>前言中描述的情况其实极易发生，因为编译器仅仅部分地检测异常的使用是否与异常明细保持一致。举例而言，假设函数A有一个明确的异常明细，并且调用了函数B，函数B抛出了违反函数A异常明细的异常，所以本次函数调用就违反了A的异常明细，程序将立即终止：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;<span class="comment">//可以抛出任意的异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;<span class="comment">//异常明细中只有int</span></span><br><span class="line">    ...</span><br><span class="line">    f1(); <span class="comment">//抛出非int型异常，程序终止</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="避免在带有类型参数的模板中使用异常"><a href="#避免在带有类型参数的模板中使用异常" class="headerlink" title="避免在带有类型参数的模板中使用异常"></a>避免在带有类型参数的模板中使用异常</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">lhs</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">rhs</span>) <span class="title">throw</span>()&#123;</span></span><br><span class="line">    <span class="keyword">return</span> &amp;lhs == &amp;rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的意思是，如果类型相同的两个对象地址相同，则认为它们相等。看起来好像确实不会抛出异常，但实际上…万一某个类重载了operator &amp;，并且该函数还能抛异常，那我们就等着terminate吧。</p>
<p>事实上，我们几乎不可能为一个模版提供一个有意义的异常明细，因为模版总是采用不同的方法使用类型参数，解决方法只能是模板和异常明细不要混用。</p>
<hr>
<h2 id="去除异常明细"><a href="#去除异常明细" class="headerlink" title="去除异常明细"></a>去除异常明细</h2><p>不触发terminate的另一个方法是：如果在一个具备异常明细的函数内调用其它没有异常明细的函数，那么我们应该去除该函数的异常明细。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>允许用户注册一个回调函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个 window 系统回调函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CallBackPtr)</span><span class="params">(<span class="keyword">int</span> eventXLocation,<span class="keyword">int</span> eventYLocation,<span class="keyword">void</span> *dataToPassBack)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallBack</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CallBack(CallBackPtr fPtr, <span class="keyword">void</span> *dataToPassBack)</span><br><span class="line">        : func(fPtr), data(dataToPassBack) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeCallBack</span><span class="params">(<span class="keyword">int</span> eventXLocation,<span class="keyword">int</span> eventYLocation)</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CallBackPtr func;<span class="comment">//需要调用的函数</span></span><br><span class="line">    <span class="keyword">void</span> *data;<span class="comment">//传递给回调函数的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallBack::makeCallBack</span><span class="params">(<span class="keyword">int</span> eventXLocation,<span class="keyword">int</span> eventYLocation)</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func(eventXLocation, eventYLocation, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，func可能抛出异常，违反了第二种解决方案。</p>
<hr>
<h2 id="处理系统本身抛出的异常"><a href="#处理系统本身抛出的异常" class="headerlink" title="处理系统本身抛出的异常"></a>处理系统本身抛出的异常</h2><p>&nbsp;<br>有人说未雨绸缪强过临阵磨枪，但实际上对于unexpected而言，直接处理unexpected异常比防止它们被抛出更有效果。<br>虽然阻止抛出unexpected异常是不现实的，但是C++允许<strong>以其它不同的异常类型替换unexpected异常</strong>。比如我们可以将所有unexpected异常都被替换为UnexpectedException对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnexpectedException</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertUnexpected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> UnexpectedException();</span><br><span class="line">&#125;</span><br><span class="line">set_unexpected(convertUnexpected);<span class="comment">//将unexpected替换掉</span></span><br></pre></td></tr></table></figure><br>当然还有一个更安全的方法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertUnexpected</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line">set_unexpected(convertUnexpected);<span class="comment">//unexpected被抛出时只是重新抛出当前异常</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>异常明细是一个应被审慎使用的特性。在编写之前，确保你已经考虑了所有可能发生的情况。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>13. 复制对象务必尽善尽美</title>
    <url>/2018/04/09/%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%8A%A1%E5%BF%85%E5%B0%BD%E5%96%84%E5%B0%BD%E7%BE%8E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>设计良好的OO System一般只留有两个函数负责对象拷贝，那就是copy构造函数和copy assignment操作符，暂称它们为copying函数。正如前文所说，编译器会在必要的时候为我们的classes创建copying函数，其行为是：将被copy对象的所有成员变量都做一份拷贝。</p>
<hr>
<h1 id="手动处理拷贝可能存在的风险"><a href="#手动处理拷贝可能存在的风险" class="headerlink" title="手动处理拷贝可能存在的风险"></a>手动处理拷贝可能存在的风险</h1><p>&lt;/br&gt;<br>如果我们自己声明和实现了copying函数，但却并没有完全拷贝成员变量，造成<strong>了partial copy，此时编译器根本不会报错</strong>，所以需要仔细地排查：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">        :name(rhs.name) &#123;&#125;;<span class="comment">//忘记了copy age 不会报错</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于这种特性，<strong>每一次新的成员变量的加入，copying函数，构造函数，以及任何重载的operator=都必须要做出修改。</strong>你就不用指望编译器会提醒你了。</p>
<hr>
<h1 id="继承体系下的partial-copy"><a href="#继承体系下的partial-copy" class="headerlink" title="继承体系下的partial copy"></a>继承体系下的partial copy</h1><h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设我们的继承体系中存在着Customer与PCustomer两个类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCustomer</span>:</span><span class="keyword">public</span> Customer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs);</span><br><span class="line">    PCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PCustomer &amp;rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line">PCustomer::PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs)</span><br><span class="line">    :priority(rhs.priority) &#123;&#125;</span><br></pre></td></tr></table></figure><br>看起来确实执行了copy，但实际上dc内部的bc成分并未被copy。在这种情况下，<strong>bc成分将会被默认初始化。</strong><br>如果是operator=，则仅仅复制了dc成分，bc成分保持不变。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在任何时候我们一旦承担起为derived class编写copying函数的责任，必须要注意一定要记得复制base class的成员变量 ，一般情况下它们是private，所以我们<strong>调用base class的copying函数</strong>来完成它们。针对上面的实例，两个copying函数的正确写法如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PCustomer::PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs)</span><br><span class="line">    :Customer(rhs),priority(rhs.priority) &#123;&#125;</span><br><span class="line">PCustomer&amp;</span><br><span class="line">PCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PCustomer &amp;rhs)&#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority=rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="copy构造函数与copy-assignment运算符之间的关系"><a href="#copy构造函数与copy-assignment运算符之间的关系" class="headerlink" title="copy构造函数与copy assignment运算符之间的关系"></a>copy构造函数与copy assignment运算符之间的关系</h1><p>&lt;/br&gt;<br>一般来说，copying 函数往往有近似的实现本体，这可能会让我们想到在一个中调用另一个。但这并不可取。</p>
<p>令copy assignment调用copy construct函数并不科学，原因很简单，你在试图构造一个已经存在的对象。<br>令copy construct函数调用copy assignment同样毫无意义。构造函数用来初始化新对象，而assignment操作符只施行于已经被初始化的对象。对还没构造好的对象赋值完全毫无意义。</p>
<p>如果它们两个之间真的存在相近的代码，那应该编写一个private的init函数，给他们两个调用，这样就完美消除了代码重复的问题。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>copying函数应该确保复制对象内所有成员，以及所有base class成分（调用bc对应的copying函数）</li>
<li>不要尝试以某个copying函数实现另一个copying 函数。应该新建一个private init函数给二者调用。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>25.对右值引用使用move，对universal reference使用forward</title>
    <url>/2018/07/13/%E5%AF%B9%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8move%EF%BC%8C%E5%AF%B9universal%20reference%E4%BD%BF%E7%94%A8forward/</url>
    <content><![CDATA[<h1 id="move与forward复习"><a href="#move与forward复习" class="headerlink" title="move与forward复习"></a>move与forward复习</h1><p>&nbsp;<br>右值引用绑定至可移动的对象，如果你当前持有一个右值引用参数，你应当明确该对象具备移动特性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    Widget(Widget&amp;&amp; rhs); <span class="comment">// rhs definitely refers to an object eligible for moving</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了充分利用对象的移动特性，我们可以利用std::move将上述移动构造定义为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(Widget&amp;&amp; rhs):name(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs.name)),p(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs.p))&#123; … &#125;</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>universal reference也可绑定至可移动的对象，为了确保它能够正常运转，一般而言需要对它执行std::forward操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span>&#123; <span class="comment">// name is a universal reference</span></span><br><span class="line">        name = <span class="built_in">std</span>::forward&lt;T&gt;(newName); </span><br><span class="line">    &#125;</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>简而言之，右值引用在转发至其他函数时应当被无条件地转为右值（使用move），而universal reference则需要有条件地转为右值（使用forward)，因为它们仅有在被右值初始化时才能体现出右值特性。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>在Item23中曾经提及到forward亦作用于右值，只是使用起来较为繁琐（需要手动声明类型），但相对于繁琐，将move作用于universal reference则可能会导致雪崩，因为它可能会修改某个左值(比如说强行移动了某个局部变量）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> <span class="comment">// universal reference</span></span></span><br><span class="line"><span class="function">    </span>&#123; name = <span class="built_in">std</span>::<span class="built_in">move</span>(newName); &#125; <span class="comment">// compiles, but is bad, bad, bad!</span></span><br><span class="line">    … </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getWidgetName</span><span class="params">()</span></span>; <span class="comment">// factory function</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">auto</span> n = getWidgetName(); <span class="comment">// n is local variable</span></span><br><span class="line">w.setName(n); <span class="comment">// moves n into w!</span></span><br><span class="line">… <span class="comment">// n's value now unknown</span></span><br></pre></td></tr></table></figure>
<p>当然，你也可能会争辩说这个程序设计存在问题，setName不会修改参数，因此应当具备const属性从而规避universal reference，正确的写法应当是针对const左值与可被移动的右值作出重载：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; newName)</span></span>&#123; </span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; newName)</span></span>&#123; </span><br><span class="line">    name = <span class="built_in">std</span>::<span class="built_in">move</span>(newName); </span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们可以认为重载版本存在3个缺陷：</p>
<ol>
<li><strong>较多的源代码</strong></li>
<li><strong>性能较低</strong></li>
<li><strong>较低的扩展性</strong></li>
</ol>
<p>缺陷1不言自明，下面重点讨论2与3。</p>
<hr>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>&nbsp;<br>假设当前存在调用如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">w.setName(<span class="string">"Adela Novak"</span>);</span><br></pre></td></tr></table></figure><br>若采用universal reference版本，字符串“Adela Novak”（此时类型是const char* 而非string）将被传递给setName后直接作为string赋值运算符参数，因此，w的name数据成员将直接经由该字符串赋值，不会出现任何临时对象。但重载版本将为setName的参数创建一个临时的std::string对象（因为常量字符串并非string类型），然后将此临时std::string移动到w的数据成员中。因此，对setName的调用将需要执行一个std::string构造函数（用于创建临时对象），一个std::string移动赋值运算符（将newName移动到w.name），以及一个std::string析构函数（用于析构临时对象），这一系列操作必然花费不菲。</p>
<hr>
<h2 id="扩展性分析"><a href="#扩展性分析" class="headerlink" title="扩展性分析"></a>扩展性分析</h2><p>&nbsp;<br>setName只存在一个参数，重载版本需要给出两个版本，显然函数参数一旦增长，重载函数的数量将以指数级别增长，此外，某些函数的参数甚至是无限数量，其中的典型案例即为std::make_shared与std::make_unique,它们的声明分别是：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>&lt;T&gt; <span class="title">make_shared</span>(<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span>(<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><br>此时必须使用universal reference，而forward是它的最佳拍档。</p>
<hr>
<h1 id="move与forward的使用时机"><a href="#move与forward的使用时机" class="headerlink" title="move与forward的使用时机"></a>move与forward的使用时机</h1><p>&nbsp;<br>在某些情况下，我们可能会在单个函数中多次使用绑定到右值引用或universal reference的对象，在此情况下，我们需要保证在结束使用前该对象不会被移动。此时，我们只能在最后一次使用中使用move（右值引用）或forward(universal reference):<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSignText</span><span class="params">(T&amp;&amp; <span class="built_in">text</span>)</span></span>&#123; <span class="comment">// univ reference</span></span><br><span class="line">    sign.setText(<span class="built_in">text</span>); <span class="comment">// use text, but don't modify it</span></span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();<span class="comment">// get current time</span></span><br><span class="line">    signHistory.add(now,<span class="built_in">std</span>::forward&lt;T&gt;(<span class="built_in">text</span>)); <span class="comment">// conditionally cast text to rvalue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>move使用与之同理，只是有时你需要使用move_if_noexcept，具体原因可见Item14。</p>
<hr>
<h1 id="move、forward与函数返回值"><a href="#move、forward与函数返回值" class="headerlink" title="move、forward与函数返回值"></a>move、forward与函数返回值</h1><p>&nbsp;<br>若一个函数需要返回一个绑定至右值引用或universal reference的对象，则在返回语句中需要使用move或forward。</p>
<h2 id="move"><a href="#move" class="headerlink" title="move"></a>move</h2><p>试以矩阵加法举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="keyword">const</span> Matrix&amp; rhs)&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">move</span>(lhs); <span class="comment">// move lhs into return value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果我们忽视对move的调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="keyword">const</span> Matrix&amp; rhs)&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> lhs; <span class="comment">// copy lhs into return value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于lhs是一个左值，因此编译器只能执行copy操作，这对性能影响较大。就算该类型不支持移动构造，最坏结果也无非就是执行一次copy而已，不会引发任何错误。</p>
<h2 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h2><p>forward类似于move。考虑现有一个函数模板reduceAndCopy，它接受一个可能未减少的Fraction对象，函数负责减少它，然后返回减少值的副本（看起来像是后缀自减）。如果原始对象是右值，则应将其值移入返回值（从而避免制作副本的费用），如果原始值为左值，则必须创建副本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Fraction <span class="title">reduceAndCopy</span><span class="params">(T&amp;&amp; frac)</span></span>&#123;</span><br><span class="line">    frac.reduce();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;T&gt;(frac); <span class="comment">// move rvalue into return value, copy lvalue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不采用forward，则将无条件执行复制操作。</p>
<h2 id="不适用场景（返回局部变量）"><a href="#不适用场景（返回局部变量）" class="headerlink" title="不适用场景（返回局部变量）"></a>不适用场景（返回局部变量）</h2><p>有些开发者可能会刻舟求剑，将上述使用范例推广至不适用之处，他们可能会作出如下判断：“如果利用std::move可以直接移动构建返回值，那返回局部变量时可能亦可使用”，于是他们写出这样的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Widget w; <span class="comment">// local variable</span></span><br><span class="line">    … <span class="comment">// configure w</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">move</span>(w); <span class="comment">// move w into return value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种行为并不可取，应当采用RVO加以改进（见More Effective C++ Item20）。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>将move应用于右值引用，forward应用于universal refernce。</strong></li>
<li><strong>当需要返回非局部对象时，采用建议1。</strong></li>
<li><strong>返回局部对象时使用RVO。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>41.多重继承</title>
    <url>/2018/04/20/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>一旦谈及multiple inheritance(MI)，C++程序员总会分为两个阵营：</p>
<ol>
<li>single inheritance(SI)不错，MI更好。</li>
<li>SI不错，MI垃圾</li>
</ol>
<hr>
<h1 id="多重继承带来的歧义"><a href="#多重继承带来的歧义" class="headerlink" title="多重继承带来的歧义"></a>多重继承带来的歧义</h1><p>&nbsp;<br>抛开争论，首先我们必须要认清：只要我们在设计中使用了MI，程度便有可能从一个以上的classes<strong>继承相同名称</strong>，这会引发一些歧义，举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BorrowableItem</span>&#123;</span><span class="comment">//允许借阅物</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;<span class="comment">//离开时检查</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectronicGadget</span>&#123;</span><span class="comment">//电子设备</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//执行自我检测</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3player</span>:</span><span class="comment">//Mp3是借阅物也是电子设备</span></span><br><span class="line">    <span class="keyword">public</span> BorrowableItem,</span><br><span class="line">    <span class="keyword">public</span> ElectronicGadget</span><br><span class="line">&#123;...&#125;;</span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.checkOut();<span class="comment">//歧义产生,改掉用哪个？</span></span><br></pre></td></tr></table></figure><br>为了避免这些歧义，我们应该使用作用域运算符::来指明具体调用哪个版本。例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp.BorrowableItem::checkout();</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="“钻石型”多重继承"><a href="#“钻石型”多重继承" class="headerlink" title="“钻石型”多重继承"></a>“钻石型”多重继承</h1><p>&nbsp;<br>多重继承是指继承一个以上的base classes，但这些base class一般不作为另一些class 的derived class，因为那会导致”钻石型”多重继承。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p><img src="http://static.zybuluo.com/zsmj2017/pzhukd2yiq6wmp7vii4uf3ul/image_1cbgc9k62aed55ka6o18k2qon9.png" alt="image_1cbgc9k62aed55ka6o18k2qon9.png-11.6kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputFile</span>:</span><span class="keyword">public</span> <span class="built_in">File</span> &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputFile</span>:</span><span class="keyword">public</span> <span class="built_in">File</span> &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOFile</span>:</span></span><br><span class="line">    <span class="keyword">public</span> InputFile,</span><br><span class="line">    <span class="keyword">public</span> OutputFile</span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure><br>具体到这个实例，有问题如下：假定File内有一个名为FileName的成员变量，那么IOFile对象内应该有几个此成员呢？它可能会忠实地完全复制从InputFile和OutputFile继承而来的所有成员，从而导致存在两个FileName，也可以只继承其中的一个。</p>
<h2 id="virtual-base-class-与-virtual继承"><a href="#virtual-base-class-与-virtual继承" class="headerlink" title="virtual base class 与 virtual继承"></a>virtual base class 与 virtual继承</h2><p>C++对上述的两种方案都支持，但默认执行完全复制。如果这并非你所愿，那你必须<strong>令带有重复数据的class（也就是File）成为一个virtual base class，同时，你还必须令所有直接继承它（file）的class采用virtual继承</strong>。实例如下：<br><img src="http://static.zybuluo.com/zsmj2017/mlo0kukn5qzc4lm0guxfxtll/image_1cbgcplh31qd81lsv19o8c62bagm.png" alt="image_1cbgcplh31qd81lsv19o8c62bagm.png-11.4kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputFile</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputFile</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOFile</span>:</span></span><br><span class="line">    <span class="keyword">public</span> InputFile,</span><br><span class="line">    <span class="keyword">public</span> OutputFile</span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure><br>STL中就有一个结构类似的多重继承体系，只不过其classes是class templates，名称分别是basic_ios,basic_istream,basic_ostream,basic_iostream。</p>
<h2 id="virtual继承的成本（详见More-Effective-C-24"><a href="#virtual继承的成本（详见More-Effective-C-24" class="headerlink" title="virtual继承的成本（详见More Effective C++ 24)"></a>virtual继承的成本（详见More Effective C++ 24)</h2><p>从行为正确的观点看，public继承应该总是virtual。但是实际上，为了避免继承得来的变量重复，编译器不得不使用一些其它操作（因此付出了成本），使用virtual继承的class所产生的对象一般比用non-virtual继承产生的对象要大，而且访问速度也慢。</p>
<p>virtual继承的成本还体现在其他方面，比如说virtual base classes初始化规则比起non-virtual bases的情况远为复杂而去不直观。<strong>virtual base class的初始化责任是由继承体系中的最底层class负责</strong>，这意味着：</p>
<ol>
<li>classes若派生自virtual base class而需要初始化，则其必须认知virtual base—无论他们离的多远。</li>
<li>当一个新的dc加入继承体系，它必须承担起其virtual base的初始化责任。</li>
</ol>
<p>对于virtual base(或者说virtual继承），我们应该保证非必要不使用。如果必须使用，则尽力避免在virtual base中放置任何数据，如此则不必担心初始化等等问题。（这不得不让人想起了Java的Interface，它在相当多的情况下兼容于C++中的virtual base class）。</p>
<hr>
<h1 id="Interface-class（详见Effective-C-32）"><a href="#Interface-class（详见Effective-C-32）" class="headerlink" title="Interface class（详见Effective C++ 32）"></a>Interface class（详见Effective C++ 32）</h1><h2 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h2><p>（课本中接着描述了Person interface与具体实现的class)<br>如果我们需要用某个类的现有接口，又希望使用另一个类现有的具体实现，无疑，我们可以public from interface &amp;&amp; private from implement。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;</p>
<ol>
<li>多重继承比单一继承复杂，并且有可能导致歧义性，以及对virtual继承的需要。</li>
<li>virtual继承会增加大小，速度，初始化各方面的成本，但如果virtual base不带有任何数据，其使用颇有价值。</li>
<li>多重继承确有正当用途，比如public继承interface且private继承implement class.</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>38.对线程句柄析构行为保持关注</title>
    <url>/2018/07/18/%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%8F%A5%E6%9F%84%E6%9E%90%E6%9E%84%E8%A1%8C%E4%B8%BA%E4%BF%9D%E6%8C%81%E5%85%B3%E6%B3%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在上一节中，我们已经解释过一个状态为joinable的<code>std::thread</code>对象对应着一个系统底层线程。基于non-defered task的<code>std::future</code>对象与之类似，也对应着一个系统底层线程，因此，我们可以认为它们都是系统线程的句柄。</p>
<p>同样，我们在上一节中已经解释过析构状态为joinable的thread会导致terminate，但future并非如此，它的析构行为有时看起来像隐式join，有时看起来像隐式detach，又有时并不与它们类似。此外，对future的析构永远不会导致terminate。</p>
<hr>
<h1 id="共享状态"><a href="#共享状态" class="headerlink" title="共享状态"></a>共享状态</h1><p>&nbsp;<br>为了探究原理，我们首先对std::future进行一次细致地观察。future可被视为通信信道的一端，callee通过该信道将结果发送给caller。callee（一般其处于异步运行状态）将其计算结果写入通信通道（一般通过std::promise对象），caller使用future来读取该结果。总之，它们的行为大致可以用下图表述，其中虚线箭头表征从callee到caller的信息流：<br><img src="http://static.zybuluo.com/zsmj2017/50v76534bwh070sm3bbcu1ab/image_1cim5vb5uis3q851maq7cfjtc9.png" alt="image_1cim5vb5uis3q851maq7cfjtc9.png-18.2kB"><br>你或许会好奇结果保存在何处。首先肯定不能放在std::promise对象之中，因为结果可能是在调用future对象获取时早已保存起来了，由于callee运行结束时会将std::promise析构，因此promise并不能承担保存结果的重任。</p>
<p>那么能否将结果放在std::future对象之中呢?这同样不行，因为std::future可以用来创建std::shared_future，因此需要将结果保存在每一个future对象中，这一行为将导致该结果被多次拷贝和复制，或许可以使用引用计数的方式来记录当前有多少个future对象关联到这个结果中，但无论何种方式都会造成一定的开销，算不上最优解。</p>
<p>因为与callee关联的对象和与caller关联的对象都不是存储结果的合适位置，所以结果被存储于这二者之外，此位置称为共享状态(shared state)。共享状态通常由heap-based对象表示，但其类型，接口和实现均没有标准形式，全凭标准库作者喜好决定。<br>我们可以设想callee，caller与共享状态之间的关系如下所示，其中虚线箭头再次表示信息流：<br><img src="http://static.zybuluo.com/zsmj2017/cx5p35v5opi66fre4ubt7zmn/image_1cim69d6g1e0tk7aed01nrg1u37m.png" alt="image_1cim69d6g1e0tk7aed01nrg1u37m.png-28kB"></p>
<hr>
<h1 id="共享状态与future析构函数"><a href="#共享状态与future析构函数" class="headerlink" title="共享状态与future析构函数"></a>共享状态与future析构函数</h1><p>&nbsp;<br>共享状态的存在十分重要，因为future析构函数的行为由与future相关联的共享状态息息相关，具体来说：</p>
<ol>
<li><strong>最后一个关联到由std::async启动的non-defered task的共享状态的future，其析构函数将一直阻塞至该task完成为止。</strong><br>从本质上来看，这种future的析构函数在运行异步执行task的线程上执行隐式join。</li>
<li><strong>不满足条件1的future执行正常析构</strong><br>对于异步运行的task，这相当于在底层线程上执行隐式detach。对于deferred策略运行的task来说，这相当于这个task将不会运行。</li>
</ol>
<p>这两条规则听起来很复杂，但实际上很简单，我们真正需要处理的只是一个简单的“正常”行为和一个例外而已。所谓的正常行为就是future的析构函数直接析构future对象，它既不执行join，也不执行deatch，也不做其他乱七八糟的事情，它唯一做的事情就是析构了future的data member（实际上它还减少了共享状态的引用计数）。</p>
<p>例外指的是同时满足下述3个条件的future：</p>
<ol>
<li><strong>该std::future通过std::async创建，并且指向了一个共享状态。</strong></li>
<li><strong>该task的启动策略为std::launch::async。</strong></li>
<li><strong>该future是最后一个指向该共享状态的future。</strong></li>
</ol>
<p>只有满足上述三个条件的情况下future的析构函数才会被阻塞至task完成，也就是相当于隐式join。</p>
<p>std::future的这种特殊的析构行为让我们的程序行为变得不可预测，特别是我们没有办法知道哪个 future会隐式join，哪些又将detach。尽管如此，但是我们知道，凡是从std::async创建的std::future都有可能隐式join，而其他方式创建的std::future对象则不是，比如通过std::packaged_task创建的std::future，其析构就不会隐式join。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>通常情况下，future的析构函数将破坏其data member。</strong></li>
<li><strong>在特殊情况下future的析构函数类似于隐式join。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>7.在析构前记得delete容器内通过new得到的指针</title>
    <url>/2018/04/07/%E5%9C%A8%E6%9E%90%E6%9E%84%E5%89%8D%E8%AE%B0%E5%BE%97delete%E5%AE%B9%E5%99%A8%E5%86%85%E9%80%9A%E8%BF%87new%E5%BE%97%E5%88%B0%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>由于容器在析构时会自发地销毁所有容器内部的元素，因此有人会忽视容器内部元素的清除工作。大部分时候确实不用手动地清除，<strong>仅有一个例外：容器内存放的是通过new得到的指针</strong>。容器析构时指针当然被销毁了，但容器绝不会自动地调用delete释放每一个指针指向的对象，而且我们再也找不到这些对象了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Widget*&gt; vwp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOME_MAGIC_NUMBER; ++i)</span><br><span class="line">        vwp.push_back(<span class="keyword">new</span> Widget);</span><br><span class="line">    <span class="comment">//vwp析构后资源也泄露了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>delete这些指针并不麻烦，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Widget*&gt; vwp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vwp.<span class="built_in">begin</span>();i != vwp.<span class="built_in">end</span>();++i) </span><br><span class="line">     <span class="keyword">delete</span> *i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码看起来似乎很美好，但是仍然存在两点不存：</p>
<ol>
<li>做了for_each做的事，但是不如for_each直观</li>
<li>不具备异常安全，如果在向vwp填充指针或者从中删除指针时有异常抛出，同样会内存泄漏。</li>
</ol>
<p>首先解决第一个问题，将上述代码改写为for_each:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(vwp.<span class="built_in">begin</span>(),vwp.<span class="built_in">end</span>(),[](Widget* pw)&#123;<span class="keyword">delete</span> pw;&#125;);</span><br></pre></td></tr></table></figure><br>(原书中描述了大量关于函数对象及其使用原理的说明，在C++11引入lambda之后，笔者跳过了这些知识）</p>
<p>使用shared_ptr可以避免异常安全的问题，我们通过将原容器替换为包含智能指针的容器之后，一切都变得美好了起来。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>1.导读</title>
    <url>/2018/04/05/%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>除非你希望构造函数发生隐式转换，否则请将其声明为explicit。</li>
<li>针对拷贝构造函数和拷贝运算符=，必须注意=可以调用构造函数。<br>因此，当我们新建一个对象时必然是调用了构造函数，而不是赋值操作。<br>同理，当有对象存在时一定是赋值，而绝非拷贝。</li>
<li>针对用户自定义的类型，通常不使用pass-by-value，而是使用pass-by-reference-to-const。</li>
<li>ctor与dtor是构造函数与析构函数的缩写。</li>
<li>rhs：right-hand side lhs亦是如此</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>39.对于一次性事件通信考虑采用void future</title>
    <url>/2018/07/18/%E5%AF%B9%E4%BA%8E%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1%E8%80%83%E8%99%91%E9%87%87%E7%94%A8void%20future/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>有时我们需要一个task告诉第二个异步运行的task当前已发生特定事件，因为第二个task可能在该事件尚不明确前无法继续。这些特定事件可能是某个数据结构已被初始化，又或者是某项计算已被完成，又或者是某个关键传感器值已被采集得到，那么我们应当采取何种方式以完成这种线程间通信？</p>
<hr>
<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>&nbsp;<br>针对上个问题，使用条件变量（condvar）是一种非常显然的方案。我们将task分为两种，检测条件是否符合的detecting task与针对条件作出反应的reacting task，那么实现通信只需要通过一种简单的策略：reacting task等待条件变量的传入，而探测线程在事件触发时传递条件变量：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv; <span class="comment">// condvar for event</span></span><br><span class="line"><span class="built_in">std</span>::mutex m; <span class="comment">// mutex for use with cv</span></span><br></pre></td></tr></table></figure><br>detecting task可以写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">… <span class="comment">// detect event</span></span><br><span class="line">cv.notify_one(); <span class="comment">// tell reacting task</span></span><br></pre></td></tr></table></figure><br>如果需要告知多个reacting task，则将notify_one改为notify_all即可。</p>
<p>reacting task的实现较为繁琐一些，因为在调用在condvar上调用wait之前，它必须通过std::unique_lock一个mutex（这种手法在线程库中相当常见，通过std::unique_lock锁定互斥锁的需求只是C++11 API的一部分）。以下将给出概念上的实现方案：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">… <span class="comment">// prepare to react</span></span><br><span class="line">&#123; <span class="comment">// open critical section</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// lock mutex</span></span><br><span class="line">    cv.wait(lk); <span class="comment">// wait for notify; this isn't correct!</span></span><br><span class="line">    … <span class="comment">// react to event(m is locked)</span></span><br><span class="line">&#125; <span class="comment">// close crit. section;</span></span><br><span class="line"><span class="comment">// unlock m via lk's dtor</span></span><br><span class="line">… <span class="comment">// continue reacting(m now unlocked)</span></span><br></pre></td></tr></table></figure><br>上述代码存在一些问题，第一个问题在于我们是否需要使用mutex。mutex用于控制对共享数据的访问，但detecting task与reacting task完全有可能并不需要使用它。举例而言，例如，detecting task可能负责初始化全局数据结构以供reacting task使用。如果detecting task在初始化之后再不访问数据结构，并且reacting task在初始化完成前从不试图访问数据结构，那么我们没有任何理由需要使用mutex。</p>
<p>除了mutex的使用必要性之外，上述程序还存在两个问题：</p>
<ol>
<li><strong>如果detecting task在reacting task wait之前便已通知，那么reacting task将一直悬挂。</strong></li>
<li><strong>wait语句存在虚假唤醒问题</strong><br>绝大多数线程API（并不仅仅只有C++）都存在条件变量尚未通知便已唤醒的情况，这被称为虚假唤醒。为了保证正确性，大多数程序往往在唤醒后第一时间确认条件变量是否通知，因此我们可以用lambda表征检测，然后将其传递给wait：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv.wait(lk,[]&#123; <span class="keyword">return</span> whether the event has occurred; &#125;);</span><br></pre></td></tr></table></figure>
但这要求reacting task能够判定条件是否触发，而我们本来就是因为reacting task无法分辨而加入了条件变量。</li>
</ol>
<hr>
<h1 id="共享布尔量"><a href="#共享布尔量" class="headerlink" title="共享布尔量"></a>共享布尔量</h1><p>&nbsp;<br>对于大多数开发者来说，他们可能会选择加入共享bool量来完成任务。该布尔量被初始化为false，当detecting task明确事件触发后将其置为true：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">td::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">// shared flag; see Item 40 for std::atomic</span></span><br><span class="line">… <span class="comment">// detect event</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">// tell reacting task</span></span><br></pre></td></tr></table></figure><br>如此一来reacting task只需要轮询flag即可明确事件是否发生：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">… <span class="comment">// prepare to react</span></span><br><span class="line"><span class="keyword">while</span> (!flag); <span class="comment">// wait for event</span></span><br><span class="line">… <span class="comment">// react to event</span></span><br></pre></td></tr></table></figure><br>这种方法没有任何基于condvar设计的缺点，但它所花费的成本太高。在task轮询的过程中task处于运行状态（尽管大多数时刻都是阻塞状态），因此它需要占用一个硬件线程，并且因此将产生context switch成本。condvar不存在这种缺陷，因为线程处于真正的阻塞状态。</p>
<hr>
<h1 id="condvar与bool的结合"><a href="#condvar与bool的结合" class="headerlink" title="condvar与bool的结合"></a>condvar与bool的结合</h1><p>&nbsp;<br>在此设计中，flag指示事件是否发生，并且通过mutex完成对flag的访问，因此flag不再需要std::atomic。此时的detecting task如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv; <span class="comment">// as before</span></span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">// not std::atomic</span></span><br><span class="line">… <span class="comment">// detect event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>; <span class="comment">// lock m via g's ctor</span></span><br><span class="line">    flag = <span class="literal">true</span>; <span class="comment">// tell reacting task (part 1)</span></span><br><span class="line">&#125; <span class="comment">// unlock m via g's dtor</span></span><br><span class="line">cv.notify_one(); <span class="comment">// tell reacting task(part 2)</span></span><br></pre></td></tr></table></figure><br>reacting task实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">… <span class="comment">// prepare to react</span></span><br><span class="line">&#123; <span class="comment">// as before</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// as before</span></span><br><span class="line">    cv.wait(lk, [] &#123; <span class="keyword">return</span> flag; &#125;); <span class="comment">// use lambda to avoid spurious wakeups</span></span><br><span class="line">    … <span class="comment">// react to event</span></span><br><span class="line">    <span class="comment">// (m is locked)</span></span><br><span class="line">&#125;</span><br><span class="line">… <span class="comment">// continue reacting(m now unlocked)</span></span><br></pre></td></tr></table></figure><br>这一设计完全规避了之前提及的所有问题，但总的看来似乎仍然存在某些多余的开销，代码不够明晰流畅。</p>
<hr>
<h1 id="void-future"><a href="#void-future" class="headerlink" title="void future"></a>void future</h1><p>&nbsp;<br>另一种方法是通过让reacting task等待detecting task设置的future来规避condvar、mutex、flag的使用。 Item38指出，发送端是std::promise且接收端是future的通信信道完全可以用于双端通信。这项设计相当简单，detecting task持有std::promise对象（即通信信道的写入端），并且reacting task持有相应的future。当特定事件触发时，detecting task设定std::promise（即写入通信信道）。与此同时，reacting task在其future上执行wait。wait将阻塞reacting task直至std::promise已完成设定。</p>
<p>std::promise和future（包括std::future与std::shared_future）都是需要类型参数的模板，该类型参数指明需要通过通信信道发送的数据类型。然而在本次实例中，并没有任何需要传达的数据，reacting task唯一感兴趣的是其future是否已被设。因此本次数据类型为void，如此一来，即使reacting task不会从detecting task接收到任何数据，通信信道亦允许reacting task通过future判断事件是否触发。</p>
<p>综上，本设计有promise定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; p; <span class="comment">// promise for communications channel</span></span><br></pre></td></tr></table></figure><br>detecting task可写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">… <span class="comment">// detect event</span></span><br><span class="line">p.set_value(); <span class="comment">// tell reacting task</span></span><br></pre></td></tr></table></figure><br>reacting task可写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">… <span class="comment">// prepare to react</span></span><br><span class="line">p.get_future().wait(); <span class="comment">// wait on future corresponding to p</span></span><br><span class="line">… <span class="comment">// react to event</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="void-future的不足"><a href="#void-future的不足" class="headerlink" title="void future的不足"></a>void future的不足</h1><p>&nbsp;<br>首先，Item38中我们便已明确，std::promise与future之间存在着共享状态，而共享状态往往动态分配，动态分配带来了堆分配与释放的开销。</p>
<p>此外，std::promise和future之间的通信通道是一次性机制：它不能重复使用，这与基于condvar和flag的设计有着明显区别，此二者均可用于多次通信。</p>
<hr>
<h1 id="void-future与线程暂停技术"><a href="#void-future与线程暂停技术" class="headerlink" title="void future与线程暂停技术"></a>void future与线程暂停技术</h1><p>&nbsp;<br>假设你需要暂停一个线程，使用void future的设计是一个合理的选择。以下是该技术的核心：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">react</span><span class="params">()</span></span>; <span class="comment">// func for reacting task</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detect</span><span class="params">()</span></span>&#123; <span class="comment">// func for detecting task</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">([]&#123;p.get_future().wait();react();&#125;)</span></span>;<span class="comment">// suspend t until future is set</span></span><br><span class="line">    … <span class="comment">// here, t is suspended prior to call to react</span></span><br><span class="line">    p.set_value(); <span class="comment">// unsuspend t (and thus call react)</span></span><br><span class="line">    … <span class="comment">// do additional work</span></span><br><span class="line">    t.join(); <span class="comment">// make t unjoinable (see Item 37)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了保证thread在所有路径均为unjoinable，上述程序可被改写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">tr</span><span class="params">(<span class="built_in">std</span>::thread([]&#123;p.get_future().wait();react();&#125;),ThreadRAII::DtorAction::join)</span></span>;</span><br><span class="line">    … <span class="comment">// thread inside tr is suspended here</span></span><br><span class="line">    p.set_value(); <span class="comment">// unsuspend thread inside tr</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码看似完美，但实际上存在问题。若在第一个”…”处抛出异常，则p将永远无法完成设定，因此tr将永远处于无法完成的状态。（作者将如何解决作为习题留给读者，我第一眼想到的方案是try catch，在catch语句中析构tr）。</p>
<h2 id="多个reacting-task的暂停"><a href="#多个reacting-task的暂停" class="headerlink" title="多个reacting task的暂停"></a>多个reacting task的暂停</h2><p>其关键在于使用std::shared_future以代替std::future。std::future的share成员函数将其共享状态的所有权转移到share生成的std::shared_future对象,本实现唯一的微妙之处即为每个reacting thread都需要自己的std::shared_future副本来引用共享状态，因此从share获取的std::shared_future由运行在reacting thread上的lambda按值捕获：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; p; <span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detect</span><span class="params">()</span></span>&#123; <span class="comment">// now for multiple reacting tasks</span></span><br><span class="line">    <span class="keyword">auto</span> sf = p.get_future().share(); <span class="comment">// sf's type is std::shared_future&lt;void&gt;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; vt; <span class="comment">// container for reacting threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadsToRun; ++i) &#123;</span><br><span class="line">        vt.emplace_back([sf]&#123; sf.wait();react(); &#125;); <span class="comment">// capture by-value </span></span><br><span class="line">    &#125;</span><br><span class="line">    … <span class="comment">// detect hangs if this "…" code throws!</span></span><br><span class="line">    p.set_value(); <span class="comment">// unsuspend all threads</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123; <span class="comment">// make all threads unjoinable</span></span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>23.将成员变量声明为private</title>
    <url>/2018/04/13/%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate/</url>
    <content><![CDATA[<h1 id="为什么不使用public成员变量"><a href="#为什么不使用public成员变量" class="headerlink" title="为什么不使用public成员变量"></a>为什么不使用public成员变量</h1><ol>
<li>语义一致性<br>如果成员变量都不是public，那我们必然是通过成员函数来访问对象，所以再也不用担心什么时候用接口，什么时候用属性了。<br>另外，使用函数可以对变量进行更加精准的控制，你完全可以实现只读，读写，或者不予读写，甚至只写操作。举例而言：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessLevels</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getReadOnly</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> readOnly;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;readWrite=value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getReadWrite</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> readWrite;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteOnly</span><span class="params">(writeOnly=value;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">private</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> noAccess;<span class="comment">//禁止访问</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> readOnly;<span class="comment">//只读</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> readWrite;<span class="comment">//读写</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> writeOnly;<span class="comment">//只写</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li>封装性<br>将成员变量隐藏在函数接口之后，可以为“所有实现的可能”提供弹性，我们可以在不改变接口的同时更改实现，从而保证了用户只需要在重新编译后即可享有与原先不同的体验。（Effective C++ 31 甚至提出了编译分离）<br>封装的重要程度可能比你想的还要更加高一些，如果你对客户隐藏了成员变量，那么至少可以保证class的约束条件总能获得维护，因为只有成员函数可以影响它们，并且开发者保留了日后变更实现的权利。如果不进行封装，那么客户码中将充斥着大量的成员变量，这也意味着我们无法随意地更改原有程序，因为每一次改动都可能造成客户端失效。public意味着不封装，不封装意味着不可改变，因为你一变用户也要跟着变。</li>
</ol>
<hr>
<h1 id="protected的封装性"><a href="#protected的封装性" class="headerlink" title="protected的封装性"></a>protected的封装性</h1><p>&lt;/br&gt;<br>可能你会认为protected的封装性要高于public，但事实并非如此。因为所有使用了该变量的derived classes都遭到了破坏。一旦你将某个成员变量设为public或protected，并且随后交付客户使用，那你在今后就很难改变该变量所涉及的一切，除非你愿意付出重写、重新测试、重新编文档、重新编译的代价。<br>从封装的角度而言，访问权限只有两种：private（提供封装）和其他（不提供封装）。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>将成员变量声明为privte。这可赋予客户语义一致性，访问权限控制，并且令class作者拥有充分的实现弹性。</li>
<li>protected并不比public更具封装性</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>45.将参数无关的代码抽离template</title>
    <url>/2018/04/21/%E5%B0%86%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplate/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>Templates是避免代码重复与节约时间的最优解。但有时，template可能会造成代码膨胀：二进制码带着大量重复（或几乎重复）的代码或者数据。其源码可能看起来优雅整洁，但实际上生成的object code完全不是一回事，我们需要对此进行优化。</p>
<hr>
<h1 id="共性与变性分析"><a href="#共性与变性分析" class="headerlink" title="共性与变性分析"></a>共性与变性分析</h1><p>&nbsp;<br>当我们在撰写函数时，往往倾向于提取出函数的共同部分，组成新的函数，然后令原来的函数调用该新函数。在OOP中，如果多个class存在相同部分，则会抽离classes的共有部分组成新的class，然后采用继承或者复合获取共性，而原本classes的互异部分则保持不变。<br>在编写templates也是同样的方式避免重复，但在细节处略有不同。在non-template程序中我们可以明确地看到重复的函数或重复的class成员，但在template编码中，源码只有一份，必须自己去感知当template具现化时可能发生的重复。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>为一个方阵编写template，其性质之一是支持求逆：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span>;<span class="comment">//求逆矩阵</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>假设现有操作如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SquareMatrix&lt;<span class="keyword">double</span>,<span class="number">5</span>&gt; sm1;</span><br><span class="line">sm1.invert();</span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>,<span class="number">10</span>&gt; sm2;</span><br><span class="line">sm2.invert();</span><br></pre></td></tr></table></figure><br>以上操作直接导致具现化了两个invert，虽然它们并非完全相同，但是相当类似，唯一的区别就是一个作用于5*5矩阵一个作用于10*10矩阵。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="第一版修改方案"><a href="#第一版修改方案" class="headerlink" title="第一版修改方案"></a>第一版修改方案</h3><p>当我们看到两个除了参数之外完全相同的函数，本能反应应当是建立一个带数值参数的可调用函数，而不是在class中重复代码。基于这种理念，第一版修改方案如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">size_t</span> matrixSize)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span>:</span><span class="keyword">private</span> SquareMatrixBase&#123;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="keyword">using</span> base::invert;<span class="comment">//避免遮蔽名称</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>-&gt;invert(n);&#125;<span class="comment">//inline调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如你所见，所有矩阵元素类型相同的class共有一个bc，并且共享这唯一一个class内的invert.在dc中调用invert的额外成本应该为0，因为这是一个inline调用，this-&gt;的使用详见前一节内容（Effective C++ 44）。private继承说明了bc只是为了帮助dc实现，他们并不是is-a的关系。</p>
<hr>
<h3 id="第二版修改方案"><a href="#第二版修改方案" class="headerlink" title="第二版修改方案"></a>第二版修改方案</h3><p>现在的问题是：base内的invert如何知道操作什么数据？虽然它知道尺寸，但他如何知道某个特定矩阵的数据存在于内存的何处？这显然只有dc知道。dc如何联络bc做逆运算呢？​<br>一个可能的做法是向invert函数添加另一个参数，一个指向矩阵数据的指针。根据经验，invert应该不是唯一一个需要获取矩阵数据的函数，所以我们令base class贮存一个指针，指向矩阵数值指向的内存，既然它持有了数据，那必然也需要了解矩阵的大小。具体实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    SquareMatrixBase(<span class="keyword">size_t</span> n,T *pMem):<span class="built_in">size</span>(n),pData(pMem) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataPtr</span><span class="params">(T* ptr)</span> </span>&#123;pData = ptr;&#125;<span class="comment">//更改数据域</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">    T* pData;<span class="comment">//矩阵具体内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种写法允许derived classes自主决定内存分配方式。</p>
<h4 id="dc的内存分配方式"><a href="#dc的内存分配方式" class="headerlink" title="dc的内存分配方式"></a>dc的内存分配方式</h4><ol>
<li>矩阵存储于对象内部<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span>:</span><span class="keyword">private</span> SquareMatrixBase&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SquareMatrix():SquareMatrixBase&lt;T&gt;(n,data) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n*n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这一类对象无需动态分配内存，但是对象自身可能非常大。</li>
<li>把对象数据放入heap<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span>:</span><span class="keyword">private</span> SquareMatrixBase&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SquareMatrix():SquareMatrixBase&lt;T&gt;(n,<span class="number">0</span>),padta(<span class="keyword">new</span> T[n*n])</span><br><span class="line">    &#123;<span class="keyword">this</span>-&gt;setDataPtr(pData.<span class="built_in">get</span>());&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;T&gt; pData;<span class="comment">//RAII</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>template生成多个class与多个函数，所以任何template代码都不应该与某个造成膨胀的template参数相互依存</li>
<li>因为non-type template parameters造成的代码膨胀往往可以消除，做法是以函数参数或者class成员变量替换template参数。</li>
<li>因type parameters造成的代码膨胀往往可以降低，做法是让带有相同二进制表述的具现类型共享实现码。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板与泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>33.将非尾端类设计为抽象类</title>
    <url>/2018/04/29/%E5%B0%86%E9%9D%9E%E5%B0%BE%E7%AB%AF%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设我们正在抽象动物，其中晰蜴和小鸡需要特别处理,当前继承体系如下：<img src="http://static.zybuluo.com/zsmj2017/ts93pmj4ugcn49y1x0pvi84z/image_1cc8lhmb189u17ud1g9qlaf1fc89.png" alt="image_1cc8lhmb189u17ud1g9qlaf1fc89.png-40.4kB"><br>动物类处理所有动物共有的特性，晰蜴类和小鸡类特别化动物类以适用这两种动物的特有行为。它们的简化版定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Chicken&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>考虑如下表达式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Lizard liz1;</span><br><span class="line">Lizard liz2;</span><br><span class="line">Animal *pAnimal1 = &amp;liz1;</span><br><span class="line">Animal *pAnimal2 = &amp;liz2;</span><br><span class="line">...</span><br><span class="line">*pAnimal1 = *pAnimal2;</span><br></pre></td></tr></table></figure><br>显然，最后的赋值操作符调用的是Animal的，所以直接导致了liz1只有animal部分被修改，也就是部分赋值。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>一个解决方法是将赋值运算符声明为虚函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种写法直接导致了operator=可以接受任意类型的Animal对象，也就是说，下面的代码是合法的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Lizard liz;</span><br><span class="line">Chicken chick;</span><br><span class="line">Animal *pAnimal1 = &amp;liz;</span><br><span class="line">Animal *pAnimal2 = &amp;chick;</span><br><span class="line">*pAnimal1 = *pAnimal2;</span><br></pre></td></tr></table></figure><br>显然这是一个混合类型赋值。在未引入虚函数之前，混合类型赋值会被C++的强类型原则判定非法，但引入虚函数之后它们变为了合法。</p>
<hr>
<h3 id="动态转换与同类型赋值"><a href="#动态转换与同类型赋值" class="headerlink" title="动态转换与同类型赋值"></a>动态转换与同类型赋值</h3><p>我们真正想要通过指针来完成同类型赋值，而非通过指针完成混合类型赋值，于是我们可以使用动态转换完成这一操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Lizard&amp; Lizard::<span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs)&#123;</span><br><span class="line">    <span class="comment">//make sure rhs is really a lizard</span></span><br><span class="line">    <span class="keyword">const</span> Lizard&amp; rhs_liz = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Lizard&amp;&gt;(rhs);</span><br><span class="line">    proceed with a normal assignment of rhs_liz to *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述代码中，如果可以转换则顺利执行operator=，否则抛出bad_cast的异常。</p>
<hr>
<h3 id="重载赋值"><a href="#重载赋值" class="headerlink" title="重载赋值"></a>重载赋值</h3><p>其实我们并不需要非得在运行期使用虚函数与dynamic_cast，下面的代码规避了在常规情况下它们的成本，而仅仅只需要增加了一个普通形式的赋值操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>事实上，有了第二个operator=后，第一个虚函数版operator=亦得到了简化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Lizard&amp; Lizard::<span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span>=(dynamic&lt;<span class="keyword">const</span> Lizard&amp;&gt;(rhs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在这个函数试图将rhs转换为一个Lizard。如果转换成功，通常的赋值操作被调用；否则，一个bad_cast异常被抛出。  </p>
<hr>
<h2 id="私有化operator"><a href="#私有化operator" class="headerlink" title="私有化operator="></a>私有化operator=</h2><p>在看到了将operator=设置为虚函数之后的弊端后，我们应该想到重新整理代码以确保用户无法写出有问题的赋值语句，最好能够在编译期就会被拒绝。比较容易的方法是在Animal类中把operator=设为private：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Chicken&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>但需要注意的是Animal本身是一个具象类，也就是说这样一来Animal对象就无法执行opertaor=操作，另外，Lizard与Chicken的赋值也不可能正确完成，因为派生类的赋值操作函数需要调用基类的赋值操作函数。第二个问题可以通过将Animal中的operator=设为protected实现，但“不允许混合类型赋值”的任务并未完成，因为Lizard与Chicken仍然可以通过Animal的指针来互相赋值。</p>
<hr>
<h2 id="修改继承体系"><a href="#修改继承体系" class="headerlink" title="修改继承体系"></a>修改继承体系</h2><p>最简单的方法就是修改继承体系。由于我们之前认定Animal必须作为一个实体类存在且有其意义，因此我们创建一个新类 AbstractAnimal，来包含 Animal、 Lizard、Chikcen的共有属性，并把它设为抽象类， 各具象类均由该抽象类派生而出，修改后的继承体系如下所示：<img src="http://static.zybuluo.com/zsmj2017/ftaqwnn4yqyivbvangkycc69/image_1cc8mt77im8l89b6ns12b710grm.png" alt="image_1cc8mt77im8l89b6ns12b710grm.png-32kB"><br>类的定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractAnimal</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractAnimal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> AbstractAnimal&amp; rhs);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractAnimal() = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span> <span class="keyword">public</span> AbstractAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> AbstractAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span>:</span> <span class="keyword">public</span> AbstractAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Chicken&amp; rhs);...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>至此，一切工作均已完成。同类型间的赋值被允许，部分赋值或不同类型间的赋值被禁止；派生类的赋值操作函数可以调用基类的赋值操作函数。 </p>
<hr>
<h1 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h1><p>&nbsp;<br>当我们找不到一个函数可以作为纯虚函数时，我们定义可以析构函数为纯虚函数，<strong>把析构函数设置为纯虚函数时需要记住必须在类的定义之外实现它。</strong><br>声明一个函数为纯虚函数并不意味着它没有实现，它意味着：</p>
<ol>
<li>当前类是抽象类</li>
<li>任何从此类派生的实体类必须将此函数申明为一个“普通”的虚函数（不能带“= 0”）</li>
</ol>
<p>尽管大部分纯虚函数都没有实现，但纯虚函数是一个特例，他必须被实现。因为它们在派生类析构函数被调用时也将被调用。而且，它们经常执行有用的任务，诸如释放资源或记录消息。  </p>
<hr>
<h1 id="非尾端类与抽象类"><a href="#非尾端类与抽象类" class="headerlink" title="非尾端类与抽象类"></a>非尾端类与抽象类</h1><p>&nbsp;<br>用如AbstractAnimal这样的抽象基类替换如Animal这样的实体基类，其好处并不只有保证operator=的行为正常，它同时减少了你试图对数组使用多态的可能（More Effective C++ 3）。但该技巧最大的好处发生在设计层，因为我们强迫认定所有实体都具备明确行为准则，仅有抽象类承担了抽象的义务。<br>我们并没有方法明确判断未来情况是否需要抽象类，但我们可以肯定，如果存在两个具象类需要以公有继承的方式相互联系，那么通常表示当前情况需要一个抽象类：<br><img src="http://static.zybuluo.com/zsmj2017/d10a84bsw0sea0bsbc07hhtv/image_1cc8ne4hf1aflqd51cd7oq0liv13.png" alt="image_1cc8ne4hf1aflqd51cd7oq0liv13.png-35.7kB"><br>显然，C1和C2具有共性，我们通过建立抽象类将它们的共性抽取出来，使其具备明确的语义。但实际使用中我们可能会发现自己没有权限取更改类库。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>非尾端类应该是抽象类。我们对类库中的程序可能没有办法，但对于能控制的代码，遵守这一约定可以提高程序的可靠性、健壮性、可读性、可扩展性。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>26.尽可能以iterator代替其const或reverse版本</title>
    <url>/2018/04/13/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BB%A5iterator%E4%BB%A3%E6%9B%BF%E5%85%B6const%E6%88%96reverse%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="四种迭代器介绍"><a href="#四种迭代器介绍" class="headerlink" title="四种迭代器介绍"></a>四种迭代器介绍</h1><p>&lt;/br&gt;<br>对于container&lt;T&gt;而言，iterator的作用相当于T*，而const_iterator则类似于const T*.<br>reverse_iterator与const_reverse_iterator同样相当于对应的T*和const T*，和上两种所不同的是，它们的遍历次序是从尾到头。</p>
<h1 id="尽可能不使用其余三种的原因"><a href="#尽可能不使用其余三种的原因" class="headerlink" title="尽可能不使用其余三种的原因"></a>尽可能不使用其余三种的原因</h1><h2 id="成员函数形参要求"><a href="#成员函数形参要求" class="headerlink" title="成员函数形参要求"></a>成员函数形参要求</h2><p>以vector举例，其insert与erase的样式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator rangeBegin, iterator rangeEnd)</span></span>;</span><br></pre></td></tr></table></figure><br>需要注意的是：这两个函数只接受iterator类型的参数，而不是const_iterator、reverse_iterator或const_reverse_iterator。</p>
<h2 id="四种迭代器之间的相互转换"><a href="#四种迭代器之间的相互转换" class="headerlink" title="四种迭代器之间的相互转换"></a>四种迭代器之间的相互转换</h2><p><img src="http://static.zybuluo.com/zsmj2017/951yidto8hhl7iqamz8e5axy/image_1cav8o342170n1eeha5v1rpge239.png" alt="image_1cav8o342170n1eeha5v1rpge239.png-20.5kB"><br>箭头表明了它们可以执行隐式转换，而且reverse可以调用base成员函数转为iterator（详见Effective STL 28）<strong>值得注意的是const迭代器无法转为普通版本</strong>，也就是说，当你需要指出插入或者删除位置的元素时,const迭代器几乎没用。</p>
<h2 id="使用iterator的优越性："><a href="#使用iterator的优越性：" class="headerlink" title="使用iterator的优越性："></a>使用iterator的优越性：</h2><ol>
<li>兼容insert与erase</li>
<li>const版本无法隐式转换普通版本，就算能转效率也不是很高</li>
<li>reverse版本转换来的iterator需要相应的调整</li>
</ol>
<p>何时应该选用reverse呢？比如说你真的需要从后向前遍历的时候。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>40.对并发应用std::atomic,对special memory使用volatile</title>
    <url>/2018/07/19/%E5%AF%B9%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8stdatomic,%E5%AF%B9special%20memory%E4%BD%BF%E7%94%A8volatile/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>一般而言，volatile与C++并发编程毫无关联。在别的语言中（例如Java或C#），volatile对于并发编程存在较大帮助，不过时至今日，C++的某些编译器也将其与某些语义相结合应用至并发编程，因此在并发编程一章讨论volatile也情有可原。</p>
<hr>
<h1 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h1><p>&nbsp;<br>在C++11中提供了一个std::atomic类模版，可以具体实例化出int、bool等类型实例，这个实例保证了操作的原子性，可以被其他线程查看到操作后的结果。它的行为类似于应用了mutex，但是性能损耗更小，因为其内部使用了一种特殊的机器指令实现，该模版类的使用实例如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">ai</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// initialize ai to 0</span></span><br><span class="line">ai = <span class="number">10</span>; <span class="comment">// atomically set ai to 10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ai; <span class="comment">// atomically read ai's value</span></span><br><span class="line">++ai; <span class="comment">// atomically increment ai to 11</span></span><br><span class="line">--ai; <span class="comment">// atomically decrement ai to 10</span></span><br></pre></td></tr></table></figure><br>在这些语句的执行期间，其他线程只能读到ai为0、10、11这几种情况，不存在别的可能（假设当前仅有此线程对ai执行修改）。</p>
<p>上述程序有两点值得注意的地方。首先，在<code>std::cout &lt;&lt; ai</code>语句中，ai的atomic特性仅仅保证ai的读取是原子的，而不能保证整条语句均具备原子性。在读取ai的值和调用<code>operator&lt;&lt;</code>以将其写入<code>cout</code>之间，可能存在另一个线程已改变了ai的值。 总之，我们需要理解仅在读取ai值时具备原子性。</p>
<p>另外，需要关注的是最后两条语句——aide自增与自减操作，这两条操作均为读-改-写（RMW)行为，但它们均具备原子性。这也是std::atomic的优势所在：一旦构造了一个std::atomic对象，其所有成员函数都将具备原子性。</p>
<hr>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>&nbsp;<br>使用volatile的相应代码在多线程环境下几乎什么都不保证：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">vi</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// initialize vi to 0</span></span><br><span class="line">vi = <span class="number">10</span>; <span class="comment">// set vi to 10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vi; <span class="comment">// read vi's value</span></span><br><span class="line">++vi; <span class="comment">// increment vi to 11</span></span><br><span class="line">--vi; <span class="comment">// decrement vi to 10</span></span><br></pre></td></tr></table></figure><br>在此代码执行期间，如果其他线程正在读取vi的值，那么将可能获取到任何内容。上述语句直接导致了未定义行为，因为这些语句在修改vi的同时其他线程可能正在读取或写入vi，vi既不具备原子性也不被mutex所保护，这导致了data race。</p>
<hr>
<h1 id="atomic与volatile比较"><a href="#atomic与volatile比较" class="headerlink" title="atomic与volatile比较"></a>atomic与volatile比较</h1><h2 id="RMW"><a href="#RMW" class="headerlink" title="RMW"></a>RMW</h2><p>假设现有一个计数器，其值会在多线程内自增，我们首先将其初始化为0：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">ac</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// "atomic counter"</span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">vc</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// "volatile counter"</span></span><br></pre></td></tr></table></figure><br>然后在两个同时运行的线程中各自增计数器一次：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*----- Thread 1 ----- */</span> <span class="comment">/*------- Thread 2 ------- */</span></span><br><span class="line">          ++ac;                       ++ac;</span><br><span class="line">          ++vc;                       ++vc;</span><br></pre></td></tr></table></figure><br>当两个线程结束时，ac的值必然为2，但vc的值则不能确定。自增需要执行三个步骤：读取值、自增读取到的值、将该值写回。ac的三个步骤均具备原子性，但vc则不然，因此vc的自增步骤可能会交错执行，例如：</p>
<ol>
<li>线程1读取vc值，读取结果为0</li>
<li>线程2读取vc值，读取结果为0</li>
<li>线程1将读取结果自增为1，将其写入vc</li>
<li>线程2将读取结果自增为1，将其写入vc</li>
</ol>
<p>因此vc最终结果为1，即使它被自增了两次。这并非是唯一可能的最终结果，事实上，存在数据竞争的代码，其最终结果不可预料。</p>
<hr>
<h2 id="信息传递"><a href="#信息传递" class="headerlink" title="信息传递"></a>信息传递</h2><p>假设当前存在两个任务，第一个任务将会在某个值计算完成后将“已完成”这一信息传递给第二个任务，在Item39只我们曾经提及这种实例可以通过std::atomic&lt;bool&gt;实现。计算task如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> imptValue = computeImportantValue(); <span class="comment">// compute value</span></span><br><span class="line">valAvailable = <span class="literal">true</span>; <span class="comment">// tell other task it's available</span></span><br></pre></td></tr></table></figure><br>对于阅读上述代码的开发者而言，我们都很明确imptValue赋值应当处于valAvailable的赋值之前，但编译器却不这么想，它们认为二者不具备任何关联性，因而编译器有资格对此进行重排。换而言之，对于赋值序列：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = b;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure><br>编译器可能会将其重排为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = y;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><br>即使编译器没有对它们进行重新排序，底层硬件也可能会这样做，因为这种行为可能会优化运行速度。</p>
<p>但std::atomic的出现使得这种重排受到限制，在源代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> imptValue = computeImportantValue(); <span class="comment">// compute value</span></span><br><span class="line">valAvailable = <span class="literal">true</span>; <span class="comment">// tell other task it's available</span></span><br></pre></td></tr></table></figure><br>atomic不仅仅要求编译器禁止对语句执行重排，它还要求底层硬件不允许对赋值先后顺序执行重排。因此它保证了valAvailable的赋值必然发生在imptValue结束赋值之后。</p>
<p>将valAvailavle声明为volatile则不能保证重排受限：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">bool</span> <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> imptValue = computeImportantValue();</span><br><span class="line">valAvailable = <span class="literal">true</span>; <span class="comment">// other threads might see this assignment before the one to imptValue!</span></span><br></pre></td></tr></table></figure><br>因此，别的线程可能会发现在valAvailable在imptValue正确赋值之前便已被赋值。</p>
<hr>
<h1 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h1><p>&nbsp;<br>上述两点——不能保证操作原子性与不能保证重排受限说明了volatile在并发编程中似乎毫无作用，实则不然。volatile目的在于告知编译器它们正在处理行为不正常的内存。</p>
<h2 id="normal-memory"><a href="#normal-memory" class="headerlink" title="normal memory"></a>normal memory</h2><p>“正常”内存的特征是，如果将值写入内存位置，则值将保留在那里，直到它被覆盖为止。因此，如果我有一个int：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure><br>并且编译器看到了如下操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// read x</span></span><br><span class="line">y = x; <span class="comment">// read x again</span></span><br></pre></td></tr></table></figure><br>编译器可能会对y的赋值语句视而不见，因为它认为这相对于初始化语句而言是冗余的。<br>此外，“正常”内存还有一大特征：如果我们将值写入特性位置后再未读取过，然后再次写入该内存位置，则可认为第一次写入从未发生。</p>
<p>综上，对于如下语句:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// read x</span></span><br><span class="line">y = x; <span class="comment">// read x again</span></span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// write x</span></span><br><span class="line">x = <span class="number">20</span>; <span class="comment">// write x again</span></span><br></pre></td></tr></table></figure><br>编译器可能会将其优化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// read x</span></span><br><span class="line">x = <span class="number">20</span>; <span class="comment">// write x</span></span><br></pre></td></tr></table></figure><br>你可能会好奇谁会写出这种无聊的程序（技术上我们将其称为redundant load与dead store），事实上开发者确实很少主动撰写类似于上述程序的代码。但在编译器执行模板实例化，内联和各种常见的重新排序优化之后，上述程序俯拾皆是，因此编译器有必要对“正常”内存执行优化。</p>
<hr>
<h2 id="special-memory"><a href="#special-memory" class="headerlink" title="special memory"></a>special memory</h2><p>特殊内存并不需要上述优化。可能最常见的特殊内存类型是用于内存映射I/O的内存。这种内存可能在与外部设备发生通信，例如外部传感器或显示器，打印机，网络端口等，而不是读取或写入普通存储器（即RAM）。在这种环境下，redundant load程序并非redundant：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// read x</span></span><br><span class="line">y = x; <span class="comment">// read x again</span></span><br></pre></td></tr></table></figure><br>如果x对应于温度传感器的返回值，则x的第二次读取并不冗余，因为温度可能在第一次和第二次读取之间发生改变。<br>对于重复写入亦是如此，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>; <span class="comment">// write x</span></span><br><span class="line">x = <span class="number">20</span>; <span class="comment">// write x again</span></span><br></pre></td></tr></table></figure><br>10与20可能是向外设发送的某种指令序列，盲目对其执行优化可能导致设备行为异常。</p>
<hr>
<h2 id="volatile与special-memory"><a href="#volatile与special-memory" class="headerlink" title="volatile与special memory"></a>volatile与special memory</h2><p>volatile对编译器的意义是：“不要对这个内存上的操作执行任何优化。”因此，我们应该将位于special memory的data声明为volatile：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure><br>如此一来，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// read x</span></span><br><span class="line">y = x; <span class="comment">// read x again (can't be optimized away)</span></span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// write x (can't be optimized away)</span></span><br><span class="line">x = <span class="number">20</span>; <span class="comment">// write x again</span></span><br></pre></td></tr></table></figure><br>最后我们需要指明的是，y的类型为int，具体原因可见Item2。</p>
<hr>
<h2 id="atomic在上述环境下的执行"><a href="#atomic在上述环境下的执行" class="headerlink" title="atomic在上述环境下的执行"></a>atomic在上述环境下的执行</h2><p>假定当前有代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// conceptually read x (see below)</span></span><br><span class="line">y = x; <span class="comment">// conceptually read x again (see below)</span></span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// write x</span></span><br><span class="line">x = <span class="number">20</span>; <span class="comment">// write x again</span></span><br></pre></td></tr></table></figure><br>前文已知，编译器可能会将其优化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// conceptually read x (see below)</span></span><br><span class="line">x = <span class="number">20</span>; <span class="comment">// write x</span></span><br></pre></td></tr></table></figure><br>但事实上，如果x是atomic，上述代码无法编译：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// error!</span></span><br><span class="line">y = x; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><br>原因在于atomic的copy操作被设为delete。试想一下，如果atomic对象能够拷贝，因为x是atomic，因此y也将被推衍为atomic对象。前文已经描述过，atomic对象的所有操作均具备原子性。但如果需要从x拷贝构造出y，编译器必须生成能够在单一原子操作内读取x与写入y的代码，这无法在底层硬件上实现，因此atomic并不支持copy构造。基于同样的理由，atomic的copy assignment也被禁止使用，因此上述程序中<code>y=x</code>无法编译。此外，移动操作并没有在atomic中显式声明，根据Item17所提及的规则，atomic亦不支持移动操作。</p>
<p>事实上我们可以利用x来初始化y或给y赋值，不过这需要使用atomic的load与store成员函数，load成员函数以原子方式读取std::atomic的值，而store成员函数以原子方式写入atomic。因此atomic对象的初始化与赋值应当被写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">y</span><span class="params">(x.load())</span></span>; <span class="comment">// read x</span></span><br><span class="line">y.store(x.load()); <span class="comment">// read x again</span></span><br></pre></td></tr></table></figure><br>当然上述语句也清楚表明它们是复合式语句，并不具备原子性。因此编译器可能会对其执行优化，优化策略是将x的值存入寄存器省得读取其两次：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">register</span> = x.load(); <span class="comment">// read x into register</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">y</span><span class="params">(<span class="keyword">register</span>)</span></span>; <span class="comment">// init y with register value</span></span><br><span class="line">y.store(<span class="keyword">register</span>); <span class="comment">// store register value into y</span></span><br></pre></td></tr></table></figure><br>显然最终我们只对x读取了一次，这在special memory中必须避免。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>std::atomic可以在不使用mutex的前提下在并发编程中安全访问数据。</strong></li>
<li><strong>volatile适用于禁止编译器执行优化的内存。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>4.尽可能使用const</title>
    <url>/2018/04/06/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const%20/</url>
    <content><![CDATA[<h1 id="const的意义"><a href="#const的意义" class="headerlink" title="const的意义"></a>const的意义</h1><h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><p>首先复习一下const修饰指针的含义：</p>
<blockquote>
<p>如果const出现在*左边,被指物是常量<br>const出现在*右边，指针自身是常量<br>两边都有 指向常量的常量指针<br>至于他们相对类型名的次序则无关紧要<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Widget* pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget <span class="keyword">const</span>* pw)</span></span>; </span><br></pre></td></tr></table></figure><br>两种写法的意义相同</p>
</blockquote>
<hr>
<h2 id="const与迭代器"><a href="#const与迭代器" class="headerlink" title="const与迭代器"></a>const与迭代器</h2><p>STL迭代器以指针为根据塑造出来，因此iterator就类似于一个T*指针。那么同理，把迭代器声明为const就像把指针声明为const一样(T *const);这意味着该迭代器不得指向不同的东西。<br>如果你希望迭代器的指向物不可修改，那你应该使用STL中的const_iterator，用它来模拟const T*。</p>
<hr>
<h2 id="const与返回值"><a href="#const与返回值" class="headerlink" title="const与返回值"></a>const与返回值</h2><p>我们应该尽量令函数返回一个常量值，从而在不放弃安全和高效的前提下降低因客户失误而造成的意外。（诸如运算符的返回值应该是一个const对象）</p>
<hr>
<h1 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h1><p>用const修饰成员的目的是为了确认该成员函数可以作用于const对象。它们有两大重要特性：</p>
<ol>
<li>它们使用class接口时我们可以清楚看到哪些函数可以改变函数的内容。</li>
<li>它们可以操作const对象，这是编写高效代码的关键。因为改善c++程序效率的一个根本办法就是使用pass by reference-to-const方式传递对象。</li>
</ol>
<p>const成员函数的另一个易被忽视之处在于常量性的不同可以构成重载。<br>最常见的例子莫过于下标运算符的定义，const的下标运算符返回const引用，普通则返回普通引用。这样则避免了试图修改一个const对象。</p>
<hr>
<h2 id="成员函数是const意味着什么？"><a href="#成员函数是const意味着什么？" class="headerlink" title="成员函数是const意味着什么？"></a>成员函数是const意味着什么？</h2><p>这一问题直接引发了2个流派之争：bitwise constness与logical constness<br>bitwise constness阵营的人认为<strong>成员函数只有在不改变对象内任何一个成员变量的情况下才可以称为const</strong>。<br>这听起来很有道理，但实际上很多不具备const性质的成员函数却能够通过bitwise测试。举例而言，假如一个class内有一个指针，我们通过指针修改指针指向的对象，那么它不会引发编译器异议。最终，我们创建了一个常量对象并对它调用了const成员函数，可是最终它的值还是被改变了。<br>这种情况导出了logical constness。这一派拥护者指出，<strong>一个const成员可以修改所处理对象的某些数据，但只有在客户端检测不出的情况才能如此</strong>。这种情况是很直观的，但是编译器只能辨别bitwise constness.为了避免这种无谓的情况，我们可以用mutable来修饰non-static成员变量，在样就算在const成员里我们也可以修改它们。<br>然而mutable并不能解决所有的问题。至少在以下情况不能：<br>假设下标运算符不仅需要返回，还需要进行边界检测，扩展边界等操作。显然，这样的下标运算符的const性质十分繁琐，而且伴随着大量的代码重复。<br>我们真正需要做的是实现const下标运算符的功能，并在non-const函数中调用它，然后再去除它返回对象的const属性。在这里去除const是安全的，因为不管谁调用non-const operator[]都必须要有一个non-const对象。其实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;</span><br><span class="line">        (<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlocks&gt;(*<span class="keyword">this</span>)[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>很显然，我们先把this转为了const对象，这样就可以调用const版本的下标运算符。再把const函数返回的对象去除了const属性，我们只有const_cast一种方法来实现这种操作。<br>之所以我们不在const成员函数里调用普通成员函数，是因为这一点及其危险：const成员承诺不修改对象，而non-const成员却可能修改对象。而且要调用non-const函数的话你必须先通过const_cast去掉this的const性质，这简直就是雪崩的前兆。<strong>通过non-const函数调用const函数自然很安全。</strong></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>将某些东西声明为const可帮助编译器侦测出错误用法。尤其是返回值可以用const修饰。</li>
<li>编译器强制实施bitwise constness，但编写程序时应该活用mutable，做到logical constness.</li>
<li>当const函数与non-const函数实现几乎等价时，我们应该在non-const函数中调用const版本以避免代码重复。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>28.尽量避免转型操作</title>
    <url>/2018/04/14/%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E8%BD%AC%E5%9E%8B%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>（本节内容联系More Effective C++ 5 效果更佳）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>c++规则的设计目标之一就是：保证类型错误绝不可能发生。理论上而言，如果你的程序能很干净地通过编译，就说明了它并不企图在任何对象身上执行任何不安全、无意义、荒谬的操作。<br>但转型（cast)破坏了类型系统。在Java，C#，或C中，转型操作必要且较为安全（当然，安全是相对的），C++的转型则充斥着风险。</p>
<hr>
<h1 id="转型语法"><a href="#转型语法" class="headerlink" title="转型语法"></a>转型语法</h1><h2 id="旧式转型"><a href="#旧式转型" class="headerlink" title="旧式转型"></a>旧式转型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(T)expression;<span class="comment">//将expression转为T</span></span><br><span class="line">T(expression);<span class="comment">//将expression转为T</span></span><br></pre></td></tr></table></figure>
<p>两者并无差别，无非是小括号的位置不同。</p>
<h2 id="C-转型"><a href="#C-转型" class="headerlink" title="C++转型"></a>C++转型</h2><p>C++提供了四种新式转型操作符：</p>
<ul>
<li>const_cast<T>(expression)</li>
<li>dynamic_cast<T>(expression)</li>
<li>reinterpret_cast<T>(expression)</li>
<li>static_cast<T>(expression)</li>
</ul>
<h3 id="C-转型操作符介绍"><a href="#C-转型操作符介绍" class="headerlink" title="C++转型操作符介绍"></a>C++转型操作符介绍</h3><ul>
<li>const_cast：能够将对象的const属性去除，也只有它拥有该能力</li>
<li>dynamic_cast：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系的某个类型。它是唯一一个无法由旧式语句转换的新类型转换，也是唯一一个可能耗费大量运行成本的转型操作。</li>
<li>reinterpret_cast：意图执行低级转型，实际动作可能取决于编译器，这一特性也就意味着不可移植。比如将一个pointer to int转为int，该转型操作在低级代码以外相当少见。</li>
<li>static_cast：强迫隐式转换，比如把non-const转为const，int转为double。它也可以作上述转换的反向转换，例如把pointer-to-base转为pointer-to-derived，或者把void*指针转为typed指针。但是没法把const转为non-const。</li>
</ul>
<h2 id="新旧转型的优劣以及使用时机"><a href="#新旧转型的优劣以及使用时机" class="headerlink" title="新旧转型的优劣以及使用时机"></a>新旧转型的优劣以及使用时机</h2><h3 id="新式转型的优点"><a href="#新式转型的优点" class="headerlink" title="新式转型的优点"></a>新式转型的优点</h3><p>尽管旧式转型依然合法，但新式转型更受青睐。原因在于：</p>
<ol>
<li>易于辨识</li>
<li>转型动作明确</li>
</ol>
<h3 id="何时采用旧式转型"><a href="#何时采用旧式转型" class="headerlink" title="何时采用旧式转型"></a>何时采用旧式转型</h3><p>一般来说，仅在需要调用一个explicit构造函数将一个对象传递给一个函数时使用旧式转型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">doSth(Widget(<span class="number">15</span>));</span><br><span class="line">doSth(<span class="keyword">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure><br>然而这种风格并不像是转型，更像是一种构造。但必须明确，这里其实执行的类型转换操作。</p>
<hr>
<h1 id="类型转换的意义"><a href="#类型转换的意义" class="headerlink" title="类型转换的意义"></a>类型转换的意义</h1><p>&nbsp;<br>有人认为转型只不过告诉编译器把某种类型视为另一种类型，其他什么都没做，实际上这是不可能的<br>。将int转为double的时候编译器肯定生成了一些代码，因为int的底层描述与double的底层描述并不相同。再比如说：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;<span class="comment">//暗中将Derived*转为了Base*</span></span><br></pre></td></tr></table></figure><br>我们建立了一个base指针指向derived class对象，但有时上述的两个指针值并不相同，这时会有一个偏移量在运行期间被施行于derived*指针，以取得正确的base*值。</p>
<p>上述案例表明，<strong>单一对象可能拥有多个地址</strong>（这在C，Java，C#中是不可能发生的）。如果在C++中使用多重继承，单一对象必然拥有多个地址，并且在单一继承下也可能存在多个地址。<strong>我们应该避免做出“对象在c++中如何布局”的假设，更不应该以某种假设为基础执行任何转型操作。</strong></p>
<hr>
<h1 id="类型转换的误区"><a href="#类型转换的误区" class="headerlink" title="类型转换的误区"></a>类型转换的误区</h1><p>&nbsp;<br>类型转换可能会导致我们易写出一些似是而非的代码，（它们在其他语言中可能是正确的）。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>许多应用框架都要求derived classes内的virtual函数第一件事就是调用base class的对应函数。下面给出一个具体实例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindows</span>:</span><span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;<span class="comment">//要求首先调用base class的对应函数</span></span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).onResize();<span class="comment">//error！</span></span><br><span class="line">        ...<span class="comment">//执行专有操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们确实成功地将它转为了Window对象，也确实调用了Window::onResize。但值得注意的是，调用的并不是当前对象上的函数，而是稍早转型动作建立的一个“*this对象之base class成分”的<strong>暂时副本</strong>身上的onResize(),也就是说当前对象内部的数据并没有改变，改变的是一个副本。(这个原理很简单，就是转型操作导致了一个临时Window对象被生成，我们在该临时对象身上调用了onResize，伴随着它的析构，这个操作就像没做一样，（*this)的bc成分根本没有改变）</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方案就是直接调用，不要使用转型操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindows</span>:</span><span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Window::onResize();</span><br><span class="line">        ...<span class="comment">//执行专有操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="dynamic-cast探究"><a href="#dynamic-cast探究" class="headerlink" title="dynamic_cast探究"></a>dynamic_cast探究</h1><p>&nbsp;<br>首先需要强调的是，dynamic_cast执行速度相当缓慢，如果继承层次很深或者存在多继承的情况下使用dynamic_cast，可能对性能的冲击极大，请谨慎使用！</p>
<h2 id="dynamic-cast功能"><a href="#dynamic-cast功能" class="headerlink" title="dynamic_cast功能"></a>dynamic_cast功能</h2><p>之所以需要使用dynamic_cast，主要是因为我们需要在一个derived class对象身上执行derived class专属操作，但偏偏我们目前只有一个指向base的pointer或reference.</p>
<h2 id="如何避免使用dynamic-cast"><a href="#如何避免使用dynamic-cast" class="headerlink" title="如何避免使用dynamic_cast"></a>如何避免使用dynamic_cast</h2><h3 id="使用容器-并指定其存储的元素类型为指向derived-class对象的指针"><a href="#使用容器-并指定其存储的元素类型为指向derived-class对象的指针" class="headerlink" title="使用容器,并指定其存储的元素类型为指向derived class对象的指针"></a>使用容器,并指定其存储的元素类型为指向derived class对象的指针</h3><p>举例而言，假设在之前的体系中，SpecialWindow有一个特有操作：闪烁<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindows</span>:</span><span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要闪烁所有可以闪烁的窗口</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用dynamic_cast</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=winPtrs.<span class="built_in">begin</span>();it!=winPtrs.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">    <span class="comment">//赋值，检测其返回值不为nullptr</span></span><br><span class="line">    <span class="keyword">if</span>(SpecialWindow *psw = <span class="keyword">dynamic_cast</span>&lt;SpecialWindows*&gt;(iter-&gt;<span class="built_in">get</span>()))</span><br><span class="line">        psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>应该改为在容器内存在指向dc的smart_ptr:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=winPtrs.<span class="built_in">begin</span>();it!=winPtrs.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不过，这种做法无法在同一个容器内存储指向所有派生类的指针。</p>
<h3 id="通过base接口处理所有可能的派生类"><a href="#通过base接口处理所有可能的派生类" class="headerlink" title="通过base接口处理所有可能的派生类"></a>通过base接口处理所有可能的派生类</h3><p>具体来说，就是在基类中声明所有派生类所具备的特殊函数，然后提供一份空白实现。（这种方法十分恶劣，违背了面向对象准则）</p>
<h2 id="dynamic-cast禁区"><a href="#dynamic-cast禁区" class="headerlink" title="dynamic_cast禁区"></a>dynamic_cast禁区</h2><p>绝对必须避免的是连锁式使用dynamic_cast，其运行效率极低且缺乏维护性。这种程序总应该被某种基于virtual函数调用的方法取而代之。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>优秀的c++代码很少使用转型，但完全摆脱它们也不切实际。我们要做的只能是<strong>尽可能隔绝转型动作，把他们隐藏在某个函数内。</strong></p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>27.尽可能延后变量定义式的出现时间</title>
    <url>/2018/04/14/%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>只要你定义了一个需要构造和析构的成员变量，那么当程序的控制流转移到该变量定义式时，你就必须承担构造成本。同样地，当控制流离开其作用域时，你必须承担析构成本。即使这个变量从未被使用。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>你或许认为没人会定义一个不使用的变量。请看下述程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="comment">//加密文本串，如果串过短则抛出异常</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">string</span> encrypted;</span><br><span class="line">    <span class="keyword">if</span>(password.length()&lt;MinLength)&#123;</span><br><span class="line">        <span class="keyword">throw</span> logic_error(<span class="string">"Password is too short"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在此例中，对象encrypted可能并未使用，所以最好延后其定义式，直到确实需要使用该对象为止：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="comment">//加密文本串，如果串过短则抛出异常</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">if</span>(password.length()&lt;MinLength)&#123;</span><br><span class="line">        <span class="keyword">throw</span> logic_error(<span class="string">"Password is too short"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> encrypted;<span class="comment">//肯定能被使用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但上述代码仍然存在提升的空间，请注意encrypted对象虽然获得了定义但并没有值（执行了默认初始化），在Effective C++ 5中我们了解到<strong>“通过default构造函数构造然后再赋值”的行为比“直接指定初值”的效率要低</strong>，所以，正确的写法应当如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; password)</span></span>&#123;</span><br><span class="line">    ...<span class="comment">//检查长度</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encrypted</span><span class="params">(password)</span></span>;<span class="comment">//直接copy构造</span></span><br><span class="line">    encrypt(encrypted);<span class="comment">//加密函数</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这才是延后变量定义式的出现时间的真谛：<strong>可能地延后变量的定义直到可以直接用某个具体值初始化它为止。</strong></p>
<hr>
<h1 id="定义式与循环"><a href="#定义式与循环" class="headerlink" title="定义式与循环"></a>定义式与循环</h1><p>&nbsp;<br>如果变量仅在循环内部使用，那么是应该把它定义在循环内还是循环外？也就是说，写法A与写法B，哪一种的效率更高？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法A 循环外定义，循环内赋值</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    w=..<span class="comment">//赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法B 循环内定义</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    w(...)<span class="comment">//copy初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>两种写法的成本如下：</p>
<ul>
<li>A：1次构造，1次析构，n次赋值</li>
<li>B：n次构造，n次析构</li>
</ul>
<p>那么显然地，如果赋值成本较低，那应当使用A。但A造成了w的作用域不仅仅在循环内，这可能会降低代码的可读性与易维护性。除非你必须要对效率进行优化，否则写法B相较于A更佳。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>应当尽可能延后变量定义式出现的时间，这不仅有利于效率，也提高了程序的可读性。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>29.引用计数</title>
    <url>/2018/04/29/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>引用计数允许多个具有相同值的对象共享这个值的实现，其作用大致有二：</p>
<ol>
<li>简化跟踪堆中对象。<br>在使用引用计数后，对象明确自己拥有自己的资源，当没人使用时自动销毁，可以算是一个简单的垃圾回收。</li>
<li>Lazy evaluation<br>如果很多对象拥有相同的值，我们不应该存储这个值，而是让所有对象共享其实现。</li>
</ol>
<hr>
<h1 id="引用计数实例"><a href="#引用计数实例" class="headerlink" title="引用计数实例"></a>引用计数实例</h1><p>&nbsp;<br>我们首先复习一下Lazy evaluation。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span><span class="comment">//自定义string类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span> a, b, c, d, e;</span><br><span class="line">a = b = c = d = e = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><br>a到e的具体值形态其实取决于string类的实现。如果不作特殊化处理，每一个string对象均应具有一个值的拷贝，此时有赋值操作符实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, rhs.data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，在这种实现下，abcde如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/qts3knjxll0lza2h7vmqh5lp/image_1cc7oo06d1n3v1sjt1omc1h6b15gc9.png" alt="image_1cc7oo06d1n3v1sjt1omc1h6b15gc9.png-48.3kB"><br>​这无疑是冗余的，我们希望的理想情况是这样：<br><img src="http://static.zybuluo.com/zsmj2017/pl4h5tdvws1z0tz8zc03d9ax/image_1cc7opfrj1avv1hha5ub1sdu84tm.png" alt="image_1cc7opfrj1avv1hha5ub1sdu84tm.png-30.9kB"><br>但这种情况是不现实的，我们<strong>至少应该记录当前有多少对象在使用该资源</strong>，增设计数器之后的效果如下：<img src="http://static.zybuluo.com/zsmj2017/4mds08expzujjkkyd5janclh/image_1cc7oqndik0j1i0h1ue21mmkgue13.png" alt="image_1cc7oqndik0j1i0h1ue21mmkgue13.png-35.5kB"></p>
<hr>
<h1 id="实现引用计数"><a href="#实现引用计数" class="headerlink" title="实现引用计数"></a>实现引用计数</h1><p>&nbsp;<br>仍以String为例。首先我们应当明确需要空间来存储计数值。该空间不可能存在于string内部，因为引用计数的本质是每一个资源一个计数，而非一个对象一个计数，这也表明了资源和引用计数之间存在一种耦合关系。<br>我们使用一个名为StringValue的struct帮助我们实现上述功能。它不仅仅保存计数器，同时也保存资源。我们将其置于String的private部分(<strong>将一个struct内嵌在类的私有区内，能便于这个类的所有成员访问这个结构，但阻止了其它任何人对它的访问</strong>)其设计与实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> refCount;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line">    StringValue* value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">:refCount(<span class="number">1</span>)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>::StringValue::~StringValue()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这便是引用计数的全部，你所认为缺少的功能将由String类提供。StringValue的功能主要就是：将一个特殊的值与共享此值的对象的数目联系起来。</p>
<hr>
<h2 id="String的构造"><a href="#String的构造" class="headerlink" title="String的构造"></a>String的构造</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue = <span class="string">""</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">: value(<span class="keyword">new</span> StringValue(initValue))&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，String对象是独立构造的，有同样初始化值的对象并不共享数据：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"More Effective C++"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">s2</span><span class="params">(<span class="string">"More Effective C++"</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>产生的数据结构如下所示：<img src="http://static.zybuluo.com/zsmj2017/a8xpqnsww9an00wvqr4fn6r4/image_1cc7qinp41b8b1pd851p11dd1gv61t.png" alt="image_1cc7qinp41b8b1pd851p11dd1gv61t.png-42kB"><br>消除这样的副本是可能的：通过让String或StringValue对象跟踪已存在的StringValue对象，并只在不同串时才创建新的对象。</p>
<hr>
<h2 id="String的拷贝"><a href="#String的拷贝" class="headerlink" title="String的拷贝"></a>String的拷贝</h2><p>String 的拷贝构造函数效率很高，新生成的String对象与被拷贝的对象共享相同的StringValue对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs)</span><br><span class="line">: value(rhs.value)&#123;</span><br><span class="line">    ++value-&gt;refCount;<span class="comment">//需要注意value在heap中，为对象所共有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如下代码产生的数据结构如图所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"More Effective C++"</span>)</span></span>;</span><br><span class="line"><span class="keyword">String</span> s2 = s1;</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/zsmj2017/a5r77zx2z4bb6n94dyjdlz7m/image_1cc7qpffq11lo13nkif8m84r0d2a.png" alt="image_1cc7qpffq11lo13nkif8m84r0d2a.png-25.3kB"><br>这必然比值拷贝系列效率要高，在本次拷贝中，我们只不过是拷贝了一个指针并增加了一次引用计数。</p>
<hr>
<h2 id="String的析构"><a href="#String的析构" class="headerlink" title="String的析构"></a>String的析构</h2><p>析构函数实现较为容易：只要引用计数值不为0，也就是当前至少存在一个String对象使用这个值，这个值就不可以被销毁：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="keyword">String</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) <span class="keyword">delete</span> value;<span class="comment">//先执行自减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="String的赋值"><a href="#String的赋值" class="headerlink" title="String的赋值"></a>String的赋值</h2><p>当用户写下这样的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1 = s2;</span><br></pre></td></tr></table></figure><br>其结果应该是s1和s2指向相同的StringValue对象,对象的引用计数在赋值时被增加。并且，s1原来指向的 StringValue对象的引用计数应该减少，如果s1是拥有原来的值的唯一对象，这个值销毁。上述功能实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == rhs.value) &#123;<span class="comment">//类似于自赋值，这里指的是已经指向相同对象</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = rhs.value;</span><br><span class="line">    ++value-&gt;refCount;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h1><p>&nbsp;<br>数组下标操作符[]允许字符串中的单个字符被读或写:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>; <span class="comment">// for const Strings</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index); <span class="comment">// for non-const Strings</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>const成员函数很容易实现，因为它仅仅提供读操作。但non-const则较为繁琐，因为它需要分别处理读和写的情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[<span class="number">3</span>];<span class="comment">//read</span></span><br><span class="line">s[<span class="number">5</span>] = <span class="string">'x'</span>;<span class="comment">//write</span></span><br></pre></td></tr></table></figure><br>当我们试图修改一个String对象的值时，必须确保没有修改和它共享StringValue的对象。但我们无法确定operator[]执行的是何种操作（proxy class可以帮助区分读写，详见More Effective C++ 30），所以我们必须假设所有operator[]都在执行写操作。<br>为了安全地实现non-const operator[]，我们必须确保资源被当前String对象独占。简而言之，当我们返回StringValue对象中的一个字符的引用时，必须确保这个StringValue的引用计数是1：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;refCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        --value-&gt;refCount;<span class="comment">//脱离当前资源共享阶段</span></span><br><span class="line">        value = <span class="keyword">new</span> StringValue(value-&gt;data);<span class="comment">//生成一个新资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>写时拷贝是这么一种情况：一个对象永远与其他等值对象共享资源，直到它需要修改自身时才迅速拷贝一份资源，你可以把它视为lazy-evacuation的一个应用特例。</p>
<hr>
<h1 id="指针、引用与写时拷贝"><a href="#指针、引用与写时拷贝" class="headerlink" title="指针、引用与写时拷贝"></a>指针、引用与写时拷贝</h1><p>&nbsp;<br>多数情况下上文所实现的写时拷贝兼具正确性与高效性，但加入了指针后正确性可能会因此失效：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;s1[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><br>其数据结构如下所示：<img src="http://static.zybuluo.com/zsmj2017/q5z8n5l245jbml5g9c7xaoq9/image_1cc7skm1scn5emb6i1d1tsno2n.png" alt="image_1cc7skm1scn5emb6i1d1tsno2n.png-15.3kB"><br>现增加一条语句：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s2 = s1;</span><br></pre></td></tr></table></figure><br>由于资源共享的原因，当前数据结构如下所示：<img src="http://static.zybuluo.com/zsmj2017/e5xeg3q7myaib4p73vr1dqy0/image_1cc7smvc4e04147p1dml1tb757s34.png" alt="image_1cc7smvc4e04147p1dml1tb757s34.png-21.5kB"><br>如果我们试图通过p去更改s1，就会发现s2也遭到了更改。并非只有指针会造成这种情况，non-conts-reference也是如此。<br>解决方案不难实现，但我们付出了代价：降低一个值共享于对象间的次数。解决方案原理是：在每个StringValue对象中增加一个标志以指出它是否具备共享性，一开始标志位设置为可共享，一旦有operator[]被调用，标志位翻转为不可共享状态，并且永久保持为不可共享：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> refCount;</span><br><span class="line">        <span class="keyword">bool</span> shareable; <span class="comment">// add this</span></span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">: refCount(<span class="number">1</span>),shareable(<span class="literal">true</span>)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>::StringValue::~StringValue()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在标志位增加后，String的成员函数也需要修改保持配合：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs)&#123;<span class="comment">//以拷贝构造举例</span></span><br><span class="line">    <span class="keyword">if</span> (rhs.value-&gt;shareable) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        ++value-&gt;refCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="keyword">new</span> StringValue(rhs.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>non-const operator[]是唯一一个可以更改标志位的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;refCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        --value-&gt;refCount;</span><br><span class="line">        value = <span class="keyword">new</span> StringValue(value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    value-&gt;shareable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="引用计数与mixin-class"><a href="#引用计数与mixin-class" class="headerlink" title="引用计数与mixin class"></a>引用计数与mixin class</h1><p>&nbsp;<br>不仅仅只有String需要引用计数，但我们不可能为所有需要引用计数的类都添加对应的struct，为了把引用计数功能抽象到与运行环境无关，我们想到了mixin class。</p>
<h2 id="RCObject"><a href="#RCObject" class="headerlink" title="RCObject"></a>RCObject</h2><p>首先构建一个基类RCObject，任何需要引用计数的类都必须继承自它，其具体定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCObject();</span><br><span class="line">    RCObject(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~RCObject() = <span class="number">0</span>;<span class="comment">//纯虚析构函数，表明该类仅能作为基类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RCObject的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RCObject::RCObject():refCount(<span class="number">0</span>), shareable(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject::RCObject(<span class="keyword">const</span> RCObject&amp;):refCount(<span class="number">0</span>), shareable(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject&amp; RCObject::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp;)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">RCObject::~RCObject() &#123;&#125;<span class="comment">//虚析构函数必须被定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::addReference</span><span class="params">()</span> </span>&#123; ++refCount; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::removeReference</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (--refCount == <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::markUnshareable</span><span class="params">()</span></span>&#123; </span><br><span class="line">    shareable = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shareable; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShared</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> refCount &gt; <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所有的构造函数都把refCount设为了0，因为我们会在构造完毕后把构造它的这个对象的count设为1。赋值操作也很奇怪，它什么都没做，因为我们不可能把计数对象从一个赋予另外一个。就算真的被赋值，它也什么都没变。removeReference函数不仅仅负责减少count值，还负责析构对象，因此这里我们必须要保证对象只被构建于堆中。（More Effective C++ 27）</p>
<hr>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>::StringValue::~StringValue()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的StringValue什么都不用管，其基类接管了所有行为。</p>
<hr>
<h1 id="引用计数自动化处理"><a href="#引用计数自动化处理" class="headerlink" title="引用计数自动化处理"></a>引用计数自动化处理</h1><p>&nbsp;<br>RCObject并没有提供自动化操作，一切关于refcount的行为都必须手动完成，比如在String的拷贝构造函数和赋值运算函数中，我们需要调用StringValue的addReference和removeReference函数。我们寄希望于某种操作，能够将大部分与引用计数相关的工作从所有具象类中移出。确实存在这种东西：智能指针。</p>
<h2 id="计数对象所使用的智能指针"><a href="#计数对象所使用的智能指针" class="headerlink" title="计数对象所使用的智能指针"></a>计数对象所使用的智能指针</h2><p>以下是计数对象所使用的智能指针模版：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RCPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    RCPtr(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    ~RCPtr();</span><br><span class="line">    RCPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>; <span class="comment">// see Item 28</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>; <span class="comment">// see Item 28</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该模板允许了我们自定义构造、赋值、析构时执行的操作。当这些事件发生时，智能指针对象可以自动执行正确的操作来处理它们指向的对象（引用计数对象）的refCount字段。其具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCPtr</span>&lt;T&gt;:</span>:RCPtr(T* realPtr): pointee(realPtr)&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCPtr</span>&lt;T&gt;:</span>:RCPtr(<span class="keyword">const</span> RCPtr&amp; rhs): pointee(rhs.pointee)&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RCPtr</span>&lt;T&gt;:</span>:init()&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pointee-&gt;isShareable() == <span class="literal">false</span>) &#123;<span class="comment">//如果计数对象所指向的资源不可共享</span></span><br><span class="line">        pointee = <span class="keyword">new</span> T(*pointee);</span><br><span class="line">    &#125;</span><br><span class="line">    pointee-&gt;addReference();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="init存在的问题"><a href="#init存在的问题" class="headerlink" title="init存在的问题"></a>init存在的问题</h2><p>当init()函数中发现拷贝构造的rhs处于不可共享状态，它会构建一个新的T型的对象，并且使用T对象的拷贝构造完成了初始化。对于一个String来说，T型对象是StringValue，我们没有对它声明拷贝构造函数，因此编译器选择调用默认版本，只拷贝了StringValue的数据pointer，而没有拷贝所指向的char*字符串。<br>正确的做法是令T含有正确的值拷贝行为(如深拷贝），以StringValue举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        StringValue(<span class="keyword">const</span> StringValue&amp; rhs);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::StringValue::StringValue(<span class="keyword">const</span> StringValue&amp; rhs)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, rhs.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>深copy并非唯一选择，我们应该将具体拷贝实现类型写于文档，告知用户。</p>
<h2 id="智能指针的指向对象"><a href="#智能指针的指向对象" class="headerlink" title="智能指针的指向对象"></a>智能指针的指向对象</h2><p>RCPtr<T>假设智能指针永远指向T型对象，但实际上我们知道可以指向T的派生类，为了防止一些奇怪的问题，建议使用虚拷贝构造等手段（More Effective C++ 25）。</p>
<h2 id="智能指针的赋值与析构"><a href="#智能指针的赋值与析构" class="headerlink" title="智能指针的赋值与析构"></a>智能指针的赋值与析构</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCPtr</span>&lt;T&gt;&amp; <span class="title">RCPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee != rhs.pointee) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointee) &#123;</span><br><span class="line">            pointee-&gt;removeReference();</span><br><span class="line">        &#125;</span><br><span class="line">        pointee = rhs.pointee;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCPtr</span>&lt;T&gt;:</span>:~RCPtr()&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee)</span><br><span class="line">        pointee-&gt;removeReference();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符"></a>解引用操作符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">RCPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> pointee; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">RCPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *pointee; &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h1><p>&nbsp;<br>将之前提到的所有东西合在一起，真正的带有引用计数的String对象数据结构如下：<br><img src="http://static.zybuluo.com/zsmj2017/xfk39ev9qbd2xhu4q4slsrpg/image_1cc813plr5sq19f6cqi19mviu3h.png" alt="image_1cc813plr5sq19f6cqi19mviu3h.png-120.6kB"><br>String类有定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RCPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    RCPtr(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    ~RCPtr();</span><br><span class="line">    RCPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;<span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    RCObject();</span><br><span class="line">    RCObject(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~RCObject() = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        StringValue(<span class="keyword">const</span> StringValue&amp; rhs);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span></span>;</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line">    RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>String class没有声明拷贝构造、赋值运算、析构函数，但这并不是因为操作失误，而是这些函数均可以使用编译器自动生成的版本，真正本质上的上述操作均已在智能指针类及引用计数类中实现。<br>通过完美的封装，我们在没有更改String接口的同时增加了功能。</p>
<hr>
<h1 id="在现存类上增加引用计数"><a href="#在现存类上增加引用计数" class="headerlink" title="在现存类上增加引用计数"></a>在现存类上增加引用计数</h1><p>&nbsp;<br>假设我们有一个不可更改的class Widget（不该更改的原因可能是其位于支持库中），如何给它添加引用计数功能？<br>首先从刚才已实现的思路入手，我们应该会建立一个RCWidget class，内部嵌套有一个struct public继承自RCObject，RCWidget内持有一个智能指针RCPtr指向Count对象：<br><img src="http://static.zybuluo.com/zsmj2017/za7vr0i7hw24a9ie3eba1ppd/image_1cc81soqn1pls1vmttmu3c2ukg4b.png" alt="image_1cc81soqn1pls1vmttmu3c2ukg4b.png-107.6kB"><br>我们当前自然无法修改Widget内部，但我们可以试图构造一个中间层，然后完成这份任务：<img src="http://static.zybuluo.com/zsmj2017/ebw6lpwidbhlsn78bd4c78la/image_1cc81h7851qt1182q2fdffkmci3u.png" alt="image_1cc81h7851qt1182q2fdffkmci3u.png-122.9kB"><br>其中，CountHolder是人为构造的class，其内部有一个指针指向了Widget资源，我们用一个智能指针指向CountHolder。</p>
<h2 id="PCIPtr与CountHolder"><a href="#PCIPtr与CountHolder" class="headerlink" title="PCIPtr与CountHolder"></a>PCIPtr与CountHolder</h2><p>我们可以认为CountHolder是RCIPtr的实现细节，所以将其嵌套在该类中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">RCIPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCIPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    RCIPtr(<span class="keyword">const</span> RCIPtr&amp; rhs);</span><br><span class="line">    ~RCIPtr();</span><br><span class="line">    RCIPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCIPtr&amp; rhs);</span><br><span class="line">    <span class="keyword">const</span> T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;();</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CountHolder</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        ~CountHolder() &#123; <span class="keyword">delete</span> pointee; &#125;</span><br><span class="line">        T *pointee;</span><br><span class="line">    &#125;;</span><br><span class="line">    CountHolder *counter;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeCopy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RCIPtr</span>&lt;T&gt;:</span>:init()&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter-&gt;isShareable() == <span class="literal">false</span>) &#123;</span><br><span class="line">        T *oldValue = counter-&gt;pointee;</span><br><span class="line">        counter = <span class="keyword">new</span> CountHolder;</span><br><span class="line">        counter-&gt;pointee = <span class="keyword">new</span> T(*oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    counter-&gt;addReference();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCIPtr</span>&lt;T&gt;:</span>:RCIPtr(T* realPtr)</span><br><span class="line">:counter(<span class="keyword">new</span> CountHolder)&#123;</span><br><span class="line">    counter-&gt;pointee = realPtr;init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCIPtr</span>&lt;T&gt;:</span>:RCIPtr(<span class="keyword">const</span> RCIPtr&amp; rhs)</span><br><span class="line">:counter(rhs.counter)&#123;</span><br><span class="line">    init(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCIPtr</span>&lt;T&gt;:</span>:~RCIPtr()&#123; </span><br><span class="line">    counter-&gt;removeReference(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCIPtr</span>&lt;T&gt;&amp; <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> RCIPtr&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter != rhs.counter) &#123;</span><br><span class="line">        counter-&gt;removeReference();</span><br><span class="line">        counter = rhs.counter;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RCIPtr</span>&lt;T&gt;:</span>:makeCopy()&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter-&gt;isShared()) &#123;</span><br><span class="line">        T *oldValue = counter-&gt;pointee;</span><br><span class="line">        counter-&gt;removeReference();</span><br><span class="line">        counter = <span class="keyword">new</span> CountHolder;</span><br><span class="line">        counter-&gt;pointee = <span class="keyword">new</span> T(*oldValue);</span><br><span class="line">        counter-&gt;addReference();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>* <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> counter-&gt;pointee; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">non</span>-<span class="title">constT</span>* <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">    makeCopy(); </span><br><span class="line">    <span class="keyword">return</span> counter-&gt;pointee; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>&amp; <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(counter-&gt;pointee); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>*()&#123; </span><br><span class="line">    makeCopy(); </span><br><span class="line">    <span class="keyword">return</span> *(counter-&gt;pointee); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="RCwidget"><a href="#RCwidget" class="headerlink" title="RCwidget"></a>RCwidget</h2><p>有了RCIPtr，RCWidget很容易实现，因为RCWidget的每个函数都是将操作RCIPtr以完成对Widget对象的操作。若有Widget class有实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    ~Widget();</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doThis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">showThat</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>那么RCWidget将被定义为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCWidget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCWidget(<span class="keyword">int</span> <span class="built_in">size</span>): value(<span class="keyword">new</span> Widget(<span class="built_in">size</span>)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doThis</span><span class="params">()</span> </span>&#123; value-&gt;doThis(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">showThat</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value-&gt;showThat(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RCIPtr&lt;Widget&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>需要注意的是，RcWidget没有拷贝，析构，赋值函数，因为RCIPtr将自动地执行这些行为。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>3.尽量以const，enum，inline替换#define</title>
    <url>/2018/04/06/%E5%B0%BD%E9%87%8F%E4%BB%A5const%EF%BC%8Cenum%EF%BC%8Cinline%E6%9B%BF%E6%8D%A2#define/</url>
    <content><![CDATA[<p>众所周知，使用const来替换#define定义的常量是一个不错的选择，当我们以常量替换预处理时，有两点值得注意：</p>
<blockquote>
<p>1.常量指针<br>在定义常量指针时，由于常量定义式通常置于头文件内，同时在多次调用时为了避免不必要的修改，因此有必要将指针声明为const，而非指针所指的对象。如果你需要将指向对象也声明为const，则需要两个const.举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorname = “mie”； </span><br></pre></td></tr></table></figure></p>
<p>当然，这里使用string比使用char<em>-based字符串更合适。<br>2.class的专属常量<br>在定义class的专属常量时，为了将变量的作用域仅仅局限在class内，我们将其作为class的一个成员。为了确保此常量至多只有一份实体，我们将其设为static。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> sc = <span class="number">5</span>； </span><br></pre></td></tr></table></figure><br>值得注意的是，此处只是sc的声明而非定义。通常意义下，c++需要你对你所使用的任何东西提供一个定义式。<br><em>*但如果它是一个class的static const member且为intergral type(int,char,bool)，则需要特殊处理。</em></em><br>如果你无需获取地址，那你可以只声明不定义。但如果你需要使用地址或者你的编译器非要看到一个定义式，则应该另外提供定义式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns； </span><br></pre></td></tr></table></figure><br>由于const class member在声明时获得了初值，因此在定义时不可再设初值。</p>
</blockquote>
<hr>
<p>如果class在编译期间需要一个class常量，比如说数组声明式。那么我们也没必要非要用#define。<br>我们可以使用enum hack来提供一个整形数据，因为<strong>一个枚举类型的数值总可以充当int被使用</strong>，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;NumTurns = <span class="number">5</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> scores[NumTurns];</span><br></pre></td></tr></table></figure><br>这样写有两个好处：</p>
<ol>
<li>enum的行为比较像#define而不是const，比如你无法对它取址，也无法有一个pointer或者reference指向它。同时，避免使用了额外的内存空间以存储const int.</li>
<li>实用主义 很多代码使用了它</li>
</ol>
<hr>
<p>#define还有一个作用就是有人喜欢用它写宏。实际上这样根本不方便而且难于维护。我们有更好的替代方法：<strong>template inline函数</strong></p>
<hr>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>对于单纯常量，最好用const对象与enum替换#define</li>
<li>对于形似函数的宏，最好使用inline函数替代</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>6.当auto推衍类型错误时，使用显式初始化</title>
    <url>/2018/06/26/%E5%BD%93auto%E6%8E%A8%E8%A1%8D%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在Item5中曾经提及，使用auto声明变量相较于显式类型声明有许多优势，但有时也会带来问题。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>举例而言，假若我们当前有一个函数，其形参为一个Widget切返回一个std::vector&lt;bool&gt;,每一个bool表征当前Widget是否提供某项功能：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span></span><br></pre></td></tr></table></figure><br>进一步地，我们假定bit5代表Widget是否具备权限，因此我们可能会写出如下程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">bool</span> highPriority = features(w)[<span class="number">5</span>];<span class="comment">//is w high priority?</span></span><br><span class="line">processWidget(w, highPriority);<span class="comment">//process w in accord with its priority</span></span><br></pre></td></tr></table></figure><br>上述代码将会运行正常，但如果我们使用auto代替显式的类型声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = features(w)[<span class="number">5</span>];</span><br><span class="line">processWidget(w, highPriority);</span><br></pre></td></tr></table></figure><br>上述代码仍然能够通过编译，只是其行为不可预料。原因很简单，vector&lt;bool&gt;返回的并不是一个bool类型，而是一个代理类对象的引用，从而导致上述函数无法被正确运行（详见Effective STL Item18）。<br>在原始程序中，highPriority发生了一次隐式类型转换，而auto只会如实推衍类型（一个reference-to-bit），不会发生任何类型转换。除此之外，我们在进一步剖析上述程序时会发现，feature(w)生成了一个临时的Vector，highPriority作为其内部元素的一个引用，在语句结束后不可避免地成为了空悬指针，这也就是函数行为不可预料的原因所在。 </p>
<hr>
<h1 id="proxy-class"><a href="#proxy-class" class="headerlink" title="proxy class"></a>proxy class</h1><p>&nbsp;<br>不仅仅vector&lt;bool&gt;存在着代理类的情况，标准库中的智能指针类型在某种意义上也是负责管理内存资源的代理类。事实上，设计模式中的代理模式在程序设计中十分流行，有些代理类对于用户而言是显然的，例如std::shared_ptr与std::unique_ptr，但有一些被设计为对用户不可见，例如std::vector&lt;bool&gt;::reference。</p>
<p>除此之外，某些C++库中的class使用了一种名为”expression template”的技术，这项技术的目的主要在于提高数学计算效率。举例而言，现有矩阵计算表达式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix sum = m1 + m2 + m3 + m4;</span><br></pre></td></tr></table></figure><br>如果使用了”expression template”技术，那么operator+返回的并非是计算结果，而是一个代理类，例如Sum&lt;Matrix,Matrix&gt;之类（此技术的详细说明详见More Effective C++ Item17）。operator=执行了一次隐式类型转换，但如果我们采用auto声明变量，恐怕会得出sum的类型为Sum&lt;Sum&lt;Sum&lt;Matrix, Matrix&gt;,Matrix&gt;, Matrix&gt;。</p>
<p>隐性代理类与auto配合不甚默契，因为它们的生存期往往十分短暂（语句结束即完成析构），因此创建这些类型的变量往往会违反基本设计原则，其往往带来未定义后果。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> someVar = expression of <span class="string">"invisible"</span> proxy class type;</span><br></pre></td></tr></table></figure>
<p>这种写法固然不可取，但如何避免出现这类表达式呢？</p>
<p>首先，我们应当学习如何找到隐性代理类。尽管它们难以被开发者所察觉，但库通常会记录下它们的行为，你对库越熟，那么你越不可能忽视这些代理类的使用。即使文档中没有给出介绍，头文件也会忠实地反应出代理类的使用情况，例如vector&lt;bool&gt; operator[]声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123; <span class="comment">// from C++ Standards</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">vector</span>&lt;bool, Allocator&gt; &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        …</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">reference</span> &#123;</span> … &#125;;</span><br><span class="line">        reference <span class="keyword">operator</span>[](size_type n);</span><br><span class="line">        …</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以一目了然地发现vector&lt;bool&gt;返回了一个代理类。</p>
<p>在实际开发过程中，许多人只有在他们试图追踪编译问题或不正确的单元测试结果时才会发现使用代理类的存在。但不管你是怎么找到它们的，即使auto推衍得到了某个代理类类型，但我们仍然没有放弃使用auto的理由。auto本身并不是问题，问题是auto无法推衍出我们想要的类型，因此解决方案很简单：我们强制auto推衍为正确的类型，这种手法被本书作者称为“the explicitly typed initializer”。 idiom”。其基本表现形式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(features(w)[<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">auto</span> sum = <span class="keyword">static_cast</span>&lt;Matrix&gt;(m1 + m2 + m3 + m4);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>隐性代理类可能会导致auto推衍出“错误”的类型。</strong></li>
<li><strong>我们可以使用the explicitly typed initializer加以修正。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>9.慎重选择删除元素的方法</title>
    <url>/2018/04/08/%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="删除某个值-10"><a href="#删除某个值-10" class="headerlink" title="删除某个值&#10;"></a>删除某个值&#10;</h1><p>假设我们有一个容器，其内部元素类型为int.现在需要删除容器c内所有值为1963的元素，值得注意的是，完成这项任务的方法因不同的容器类型而不同，<strong>无通用解</strong>。</p>
<h2 id="连续内存容器（vector-deque-string"><a href="#连续内存容器（vector-deque-string" class="headerlink" title="连续内存容器（vector,deque,string)"></a>连续内存容器（vector,deque,string)</h2><p>最好的删除操作是erase—remove惯用法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.erase(<span class="built_in">remove</span>(c.<span class="built_in">begin</span>()，c.<span class="built_in">end</span>()，<span class="number">1963</span>)，c.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>list也可以用erase_remove，但是最好直接使用remove：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">remove</span>(<span class="number">1963</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="标准关联容器"><a href="#标准关联容器" class="headerlink" title="标准关联容器"></a>标准关联容器</h2><p>标准关联容器没有remove成员函数，其删除操作的正确做法是使用erase<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.erase(<span class="number">1963</span>);</span><br></pre></td></tr></table></figure><br>这种做法兼具高效性与正确性，对数时间开销，同时<strong>关联容器的erase基于等价而非相等</strong>。(详见Effective STL 19）</p>
<hr>
<h1 id="删除所有符合条件的值"><a href="#删除所有符合条件的值" class="headerlink" title="删除所有符合条件的值"></a>删除所有符合条件的值</h1><h2 id="序列容器（连续内存容器与list）"><a href="#序列容器（连续内存容器与list）" class="headerlink" title="序列容器（连续内存容器与list）"></a>序列容器（连续内存容器与list）</h2><p>我们只需要把remove改为remove_if<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">badValue</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">c.erase(remove_if(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),badValue),c.<span class="built_in">end</span>());<span class="comment">//连续内存容器</span></span><br><span class="line">c.remove_if(badValue); <span class="comment">//list</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p>对于关联容器，一般有两种方法来处理这一情况，一个容易编码，一个高效。</p>
<h3 id="容易编码的方法"><a href="#容易编码的方法" class="headerlink" title="容易编码的方法"></a>容易编码的方法</h3><p>其原理为：remove_copy_if把我们需要的值拷贝到新容器中，然后把原容器内容与新容器的交换：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c; </span><br><span class="line">... </span><br><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; goodValues; <span class="comment">//临时容器</span></span><br><span class="line">remove_copy_if(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), inserter(goodValues, goodValues.<span class="built_in">end</span>()), badValue);</span><br><span class="line">c.swap(goodValues); <span class="comment">// 交换c和goodValues</span></span><br></pre></td></tr></table></figure><br>这种方法的缺点是它拷贝了所有不删除的元素,直接造成了效率极低。</p>
<h3 id="高效的方法"><a href="#高效的方法" class="headerlink" title="高效的方法"></a>高效的方法</h3><p>其直接从容器中删除元素，不过关联容器没有remove_if之类的成员函数，所以必须通过循环来完成，首先给出一个错误案例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>(); i!= c.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (badValue(*i)) c.erase(i);<span class="comment">//未考虑迭代器失效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了避免迭代器失效，我们必须保证<strong>在调用erase之前就得到了c中下一个元素的迭代器</strong>，所以有正确写法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();<span class="comment">/*nothing*/</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span> (badValue(*i)) c.erase(i++); <span class="comment">//如果需要删除，删除当前位置并自增迭代器</span></span><br><span class="line"><span class="keyword">else</span> ++i;<span class="comment">//不需要删除则直接递增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="删除元素后记录日志"><a href="#删除元素后记录日志" class="headerlink" title="删除元素后记录日志"></a>删除元素后记录日志</h1><h2 id="关联容器-1"><a href="#关联容器-1" class="headerlink" title="关联容器"></a>关联容器</h2><p>对于关联容器，只要在循环内部增加一条语句即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream logFile; <span class="comment">//日志文件</span></span><br><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>();i !=c.<span class="built_in">end</span>();)&#123;</span><br><span class="line">    <span class="keyword">if</span> (badValue(*i))&#123;</span><br><span class="line">        logFile &lt;&lt; <span class="string">"Erasing "</span> &lt;&lt; *i &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//写日志文件</span></span><br><span class="line">        c.erase(i++); <span class="comment">// 删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="连续内存容器"><a href="#连续内存容器" class="headerlink" title="连续内存容器"></a>连续内存容器</h2><p>与关联容器不同，连续容器的erase不仅令当前迭代器失效，也同时令后面的迭代器失效。所以我们必须利用<strong>erase返回被删除元素之后的元素的迭代器</strong>的特性，完成操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>();i != c.<span class="built_in">end</span>();)&#123;</span><br><span class="line">    <span class="keyword">if</span> (badValue(*i))&#123;</span><br><span class="line">        logFile &lt;&lt; <span class="string">"Erasing "</span> &lt;&lt; *i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        i = c.erase(i);<span class="comment">//利用返回值，也是C++ primer描述容器删除时使用的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h2><p>对于list，上述两种方法都行。</p>
<hr>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>去除容器内有特定值的对象，连续容器使用erase-remove，list使用remove，关联容器使用erase</li>
<li>去除满足某个判定式的所有对象，连续容器使用erase-remove_if，list使用remove_if，关联容器则使用remove_cooy_if与swap，或者使用循环（记得后置递增）</li>
<li>需要在循环中做操作时，连续内存容器记得要利用erase返回值更新迭代器，关联容器同2。</li>
</ol>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>34.尽量以lambda取代std::bind</title>
    <url>/2018/07/17/%E5%B0%BD%E9%87%8F%E4%BB%A5lambda%E5%8F%96%E4%BB%A3std%20bind/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>std::bind是C++98中std::bind1st和std::bind2nd的C++11继承者，但C++11引入的lambda几乎全面优于std::bind,并且C++14中lambda得到了更进一步地加强。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>在Item32中，我们曾经提及std:bind返回一个bind对象。我们可以认为，lambda优于bind的最主要原因在于lambda具备更高的可读性，下文中的实例将证明这一点。<br>假定当前有一个声音报警函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Time = <span class="built_in">std</span>::chrono::steady_clock::time_point;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Sound</span> &#123;</span> Beep, Siren, Whistle &#125;;</span><br><span class="line"><span class="keyword">using</span> Duration = <span class="built_in">std</span>::chrono::steady_clock::duration;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d)</span></span>;</span><br></pre></td></tr></table></figure><br>进一步地，我们假定警报将在设定完成后经过1小时触发，并且持续30s。目前尚未明确的是警报选用何种声音，因此我们可以编写一个lambda来完成设定：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL =[](Sound s)&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line">    setAlarm(steady_clock::now() + hours(<span class="number">1</span>),s,seconds(<span class="number">30</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>C++14支持时间后缀（s、ms、h等等），它们位于命名空间std::literals之中，因此上述代码可以进一步被简化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL =[](Sound s)&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals;</span><br><span class="line">    setAlarm(steady_clock::now() + <span class="number">1</span>h,s,<span class="number">30</span>s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="有关bind的第一次尝试"><a href="#有关bind的第一次尝试" class="headerlink" title="有关bind的第一次尝试"></a>有关bind的第一次尝试</h2><p>我们试图用std::bind完成上述功能:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders; <span class="comment">// needed for use of "_1"</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = <span class="built_in">std</span>::bind(setAlarm,</span><br><span class="line">    steady_clock::now() + <span class="number">1</span>h, <span class="comment">// incorrect! see below</span></span><br><span class="line">    _1,</span><br><span class="line">    <span class="number">30</span>s);</span><br></pre></td></tr></table></figure><br>这段代码的读者只需知道调用setSoundB是将会触发setAlarm的调用。<code>_1</code>的含义是：将setSoundB的第一个参数作为setAlarm的第二个参数。在调用std::bind时并不能明确此参数的类型，因此读者必须查阅setAlarm声明以确认要传递给setSoundB的参数类型。</p>
<p>上述代码并不正确。在lambda中，表达式“steady_clock::now（）+ 1h”是setAlarm的参数，调用setAlarm时将对其进行求值（evaluate），因此完成在setAlarm后1小时触发报警。 但在std :: bind调用中，“steady_clock::now（）+ 1h”是传递给std::bind的参数，而不是传给setAlarm，这意味着将在调用std::bind时完成表达式求值，也就是在调用std::bind一小时后触发警报。</p>
<hr>
<h2 id="有关bind的第二次尝试"><a href="#有关bind的第二次尝试" class="headerlink" title="有关bind的第二次尝试"></a>有关bind的第二次尝试</h2><p>修复上述问题的关键在于令std::bind明确在调用setAlarm前推迟对表达式的求值，为此我们需要引入第二个bind：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB =<span class="built_in">std</span>::bind(setAlarm,<span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;&gt;(), steady_clock::now(), <span class="number">1</span>h),_1,<span class="number">30</span>s);</span><br></pre></td></tr></table></figure><br>如果熟悉C++98中的std::plus模板的话，你可能会惊讶地发现当前模板并未指定模板参数，即我们撰写的是“std::plus&lt;&gt;”而非 “std::plus&lt;type&gt;”。原因在于C++14中通常可以省略标准运算符模板的模板类型参数，因此不需要在此处提供它。 C+ 11没有提供这样的功能，因此与lambda等效的C++11 std::bind需要写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line"><span class="keyword">auto</span> setSoundB =<span class="built_in">std</span>::bind(setAlarm,</span><br><span class="line">                <span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;steady_clock::time_point&gt;(),steady_clock::now(),hours(<span class="number">1</span>)),</span><br><span class="line">                _1,</span><br><span class="line">                seconds(<span class="number">30</span>));</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="引入重载后的问题实例"><a href="#引入重载后的问题实例" class="headerlink" title="引入重载后的问题实例"></a>引入重载后的问题实例</h1><p>&nbsp;<br>当setAlarm添加了重载函数后，问题再次产生了变化。假定当前我们除了可以设定声音类型外，还可以设定声音大小：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Volume</span> &#123;</span> Normal, Loud, LoudPlusPlus &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d, Volume v)</span></span>;</span><br></pre></td></tr></table></figure><br>lambda运行得照样很流畅，因为它将直接调用setALarm的三参数版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s)&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line">    setAlarm(steady_clock::now() + <span class="number">1</span>h,s,<span class="number">30</span>s); <span class="comment">// calls 3-arg version of setAlarm</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>但bind则无法通过编译，原因在于它并不能确定调用哪个setAlarm:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error! which setAlarm?</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB =<span class="built_in">std</span>::bind(setAlarm,<span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;&gt;(), steady_clock::now(), <span class="number">1</span>h),_1,<span class="number">30</span>s);</span><br></pre></td></tr></table></figure><br>为了解决这一问题，必须将setAlarm转换为正确的函数指针类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SetAlarm3ParamType = <span class="keyword">void</span>(*)(Time t, Sound s, Duration d);</span><br><span class="line"><span class="keyword">auto</span> setSoundB = <span class="built_in">std</span>::bind(<span class="keyword">static_cast</span>&lt;SetAlarm3ParamType&gt;(setAlarm),</span><br><span class="line">                           <span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;&gt;(),steady_clock::now(),<span class="number">1</span>h),</span><br><span class="line">                           _1,</span><br><span class="line">                           <span class="number">30</span>s)</span><br></pre></td></tr></table></figure><br>但这会带来lambda和std::bind之间的另一大区别。在setSoundL的operator()（即lambda所生成的closure class的operator()）中，对setAlarm的调用是一个普通的函数调用，因此可以通过编译器完成内联：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">setSoundL(Sound::Siren); <span class="comment">// body of setAlarm may well be inlined here</span></span><br></pre></td></tr></table></figure><br>但在std::bind的调用中，编译器将函数指针传递给setAlarm，这意味着在setSoundB的operator()内（即bind对象的operator()），对setAlarm的调用通过函数指针完成。编译器不太可能通过函数指针内联函数调用，这意味着std::bind的内联程度往往低于lambda版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">setSoundB(Sound::Siren); <span class="comment">// body of setAlarm is less likely to be inlined here</span></span><br></pre></td></tr></table></figure><br>因此，使用lambda在效率上亦可能优于bind。</p>
<hr>
<h1 id="问题实例二"><a href="#问题实例二" class="headerlink" title="问题实例二"></a>问题实例二</h1><p>&nbsp;<br>setAlarm示例仅涉及一个简单的函数调用,lambda在复杂事物的处理中将更加大放异彩。考虑如下所示的C++14 lambda，它返回其参数是否在最小值（lowVal）和最大值（highVal）之间，其中lowVal和highVal是局部变量：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> betweenL =[lowVal, highVal](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val)&#123; <span class="keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal; &#125;;</span><br></pre></td></tr></table></figure><br>C++11不支持在lambda中使用auto，因此其形式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> betweenL = [lowVal, highVal](<span class="keyword">int</span> val)&#123; <span class="keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal; &#125;;</span><br></pre></td></tr></table></figure><br>std::bind也能完成同样的工作，只是过于晦涩：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line"><span class="keyword">auto</span> betweenB =<span class="built_in">std</span>::bind(<span class="built_in">std</span>::logical_and&lt;&gt;(),<span class="comment">// C++14</span></span><br><span class="line">                         <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;&gt;(), lowVal, _1),</span><br><span class="line">                         <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;&gt;(), _1, highVal));</span><br></pre></td></tr></table></figure><br>C++11所需要的代码量更多：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> betweenB =<span class="built_in">std</span>::bind(<span class="built_in">std</span>::logical_and&lt;<span class="keyword">bool</span>&gt;(),</span><br><span class="line">                         <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(), lowVal, _1),</span><br><span class="line">                         <span class="built_in">std</span>::bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(), _1, highVal));</span><br></pre></td></tr></table></figure><br>显然，lambda版本代码量更少，且具有更高的可读性与可维护性。</p>
<hr>
<h1 id="std-bind的些许晦涩之处"><a href="#std-bind的些许晦涩之处" class="headerlink" title="std::bind的些许晦涩之处"></a>std::bind的些许晦涩之处</h1><p>&nbsp;<br>前文中出现的<code>_1</code>可能会令某些从未接触过std::bind的读者大感神奇，但std::bind的晦涩之处不止如此。假定当前我们有一个函数来创建Widget的压缩副本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CompLevel</span> &#123;</span> Low, Normal, High &#125;; <span class="comment">// compression level</span></span><br><span class="line"><span class="function">Widget <span class="title">compress</span><span class="params">(<span class="keyword">const</span> Widget&amp; w, CompLevel lev)</span></span>; <span class="comment">// make compressed copy of w</span></span><br></pre></td></tr></table></figure><br>更进一步地，我们希望创建一个函数对象，它允许我们指定压缩品质，std::bind有实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line"><span class="keyword">auto</span> compressRateB = <span class="built_in">std</span>::bind(compress, w, _1);</span><br></pre></td></tr></table></figure><br>显然，当我们将w传递给std::bind时，必须将其存储于bind对象内部以便于后期的压缩函数调用。但本次实现是以refernece还是value方式存储？若以引用存储，w在调用bind对象之前发生的改变将反应于compress之中，否则不然。答案是std::bind按值存储，std::bind表达式并不表明其存储方式（这意味着你只能硬生生记下来），这一点与lambda的显式声明并不相同：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// w is captured by value; lev is passed by value</span></span><br><span class="line"><span class="keyword">auto</span> compressRateL =[w](CompLevel lev)&#123; <span class="keyword">return</span> compress(w, lev); &#125;;</span><br></pre></td></tr></table></figure><br>以何种方式将参数传递给lambda也十分明确：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">compressRateL(CompLevel::High); <span class="comment">// arg is passed by value</span></span><br></pre></td></tr></table></figure><br>但std::bind则不然：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">compressRateB(CompLevel::High); <span class="comment">// how is arg passed?</span></span><br></pre></td></tr></table></figure><br>同样，唯一知道传入参数方式的方法是记住std::bind的工作原理。（答案是传递给bind对象的所有参数都是by-reference，因为这些对象的operator()使用完美转发。）</p>
<hr>
<h1 id="std-bind的可用之处"><a href="#std-bind的可用之处" class="headerlink" title="std::bind的可用之处"></a>std::bind的可用之处</h1><p>&nbsp;<br>在C++14中std::bind全面落后于lambda，但在C++11中它存在两点用武之地：</p>
<ol>
<li><strong>移动捕获</strong><br>（详见Item32）</li>
<li><strong>多态函数对象</strong><br>因为bind对象的operator()使用完美转发，所以它可以接受任何类型的参数,因此当你想要讲一个对象绑定至模板函数operator()将非常有用，例如以下实例：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolyWidget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
std::bind可以用如下形式绑定一个PolyWidget：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PolyWidget pw;</span><br><span class="line"><span class="keyword">auto</span> boundPW = <span class="built_in">std</span>::bind(pw, _1);</span><br></pre></td></tr></table></figure>
boundPW则可以通过多种参数完成调用：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boundPW(<span class="number">1930</span>); <span class="comment">// pass int to PolyWidget::operator()</span></span><br><span class="line">boundPW(<span class="literal">nullptr</span>); <span class="comment">// pass nullptr to PolyWidget::operator()</span></span><br><span class="line">boundPW(<span class="string">"Rosebud"</span>); <span class="comment">// pass string literal to PolyWidget::operator()</span></span><br></pre></td></tr></table></figure>
C++11无法模拟出上述情形，C++14可以通过auto来解决：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> boundPW = [pw](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; param)&#123; pw(param); &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>lambda在可读性与效率上均优于std::bind。</li>
<li>C++11中可以利用std::bind实现移动捕获与将对象绑定至模板化operator()。</li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>33.当需要forward auto&amp;&amp;参数时，记得采用decltype</title>
    <url>/2018/07/16/%E5%BD%93%E9%9C%80%E8%A6%81forward%20auto&amp;&amp;%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E8%AE%B0%E5%BE%97%E9%87%87%E7%94%A8decltype/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>C++14提供了一项新特性：允许开发者们在lambda中使用auto。实现它并不困难，无非就是把closure class的operator()变为了template而已。举例而言，对于下述lambda：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x)&#123; <span class="keyword">return</span> func(normalize(x)); &#125;;</span><br></pre></td></tr></table></figure><br>其生成的closure class的operator()大致有如下形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCompilerGeneratedClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> func(normalize(x)); &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，lambda只负责将其参数x转发至normalize。如果normalize区分左右值的话，该lambda无法正确写入，原因在于参数x永远是一个左值，lambda永远将一个左值传递给normalize。</p>
<p>修改方法很容易：使用完美转发。这意味着x将成为一个universal reference，并且需要使用std::forward,不过这些都只是微不足道的小小修改：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x)&#123; <span class="keyword">return</span> func(normalize(<span class="built_in">std</span>::forward&lt;???&gt;(x))); &#125;;</span><br></pre></td></tr></table></figure><br>唯一存在疑问的地方在于，forward的模板参数应该是何种类型？</p>
<p>在通常情况下，完美转发存在于一个模板参数为T的模板函数中，因此我们在使用时只需要编写std::forward &lt;T&gt;即可，但lambda中不存在模板参数，因此我们写不了。</p>
<hr>
<h1 id="问题剖析与解决"><a href="#问题剖析与解决" class="headerlink" title="问题剖析与解决"></a>问题剖析与解决</h1><p>&nbsp;<br>众所周知，universal reference的性质由其初始化对象决定，若由左值初始化则变为左值引用，反之则为右值引用，因此我们可以通过判断x的类型来推断传递的参数是左值还是右值，此时decltype帮了大忙。如果传入的是左值，那么x必然是左值引用，反之则必为右值引用。但Item28亦曾提及，若传入左值，那么此时推衍类型T为左值引用，但如果传入右值，则推衍T为non-reference，这与decltype（x)将表现为右值引用有所背离。</p>
<p>如下是C++14中std::forward的实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果当前客户端需要forward一个右值Widget，此时forward将被实例化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但如果当T被指定为Widget&amp;&amp;时，forward实例化如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行引用塌缩之后，forward转为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，当我们将右值引用传入forward时，其效果与non-reference相同。这无疑是一个好消息，这意味着我们把decltype(x)的结果（右值引用）传递给forward时，其展现出的效果与non-reference一致，因此，完美转发可以被写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f =[](<span class="keyword">auto</span>&amp;&amp; param)&#123;<span class="keyword">return</span> func(normalize(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param)));&#125;;</span><br></pre></td></tr></table></figure><br>如果当前需要转发的是一个参数集，那么在C++14中它可以被写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f =[](<span class="keyword">auto</span>&amp;&amp;... params)&#123;<span class="keyword">return</span> func(normalize(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...));&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>15.尽量使用constexpr</title>
    <url>/2018/07/02/%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8constexpr/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>constexpr应用于对象时，其类似于const的加强版，但其应用于函数时的意义却与此大相径庭。从概念而言，constexpr不仅仅表示一个常量，也表示该量在编译期即可明确。然而，在constexpr function中，constexpr未必代表着编译期取值，甚至未必能保证const。</p>
<hr>
<h1 id="constexpr-objects"><a href="#constexpr-objects" class="headerlink" title="constexpr objects"></a>constexpr objects</h1><p>&nbsp;<br>constexpr对象具备const属性，其值在编译期已知。（从技术层面来说，其值决定于translation时期，也就是编译期和链接期，但这一点并不重要，除非你需要自己写一个C++的编译器和链接器，不然你总可以认为constexpr对象的值在编译期即已确定）。</p>
<p>编译期即被明确的值具有一定的特权，例如它们可能会被存于只读存储器中，对于嵌入式开发者来说这或许是一个非常重要的特性，但其更广泛适用于C++编译期需要整型常量表达式的环境中，例如数组长度说明、整型模板参数设定、枚举量设定、齐位说明符设定等等。当你需要将一个变量应用于上述环境时，将其声明为constexpr即等效于向编译器保证其可在编译期求值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sz; <span class="comment">// non-constexpr variable</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz; <span class="comment">// error! sz's value not known at compilation</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, sz&gt; data1; <span class="comment">// error! same problem</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>; <span class="comment">// fine, 10 is a compile-time constant</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize2&gt; data2; <span class="comment">// fine, arraySize2 is constexpr</span></span><br></pre></td></tr></table></figure><br>需要注意的是const并不具备编译期明确其值的能力：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sz; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> arraySize = sz; <span class="comment">// fine, arraySize is const copy of sz</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize&gt; data; <span class="comment">// error! arraySize's value not known at compilation</span></span><br></pre></td></tr></table></figure><br>简而言之，所有的constexpr对象都是const的，但并不是所有的const对象都是constexpr。仅有constexpr对象具备编译期明确其值的能力。</p>
<hr>
<h1 id="constexpr-function"><a href="#constexpr-function" class="headerlink" title="constexpr function"></a>constexpr function</h1><p>&nbsp;<br>constexpr function的情况与其使用情境相关，如果你以一个compile-time constants调用constexpr function，该函数会产生一个compile-time constants，而如果你以一个runtime values调用它，它则会产生一个runtime value。</p>
<h2 id="constexpr-function的用途"><a href="#constexpr-function的用途" class="headerlink" title="constexpr function的用途"></a>constexpr function的用途</h2><ol>
<li><strong>用于必需compile-time constants的环境下（例如数组长度）</strong><br>如果你传入的参数可在编译期获得，那么constexpr function会在编译期产生结果，反之只要有一个参数不符合compile-time，则代码将无法通过编译。</li>
<li><strong>减少代码重复</strong><br>当一个constexpr函数被一个或多个runtime values调用时，它会按照普通函数的形式运行。这意味着我们不需要在开发时区分compile-time value与runtime value。</li>
</ol>
<hr>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>&nbsp;<br>假设我们需要一个数据结构以保存各种实验条件下的运行结果，实验条件条件可能有光照等级、风扇速度、室内温度等等。如果可变的实验条件共有n个，每个实验条件又存在3种状态，那么本实验共有3^n种组合，因此我们需要一个可以容纳3^n个实验结果的数据结构。假定每一个结果均为int类型且n在编译期已知（或可被计算），那么std::array似乎可以适用于本次设计，但我们还需要一种方式以在编译期计算出3^n具体的大小。std::pow可以完成我们想要的计算，但它存在两个问题：1、工作于浮点数；2、不具备constexpr属性。因此我们无法使用它来在编译期计算std::array的大小。</p>
<p>不过我们可以自己完成pow的编写。在定义它之前，我们先看看它应当被如何声明与使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    … <span class="comment">// impl is below</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> numConds = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="built_in">pow</span>(3, numConds)&gt; results;</span><br></pre></td></tr></table></figure><br>pow前面的constexpr并不表明pow返回一个const值，它表示如果base和exp是编译时常量，那么pow的结果可以用作编译时常量。 如果base或exp不是编译时常量，pow的结果将在运行时计算。这意味着pow不仅用于在编译期计算std::array的大小，还可以在运行时环境中调用它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> base = readFromDB(<span class="string">"base"</span>); <span class="comment">// get these values</span></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">exp</span> = readFromDB(<span class="string">"exponent"</span>); <span class="comment">// at runtime</span></span><br><span class="line"><span class="keyword">auto</span> baseToExp = <span class="built_in">pow</span>(base, <span class="built_in">exp</span>); <span class="comment">// call pow function at runtime</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="constexpr的限制条件"><a href="#constexpr的限制条件" class="headerlink" title="constexpr的限制条件"></a>constexpr的限制条件</h2><p>&nbsp;<br>当传入参数是一个compile-time value时，constexpr function必然compile-time value，因此它的实现方式存在一些限制，并且在C++11与C++14中这些限制不尽相同。</p>
<p>在C++11中，constexpr函数只允许包含一个可执行语句：return语句，但实际上我们可以用两种方法钻空子。首先，我们可以使用条件”?:”运算符来代替if-else语句；其次，我们可以使用递归来代替循环。因此，pow可被实现为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, <span class="built_in">exp</span> - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>想必除了函数式语言开发者之外没人会觉得上述代码比较优雅直观。C++14对于constexpr的限制较为宽泛，因此我们可以自由地写出这样的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">exp</span>; ++i) result *= base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>constexpr函数的参数与返回值均限定为literal type，因为仅有该类型可在编译期确定。 在C++11中，除void之外的所有内置类型均为literal type，但用户自定义类型也可能是literal type，因为其构造函数和其他成员函数可能具备constexpr属性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr Point(double xVal = 0, double yVal = 0) noexcept: x(xVal), y(yVal)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>值得注意的是在上述定义中Point构造函数被声明为constexpr，原因在于如果在编译期间传给构造函数的参数已知，那么在编译期Point内部数据成员均已确定，那么这种初始化得到的point具备constexpr属性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>; <span class="comment">// fine, "runs" constexpr ctor during compilation</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>; <span class="comment">// also fine</span></span><br></pre></td></tr></table></figure><br>同样地，xValue和yValue也可以是constexpr，如果在constexpr Point对象上调用getter，则可以在编译期间知道数据成员x和y的值。如此则可以用这些函数的结果初始化constexpr对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midpoint</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (p1.xValue() + p2.xValue()) / <span class="number">2</span>,</span><br><span class="line">             (p1.yValue() + p2.yValue()) / <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br></pre></td></tr></table></figure><br>这种操作手法十分高妙，尽管mid的初始化操作涉及构造函数、getter函数、非成员函数，但最终我们在只读内存中完成了对它的创建。这种技法意味着编译期与运行期的界限开始趋于模糊，并且以往在运行期才能完成的操作如今可以提前至编译期完成。参与提前的代码越多，运行速度越快（当然编译速度会有所降低）。</p>
<p>在C++11中，两个限制阻止了Point的成员函数setX和setY被声明为constexpr。首先，它们能够修改*this，而在C++11中，constexpr成员函数被隐式的认为具备const属性。 其次，它们具有void返回类型，而void在C++11中不属于literal type。这两个限制都在C++14中得到了解除，所以在C++14中，Point的setter也可被声明为constexpr：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>因此下述函数成为了可能：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//return reflection of p with respect to the origin (C++14)</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    Point result; <span class="comment">// create non-const Point</span></span><br><span class="line">    result.setX(-p.xValue()); <span class="comment">// set its x and y values</span></span><br><span class="line">    result.setY(-p.yValue());</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// return copy of it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>客户端程序看起来可能如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>; <span class="comment">// as above</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid = reflection(mid); <span class="comment">// known during compilation</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="constexpr的意义"><a href="#constexpr的意义" class="headerlink" title="constexpr的意义"></a>constexpr的意义</h1><p>&nbsp;<br>constexpr对象和constexpr函数的使用范围均大于non-constexpr对象与函数，通过尽可能使用constexpr，对象与函数的使用范围得到了扩大。</p>
<p>constexpr类似于const、noexcept，是对象和函数接口的一部分，如果一个对象或函数被声明为constexpr，则意味着它可以在任何需要常量表达式的环境中使用。如果你将某个对象或函数声明为constexpr后又后会做出了这个决定，并且将constexpr撤销，那么可能会导致无数的客户端程序发生了雪崩。我们这里所说的尽可能，指的是在你愿意付出精力长期维系它们为constexpr的情况下。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>constexpr对象具有const属性，并且其值在编译期即可确定。</strong></li>
<li><strong>constexpr函数在其调用对象为compile-time value时会产生compile-time value。</strong></li>
<li><strong>constexpr对象与函数的使用范围大于non-constexpr。</strong></li>
<li><strong>constexpr是对象或函数接口的一部分。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>36.必须异步时请使用std::launch::async</title>
    <url>/2018/07/17/%E5%BF%85%E9%A1%BB%E5%BC%82%E6%AD%A5%E6%97%B6%E8%AF%B7%E4%BD%BF%E7%94%A8stdlaunchasync/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>当开发者决定异步执行某函数或其他可调用对象时，往往会选择调用std::async，但实际上这种做法并没有要求异步执行，当你明确需要使用异步时，你应当使用std::launch::async。</p>
<hr>
<h1 id="启动策略"><a href="#启动策略" class="headerlink" title="启动策略"></a>启动策略</h1><p>&nbsp;<br>std::lauch是一个enum class，其中含有两个枚举量，分别代表着不同的异步启动策略。假定当前存在一个函数f被传递至std::async</p>
<ol>
<li><strong>std::launch::async launch policy意味着函数f必然将运行于另一个线程之上（即异步运行）</strong></li>
<li><strong>std::launch::deferred launch policy意味着f只有在std::async返回的future对象上调用get或wait时才会运行</strong><br>换而言之，f的执行被推迟至调用get或wait时。当调用get或wait时，f将<strong>同步</strong>执行（即调用程序将阻塞，直到f完成运行）。如果一直不调用get或wait，f将永不执行。</li>
</ol>
<h2 id="默认启动策略"><a href="#默认启动策略" class="headerlink" title="默认启动策略"></a>默认启动策略</h2><p>更加让人惊讶地是，std::async的默认启动策略并非是二者中的某一种，而是二者的综合，也就是说下述两种调用其实时等价的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut1 = <span class="built_in">std</span>::async(f); <span class="comment">// run f using default launch policy</span></span><br><span class="line"><span class="keyword">auto</span> fut2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async|<span class="built_in">std</span>::launch::deferred,f);</span><br></pre></td></tr></table></figure><br>因此，默认启动策略允许f以异步或同步方式运行。如Item35所述，这种灵活性允许std::async与标准库中线程管理组件承担线程的创建和销毁任务，避免触发oversubscription以及保证负载均衡，因此使用std::async可以保证开发者能够高效完成并发编程。</p>
<hr>
<h1 id="默认启动策略特性"><a href="#默认启动策略特性" class="headerlink" title="默认启动策略特性"></a>默认启动策略特性</h1><p>std::async的默认启动策略还有一些值得一提的因素。假设当前存在一个线程t正在执行以下语句：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(f); <span class="comment">// run f using default launch policy</span></span><br></pre></td></tr></table></figure><br>我们将得出以下结论：</p>
<ol>
<li>无法预测f是否将与t同时运行，因为f可能被安排为推迟执行（因为不明确调用get或wait的时机）。</li>
<li>无法预测f是否会在一个不同于调用fut之get或wait的线程上执行，本例即无法预测f的执行线程是否不同于t。</li>
<li>无法预测f是否会运行，因为可能无法保证在程序的所有路径上都会调用fut的get或wait。</li>
</ol>
<p>默认启动策略几乎不能与thread_local变量混用，因为混用意味着f要读或写thread-local storage（TLS） ，但我们并不知道究竟会访问哪一个线程中的变量：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TLS for f possibly for independent thread, but possibly for thread invoking get or wait on fut</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(f);</span><br></pre></td></tr></table></figure></p>
<p>默认启动策略还会影响使用timeout的wait-based loop，因为在被推迟的task(见Item35）上调用wait_for或wait_until会产生std::launch::deferred。这意味着以下循环看起来似乎会终止，实际上也许将永远运行：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals; <span class="comment">// for C++14 duration suffixes;see Item 34</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="comment">// f sleeps for 1 second,then returns</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(f); <span class="comment">// run f asynchronously(conceptually)</span></span><br><span class="line"><span class="keyword">while</span> (fut.wait_for(<span class="number">100</span>ms) != <span class="built_in">std</span>::future_status::<span class="built_in">ready</span>)&#123; <span class="comment">// loop until f has finished running...</span></span><br><span class="line">    …<span class="comment">// may be always runing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果f与调用std::async的线程同时运行（即启动策略为std::launch::async），那么该程序毫无问题。但如果f推迟运行，那么fut.wait_for将永远返回std::future_status::deferred，因而造成死循环。</p>
<p>这种bug在开发和单元测试阶段很容易被忽视，因为它只有在系统负载过重时才会出现。要修正该问题也很简单：只需通过std::async返回的future对象检查task是否被推迟，如果是则并不执行循环。然而不幸的是，并没有直接方法来检查tsk是否被推迟，因此我们不得不调用一个基于time-out的函数(比如wait_for)。因为我们只是需要明确task状态，而不是真的想等待什么，因此等待参数设为0s即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(f);</span><br><span class="line"><span class="keyword">if</span> (fut.wait_for(<span class="number">0</span>s) == <span class="built_in">std</span>::future_status::deferred)&#123; <span class="comment">// deferred...</span></span><br><span class="line">    … <span class="comment">// ...use wait or get on fut to call f synchronously </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// task isn't deferred</span></span><br><span class="line">    <span class="keyword">while</span> (fut.wait_for(<span class="number">100</span>ms) != <span class="built_in">std</span>::future_status::<span class="built_in">ready</span>) &#123;</span><br><span class="line">         … <span class="comment">// task is neither deferred nor ready,so do concurrent work until it's ready</span></span><br><span class="line">    &#125;</span><br><span class="line">    … <span class="comment">// fut is ready</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="默认启动策略使用条件"><a href="#默认启动策略使用条件" class="headerlink" title="默认启动策略使用条件"></a>默认启动策略使用条件</h1><p>&nbsp;<br>只要满足以下条件，我们就可以放心大胆的采用默认启动策略执行task：</p>
<ol>
<li><strong>task无需与调用wait或get的线程并行执行</strong></li>
<li><strong>无需关注存取哪个线程的thread_local变量</strong></li>
<li><strong>要么能够保证返回future对象的get或者wait方法一定会被调用，或者允许task不被执行</strong></li>
<li><strong>在使用wait_for和wait_unitl时检测task状态是否为defered</strong></li>
</ol>
<p>只要上述条件有一个不满足，那我们都应当使用std::lunch::async确保异步执行task：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, f); <span class="comment">// launch f asynchronously</span></span><br></pre></td></tr></table></figure></p>
<p>事实上，如果能有一个函数功能与std::async一样，但是自动采用std::launch::async作为启动策略，会是一个很方便的工具，但实现它也不难，以下为C++11版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Ts...)&gt;::type&gt;</span><br><span class="line">reallyAsync(F&amp;&amp; f, Ts&amp;&amp;... params)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,<span class="built_in">std</span>::forward&lt;F&gt;(f),<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++14由于返回值类型推衍的原因，实现可以得到进一步的简化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">reallyAsync</span><span class="params">(F&amp;&amp; f, Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,<span class="built_in">std</span>::forward&lt;F&gt;(f),<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>std::async的默认启动策略既同步也异步</strong></li>
<li><strong>默认启动策略可能会导致TLS访问的不确定性、以及wait_for、wait_until的使用时状态检查</strong></li>
<li><strong>如果异步执行至关重要，请采用std::launch::async启动策略</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>执行期语义学——临时性对象</title>
    <url>/2018/05/30/%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="临时对象的生成"><a href="#临时对象的生成" class="headerlink" title="临时对象的生成"></a>临时对象的生成</h1><p>&nbsp;<br>如果我们有函数如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure><br>那么在执行该函数时，可能会生成一个临时对象以存储需要传回的对象。是否会产生临时对象由很多因素决定，其中我们需要的知识点是NRV。</p>
<p>由于市场竞争的关系，大多数编译器均采取了一系列优化策略，以至于如下表达式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T c = a+b;</span><br></pre></td></tr></table></figure><br>几乎不可能产生临时对象。但值得注意的是下一种情况——与表达式意义相当的assignment statement：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c = a+b;</span><br></pre></td></tr></table></figure><br>它会直接导致临时对象的生成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T temp;</span><br><span class="line">temp.<span class="keyword">operator</span>+(a,b);</span><br><span class="line">c.<span class="keyword">operator</span>=(temp);</span><br><span class="line">temp.T::~T();</span><br></pre></td></tr></table></figure><br>我们可以认为，初始化操作总比赋值操作效率更高。<br>此外，还有一种生成临时对象的情况：没有出现目标对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a+b;</span><br></pre></td></tr></table></figure><br>这会产生一个临时对象，用以放置运算后的结果。</p>
<hr>
<h1 id="临时对象的生命期"><a href="#临时对象的生命期" class="headerlink" title="临时对象的生命期"></a>临时对象的生命期</h1><p>&nbsp;<br>在C++ standard之前，临时对象的生命期并没有明确指定，完全由各编译器生产厂商决定。而C++ standard定义如下：临时对象的被摧毁，应该是对full expression求值过程中的最后一个步骤，该表达式造成临时对象的产生。</p>
<p>什么是full expression？你可以认为是被涵括的表达式中最外围的那个：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((objA&gt;<span class="number">1024</span>) &amp;&amp; (objB&gt;<span class="number">1024</span>))?objA+objB:foo(objA,objB);</span><br></pre></td></tr></table></figure><br>比如该三目运算符表达式即为full expression，任何一个子算式产生的任何一个临时对象，都应当在完整表达式被求值完成后销毁。</p>
<p>此外，C++ standard又有两个特例：</p>
<ol>
<li><strong>凡含有表达式执行结果的临时对象，应该存留到object的初始化操作完成为止。</strong><br>这种做法提高了初始化效率，防止了另一个临时对象的生成。</li>
<li><strong>如果一个临时性对象被绑定于一个reference，对象将会被残留，直到被初始化的reference声明结束，或临时对象的生命期结束。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>执行期语义学——导读</title>
    <url>/2018/05/29/%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>当前我们有一个简单的表达式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(yy==xx.getValue()) ...</span><br></pre></td></tr></table></figure><br>其中xx与yy分别有定义为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X xx;</span><br><span class="line">Y yy;</span><br></pre></td></tr></table></figure><br>而X与Y有定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X();</span><br><span class="line">    ~X();</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">Y</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">X <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Y();</span><br><span class="line">    ~Y();</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Y&amp;) <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>在得到了上述定义之后，我们对之前那个简单的表达式进行剖析。<br>首先，我们决定equality运算符所参考到的真正实体。在本次实例中，它被resloved为“被overloaded的Y成员实体”。下面是该表达式的第一次转换：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(yy.<span class="keyword">operator</span>==(xx.getValue()))</span><br></pre></td></tr></table></figure><br>Y的equality运算符需要一个类型为Y的参数，然而getValue()传回的却是一个类型为X的object，因此，在实际执行时，上述表达式发生了隐式转换：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(yy.<span class="keyword">operator</span>==(xx.getValue().<span class="keyword">operator</span> Y()))</span><br></pre></td></tr></table></figure><br>上述扩张是编译器根据class的语意自动补全的操作，你可以明确地写出它们，这样编译速度可能会快上一丢丢。</p>
<p>实际上这并非上述表达式的完全形态，在实际使用中我们生成了相对应的临时对象，用来放置函数调用所传回的值，最终，实际表达式被扩张成为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    X temp1 = xx.getValue();</span><br><span class="line">    Y temp2 = temp1.<span class="keyword">operator</span> Y();</span><br><span class="line">    <span class="keyword">int</span> temp3 = yy.<span class="keyword">operator</span>==(temp2);</span><br><span class="line">    <span class="keyword">if</span>(temp3) ....</span><br><span class="line">    temp2.Y::~Y();</span><br><span class="line">    temp1.X::~X();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如此看来，这个表达式似乎并不简单。这也是C++的一大困难之处：无法从程序代码看出表达式的复杂程度。在本章，我们将升入探究执行期所发生的一些转换。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>执行期语义学——对象的构造与析构</title>
    <url>/2018/05/29/%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>一般而言，constructor与destructor的安插恰如其分：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Point <span class="built_in">point</span>;</span><br><span class="line">    <span class="comment">//point.Point::Point() 插入构造</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//point.Point::~Point() 插入析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果一个区段（以{}括起来的区域）或函数中有一个以上的离开点，情况又稍微混乱一些。Destructor必须被放在每一个离开点（当时object还处于存活状态）之前，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Point <span class="built_in">point</span>;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">int</span>(<span class="built_in">point</span>.x()))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="comment">//插入destructor</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">//插入destructor</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//插入destructor</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//destructor在这里行动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述实例中会生成几个destructor，甚至会在区段结束前生成一个destructor——即使程序本身根本不可能执行到那里。那么同样地，goto指令可能也需要多个destructor调用操作。<br>我们倾向于把object放置在使用它的程序区段附近，这样通常可以节约不必要的构造与析构操作。</p>
<hr>
<h1 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h1><p>&nbsp;<br>假设当前存在如下程序段：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix identity;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="comment">//identity必须被初始化</span></span><br><span class="line">    Matrix m1 = identity;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++保证，一定会在main()函数中第一次使用identity之前，将identity构造完毕，并且在main()函数结束之前把identity析构。全局对象如果存在constructor与destructor的话，我们一般称其需要静态的初始化操作与内存释放操作。</p>
<p>C++程序中所有的global objects都被置于程序的data segment中。如果明确指定给global object一个值，那么object将以该值为初始值，否则object所配置到的内存内容为0。这里和C语言存在一定的分歧，C语言不会给任何全局变量设定为0的初值。<br>我们可以认为，C++将global object在编译时期置于data segment中且内容为0，其constructor一直到程序startup时才会实施。我们必须对一个放置于program data segment中的object的初始化表达式做evaluate，这也是为什么一个object需要静态初始化的原因。</p>
<hr>
<h2 id="munch策略"><a href="#munch策略" class="headerlink" title="munch策略"></a>munch策略</h2><p>cfront有一个执行静态初始化（以及内存释放）的可移植方法munch。其策略如下：</p>
<ol>
<li>为每一个需要静态初始化的档案产生一个_sti()函数（static initialization），内带必要的constrcutor调用操作或inline expansions。例如前文所说的identity对象会在matrix.c中产生下面的_sit()函数：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> _sti_matrix_c_identity()&#123;</span><br><span class="line">    identity.Matrix::Matrix();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类似地，在每一个需要静态的内存释放操作文件中产生一个_std()函数（static deallocation），该函数内带必要的destructor调用操作，或其inline expansions。</li>
<li>提供一组runtime library “munch”函数：一个_main()函数（用以调用所有可执行文件中的_sti()函数），以及一个_exit函数（用以调用所有的_std()函数）。</li>
</ol>
<p>其执行策略如图所示：<img src="http://static.zybuluo.com/zsmj2017/6v71jxx17zy84yrjdaxtqkpk/image_1celqealem9v1eb0hhr10ip1cft9.png" alt="image_1celqealem9v1eb0hhr10ip1cft9.png-120.2kB"><br>（接下来作者以较多篇幅描述了cfont如何在众多可执行文件中找出_sti函数与_std函数，其内容有兴趣的读者可自行参阅，以及静态初始化的一些局限性）</p>
<hr>
<h1 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h1><p>&nbsp;<br>假设当前有程序片段如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Matrix&amp; <span class="title">identity</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Matrix mat_identity;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> mat_identity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Local static class object有语意如下：</p>
<ol>
<li>其constrcutor只能执行一次，尽管上述函数可能会被调用多次。</li>
<li>其destructor只能执行一次，尽管上述函数可能会被调用多次。</li>
</ol>
<p>编译器曾经的策略是无条件地在startup时构造对象，然而这会导致所有的local static class objects初始化，即使它们所在的那个函数从未被使用过。因此，应当仅在identity()被调用时构造mat_identity才是最佳选择。</p>
<p>对于上述机制，cfront有实现策略如下：首先，导入一个临时bool量以保护mat_identity的初始化操作，当第一次处理identity()时，该bool量为false，于是调用constructor，随后将临时bool量置为true。同样地，destructor也使用类似的策略。</p>
<hr>
<h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><p>&nbsp;<br>假设当前有对象数组定义式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><br>如果Point既没有定义一个constructor也没有定义一个destructor，那么编译器行为十分简单：只需要分配足够多的内存以容纳10个Point object。</p>
<p>但如果Point定义了一个default destructor，那么这个destructor必须轮流施行于每一个元素之上，一般而言，这是经由一个或多个runtime library函数达成。我们暂且将该此类函数命名为vec_new()，其基本形式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">vec_new</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* <span class="built_in">array</span>,<span class="comment">//数组起始地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> elem_size,<span class="comment">//object大小</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> elem_count,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*constructor)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*,<span class="keyword">char</span>)<span class="comment">//析构操作，在有异常抛出时释放资源</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><br>对于上述数组定义表达式，编译器真正处理操作如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec_new(&amp;knots,<span class="keyword">sizeof</span>(Point),<span class="number">10</span>,&amp;Point::Point(),<span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>类似地，对于destructor，也有vec_delete()函数如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vec_delete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *<span class="built_in">array</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> elem_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> elem_count,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*,<span class="keyword">char</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果开发者提供了一个或多个明确初值给对象数组，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>]=&#123;Point(),Point(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0.5</span>),<span class="number">0.5</span>&#125;;</span><br></pre></td></tr></table></figure><br>那么编译器将会将其转为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//明确初始化前三个</span></span><br><span class="line">Point::Point(&amp;knots[<span class="number">0</span>]);</span><br><span class="line">Point::Point(&amp;knots[<span class="number">1</span>],<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0.5</span>);</span><br><span class="line">Point::Point(&amp;knots[<span class="number">2</span>],<span class="number">0.5</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">vec_new(&amp;knots+<span class="number">3</span>,<span class="keyword">sizeof</span>(Point),<span class="number">7</span>,&amp;Point::Point,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Default-Constructors和数组"><a href="#Default-Constructors和数组" class="headerlink" title="Default Constructors和数组"></a>Default Constructors和数组</h1><p>&nbsp;<br>(本小结似乎在描述语言陋规，没看明白）</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>1.指针与引用的区别</title>
    <url>/2018/04/22/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>指针与引用似乎完全不同，前者是某个对象的地址，后者是某个对象的别名，但是功能却似乎一样，都是间接引用其他对象。那么何时用指针何时用引用呢？</p>
<hr>
<h1 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h1><p>&nbsp;<br>不存在指向空值的引用，但是存在指向空值的指针。<br>但可能会有人写出这种程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *pc = <span class="literal">nullptr</span>；<span class="keyword">char</span> &amp; rc = *pc；</span><br></pre></td></tr></table></figure><br>其结果未定义，在C++的世界里我们不讨论这种无聊且低级的错误。<br><strong>引用不存在空值，所以必须要初始化</strong>，而指针则不用，虽然这样很危险。<br>引用不存在空值这一特性说明其有效性比指针高，因为我们在指针的使用中总需要判断其非空，但引用则无需如此。</p>
<hr>
<h1 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h1><p>&nbsp;<br>指针可以被重新赋值以指向另一个不同的对象。但引用则总是指向在初始化时被指定的对象，无法改变。</p>
<hr>
<h1 id="在何种情况下使用它们"><a href="#在何种情况下使用它们" class="headerlink" title="在何种情况下使用它们"></a>在何种情况下使用它们</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>使用指针的情况是：</p>
<ul>
<li>可能会不指向任何对象</li>
<li>可能需要改变绑定</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>使用引用的情况是：</p>
<ul>
<li>一旦绑定后不再更改</li>
<li>重载某个操作符</li>
</ul>
<p>假设需要自定义<code>operator[]</code>，其功能是返回一个目标对象，其能被赋值:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v(10);</span><br><span class="line">v[5]&#x3D;10;</span><br></pre></td></tr></table></figure><br>如果<code>operator[]</code>返回值不是引用而是指针，则最后一句必须写为 <code>*v[5]=10</code>,这看起来有点像一个数组指针，容易造成不必要的误解。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>28.智能指针</title>
    <url>/2018/04/28/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>智能指针在多个领域都具备使用价值，例如资源管理与重复代码任务的自动化。</p>
<hr>
<h1 id="智能指针相对于raw-pointer的优点"><a href="#智能指针相对于raw-pointer的优点" class="headerlink" title="智能指针相对于raw pointer的优点"></a>智能指针相对于raw pointer的优点</h1><p>&nbsp;</p>
<ol>
<li>构造、析构<br>智能指针将完美初始化，并且智能指针的析构会负责对象的释放。</li>
<li>拷贝与赋值操作<br>可以自由地深拷贝，或者指针拷贝，又或者禁止这些行为。</li>
<li>解引用<br>自行决定解引用功能，比如用它来实现lazy-fetching.</li>
</ol>
<hr>
<h1 id="智能指针的实现雏形"><a href="#智能指针的实现雏形" class="headerlink" title="智能指针的实现雏形"></a>智能指针的实现雏形</h1><p>&nbsp;<br>智能指针从模版中生成，因为要与内置指针一致，所以它们是strong-typed:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SmartPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&amp; rhs);</span><br><span class="line">    ~SmartPtr();</span><br><span class="line">    SmartPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&amp; rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;<span class="comment">//解引用</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>; <span class="comment">//解引用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不允许copy与赋值，那就应该把拷贝构造与operator=设为private。解引用对象的两个操作符设为const，因为解引用并不能改变对象本身。</p>
<hr>
<h1 id="用户如何使用智能指针"><a href="#用户如何使用智能指针" class="headerlink" title="用户如何使用智能指针"></a>用户如何使用智能指针</h1><p>&nbsp;<br>假设存在一个分布式系统（对象一些在本地一些在远程），采用不同的方法分别处理本地对象和远程对象相当麻烦，我们试图让所有东西看起来在一个地方：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DBPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DBPtr(T *realPtr = <span class="literal">nullptr</span>);</span><br><span class="line">    DBPtr(DataBaseID id);<span class="comment">//指向DB id对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&#123;</span><span class="comment">// 数据库元组类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayEditDialog</span><span class="params">()</span></span>;<span class="comment">//显示一个图形对话框，允许用户编辑</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//返回合法性检验</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LogEntry</span> &#123;</span><span class="comment">//修改T对象时完成日志登记</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LogEntry(<span class="keyword">const</span> T&amp; objectToBeModified);</span><br><span class="line">    ~LogEntry();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">editTuple</span><span class="params">(DBPtr&lt;Tuple&gt;&amp; pt)</span></span>&#123;</span><br><span class="line">    <span class="function">LogEntry&lt;Tuple&gt; <span class="title">entry</span><span class="params">(*pt)</span></span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;<span class="comment">//重复显示对话框，直到数值合法</span></span><br><span class="line">        pt-&gt;displayEditDialog();</span><br><span class="line">    &#125; <span class="keyword">while</span> (pt-&gt;<span class="built_in">isValid</span>() == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>被编辑的元祖既可以位于本地也可以位于远程，在编写程序时我们感受不到他们的区别。Logentry的构造函数负责了启动日志记录，析构函数负责关闭记录。这在含有异常时能让程序更加robust，并且建立对象本身也比调用记录函数要直观。</p>
<p>如我们所见，使用智能指针与使用raw pointer区别不大，在了解了这一特性之后，我们开始编写智能指针。</p>
<hr>
<h1 id="构造、赋值、析构"><a href="#构造、赋值、析构" class="headerlink" title="构造、赋值、析构"></a>构造、赋值、析构</h1><p>&nbsp;<br>一般来说构造较为简单：找到需要指向的对象，令raw pointer指向它，如果没有则将raw pointer指向nullptr或者抛出一个异常。<br>拷贝、赋值、析构由于对象所有权的问题，所以导致略微复杂。我们默认智能指针被释放时需要析构指向的对象，当然，这里的对象说的是动态分配得到的对象。<br>以STL中的auto_ptr为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">auto_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(T *ptr = <span class="number">0</span>): pointee(ptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> pointee; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当auto_ptr被拷贝或被赋值时，会发生什么情况？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;TreeNode&gt; <span class="title">ptn1</span><span class="params">(<span class="keyword">new</span> TreeNode)</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;TreeNode&gt; ptn2 = ptn1;<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;TreeNode&gt; ptn3;</span><br><span class="line">ptn3 = ptn2;<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><br>如果我们只拷贝内部的raw pointer，则会有两个智能指针指向一个对象，如果两个智能指针依次释放，我们会试图析构一个已经被析构的东西，结果未定义。<br>另一种方法是new一个新的对象，但这本身带有性能损耗，更何况我们也不知道建立什么对象，万一是派生类而非基类呢。<br>STL定义：“当auto_ptr被拷贝和赋值时，对象所有权随之传递”：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">auto_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs);</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto_ptr</span>&lt;T&gt;:</span>:<span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">    pointee = rhs.pointee;</span><br><span class="line">    rhs.pointee = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto_ptr</span>&lt;T&gt;&amp; <span class="title">auto_ptr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)<span class="comment">//处理自赋值,此处内容建议翻阅Effective C++ 12</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pointee;</span><br><span class="line">    pointee = rhs.pointee;</span><br><span class="line">    rhs.pointee = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般来说，拷贝构造和赋值运算符的形参都是const，但是auto_ptr的就不是，原因在于rhs被改变了。</p>
<p>最后，其析构函数如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">SmartPtr</span>&lt;T&gt;:</span>:~SmartPtr()&#123;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">this</span> owns *pointee) &#123;</span><br><span class="line">        <span class="keyword">delete</span> pointee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不同的智能指针析构函数各有不同，比如说shared_ptr就需要检查引用计数。</p>
<hr>
<h1 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符"></a>解引用操作符</h1><h2 id="operator"><a href="#operator" class="headerlink" title="operator*"></a>operator*</h2><p>operator*返回所指向的对象，理论上来说这好像很简单：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">SmartPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">    perform <span class="string">"smart pointer"</span> processing;</span><br><span class="line">    <span class="keyword">return</span> *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先，我们必须初始化指针或者让raw pointer合法(例如Lazy evaluation中构建对象）。<br>其次，我们必须返回引用而非对象，因为在引入继承体系后，如果返回对象会导致slicing，而且智能指针也因此丧失了虚函数的功能，此外返回引用效率也高。</p>
<h2 id="operator-gt"><a href="#operator-gt" class="headerlink" title="operator-&gt;"></a>operator-&gt;</h2><p>operator-&gt;与operator*差不多，我们先回头看用户使用实例中调用-&gt;的语句：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pt-&gt;displayEditDialog();</span><br></pre></td></tr></table></figure><br>该语句被编译器解释为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(pt.<span class="keyword">operator</span>-&gt;())-&gt;displayEditDialog();</span><br></pre></td></tr></table></figure><br>这意味着不论operator-&gt;返回什么，它必须在返回结果上使用-&gt;，那也就是说operator-&gt;仅能返回一个指针或类指针对象，一般来说，我们把一个raw pointer作为其返回值。</p>
<hr>
<h1 id="测试智能指针是否为nullptr"><a href="#测试智能指针是否为nullptr" class="headerlink" title="测试智能指针是否为nullptr"></a>测试智能指针是否为nullptr</h1><p>&nbsp;<br>为了保证智能指针的行为与raw pointer完全一致，比如保证下述表达式能够编译：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">if</span> (ptn)</span><br><span class="line"><span class="keyword">if</span> (!ptn)</span><br></pre></td></tr></table></figure><br>为了谨慎和保险，我们在智能指针类中重载operator！，当且仅当其为空指针时返回true:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:...</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!() <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="把智能指针转为raw-pointer"><a href="#把智能指针转为raw-pointer" class="headerlink" title="把智能指针转为raw pointer"></a>把智能指针转为raw pointer</h1><p>&nbsp;<br>有时我们需要作出类似的转换，因为有些接口只接受raw pointer，可能你会写出&amp;*sp之类的东西，但这无疑太丑了。所以某些人更倾向于隐式类型转换符：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> T*() &#123; <span class="keyword">return</span> pointee; &#125;</span><br></pre></td></tr></table></figure><br>这种设计看起来很好，但实际上完全不行，如果直接可以让用户操纵raw pointer，那我们设计智能指针的意义何在？并且引用计数等功能也遭到了破坏。<br>此外，这种隐式转换编译器同一时间只能使用一次，比如说智能指针和raw pointer之间存在隐式转换，raw pointer又和A之间存在转换，智能指针无法隐式转为A，也就是说其行为与raw pointer不符。<br>这种写法还会诱导用户写下delete sp这种天理难容的东西，要知道智能指针是一个对象…<br>编译器不会报错，但你的对象会被删除两次（一次是delete，一次是sp被析构）<br>总之，智能指针应该拒绝提供隐式转换操作符，最好的操作就是提供显示接口，例如get。</p>
<hr>
<h1 id="智能指针与基于继承的类型转换（Effective-C-46）"><a href="#智能指针与基于继承的类型转换（Effective-C-46）" class="headerlink" title="智能指针与基于继承的类型转换（Effective C++ 46）"></a>智能指针与基于继承的类型转换（Effective C++ 46）</h1><p>&nbsp;<br>下图是模型化音乐商店商品的一个继承体系，其大致实现如下：<img src="http://static.zybuluo.com/zsmj2017/wuswa468p8neq5lz5881824f/image_1cc655eos1cq45b81l021alv1kj49.png" alt="image_1cc655eos1cq45b81l021alv1kj49.png-39.2kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicProduct</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MusicProduct(<span class="keyword">const</span> <span class="built_in">string</span>&amp; title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cassette</span>:</span> <span class="keyword">public</span> MusicProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cassette(<span class="keyword">const</span> <span class="built_in">string</span>&amp; title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CD</span>:</span> <span class="keyword">public</span> MusicProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CD(<span class="keyword">const</span> <span class="built_in">string</span>&amp; title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>更进一步地假设存在一个函数，它对于任何一个Musicproduct对象都会显示标题并播放指定次数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> MusicProduct* pmp, <span class="keyword">int</span> numTimes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numTimes; ++i) &#123;</span><br><span class="line">        pmp-&gt;displayTitle();</span><br><span class="line">        pmp-&gt;play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然该函数本身具备多态性，但如果我们使用智能指针，则无法具备多态性，原因在于sp派生出的这几个class根本不具备任何相关性。</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>我们想到的第一个解决方案是令每一个sp class具备隐式类型转换符：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&lt;Cassette&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;()&#123;<span class="keyword">return</span> SmartPtr&lt;MusicProduct&gt;(pointee);&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cassette *pointee;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&lt;CD&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;()&#123;<span class="keyword">return</span> SmartPtr&lt;MusicProduct&gt;(pointee);&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CD *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此方法缺点十分明显：</p>
<ol>
<li>对于每一个sp class都需要加入大量的隐式类型转换符，这对template是一大讽刺。</li>
<li>如果当前对象位于继承体系的底层，那你必须为每一个直接或者间接继承的基类提供隐式类型转换，因为编译器无法执行多次转换。</li>
</ol>
<h2 id="非虚成员函数模板"><a href="#非虚成员函数模板" class="headerlink" title="非虚成员函数模板"></a>非虚成员函数模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SmartPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">newType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">operator</span> <span class="title">SmartPtr</span>&lt;newType&gt;()&#123;</span></span><br><span class="line">        <span class="keyword">return</span> SmartPtr&lt;newType&gt;(pointee);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其具体工作原理如下：<br>假设编译器持有一个指向T对象的智能指针，它需要把该指针转换成指向T的基类的智能指针.<br>编译器检查了一番SmartPtr&lt;T&gt;,但并没有找到明确的类型转换符，然后检查有没有一个成员函数模板，通过该模板实例化一个对象完成类型转换。最终它构建了这么一个对象，完成了隐式转换。<br>结合具体实例而言，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;MusicProduct&gt;&amp; pmp,<span class="keyword">int</span> howMany)</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;Cassette&gt; <span class="title">funMusic</span><span class="params">(<span class="keyword">new</span> Cassette(<span class="string">"Alapalooza"</span>))</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;CD&gt; <span class="title">nightmareMusic</span><span class="params">(<span class="keyword">new</span> CD(<span class="string">"Disco Hits of the 70s"</span>))</span></span>;</span><br><span class="line">displayAndPlay(funMusic, <span class="number">10</span>);</span><br><span class="line">displayAndPlay(nightmareMusic, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>函数在调用时本质上使用了Smart&lt;music&gt;的构造函数，将新的对象作为参数传递给了函数，最终完成多态。</p>
<p>不要觉得这种方法只能用于继承体系中的相互转换，事实上，这是一种通用的、安全的智能指针转换操作，只要你能够把T*隐式地转为NT*，那我们就一定能安全直接地转换它们的智能指针。假设我们修改了继承体系：<br><img src="http://static.zybuluo.com/zsmj2017/n7npu89nb9veidxhtnv1wnkn/image_1cc661nbnnb27o7m5i5rj17egm.png" alt="image_1cc661nbnnb27o7m5i5rj17egm.png-53.5kB"><br>并有如下代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtr</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;MusicProduct&gt;&amp; pmp,<span class="keyword">int</span> howMany)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;Cassette&gt;&amp; pc,<span class="keyword">int</span> howMany)</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;CasSingle&gt; <span class="title">dumbMusic</span><span class="params">(<span class="keyword">new</span> CasSingle(<span class="string">"Achy Breaky Heart"</span>))</span></span>;</span><br><span class="line">displayAndPlay(dumbMusic, <span class="number">1</span>);<span class="comment">//error!</span></span><br></pre></td></tr></table></figure><br>这里错误的原因很简单，二义性，所有类型的转换符具有同等地位，编译器无法知道该使用哪一个（这种行为与内置指针不符，内置指针会直接匹配继承体系最接近的重载）。</p>
<hr>
<h1 id="智能指针与const"><a href="#智能指针与const" class="headerlink" title="智能指针与const"></a>智能指针与const</h1><p>&nbsp;<br>对于raw pointer，我们的const属性分为顶层和底层，详见C++ Primer。<br>我们希望智能指针也拥有const属性，但实际上好像不太行，我们可以令智能指针自身const，无法让指向的对象也const.有一个简单的补救方法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SmartPtr&lt;<span class="keyword">const</span> Sth&gt;;</span><br></pre></td></tr></table></figure><br>但该类型的对象与SmartPtr&lt;Sth&gt;不具备任何相关性，所以需要再次使用上文所提到的成员模板。需要注意的是，const的类型转换是单向的，就像public继承一样，non-const可以做const的事，反之则不行.既然如此，我们不如把它设为继承关系：<img src="http://static.zybuluo.com/zsmj2017/8v5j11i9bdlqapt9gfgptqmk/image_1cc66ffmd52a1u2f15vkhp81b7u1j.png" alt="image_1cc66ffmd52a1u2f15vkhp81b7u1j.png-66.2kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtrToConst</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> T* constPointee;</span><br><span class="line">        T* pointee;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtr</span>:</span><span class="keyword">public</span> SmartPtrToConst&lt;T&gt; &#123;</span><br><span class="line">    ...<span class="comment">//没有数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>使用这种设计方法，指向non-const-T对象的智能指针包含一个指向const-T的raw pointer。union的特点是节约空间，但我们需要手动约束两个类各自使用专属指针。其使用大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; pCD = <span class="keyword">new</span> CD(<span class="string">"Famous Movie Themes"</span>);</span><br><span class="line">SmartPtrToConst&lt;CD&gt; pConstCD = pCD;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针概述</title>
    <url>/2018/07/04/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>一般来说，原始指针有以下缺点：</p>
<ol>
<li>不能从声明中推断出它到底是指向单一对象还是数组。</li>
<li>不能从声明中推断出当你使用完毕后是否应当销毁其指向对象（即不能确定是否只有该指针指向那份资源）。</li>
<li>如果你确定应当销毁指针所指物，你无法明确当以何种方式完成销毁（使用delete还是存在专有销毁函数）。</li>
<li>如果你明确应当使用delete完成销毁，你也无法确定应当使用delete还是delete[]。</li>
<li>就算你解决了上述问题，你也无法保证销毁程序能够正确执行，可能它会被执行多次，也可能一次都不会执行。前者会导致未定义行为，后者则将导致资源泄漏。</li>
<li>无法判断当前指针是否空悬。</li>
</ol>
<p>无疑，原始指针是相当强大的工具，但多年经验表明，好用者实繁，善用者盖寡，为了解决上述问题，C++引入了智能指针。智能指针是原始指针的外覆器，它们的行为与原始指针非常相似，但可以避开许多陷阱。</p>
<p>C++11有四个智能指针：std::auto_ptr，std::unique_ptr，std::shared_ptr与std :: weak_ptr。这些智能指针均旨在帮助管理动态分配对象的生命周期，即通过保证在适当的时间（包括异常情况下）以适当的方式销毁这些对象来避免资源泄漏。</p>
<p>std::auto_ptr是C++98设计下的失败品，C++11中的std::unique_ptr才是它的完全形态。理论来说，auto_ptr需要使用移动语义，但遗憾的是C++98中移动语义并不存在，因此 std::auto_ptr不得不使用copy来模拟move。这一特性直接导致auto_ptr存在一些奇怪的行为，例如auto_ptr拷贝会将其置为null，因此也无法将auto_ptr置于容器之中。std::unique_ptr能做所有auto_ptr能做的事，而且不存在那些约束，除非你是在C++98编译环境下，否则绝无使用auto_ptr的必要。</p>
<p>不同的智能指针API各不相同，可能唯一的共同点仅在于他们均存在默认构造函数。由于这些API的综合参考资料俯拾皆是，因此本章将重点讨论API概述并不关注之处，例如值得注意的用例，运行成本分析等等。通过掌握此类信息，开发者可以更加了解智能指针之间的区别以及如何高效地使用它们。</p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>执行期语义学——new与delete运算符</title>
    <url>/2018/05/30/%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94new%E4%B8%8Edelete%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;</p>
<p>new operator看起来似乎是一个单一运算，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><br>但实际上它由以下两个步骤组成：</p>
<ol>
<li>通过适当的new运算符函数实体，配置所有所需内存：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = _new(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li>
<li>给配置得来的对象设立初值：<br>*pi = 5;</li>
</ol>
<p>当然，初始化操作应当在内存配置成功后才执行：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写声明</span></span><br><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">if</span>(pi = _new(<span class="keyword">sizeof</span>(<span class="keyword">int</span>))) *pi=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>delete运算符性质类似，只是在使用前会判断一下参数是否为nullptr，并且需要注意的是，在执行完delete后，p并不会被置为nullptr。</p>
<p>如果我们new或delete的是一个具备constructor或destructor的object，那么在执行new或delete时会触发对应的函数调用(其实一直说到这都是描述new operator与operator new）。</p>
<hr>
<h1 id="new运算符的小机巧"><a href="#new运算符的小机巧" class="headerlink" title="new运算符的小机巧"></a>new运算符的小机巧</h1><p>&nbsp;<br>new操作符的实现一般均很直截了当，但有两个精巧之处值得斟酌：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span>*</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">0</span>) <span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *last_alloc;</span><br><span class="line">    <span class="keyword">while</span>(!(last_alloc = <span class="built_in">malloc</span>(<span class="built_in">size</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!_new_handler) (*_new_handler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_alloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然<code>new T[0]</code>从语法层胶墩来说合法，但语言要求每一次对new的调用都必须传回一个独一无二的指针，这也就是每一次当size为0都将其置1的原因。此外，new允许开发者提供自己的_new_handler()函数，这也就是循环调用的原因。</p>
<p>实际上，new运算符总是以标准的C malloc()完成，虽然这并不是强制要求。类似地，delete也总是以标准的C free()完成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> </span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr) <span class="built_in">free</span>((<span class="keyword">char</span>*)ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="针对数组的new与delete语意"><a href="#针对数组的new与delete语意" class="headerlink" title="针对数组的new与delete语意"></a>针对数组的new与delete语意</h1><p>&nbsp;<br>当我们写下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><br>时，vec_new并不会真正被调用，因为其主要功能是把default constructor施行于class objects所组成的数组的每一个元素身上，倒是new运算符函数会被调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p_array = (<span class="keyword">int</span>*)_new(<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><br>对于strcut这种Plain OI’s Data，其执行类似于内置类型，因为其不具备constructor与destructor。new与delete运算符只需要获取或释放内存即可，vec_new()也不会被调用。</p>
<p>但如果class定义有一个default constructor，那么某些版本的vec_new()将会被调用，举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d *p_array = <span class="keyword">new</span> Point3d[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//编译结果</span></span><br><span class="line">Point3d* p_array;</span><br><span class="line">p_array = vec_new(<span class="number">0</span>,<span class="keyword">sizeof</span>(Point3d),<span class="number">10</span>,&amp;Point3d::Point3d(),&amp;Point3d::~Point3d());</span><br></pre></td></tr></table></figure><br>需要注意的是，只有已经构造完毕的object才可以经过destructor处理，在发生异常时，vec_new释放所有资源。</p>
<p>在很久之前，delete对象数组时必须要指定数组长度<code>delete[10] p_array</code>，当然现在不需要了,不过这种写法依然有效。有人会产生疑问，<code>delete[]</code>是如何了解当前所需要析构的元素数目？答案是vec_new所传回的内存区块内有一个word记录了数组长度。另外需要记住的是，在数组中使用多态性是非常不恰当的行为，我们在任何情况下都应当避免当一个base class 指针或引用指向derived class object组成的数组。</p>
<hr>
<h1 id="Placement-Operator-new的语意"><a href="#Placement-Operator-new的语意" class="headerlink" title="Placement Operator new的语意"></a>Placement Operator new的语意</h1><p>&nbsp;<br>new操作符可以重载，其最常见的一种形态我们称为placement operator new，它需要第二个参数，用来指定分配内存的位置：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span>* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有人认为如果其作用只是传回第二参数，那它的实际意义何在？事实上，placement operator new还负责调用constructor自动实施于所指地址：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point2w *ptw = (Point2w*) arena;</span><br><span class="line"><span class="keyword">if</span>(ptw!=<span class="number">0</span>) ptw-&gt;Point2w::Point2w();</span><br></pre></td></tr></table></figure><br>然而存在一些小问题：假若当前我们需要被构造的内存段已经存在了一个object，而这个object拥有一个destructor。在我们执行placement operator new时，该destructor并不会被调用，可能会有人想到使用delete从而触发destructor，然而这也释放掉了这一块内存，并不可，。较好的做法是直接在地址上执行destructor（在后来的C++ standrad中出现了placement perator delete，它可以析构且不释放内存）。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>构造、析构、拷贝语义学——对象复制语义学</title>
    <url>/2018/05/29/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>当我们设计了一个class，并以一个class object指定给另一个class object时，我们有三种选择：</p>
<ol>
<li>不提供任何操作，执行默认行为</li>
<li>提供一个explicit copy assignment operator</li>
<li>明确拒绝复制操作</li>
</ol>
<p>如果选择了第三点，那么执行策略是将copy assignment operator与copy constructor声明为private，并且不提供任何定义。声明为private避免了在member function或friends以外的任何地点执行copy操作，不提供定义则是确保当其在friends或member function中被调用时链接器会报错。</p>
<hr>
<h1 id="copy-assigenment-operator语义"><a href="#copy-assigenment-operator语义" class="headerlink" title="copy assigenment operator语义"></a>copy assigenment operator语义</h1><p>&nbsp;<br>我们仍以Point class作为实例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">//不存在任何virtual function</span></span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果我们只需要完成基础data拷贝操作，那么默认拷贝行为似乎已经足够并且高效，我们没有理由去提供一个copy assignment operator。</p>
<p>但如果我们不对Point提供一个copy assignment operator,而是光靠memberwise copy，编译器会生成一个copy assignment operator实体吗？答案是否定的，正如copy constructor一样，由于编译器认为此class已经有了bitwise copy语义，所以implicit copy assignment operator被视为毫无用处，也不会被合成出来。</p>
<p>一个class对于默认的copy assignment operator，在以下情况中不会表现出bitwise copy语意：</p>
<ol>
<li>当class内带有一个member object，而其class有一个copy assignment operator。</li>
<li>当一个class的base class有一个copy assignment operator。</li>
<li>当一个class声明了任何virtual functions（我们不一定能够准确拷贝到class object的vptr地址，因为它可能是一个derived class object）。</li>
<li>当class继承自一个virtual base class（无论其有没有copy assignment operator）。</li>
</ol>
<p>C++ Standard上说copy assignment operator并不表示bitwise copy semantics是nontrivial。实际上，只有nontrivial instances才会被合成。于是，对于下面的语句：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point a,b;</span><br><span class="line">...</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure><br>赋值操作将由bitwise copy完成，期间并没有copy assignment operator被调用。但我们可能仍然需要一个copy constructor以方便完成NRV操作，这里需要注意的是，一个class需要copy constructor并不代表其也需要copy assignment operator。</p>
<h2 id="虚拟继承下的copy-assignment-operator"><a href="#虚拟继承下的copy-assignment-operator" class="headerlink" title="虚拟继承下的copy assignment operator"></a>虚拟继承下的copy assignment operator</h2><p>在Point class中导入copy assignment operator：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Point&amp;</span><br><span class="line">Point::<span class="keyword">operator</span>=(<span class="keyword">const</span> Point &amp;p)&#123;</span><br><span class="line">    _x = p._x;</span><br><span class="line">    _y = p._y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现对继承体系作出修改，有Point3d虚继承自Point：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y =<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果我们没有为Point3d定义一个copy assignment operator，编译器就必须合成一个（理由见前述的2与4），合成得到的东西可能看起来如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Point3d&amp;</span><br><span class="line">Point3d::<span class="keyword">operator</span>=(Point3d* <span class="keyword">const</span> <span class="keyword">this</span>,<span class="keyword">const</span> Point3d &amp;P)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(p);</span><br><span class="line">    _z=p._z;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>copy assignment operator有一个nonorthogonal aspect（不理想、不严谨的情况），因为我们无法使用member initialization list（不能使用的原因是Point并没有copy constructor），我们必须写成以下两种形式，才能够调用base class的copy assignment operator：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point::<span class="keyword">operator</span>=(p3d);</span><br><span class="line">(*(Point*)<span class="keyword">this</span>)=p3d;</span><br></pre></td></tr></table></figure><br>缺乏copy assignment list看起来无所谓，但实际上如果缺乏它，编译器将无法抑制上一层base class的copy operators被调用。</p>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>下面的Vertex copy assignment operator（Vertex也虚继承自Point）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vertex&amp;</span><br><span class="line">Vertex::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex &amp;v)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    _next = v.next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在让我们从Point3d和Vertex中派生出Vertex3d,以下是Vertex3d的copy assignment operator：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vertex3d&amp;</span><br><span class="line">Vertex3d::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex3d &amp;v)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point3d::<span class="keyword">operator</span>=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex::<span class="keyword">operator</span>=(v);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>编译器将如何在Point3d与Vertex的copy assignment operators中抑制Point的copy assignment operators呢？<br>答案相当多，但均不够完备（详见书中介绍）。作者的建议是不允许任何一个virtual base class的拷贝操作，或者更进一步地，不在任何virtual base class中声明数据（类似于Java中的interface）。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>构造、析构、拷贝语义学——对象的功能</title>
    <url>/2018/05/29/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>（本章对前文所述的各种操作进行了测试，给出了优化与未优化的区别）</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>19.接口设计原则：易于使用，不易误用</title>
    <url>/2018/04/11/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9A%E6%98%93%E4%BA%8E%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%AF%AF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>作为接口设计者，我们应该明确客户可能并不了解实现，也就是说，客户会大概率地不按期望方式使用接口。我们应当以下面的句子作为目标时刻鞭策自己：</p>
<ol>
<li><strong>如果客户使用了某个接口但却不能得到预期行为，该代码不应该被正确编译</strong></li>
<li><strong>如果某段代码通过了编译，它的行为必然是客户所期望的</strong></li>
</ol>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假定我们正在为一个表现日期的class设计构造函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> month,<span class="keyword">int</span> day,<span class="keyword">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>客户至少可能会针对这个看似不错的接口犯下两个错误：</p>
<ol>
<li>以错误的次序传递参数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">11</span>,<span class="number">4</span>,<span class="number">2018</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>传递无效的日期<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2</span>,<span class="number">30</span>,<span class="number">2018</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="导入新类型以预防"><a href="#导入新类型以预防" class="headerlink" title="导入新类型以预防"></a>导入新类型以预防</h2><h3 id="建立wrapper-types以区分年月日"><a href="#建立wrapper-types以区分年月日" class="headerlink" title="建立wrapper types以区分年月日"></a>建立wrapper types以区分年月日</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="keyword">int</span> d)</span>:<span class="title">val</span><span class="params">(d)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Month</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span>:<span class="title">val</span><span class="params">(m)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Year</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="keyword">int</span> y)</span>:<span class="title">val</span><span class="params">(y)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">const</span> Month&amp; m,<span class="keyword">const</span> Day&amp; d,<span class="keyword">const</span> Year &amp;y);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如此一来，只有正确的类型才能导致正确的初始化。</p>
<h3 id="限制wrapper-types的取值"><a href="#限制wrapper-types的取值" class="headerlink" title="限制wrapper types的取值"></a>限制wrapper types的取值</h3><p>举例而言，Months的个数应当只有12个，那么使用enum来表征Month看起来是合理的。但是，enum不具备类型安全性（总可以转为int 详见Effective C++ 3），因此比较安全的写法是预先定义所有有效的Months:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Month</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>：</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">Month</span> <span class="title">Jan</span>() &#123;</span><span class="keyword">return</span> Month(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Month(<span class="number">2</span>);&#125;</span><br><span class="line">    .......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span></span>;<span class="comment">//禁止用户构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Mar(),Day(<span class="number">30</span>),Year(<span class="number">1995</span>))</span></span></span><br></pre></td></tr></table></figure><br>值得注意的是这里是以函数替换对象，具体原因见Effective C++ 5 non—local static对象的初始化顺序一节。</p>
<h2 id="限定类型可以执行的任务"><a href="#限定类型可以执行的任务" class="headerlink" title="限定类型可以执行的任务"></a>限定类型可以执行的任务</h2><p>最常见的限制是加上const。<br>比如我们可以对operator*的返回值加上const，从而让诸如if(a*b=c)这样的东西失去了意义。（用户再也不用担心把==写作=了）</p>
<hr>
<h1 id="令自定义类型的行为与内置类型保持一致"><a href="#令自定义类型的行为与内置类型保持一致" class="headerlink" title="令自定义类型的行为与内置类型保持一致"></a>令自定义类型的行为与内置类型保持一致</h1><p>&lt;/br&gt;<br>该原则的本质是<strong>提供行为一致的接口</strong>​。一致性是快速学习与开发的前提。（写算法时也应该注意语义一致）</p>
<hr>
<h1 id="接口不应当要求用户必须做某事"><a href="#接口不应当要求用户必须做某事" class="headerlink" title="接口不应当要求用户必须做某事"></a>接口不应当要求用户必须做某事</h1><p>&lt;/br&gt;<br>任何接口如果要求客户必须记得做某件事，那么说明它必然存在“不正确使用”的可能，因为墨菲定律，因为用户的操作无法由开发者决定。</p>
<h2 id="RAII的进一步优化（factory模式）"><a href="#RAII的进一步优化（factory模式）" class="headerlink" title="RAII的进一步优化（factory模式）"></a>RAII的进一步优化（factory模式）</h2><p>factory函数总是返回指向一个动态分配的object的指针,仍以Investment举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>为了避免资源泄漏，factory函数返回的指针最终必须要被删除。这给了用户两个错误机会：</p>
<ol>
<li>忘了delete</li>
<li>重复delete</li>
</ol>
<p>我们采用RAII避免了资源泄露，但前提是用户必须了解和记得使用智能指针来管理返回的指针。因此，factory函数可以先发制人，直接就返回一个智能指针：<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>shared_ptr默认的析构行为是delete raw point，这可能与客户所需要的删除操作（deleter)不符，因此我们干脆初始化一个指向nullptr并且删除器是deleter的shared_ptr,最终，factory函数如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="literal">nullptr</span>,deleter)</span></span>;</span><br><span class="line">    retval=...;<span class="comment">//指向需要管理的资源</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上是原始指针未能确定的情况，实际上把原始指针直接传给shared_ptr构造函数的话效果更佳。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>接口应当易于使用，不易误用。</li>
<li>促进正确使用的方法包括语义一致性，以及行为兼容性。</li>
<li>阻止误用的办法包括建立新外覆类型，限制类型操作，束缚对象值，以及改进RAII。</li>
<li>shared_ptr支持定制删除器，这样可以防范dll问题（跨DLL删除，自动解除互斥锁）。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>7.禁止重载&quot;&amp;&amp;&quot;、&quot;||&quot;或&quot;,&quot;</title>
    <url>/2018/04/24/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>C++允许重载标题所提及的三种操作符，但本节禁止其重载的原因很简单，易于引发歧义或者说与预期设想不符。</p>
<hr>
<h1 id="“-amp-amp-”、”-”"><a href="#“-amp-amp-”、”-”" class="headerlink" title="“&amp;&amp;”、”||”"></a>“&amp;&amp;”、”||”</h1><p>&nbsp;<br>众所周知，&amp;&amp;与||具备短路特性。当你重载&amp;&amp;或者||以后，你以函数调用代替了短路求值。<br>这样会造成两个缺点：</p>
<ol>
<li>函数调用需要计算所有参数，你的表达式不再具备短路特性。</li>
<li>c++没有规定函数参数的计算顺序，最终表达式结果由编译器决定。</li>
</ol>
<hr>
<h1 id="“-”"><a href="#“-”" class="headerlink" title="“,”"></a>“,”</h1><p>&nbsp;<br>一个包含逗号的表达式首先计算逗号左边的表达式，然后计算逗号右边的表达式；整个表达式的结果是逗号右边表达式的值。自定义的<code>operator,</code>没有这样的特性，最终结果由编译器决定。</p>
<hr>
<h1 id="禁止重载的操作符"><a href="#禁止重载的操作符" class="headerlink" title="禁止重载的操作符"></a>禁止重载的操作符</h1><p><img src="http://static.zybuluo.com/zsmj2017/82ozl49wymt33r49fwkk6q3a/image_1cbr9rtb1nrf14vme33t9v1akk26.png" alt="image_1cbr9rtb1nrf14vme33t9v1akk26.png-5.1kB"><br><img src="http://static.zybuluo.com/zsmj2017/i6l7mz2u1gdn6ucg4bcxguxx/image_1cbr9sef1pambvi1oes12158jn2j.png" alt="image_1cbr9sef1pambvi1oes12158jn2j.png-5.8kB"></p>
<hr>
<h1 id="允许重载的操作符"><a href="#允许重载的操作符" class="headerlink" title="允许重载的操作符"></a>允许重载的操作符</h1><p><img src="http://static.zybuluo.com/zsmj2017/wjpo5bqwhzxkes4zki83zpjy/image_1cbr9u7ik1bils4n8a613oel9b30.png" alt="image_1cbr9u7ik1bils4n8a613oel9b30.png-16.9kB"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>操作符重载的目的是为了令程序更容易阅读，书写和理解，而不是炫耀技巧。如果没有重载操作符的必要，就不要重载。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>构造、析构、拷贝语义学——导读</title>
    <url>/2018/05/17/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>现有abstract base class声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Abstract_base() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _mumble;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *_mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们可以看出，即使该class不会具象出一个实体，但它仍然需要一个明确的构造函数以初始化其data member _mumble。如果没有这个初始化操作，其derived class的局部性对象_mumble将无法决定初值。</p>
<p>可能会有人认为这是abstract_base的设计者试图让其每一个derived class提供_mumble初值，然而如果是这样，abstract_base必须提供一个带有唯一参数的protected constructor：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Abstract_base::</span><br><span class="line">Abstract_base(<span class="keyword">char</span> *mumble_value = <span class="number">0</span>):_mumble(mumble_value) &#123;&#125;</span><br></pre></td></tr></table></figure><br>一般而言，class的data member应当在自身的constructor或其他member functions中被初始化，其他任何操作都将破坏封装性，使class的维护和修改变得更加困难。<br>当然，你也可以认为该设计并不合理，因为不应当将在abstract class中设定data member，这种思想体现了interface与implementation分离。但在base class中放置共有的data member也是行之有效的真理。</p>
<hr>
<h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>&nbsp;<br>在学习了长时间的C++后我们已经了解，即使是纯虚函数，也可以被定义和调用。只不过它们只能被静态地调用，无法通过虚拟机制调用，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Abstract::interface</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="comment">//定义纯虚函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Concrete_derived::interface</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    Abstract_base::interface();<span class="comment">//静态调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>具体是否需要定义和调用纯虚函数只看开发者是否需要，唯一的例外是pure virtual destructor 一定需要被定义。原因在于每一个derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。在缺乏定义的情况下，会导致链接失败。</p>
<hr>
<h1 id="虚拟规格"><a href="#虚拟规格" class="headerlink" title="虚拟规格"></a>虚拟规格</h1><p>&nbsp;<br>把Abstract::base::mumble()设计为一个virtual function是不明智的，因为其函数定义内容并不与类型有关（并不因为class的类型而形成不同的操作），因而几乎不会被后继的derived class override。此外，由于它的non-virtual函数实体是一个inline函数，如果常常被调用，效率上恐怕会出现问题。<br>我们认为，无需对不必要声明为virtual的函数实行虚拟化，其弊端在Effective C++中亦有提及。</p>
<hr>
<h1 id="虚拟规格中const的存在"><a href="#虚拟规格中const的存在" class="headerlink" title="虚拟规格中const的存在"></a>虚拟规格中const的存在</h1><p>&nbsp;<br>考虑virtual function的const属性很麻烦，因为我们也无法了解未来的需求。如果不把函数声明为const，则意味着该函数不能够获得一个const reference或const pointer，这似乎也不是什么缺点，所以我们提倡将所有的virtual function设置为const。</p>
<hr>
<h1 id="重新考虑class的声明"><a href="#重新考虑class的声明" class="headerlink" title="重新考虑class的声明"></a>重新考虑class的声明</h1><p>&nbsp;<br>经过前面的讨论，我们将Abstarct_base重新定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Abstract_base();<span class="comment">//放弃纯虚</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//不再是const</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _mumble;&#125;<span class="comment">//不再是virtual</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Abstract_base(<span class="keyword">char</span> *pc=<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *_mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>7.明确拒绝编译器自动生成的函数</title>
    <url>/2018/04/07/%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>某些类可能不允许被拷贝，我们可能会试图去不声明copy构造函数和copy assignment操作符来让用户无法copy，但这毫无意义，因为编译器还是会生成它们。</p>
<p>解决的关键在于编译器所自动生成的这些函数都是public的，如果我们<strong>声明一个private</strong>的copy构造函数以及copy assignment运算符，并且<strong>不去定义</strong>它们（<strong>以防止友元访问</strong>），那么这个类自然就无法copy了。</p>
<p>当你把它们声明为private时，如果用户试图去拷贝，此时编译器会报错，如果我们通过友元或者在成员函数内试图调用它们，因为没有定义，此时轮到连接器发出警告。</p>
<p>当然，越早报错越好，那能不能把连接期错误移至编译期呢？答案是可行的。<br>为了实现上述理想，我们需要借助一个base class，它什么也不干，就是为了阻止copy。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span>｛</span></span><br><span class="line"><span class="class"><span class="title">protected</span>:</span></span><br><span class="line">    Uncopyable() &#123;&#125;</span><br><span class="line">    ～Uncopyable()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果我们需要令某个类无法被copy，那我们只需要让该类私有继承Uncopyable即可（关于采用何种方式继承最为恰当，详见Effective C++ 38 39）<br>当友元或者成员函数试图拷贝时，编译器会试着生成copy构造函数或者copy assignment操作符，这两个函数又会去调用base class中的版本，发现调用失败，编译报错。</p>
<p>Uncopyable的设计颇为微妙，值得仔细揣摩，比如说继承方式，析构函数，以及空类优化等诸多方面。但在本章，我们只关心它的作用：阻止拷贝。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>为了拒绝编译器生成的某些函数，我们可以将其<strong>设为private且不予实现</strong>。或者令该类继承类似于Uncopyable这样的基类。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>构造、析构、拷贝语义学——析构语意学</title>
    <url>/2018/05/29/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6/</url>
    <content><![CDATA[<p>如果class没有定义destructor，那么<strong>只有在class内置的member object（或者class的base class）拥有destructor的情况下，编译器才会合成出一个</strong>。否则，destructor将会被视为不需要，自然也就不需要被合成（更不需要被调用）。</p>
<p>不定义destructor反而具备某种功效性，我们不应当认为某一个class具备constructor就也应当具备destructor，实际上，我们应当根据“需要”而非“感觉”来提供destructor。</p>
<p>为了决定class是否需要一个程序层面的destructor（或constructor），开发者必须明确一个class object的生命在哪里结束（或开始），需要何种操作才能保证对象的完整性，这也是constructor和destructor何时发生作用的关键。举例而言，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Point pt;</span><br><span class="line">    Point *p = <span class="keyword">new</span> Point3d;</span><br><span class="line">    foo(&amp;pt,p);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们看到，pt和p在作为foo()的参数之前，都必须先初始化为某些坐标值。这个时候需要有一个constructor，一般而言，class的使用者无法检验一个local变量或者heap变量是否已经被初始化。从这个角度来看，一个constructor的存在至少令开发者得以确认object必然已被初始化。</p>
<p>再来关注delete语句。当我们在delete掉p后，有任何程序上必须要处理的吗？答案是否定的，因为在本实例中我们无需归还任何资源，因此，我们无需一个destructor。</p>
<p>接着考虑Vertex class，它维护了一个由紧邻的“顶点”所形成的链表，并且当一个顶点的生命结束时，在链表上来回移动以完成删除操作，因此，Vertex destructor需要一个destructor。</p>
<p>当我们从Point3d和Vertex派生出Vertex3d时，如果我们不提供explicit destructor但仍然希望Vertex destructor被调用，因此，编译器必须合成一个Vertex3d destructor，其唯一任务就是调用Vertex destructor。如果我们提供一个Vertex3d destructor，编译器会扩展它，使他调用Vertex destructor。一个由开发者定义的destructor被扩展的方式类似于constructors，但是顺序相反：</p>
<ol>
<li>destructor函数本身首先被执行</li>
<li>如果class拥有member class objects，而后者拥有destructors，那么它们会以其声明顺序的相反顺序被调用。</li>
<li>如果class内带一个vptr，则现在将会被重新设定，指向适当的vtbl（当前object已经退化）。</li>
<li>如果上层nonvirtual base class拥有destructor，它们会以其声明顺序的相反顺序被调用。</li>
<li>如果任何virtual base class拥有destructor，而当前讨论的class是最尾端class（most derived），那么它们会以其原来的构造顺序的相反顺序被调用。</li>
</ol>
<p>类似于constructor，对于destructor的最佳实现策略就是维护两份destructor实体：</p>
<ol>
<li>一个complete object实体，总是设定好vptr，并且调用virtual base class destrcutors</li>
<li>一个base class subobject实体，除非在destructor函数中调用一个virtual function，否则它绝不会调用virtual base class destructors并设定vptr。</li>
</ol>
<p>我们可以认为，每一次destructor的调用都使当前的object退化为另一个object，它们在destructor之外的任何地方都是完整的。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数语义学——Copy Constructor的建构操作</title>
    <url>/2018/05/03/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Copy%20Constructor%E7%9A%84%E5%BB%BA%E6%9E%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在三种情况下，会以一个object的内容作为另一个class object的初值：</p>
<ol>
<li><p>object明确初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>...&#125;;</span><br><span class="line">X x;</span><br><span class="line">X xx = x;</span><br></pre></td></tr></table></figure>
</li>
<li><p>object被当作参数交与某个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    foo(xx);<span class="comment">//作为第一个参数的初值（不明显的初始化）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回值是一个class object</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果开发者已经明确定义了一个copy constructor如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//copy constructor可以是多参数，其中有一个参数是其class type</span></span><br><span class="line">X::X(<span class="keyword">const</span> X&amp; x);</span><br><span class="line">Y::Y(<span class="keyword">const</span> Y&amp; y);</span><br></pre></td></tr></table></figure><br>那么在大部分情况下，当class object以另一个同类实体作为初值时，上述constructor会被调用，这可能会导致一个暂时性class object的产生或程序代码发生改变（或二者都有）。</p>
<hr>
<h1 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h1><p>&nbsp;<br>如果函数并没有提供一个explicit copy constructor，那么其拷贝同类型对象的操作由default memberwise initialization完成，其执行策略为：对每一个内建或派生的data member的值，从某一个object拷贝到另一个object。不过它不会拷贝其中的member class object，而是实施递归式的memberwise initialization(对每一个对象依次执行default memberwise initialization）。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>考虑如下class声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">//不存在explicit copy constructor</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>String object的default memberwise initialization发生于这种情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">noun</span><span class="params">(<span class="string">"book"</span>)</span></span>;</span><br><span class="line"><span class="keyword">String</span> verb = noun;</span><br></pre></td></tr></table></figure><br>其完成方式类似于依次各别设定每一个member：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">verb.str = noun.str;</span><br><span class="line">verb.len = noun.len;</span><br></pre></td></tr></table></figure><br>如果String是另一个class的member：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     ...<span class="comment">//不存在explicit copy constructor</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _occurs;</span><br><span class="line">    <span class="keyword">String</span> _word;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>那么一个Word object的default memberwise initialization会拷贝其内建的member _occurs，然后对String member执行递归式memberwise initialization。</p>
<p>如果开发者没有为class指定copy constructor，那么编译器也会生成implicit的声明与定义。类似于Default constructor，C++亦把copy constructor区分为trivial与non-trivial两种，只有non-trivial的实体才会被合成于程序之中。决定一个copy constructor是否为trivial的依据是class是否表现出所谓的“bitwise copy semantics”。</p>
<hr>
<h1 id="Bitwise-Copy-Semantics"><a href="#Bitwise-Copy-Semantics" class="headerlink" title="Bitwise Copy Semantics"></a>Bitwise Copy Semantics</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Word.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Word <span class="title">noun</span><span class="params">(<span class="string">"book"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Word verb = noun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显verb是根据noun来初始化，但在未了解Word class声明之前，我们无法预测该初始化操作的程序行为。如果开发者定义了copy constructor，那么编译器会调用它。如果没有，编译器会根据class 是否展现出bitwise copy semantics，来合成一个copy constructor。</p>
<p>举例而言，如果Word内部数据仅仅含有内置类型，那么编译器不会合成copy constructor，而是执行bitwise copy。但如果Word内含一个String object，而String class存在一个explicit copy constructor，那么编译器将不得不合成一个copy constructor，以调用member object的copy constructor，在该合成的copy constructor中，内置类型仍然使用bitwise copy。</p>
<hr>
<h1 id="Bitwise-Copy不出现的情况"><a href="#Bitwise-Copy不出现的情况" class="headerlink" title="Bitwise Copy不出现的情况"></a>Bitwise Copy不出现的情况</h1><p>&nbsp;<br>一个class有四种情况不会表现出bitwise copy：</p>
<ol>
<li>class内含一个member object，而后者有一个copy constructor（无论是开发者指定还是编译器合成）</li>
<li>class继承自一个base class，而后者存在一个copy constructor（无论是开发者指定还是编译器合成）</li>
<li>class声明了一个或多个virtual functions</li>
<li>class存在的继承体系内存在一个或多个virtual base class</li>
</ol>
<p>在前两种情况下，编译器会将member或base class的copy constructors插入至合成的copy constructors中。</p>
<hr>
<h1 id="重设定vptr"><a href="#重设定vptr" class="headerlink" title="重设定vptr"></a>重设定vptr</h1><p>&nbsp;<br>在上一节我们曾经阐述过，含有virtual functions的class会在编译期间构造函数会自发扩张：</p>
<ol>
<li>class会增加一个vtbl</li>
<li>class object会增加一个vptr</li>
</ol>
<p>显然，vptr是决定多态机制能否正确运行的关键，当编译器将vptr导入至class之中时，该class不再具备bitwise semantics。编译器需要合成一个copy constructor，将vptr合理初始化。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>现有继承体系及class声明如下：<br><img src="http://static.zybuluo.com/zsmj2017/5gae9idazakmnc5fwjk6ny40/image_1cchrq8qc1m3sqpgqhe15te9389.png" alt="image_1cchrq8qc1m3sqpgqhe15te9389.png-6.9kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal();</span><br><span class="line">    <span class="keyword">virtual</span> ~ZooAnimal();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...<span class="comment">//some data</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">public</span> ZooAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bear();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...<span class="comment">//some data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>ZooAnimal object相互赋值或者Bear object相互赋值都可以通过bitwise copy semantics完成。在这种情况下，vptr保持bitwise copy是安全的。</p>
<p>当一个base class object以其derived class object内容作初始化操作时，其vptr也需要保证安全：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bear B;</span><br><span class="line">ZooAnimal Z = B;<span class="comment">//sliced</span></span><br></pre></td></tr></table></figure><br>显然，Z的vptr不应该指向Bear的vtbl，也就是说，Base class被合成出来的copy constructor会明确设定object的vptr指向Base Class的vtbl，而非从rhs处执行bitwise copy。</p>
<hr>
<h1 id="处理Virtual-Base-Class-Subobject"><a href="#处理Virtual-Base-Class-Subobject" class="headerlink" title="处理Virtual Base Class Subobject"></a>处理Virtual Base Class Subobject</h1><p>&nbsp;<br>一个class object如果以另一个object作为初值，而后者带有一个virtual base class subobject，那么bitwise semantics同样会失效。</p>
<p>在上一节中我们已经编译器需要保证在运行期明确virtual base class subobject的位置。Bitwise copy可能会破坏这个位置。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>现有继承体系及class声明如下：<br><img src="http://static.zybuluo.com/zsmj2017/i73mehnd789qh71ex5eow5fm/image_1cchsh99imb2u671bk629s13ubm.png" alt="image_1cchsh99imb2u671bk629s13ubm.png-13.9kB"><br>···C++<br>class Raccoon:public virtual ZooAnimal{<br>public:<br>    Raccoon();<br>    Raccoon(int val);<br>    …<br>private:<br>    …//some data<br>}<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在开发者撰写的constructor中，编译器会生成：</span><br><span class="line"> 1. 调用ZooAnimal的default constructor代码</span><br><span class="line"> 2. Raccoon的vptr初始化代码</span><br><span class="line"> 3. 定位Raccoon中ZooAnimal subobject代码</span><br><span class="line"></span><br><span class="line">编译器会将上述代码插入至两个constructor之内，并且放在开头位置。</span><br><span class="line"></span><br><span class="line">当一个class object以其derived class object作为初值时，bitwise失效，因为此时编译器必须判断“后续当程序员试图存取其Base class subobject时程序能否正常运行。</span><br><span class="line">考虑如下继承体系与声明：</span><br><span class="line">![image_1cchtdv2o1tvlga1o4414a752613.png-20.9kB][3]</span><br><span class="line">&#96;&#96;&#96;C++</span><br><span class="line">class RedPanda:public Raccoon&#123;</span><br><span class="line">public:</span><br><span class="line">    RedPanda();</span><br><span class="line">    RedPanda(int val);</span><br><span class="line">private:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现有object分析图如下：<br><img src="http://static.zybuluo.com/zsmj2017/t4rmi6sxm5b92qdobblftzde/image_1cchtl7dq17ulenn30r19ej1tft20.png" alt="image_1cchtl7dq17ulenn30r19ej1tft20.png-130.2kB"><br>在下述代码中，编译器无法判断bitwise copy是否有效，因为编译器无法了解Raccoon是否指向了一个真正的Raccoon对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Raccoon *ptr;</span><br><span class="line">Raccoon little_critter = *ptr;<span class="comment">//可能ptr指向了派生类</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>我们是否可以认为，在bitwise copy完全合理的情况下，应当禁止调用copy constructor以优化程序？这个问题将会在后续章节中讨论。<br>本节我们讨论了class不再保持bitewise copy semantics的四种情况，在这四种情况下，如果未声明copy constructor，那么编译器为了保证初始化正确，将会合成一个copy constructor。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>构造、析构、拷贝语义学——&quot;无继承“情况下的对象构造</title>
    <url>/2018/05/28/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E6%97%A0%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<p>（由于学校琐事不断，本月更新过少，下个月需要参加电赛，可能会再次影响更新）</p>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>考虑下述程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point global;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point local;</span><br><span class="line">    Point *heap = <span class="keyword">new</span> Point;</span><br><span class="line">    *heap = local;</span><br><span class="line">    ...<span class="comment">//do sth</span></span><br><span class="line">    <span class="keyword">delete</span> heap;</span><br><span class="line">    <span class="keyword">return</span> local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中第一行、第五行、第六行体现出了完全不同的对象产生方式：global内存配置、local内存配置和heap内存配置。第七行将一个class object赋值给另一个，第九行，明确地delete heap object，第十行则设定返回值（此处再次发生了构造）。</p>
<p>一个object的生命是该object的一个执行期属性，local object的生命从第五行定义开始直至第十行为止。global object的生命与整个程序的生命相同，heap object的生命从它被new出来开始，直至被delete。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>我们假定Point有声明如下，C++ standrad称这种声明为所谓的Plain OI’s Data形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125; Point;</span><br></pre></td></tr></table></figure><br>如果以C++来编译这段代码，那么编译器理论上会为Point 声明一个trivial default constructor、一个trival destructor、一个trival copy constructor、以及一个trival copy assignment operator。但是实际上，编译器会分析该声明，并为其贴上Plain OI’s Data卷标。</p>
<p>当编译器遇到定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point global;</span><br></pre></td></tr></table></figure><br>观念上Point的trival constructor与destructor都会被产生与调用，constructor在程序起始处被调用而destructor在程序的exit()处被调用(exit()由编译器产生，置于main()函数结束之前)。然而，那些constructor与destructor要么是没定义，要么是没调用，程序的行为一如在C中的表现一样。</p>
<p>除了一处例外：在C中，global被视为一个“临时性定义”，因为它没有一个明确的初始化操作。一个临时性定义会在程序中发生多次，它们的实例会被链接器折叠，只留下一个单独的实体，被放在程序data segment中一个“特别保留给未初始化之global objects使用”的空间。</p>
<p>C++并不支持临时性的定义，这是因为class构造函数的隐含应用之故。虽然大家公认C++能够判定出目前对象是一个class object或是一个Plain OI’s Data,但似乎我们没有必要去分辨它们。因此，global在C++中被视为完全定义（阻止其他的定义）。C与C++的一大差异在于，BSS data segment在C++中不甚重要，C++中所有的全局对象都被当做初始化过的数据来对待。</p>
<p>foobar()中的第五行，有一个Point object local,同样既没有被构造也没有被析构，如果其在未经初始化的情况下就试图去使用，那么会引发bug。至于heap object在第六行中的初始化操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point* heap = <span class="keyword">new</span> Point;</span><br></pre></td></tr></table></figure><br>会被转换为对new操作符的调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point *heap = _new(<span class="keyword">sizeof</span>(Point));</span><br></pre></td></tr></table></figure><br>需要注意的是，并没有任何default constructor施行于new运算符所传回的Point object身上，第七行对此object有一个赋值操作，我们可能会认为object是一个Plain OI’s Data,所以赋值操作将只是简单地纯粹位搬移操作，第九行执行的delete将被转换为对delete运算符的调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_delete(heap);</span><br></pre></td></tr></table></figure><br>而非触发Point的trivial destructor。最后，函数以pass by value的方式将local当做返回值使用，这在观念上会触发trivial copy constructor，但实际上return操作只是执行了一个简单的位拷贝操作，因为对象是一个Plain OI’s Data。</p>
<hr>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p>&nbsp;<br>现在我们考虑Point加入了private数据之后的情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>,<span class="keyword">float</span> z = <span class="number">0.0</span>):</span><br><span class="line">        _x(x),_y(y),_z(z) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y,_z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>众所周知，封装并未给其带来空间上的额外开销，另外，我们并没有声明copy constructor或copy assignment operator，因为default bitwise已经足够，出于类似的原因，我们也不需要为其声明destructor。</p>
<p>对于一个global实体，现有default constructor作用于其上：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point global;<span class="comment">//执行Point::Point(0.0,0.0,0.0);</span></span><br></pre></td></tr></table></figure><br>由于global被定义在全局范畴，因此其初始化操作将会延迟到程序startup时才开始。</p>
<h2 id="explicit-initialization-list"><a href="#explicit-initialization-list" class="headerlink" title="explicit initialization list"></a>explicit initialization list</h2><p>如果需要对class中的所有成员均设定常量初值，那么给予一个explicit initialization list会比较高效。有实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point local1 = &#123;<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>&#125;;</span><br><span class="line">    Point local2;</span><br><span class="line">    local2._x=<span class="number">1.0</span>;</span><br><span class="line">    local2._y=<span class="number">1.0</span>;</span><br><span class="line">    local2._z=<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>local1的初始化操作比local2的更加高效，因为当函数的activation record被放进程序堆栈时，上述initialization list中的常量就可以被放入local1内存中。</p>
<p>Explicit initialization list存在3项缺陷：</p>
<ol>
<li>仅能作用于class member均为public的情况</li>
<li>只能指定常量，因为仅有常量能在编译时期就可以被evaluate</li>
<li>由于不存在自动施行，因此初始化行为的失败可能性会比较高</li>
</ol>
<p>一般来说，explicit initialization list带来的优势不足以弥补其弊端，但对于全局对象而言，explicit initialization list的效率要高于inline constructor。</p>
<p>在编译器层面，会有一个特殊的机制来识别inline constructor，然后将其转变为explicit initialization list那种格式（如果可以转变的话），如果不能转变，那么将提供member-by-member的常量指定操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Point local;</span><br><span class="line">    <span class="comment">//inline expansion</span></span><br><span class="line">    local._x=<span class="number">0.0</span>;local._y=<span class="number">0.0</span>;local._z=<span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="为继承做准备"><a href="#为继承做准备" class="headerlink" title="为继承做准备"></a>为继承做准备</h1><p>&nbsp;<br>我们的第三个Point声明，将为“继承性质”以及某些操作的dynamic resolution做准备：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x=<span class="number">0.0</span>,y=<span class="number">0.0</span>):_x(x),_y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>virtual function的引入使得每一个Point object拥有一个vptr，这可能会引起空间性能的降低。另外，virtual function的引入也将引发编译器对Point class产生膨胀作用：</p>
<ul>
<li>我们所定义的constructor被附加了一些代码，以便将vptr初始化。这些代码必须附加于任何base class constructors的调用之后，但必须在任何由开发者撰写的代码之前。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point* Point(Point *this,float x,float y):_x(x),_y(y)&#123;</span><br><span class="line">    <span class="comment">//以下为附加部分</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point = _vtbl_Point;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;-y = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>合成一个constructor与一个copy assignment operator，而且其操作不再为trivial（但implicit destructor依然是trivial）。bitwise操作可能会导致vptr非法：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">inline</span> Point*</span><br><span class="line"> Point::Point(Point *<span class="keyword">this</span>,<span class="keyword">const</span> Point &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point = _vtbl_Point;</span><br><span class="line">    <span class="comment">//执行原计划的复制操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编译器在优化状态下可能会把object的连续内容拷贝到另一个object上，而不是考虑memberwise的赋值操作。C++ standard要求编译器尽量延迟nontrivial members的实际合成操作，直到其真正使用。</p>
<p>我们再一次分析如下程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point global;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point local;</span><br><span class="line">    Point *heap = <span class="keyword">new</span> Point;</span><br><span class="line">    *heap = local;</span><br><span class="line">    ...<span class="comment">//do sth</span></span><br><span class="line">    <span class="keyword">delete</span> heap;</span><br><span class="line">    <span class="keyword">return</span> local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>*heap=local</code>memberwise赋值操作，可能会触发copy assignment operator的合成，及其调用操作的一个inline expansion：以this代替heao而以rhs代替local。</p>
<p>传值返回的那一行出现了更大的冲击，由于copy constructor的出现，foobar很有可能被转化成了下面的形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">(Point &amp;_result)</span></span>&#123;</span><br><span class="line">    Point local;</span><br><span class="line">    local.Point::Point(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">//heap与之前相同</span></span><br><span class="line">    _result.Point::Point(local);<span class="comment">//应用copy constructor</span></span><br><span class="line">    local.Point::~Point();<span class="comment">//destroy local</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果支持NRV优化，那么这个函数将会进一步被转化为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">(Point &amp;_result)</span></span>&#123;</span><br><span class="line">    _result.Point::Point(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">//heap部分相同</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般而言，如果你的程序中充斥着大量需要return value的函数（例如数值计算函数），那么提供一个copy constructor比较合理，因为这会触发NRV优化。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数语义学——Default Constructor的构造操作</title>
    <url>/2018/05/02/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Default%20Constructor%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>《C++ Annotated Reference Manual》(ARM)中曾提及：“default constructor…在需要的时候被编译器产生。”关键在于何时是被需要的时刻？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> val;Foo *pnext;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//需求bar's member均初始化为0</span></span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span>(bar.val || bar.pnext)&#123;</span><br><span class="line">        ...<span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述代码中，正确的程序语意要求bar的member被初始化为0，那么它符合ARM所说的“在需要的时刻”吗？答案是否定的。ARM所说的需要是编译器需要，而非程序语意需要。</p>
<p>C++ standard已经修改了ARM中的说法，但是实际相差不大。C++ standard约定：如果没有任何user—declared constructor，那么编译器会暗中(implictitly)自动生成一个default constructor（事实上标准会对此默认构造函数的修饰词是trival…)。</p>
<p>一个non-trivial default constructor才是编译器所需要的，下面的四个小节将分别讨论nontrival default constructor的四种情况。</p>
<hr>
<h1 id="“带有Default-Constructor”的Member-Class-Object"><a href="#“带有Default-Constructor”的Member-Class-Object" class="headerlink" title="“带有Default Constructor”的Member Class Object"></a>“带有Default Constructor”的Member Class Object</h1><p>&nbsp;<br>如果一个class没有任何constructor，但它内含一个member object且后者带有一个default constructor，那么该class的implict default constructor就是所谓的“non-trival”，编译器需要为此class合成出一个default constrcutor。不过该合成操作仅仅发生于constructor真正需要被调用时。</p>
<p>那么在C++各个不同的编译模块中，编译器如何避免生成多个default constructor？解决方法是把合成的default constructor、copy constructor、destructor、assignment copy constuctor均以inline形式完成。一个inline函数具备静态链接（static linkage），无法被档案以外者观察到。如果函数过于复杂，那则合成出explicit non-inline static实体。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在以下程序片段中，编译器会为class Bar合成一个default constructor:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo();</span><br><span class="line">    Foo(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">char</span>* str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Bar bar;<span class="comment">//此处bar被初始化，原因在于foo具备默认初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>被合成的Bar default constructor内含必要的代码，能够调用class Foo的default constructor来处理member object Bar::foo，但它并不产生任何代码来初始化Bar::str。被合成的default constructor看起来可能像这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Bar::Bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    foo.Foo::Foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了保证上述程序片段正常运行，str也需要被初始化。我们假定程序员经由下面的default constructor提供了str的初始化操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bar::Bar() &#123;str=<span class="literal">nullptr</span>;&#125;</span><br></pre></td></tr></table></figure><br>现在程序的要求已经得到了满足，但编译器还需要初始化memeber object foo。由于default constructor已经被明确定义，所以编译器不会生成第二个。那么编译器会如何执行？<br>编译器的执行策略是：“如果class A中含有一个或一个以上的member class objects，那么class A的每一个constructor必须调用每一个member classes的default constuctor”。编译器会在已经编写的constructors中插入必要的代码，保证在user_code执行之前，先调用必要的default constructor。仍以Bar为例，其具体的构造函数大致如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bar::Bar()&#123;</span><br><span class="line">    foo.Foo::Foo();</span><br><span class="line">    str=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果具备多个class member objects，那么它们的初始化顺序何如？编译器的解决方案是：以“member objects在class中的声明次序”来调用各个constructors。</p>
<hr>
<h1 id="“带有Default-Constructor的Base-Class”"><a href="#“带有Default-Constructor的Base-Class”" class="headerlink" title="“带有Default Constructor的Base Class”"></a>“带有Default Constructor的Base Class”</h1><p>&nbsp;<br>如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的deafualt constructor会被视为non-trivial，并且根据需要被合成出来。它会根据base class的声明顺序依次调用base class的default constructor。</p>
<p>但如果设计者提供了多个constructors，但没有default constructor呢？编译器会扩张现有的每一个constructors，将“用以调用所有必要之default constructor”的程序代码加入其中。编译器不会去合成一个新的constructor，因此用户已经编写了其他constructors。如果同时亦存在着“带有default constructors”的member class objects，那些default constructor也会被调用——在所有base class constructor都被调用之后。 </p>
<p>（我的理解是，如果base class具备多个构造函数，但不具备无参构造函数，那么编译器会在每一个有参构造函数中增加代码使其具备无参构造性，也就是可以理解为缺什么就再调用什么的default constructor）</p>
<hr>
<h1 id="“带有一个Virtual-Function”的class"><a href="#“带有一个Virtual-Function”的class" class="headerlink" title="“带有一个Virtual Function”的class"></a>“带有一个Virtual Function”的class</h1><p>&nbsp;<br>另有两种需要合成default constructor的情况：</p>
<ol>
<li>class声明（或继承）一个virtual function。</li>
<li>class所在的继承体系中存在一个或多个virtual base classes。</li>
</ol>
<p>上述两种情况由于缺乏user声明的constructors，编译器会详细记录合成一个default constructor的必要信息。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>以如下程序段为例：<br><img src="http://static.zybuluo.com/zsmj2017/1ot3oq7nov5tg8qsscgc4nou/image_1ccfn2t8p1gst10ks1v6o7pb1cjo9.png" alt="image_1ccfn2t8p1gst10ks1v6o7pb1cjo9.png-11.4kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">const</span> Widget&amp; widget)</span></span>&#123;</span><br><span class="line">    widget.flip();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line">    flip(b);</span><br><span class="line">    flip(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以下两个扩张操作会在编译期完成：</p>
<ol>
<li>vtbl被编译器产生，内放class的virtual functions地址。</li>
<li>在每一个class object中，编译器会放置一个vptr指向vtbl。</li>
</ol>
<p>此外，widget.flip()的virtual invocation会被改写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*widget.vptr[<span class="number">1</span>](&amp;widget);<span class="comment">//&amp;widget代表着this指针</span></span><br></pre></td></tr></table></figure><br>为了保证该机制生效，编译器必须为每一个Widget（包括其派生类）object的vptr设定初值。对于class所定义的每一个constructor，编译器都会扩张它们，在其中放入vptr的初始化。对于内部未声明constructor的classes，编译器会为它们合成一个default constructor，以便正确地初始化每一个class object的vptr。</p>
<hr>
<h1 id="“带有一个Virtual-Base-class”的class"><a href="#“带有一个Virtual-Base-class”的class" class="headerlink" title="“带有一个Virtual Base class”的class"></a>“带有一个Virtual Base class”的class</h1><p>&nbsp;<br>尽管virtual base class的实现在不同编译器间存在较大差异，但共同点在于必须使每一个virtual base class在其每一个derived class object中的位置在执行期准备妥当。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>以如下代码及继承体系为例：<br><img src="http://static.zybuluo.com/zsmj2017/szlyyjtfk99locreeymv5dur/image_1ccfo2g9e1n84rf81pjt17301c58m.png" alt="image_1ccfo2g9e1n84rf81pjt17301c58m.png-7.9kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> i;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>:<span class="keyword">int</span> j;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>:<span class="keyword">double</span> d;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A,<span class="keyword">public</span> B &#123;<span class="keyword">public</span>:<span class="keyword">int</span> k;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> A* pa)</span> </span>&#123;pa-&gt;i=<span class="number">1000</span>;&#125;<span class="comment">//无法在编译期了解pa-&gt;X::i的位置</span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    foo(<span class="keyword">new</span> A);</span><br><span class="line">    foo(<span class="keyword">new</span> C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>编译器无法固定住foo()之中“经由pa而存取的X::i”的实际偏移位置，因为pa的动态类型是不确定的。编译器的操作是改变执行存取操作的那些代码，从而令X::i可以延缓到运行期执行。</p>
<h3 id="cfront实例"><a href="#cfront实例" class="headerlink" title="cfront实例"></a>cfront实例</h3><p>以cfront编译器为例，其做法是在derived class object的每一个virtual base classes中安插一个指针。所有经由reference或pointer来存取一个virtual base class的操作都由该指针完成，如此一来，foo被改写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> A* pa)</span></span>&#123;</span><br><span class="line">    pa-&gt;_vbcx-&gt;i = <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>_vbcx是编译器所产生的指针，指向virtual base class X。<br>_vbcx是在class object建构期间被完成得。对于class所定义的每一个constructor，编译器会在其中扩展代码，保证允许在执行期确定virtual base class的地址。如果class没有声明任何constructors，编译器就会为其合成一个。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>有四种情况会导致编译器为没有声明construtor的classes合成default constructor，C++ standard将这些被合成物称为implicit non-trivial default constructors。被合成物满足的编译器的需要而非程序员的需要。在这四种情况之外且没有声明任何constructor的classes，拥有的是implicit trivial default constructor，实际上它们并不会被合成出来。</p>
<p>在合成的default constructor中，只有base subobject与member class objects会被初始化，所有其他的non-static data member均不会初始化，因为这些操作对编译器而言并非必须，因此需要程序员手动完成。</p>
<p>C++新手一般会有两个误解：</p>
<ol>
<li>任何class如果没有声明default constructor就会被合成出一个。</li>
<li>编译器合成出来的default constructor会初始化所有class member。</li>
</ol>
<p>以上两条都是错的。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>构造、析构、拷贝语义学——继承体系下的对象构造</title>
    <url>/2018/05/29/%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<h1 id="构造函数扩充"><a href="#构造函数扩充" class="headerlink" title="构造函数扩充"></a>构造函数扩充</h1><p>&nbsp;<br>当我们写下这样的表达式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T object;</span><br></pre></td></tr></table></figure><br>显然，T类型的constructor会被调用，但我们不太了解constructor的调用还伴随着什么。Constructor可能带有大量的隐藏代码，因为编译器会扩充每一个constructor，扩充程序视当前class T的继承体系而定，一般而言编译器所做的扩充操作大致如下：</p>
<ol>
<li>记录在member initialization list中的data members初始化操作会被放进constructor函数本身，并以member的声明顺序为执行次序。</li>
<li>如果有member并未出现在member initialization list中且它有一个default constructor，则该default constructor被调用。</li>
<li>如果class object有vptr，则vptr会被设定初值，指向适当的vtbl（这发生在所有member构造或赋值之前）。</li>
<li>所有上一层的base class constructors必须被调用，其调用顺序以继承规格中的声明顺序为准，而非依赖member initialization list：<blockquote>
<p>如果base class存在于member initialization list之中，那么任何明确指定的参数都应当被传入<br>如果base class并未存在于member initialization list之中，但其存在一个default constructor，则调用之<br>如果base class是多重继承下的后续base class，则this指针必须要发生调整</p>
</blockquote>
</li>
<li>所有virtual base class constructors必须被调用，从左到右，从深到浅<blockquote>
<p>如果class位于member initialization list中，则任何明确指定的参数都应当被传入，如果不在list中，则应当调用其default constructor<br>此外，class中的每一个virtual base class subobject的offset必须在执行期可被存取<br>如果class obejct是最底层的class，其constructors可能会被调用，某些用以支持该行为的机制应当被放入</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>我们再一次以Point举例，本次我们为其加入一个copy constructor、一个copy assignment operator、一个virtual destructor如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x=<span class="number">0.0</span>,y=<span class="number">0.0</span>);</span><br><span class="line">    Point(<span class="keyword">const</span> Point&amp;);</span><br><span class="line">    Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp;);</span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>现有class Line,每一个Line可以由两个Point构造：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">Point _begin,_end;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(<span class="keyword">float</span>=<span class="number">0.0</span>,<span class="keyword">float</span>=<span class="number">0.0</span>,<span class="keyword">float</span>=<span class="number">0.0</span>,<span class="keyword">float</span>=<span class="number">0.0</span>);</span><br><span class="line">    Line(<span class="keyword">const</span> Point&amp;,<span class="keyword">const</span> Point&amp;);</span><br><span class="line">    draw();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>每一个explicit constructor都会被扩充以调用其两个member class objects的constructors。如果我们定义constructor如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Line::Line(<span class="keyword">const</span> Point &amp;<span class="built_in">begin</span>,<span class="keyword">const</span> Point &amp;<span class="built_in">end</span>):</span><br><span class="line">    _end(<span class="built_in">end</span>),_begin(<span class="built_in">begin</span>) &#123;&#125;<span class="comment">//注意与声明顺序不一致</span></span><br></pre></td></tr></table></figure><br>该constructor会被扩充为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++伪代码</span></span><br><span class="line">Line*</span><br><span class="line">Line::Line(Line *<span class="keyword">this</span>,<span class="keyword">const</span> Point &amp;<span class="built_in">begin</span>,<span class="keyword">const</span> Point &amp;<span class="built_in">end</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_begin.Point::Point(<span class="built_in">begin</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;_end.Point::Point(<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于Point声明了一个copy constructor、一个copy assignment operator，以及一个destructor，所以Line class的implicit copy constructor、copy operator与destructor均不为trivial。</p>
<p>当我们写下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Line a;</span><br></pre></td></tr></table></figure><br>implicit destructor将会被合成，在implicit destructor中，它的member class objects的destructors会被调用（以其构造的相反顺序）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++伪代码</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">Line::~Line(Line *<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_end.Point::~Point();</span><br><span class="line">    <span class="keyword">this</span>-&gt;_begin.Point::~Point();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里需要注意的是，尽管Point的destructor具备virtual属性，但由于在本次实例中不具备任何多态性，因此在inline函数中其会被resolved statically。</p>
<p>类似地，当写下<code>Line b = a</code>时，copy constructor会被合成；写下<code>a = b</code>时，copy assignment operator会被合成。此处还有一个知识点在于不可忘记在operator=中处理自我赋值的可能性。</p>
<hr>
<h1 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h1><p>&nbsp;<br>考虑如下虚拟继承：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>)</span><br><span class="line">        :Point(x,y),_z(z) &#123;&#125;</span><br><span class="line">    Point3d(<span class="keyword">const</span> Point3d&amp; rhs)</span><br><span class="line">        :Point(rhs),_z(rhs._z) &#123;&#125;</span><br><span class="line">    ~Point3d();</span><br><span class="line">    Point3d&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point3d&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在本例中，传统的constructor扩充现象并无作用，这是由于virtual base class具备共享性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不合法的扩充内容</span></span><br><span class="line">Point3d* </span><br><span class="line">Point3d::Point3d(Point3d *<span class="keyword">this</span>,<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::Point(x,y);</span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point3d = _vbtl_Point3d;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point3d_Point = _vtbl_Point3d_Point;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_z = rhs._z;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述扩充内容是错误的，其错误之处将会在下文中给予说明。</p>
<h2 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h2><p>试考虑以下三种类派生情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Point &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex &#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PVertex</span>:</span><span class="keyword">public</span> Vertex3d &#123;...&#125;</span><br></pre></td></tr></table></figure><br>该继承体系结构如下图所示：<br><img src="http://static.zybuluo.com/zsmj2017/p766foze3j2tmtbchu7ewabo/image_1cekr65vk111p1p2gp9ej4jure9.png" alt="image_1cekr65vk111p1p2gp9ej4jure9.png-28.4kB"></p>
<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2><p>显然，Vertex的constructor必须调用Point的constructor，然而，当Point3d与Vertex同为Vertex3d的subobjects时，它们对Point constructor的调用必然不可发生，取而代之的是，作为最底层class，Vertex3d有责任初始化Point。而在更下层的继承体系中，Pvertex将负责完成Point subobject的构造。</p>
<p>传统的扩充策略无法区分当前是否需要初始化virtual base class，因此，它必须条件式地测试传入参数，然后再决定是否调用相关的virtual base class constructors。以下为Point3d的constructor扩充内容：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++伪代码</span></span><br><span class="line">Point3d*</span><br><span class="line">Point3d::Point3d(Point3d *<span class="keyword">this</span>,<span class="keyword">bool</span> _most_derived,<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)&#123;</span><br><span class="line">    <span class="keyword">if</span>(_most_derived!=<span class="literal">false</span>) <span class="keyword">this</span>-&gt;Point::Point(x,y);</span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point3d = _vbtl_Point3d;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point3d_Point = _vtbl_Point3d_Point;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_z = rhs._z;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在更深层的继承情况下，例如在Vertex3d中，当调用Point3d与Vertex的constructor时，总是会把_most_derived参数设为false，于是抑制了两个constructors中对Point constructor的调用操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vertex3d*</span><br><span class="line">Vertex3d::Vertex3d(Vertex3d *<span class="keyword">this</span>,<span class="keyword">bool</span> _most_derived,<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)&#123;</span><br><span class="line">    <span class="keyword">if</span>(_most_derived!=<span class="literal">false</span>)    <span class="keyword">this</span>-&gt;Point::Point(x,y);</span><br><span class="line">    <span class="comment">//在调用上一层constructor时总是将_most_derived设置为false</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Point3d::Point3d(<span class="literal">false</span>,x,y,z);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex::Vertex(<span class="literal">false</span>,x,y);</span><br><span class="line">    ...<span class="comment">//设定vptrs</span></span><br><span class="line">    ...<span class="comment">//出入user code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种策略可以保证语义正确无误，举例而言，当我们定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d origin;</span><br></pre></td></tr></table></figure><br>Point3d constructor可以正确地调用其Point virtual base class subobject。而当我们定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vertex3d cv;</span><br></pre></td></tr></table></figure><br>时，Vertex3d constructor正确地调用Point constructor。Point3d和Vertex的constructors会做每一件该做的事情——除了调用Point。</p>
<p>virtual base class constructors的被调用存在明确定义：只有当一个完整的class object被定义出来（例如origin），它才会被调用，如果当前object只是某个完整object的subobject，它则不会被调用。以此作为依据我们可以撰写更加优化的编译器策略：将每一个constructor一分为二，一个针对完整的object，另一个针对subobject。它们的区别主要在于是否调用virtual base constructor以及是否设定vptr。</p>
<hr>
<h1 id="vptr初始化语义学"><a href="#vptr初始化语义学" class="headerlink" title="vptr初始化语义学"></a>vptr初始化语义学</h1><p>&nbsp;<br>仍以上文提及的集成体系为例，当我们定义一个Pvertex object时，constructor的调用顺序为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point(x,y);</span><br><span class="line">Point3d(x,y,z);</span><br><span class="line">Vertex(x,y,z);</span><br><span class="line">Vertex3d(x,y,z);</span><br><span class="line">PVertex(x,y,z);</span><br></pre></td></tr></table></figure><br>假设该继承体系中的每一个class都定义了一个virtual function size()，返回当前pointer或者reference所指向的class的大小。更进一步地，我们假定每一个constructors均内置了一个调用操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d::Point3d(<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)</span><br><span class="line">    :_x(x),_y(y),_z(z)&#123;</span><br><span class="line">    <span class="keyword">if</span>(spyOn) <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么当我们定义PVertex object时，前述的五个constructor将会如何？C++语言规则约定，在构造函数尚未执行完毕时，对象本身性质并不明确。这意味着当每一个Pvertex base class constructors被调用时，编译系统必须确保有适当的size()函数实体被调用。最根本的解决方案是：在执行constructor时，必须限制一组virtual function候选名单，也就是说，必须要有一个确定的vptr指向正确的vtbl。为了能够正确地调用当前对应的virtual function实体，编译系统只需要简单地控制vptr的初始化和设定操作即可。</p>
<p>vptr初始化应当如何被处理？改答案视vptr在constructor中“应该何时被初始化”而定。我们有三种选择：</p>
<ol>
<li>在任何操作之前</li>
<li>在base class constructors调用操作之后，但在member initialization list或开发者提供的user code之前</li>
<li>在所有事情之后</li>
</ol>
<p>正确的选择是2，我们之前也是那么做的。令每一个base class constructor设定其对象的vptr，使它指向相关的vtbl，构造中的对象就可以严格而正确地编程“构造过程中所幻化出来的每一个class”的对象。constructor执行算法通常如下：</p>
<ol>
<li>在derived class constructor中，“所有virtual base classes”及“上一层base class”的constructor会被调用。</li>
<li>对象的vptr初始化，指向相关vtbl。</li>
<li>如果存在member initialization list，它们将会在vptr完成设定后展开，以免有一个virtual member function被调用(在Effective C++中我们了解到应当尽量避免在构造和析构函数中调用virtual function）。</li>
<li>执行user code。</li>
</ol>
<h2 id="问题实例-2"><a href="#问题实例-2" class="headerlink" title="问题实例"></a>问题实例</h2><p>以PVertex constructor为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PVertex::PVertex(<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)</span><br><span class="line">    :_next(<span class="literal">nullptr</span>),Vertex3d(x,y,z),Point(x,y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(spyOn) <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它很有可能被扩展为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PVertex*</span><br><span class="line">PVertex::PVertex(PVertex* <span class="keyword">this</span>,<span class="keyword">bool</span> _most_derived,<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)&#123;</span><br><span class="line">    <span class="keyword">if</span>(_most_derived!=<span class="literal">false</span>)    <span class="keyword">this</span>-&gt;Point::Point(x,y);</span><br><span class="line">    <span class="comment">//无条件地调用上一层base</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex3d::Vertex3d(x,y,z);</span><br><span class="line">    <span class="comment">//设定vptr</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_PVertex = _vtbl_PVertex;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_vptr_Point_PVertex = _vtbl_Point_PVertex;</span><br><span class="line">    <span class="keyword">if</span>(spyOn) <span class="built_in">cerr</span> &lt;&lt; (*<span class="keyword">this</span>-&gt;_vptr_PVertex[<span class="number">3</span>].faddr)(<span class="keyword">this</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>尽管上述做法完美解决了虚拟机制的问题，但在实际使用中这种策略并不完美。</p>
<p>下面是vptr必须被设定的两种情况：</p>
<ol>
<li>当一个完整的对象被构造时，如果我们声明一个Point对象，Point constructor必须设定其vptr。</li>
<li>当一个subobject constructor调用了一个virtual function时。</li>
</ol>
<p>如果我们声明了一个PVertex对象，然后由于我们对其base class constructors的最新定义，其vptr将不需要在每一个base class constructor中被设定。解决方法是将constructor分裂为一个完整的object与一个subobject实体，在subobject中，vptr的设定可以省略（就像上一小节末尾提及的那样）。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数语义学——程序转化语义学</title>
    <url>/2018/05/03/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8C%96%E8%AF%AD%E4%B9%89%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>考虑如下程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"X.h"</span></span></span><br><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可能会做出如下假设：</p>
<ol>
<li>foo()一旦被调用，就会传回xx的值。</li>
<li>如果class X定义了一个copy constructor，当foo()被调用时，该copy constructor一定会被调用。</li>
</ol>
<p>第一个假设的正确性视class X的定义而定。第二个假设的正确性，则视编译器的优化程度而定。我们甚至可以假设，在一个高品质C++编译器中，上述两点假设均不正确。</p>
<hr>
<h1 id="Explicit-Initialization"><a href="#Explicit-Initialization" class="headerlink" title="Explicit Initialization"></a>Explicit Initialization</h1><p>&nbsp;<br>已知存在如下定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X x0;</span><br></pre></td></tr></table></figure><br>下面有三个定义，每一个都显式地以x0的值来初始化class object：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_var</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;</span><br><span class="line">    X x2 = x0;</span><br><span class="line">    X x3 = X(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>必要的程序转化有两个阶段：</p>
<ol>
<li>重写每一个定义，剥离其中的初始化操作</li>
<li>class的copy constructor调用操作被插入程序</li>
</ol>
<p>经过转化后的foo_bar()程序看起来如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//剥离初始化操作</span></span><br><span class="line">    X x1;</span><br><span class="line">    X x2;</span><br><span class="line">    X x3;</span><br><span class="line">    <span class="comment">//插入copy constructor调用操作</span></span><br><span class="line">    x1.X::X(x0);<span class="comment">//调用 X::X(const X&amp; xx)</span></span><br><span class="line">    x2.X::X(x0);</span><br><span class="line">    x3.X::X(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Argument-Initialization"><a href="#Argument-Initialization" class="headerlink" title="Argument Initialization"></a>Argument Initialization</h1><p>&nbsp;<br>C++ standard中提及，将一个class object作为函数参数传递（或作为函数返回值）等价于以下形式的初始化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X xx = arg;</span><br></pre></td></tr></table></figure><br>因此，若有函数及调用语句如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x0)</span></span>;</span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">foo(xx);</span><br></pre></td></tr></table></figure><br>将会要求local instance x0以memberwise的方式将xx作为初值。<br>在编译器实现技术上，有一种策略是导入临时对象，并调用copy constructor将它初始化，然后将临时对象转交函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X _temp0;</span><br><span class="line">_temp0.X::X(xx);</span><br><span class="line">foo(_temp0);<span class="comment">//改写调用</span></span><br></pre></td></tr></table></figure><br>然而这样的转换并不完备，问题出在foo的声明式中。临时对象已经得到了正确的初值，但传入函数作为参数时又再一次导致了临时对象的生成。为了保证函数被正确调用，编译器会修改foo的声明，其形参会由一个class object变为相应的reference：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X&amp; x0)</span></span>;</span><br></pre></td></tr></table></figure><br>当foo完成后，临时对象将调用X::~X()，确保自身被析构。</p>
<p>另有一种编译器实现策略：copy construct，它将实际参数直接建构在其应该的位置上，在函数返回之前，局部对象（不同于刚才的临时对象）会被析构（我认为此法就是真正的建立一个object，然后在使用完毕后析构之）。</p>
<hr>
<h1 id="Return-Value-Initialization"><a href="#Return-Value-Initialization" class="headerlink" title="Return Value Initialization"></a>Return Value Initialization</h1><p>&nbsp;<br>考虑如下函数定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">//处理xx</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们需要关注的问题是bar()的返回值将如何从局部对象xx中拷贝。一种解决方案是双阶段转化：</p>
<ol>
<li>首先加上一个额外参数，其类型是class object的一个reference，该参数用来放置被copy construct得到的返回值。</li>
<li>在return指令前插入一个copy constructor操作，将局部对象的copy作为引用初值传递回去。</li>
</ol>
<p>转换后的bar函数大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X&amp; _result)</span></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    xx.X::X();</span><br><span class="line">    <span class="comment">//处理xx</span></span><br><span class="line">    _result.X::X(xx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同时现在的bar调用操作也被转换，以确保和新的定义匹配：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开发者撰写</span></span><br><span class="line">X xx = bar();</span><br><span class="line"><span class="comment">//转换后</span></span><br><span class="line">X xx;</span><br><span class="line">bar(xx);</span><br></pre></td></tr></table></figure><br>对于返回值的相关使用也被改写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开发者撰写</span></span><br><span class="line">bar().memfunc();<span class="comment">//调用成员函数</span></span><br><span class="line"><span class="comment">//转换后</span></span><br><span class="line">X _temp0;</span><br><span class="line">(bar(_temp0),_temp0).memfunc();<span class="comment">//,表达式</span></span><br></pre></td></tr></table></figure><br>同样的，如果程序声明了一个函数指针：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开发者撰写</span></span><br><span class="line">X  (*pf)();</span><br><span class="line">pf = bar;</span><br><span class="line"><span class="comment">//转换后</span></span><br><span class="line"><span class="keyword">void</span>  (*pf)(X&amp;);</span><br><span class="line">rx = bar;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Optimization-at-the-User-Level"><a href="#Optimization-at-the-User-Level" class="headerlink" title="Optimization at the User Level"></a>Optimization at the User Level</h1><p>&nbsp;<br>这种做法就是More Effective C++提及的RVO：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">(<span class="keyword">const</span> T &amp;y,<span class="keyword">const</span> T &amp;z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> X(y,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果编译器对RVO作出改写，那么应该有形式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X _result;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result,<span class="keyword">const</span> T &amp;y,<span class="keyword">const</span> T&amp;z)</span></span>&#123;</span><br><span class="line">    _result.X::X(y,z);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>仅仅付出了一个构造函数的代价，而这正是我们想要的。</p>
<hr>
<h1 id="Optimization-at-the-Compiler-Level"><a href="#Optimization-at-the-Compiler-Level" class="headerlink" title="Optimization at the Compiler Level"></a>Optimization at the Compiler Level</h1><p>&nbsp;<br>在一个诸如bar()的函数中，所有的return指令返回相同的named value，因此编译器可能会自己作出优化：方法是以result参数取代named return value：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...<span class="comment">//处理xx</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result)</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用default constructor</span></span><br><span class="line">    _result.X::X();</span><br><span class="line">    ...<span class="comment">//处理res</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（此种策略就是把xx转换为了_result)<br>这种编译器优化操作被称为Named Return Value(NRV)。</p>
<h2 id="NRV受到的批判"><a href="#NRV受到的批判" class="headerlink" title="NRV受到的批判"></a>NRV受到的批判</h2><p>尽管NRV优化提供了重大的效率改善，但它仍然饱受批判，其原因大致有三:</p>
<ol>
<li>优化由编译器自主执行，其执行程度不可控（很少有编译器会说明其实现程度或是否实现）。</li>
<li>如果函数相当复杂，优化就变得难以执行，许多人认为这种情况应当使用RVO取代之。</li>
<li>优化可能破坏了原有的程序</li>
</ol>
<p>一般而言，当一个class object作为另一个class object的初值这种情况发生时，C++允许编译器具有较大的弹性发挥空间。其优点在于机器码产生时效率得到了明显的提高，但缺点就是你无法清楚你的代码究竟被编译成为了何种形式。</p>
<hr>
<h1 id="是否需要定义copy-constructor"><a href="#是否需要定义copy-constructor" class="headerlink" title="是否需要定义copy constructor"></a>是否需要定义copy constructor</h1><p>&nbsp;<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y,_z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上述class有必要定义copy constructor吗？如果不定义，那么编译器会将default copy constructor视作trivial，其memberwise初始化操作会导致bitwise copy，这无疑兼具高效性与安全性。</p>
<p>那么上述class就一定没有必要定义copy constructor吗？答案是否定的。如果class object多次以传值的姿态作为函数参数，又或者作为函数返回值，那么explicit copy constructor有助于编译器执行NRV优化，当然我们也可以显式地使用RVO优化。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>copy constructor的使用多多少少使得编译器对你的代码做出了转化，如果我们能够了解那些转换，以及copy constructor优化后的可能状态，就可以对程序的执行效率有清楚的认知与控制。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数语义学——Member Initialization List</title>
    <url>/2018/05/10/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6%E2%80%94%E2%80%94Member%20Initialization%20List/</url>
    <content><![CDATA[<p>（5.4-5.9由于开题事宜断更，即日起恢复更新）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>当写下一个constructor时我们可以设定class members的初值：它们要么经由Member Initialization List，要么在construtor内部处理（除了4种情况必须使用member initialization list）。</p>
<hr>
<h1 id="何时必须使用member-initialization-list"><a href="#何时必须使用member-initialization-list" class="headerlink" title="何时必须使用member initialization list"></a>何时必须使用member initialization list</h1><p>&nbsp;<br>以下四种情况必须使用member initialization list：</p>
<ol>
<li>初始化一个reference member</li>
<li>初始化一个const member</li>
<li>调用一个base class的constructor，而它拥有一组参数</li>
<li>当调用一个member class的constructor，而它拥有一组参数</li>
</ol>
<hr>
<h1 id="member-initialization-list详解"><a href="#member-initialization-list详解" class="headerlink" title="member initialization list详解"></a>member initialization list详解</h1><h2 id="不使用member-initialization-list"><a href="#不使用member-initialization-list" class="headerlink" title="不使用member initialization list"></a>不使用member initialization list</h2><p>考虑如下程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>&#123;</span></span><br><span class="line">    <span class="keyword">String</span> _name;</span><br><span class="line">    <span class="keyword">int</span> _cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Word()&#123;</span><br><span class="line">        _name=<span class="number">0</span>;</span><br><span class="line">        _cnt=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该程序能够正确编译并执行，只是效率偏低。编译器在执行上述程序扩张代码使之生成一个临时对象，如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Word::Word(<span class="comment">/*this poniter*/</span>)&#123;</span><br><span class="line">    _name.<span class="keyword">String</span>::<span class="keyword">String</span>();</span><br><span class="line">    <span class="keyword">String</span> temp = <span class="keyword">String</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    _name.<span class="keyword">String</span>::<span class="keyword">operator</span>=(temp);</span><br><span class="line">    temp.<span class="keyword">String</span>::~<span class="keyword">String</span>();</span><br><span class="line">    _cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了保证高效，我们应当做到对任何初始化操作都执行member initialization list。</p>
<h2 id="member-initialization-list的作用"><a href="#member-initialization-list的作用" class="headerlink" title="member initialization list的作用"></a>member initialization list的作用</h2><p>当构造函数中出现member initialization list后，编译器会一一操作member initialization list，以<strong>member声明次序（而非list内部次序）</strong>在constructor之内安插初始化操作，次序问题极易引发危险操作，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(<span class="keyword">int</span> val):j(val),i(j) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>将会被扩张为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X::X(<span class="keyword">int</span> val)&#123;</span><br><span class="line">    i=j;<span class="comment">//初始化失败</span></span><br><span class="line">    j=bal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="member-initialization-list的疑难点"><a href="#member-initialization-list的疑难点" class="headerlink" title="member initialization list的疑难点"></a>member initialization list的疑难点</h1><h2 id="二探次序"><a href="#二探次序" class="headerlink" title="二探次序"></a>二探次序</h2><p>如果member initialization list中的项目被安插到constructor中，会继续保存声明次序吗？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X::X(<span class="keyword">int</span> val)</span><br><span class="line">    :j(val)&#123;</span><br><span class="line">        i=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>j的初始化操作会安插在explicit user assignment之前或者是之后？答案是initialization list的项目总会被放在explicit user code之前。</p>
<h2 id="initialization-list与member-function"><a href="#initialization-list与member-function" class="headerlink" title="initialization list与member function"></a>initialization list与member function</h2><p>能否调用一个member function以设定一个member的初值？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X::X(<span class="keyword">int</span> val)</span><br><span class="line">    :i(xfoo(val)),j(val)<span class="comment">//xfoo是X的一个member function</span></span><br><span class="line">    &#123;&#125;</span><br></pre></td></tr></table></figure><br>答案是可行的。但是…务必使用“存在于constructor体内的一个member”，而非“存在于member initialization list中的member”，来为另一个member设定初值。因为我们无法了解xfoo()对object的依赖性，在确保了xfoo()在constructor内部之后，对于“究竟是哪一个member在xfoo()执行时被设立初值”，就不会造成歧义。</p>
<p>member function的使用是合法的，是建立在和此object相关的this指针已经就位（我们暂且忽略与该member function相关的member），此时原代码大致被扩张为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X::X(<span class="comment">/*this pointer*/</span>)&#123;</span><br><span class="line">    i = <span class="keyword">this</span>-&gt;xfoo(val);</span><br><span class="line">    j = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果一个derived class member function被调用，其返回值作为base class constructor的参数呢？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span><span class="keyword">public</span> X&#123;</span><br><span class="line">    <span class="keyword">int</span> _fval;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fval</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _fval;&#125;</span><br><span class="line">    FooBar(<span class="keyword">int</span> val):_fval(val),X(fval()) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其扩张结果如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FooBar::FooBar(<span class="comment">/*this pointer*/</span>)&#123;</span><br><span class="line">    X::X(<span class="keyword">this</span>,<span class="keyword">this</span>-&gt;fval());</span><br><span class="line">    _fval =val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，这确实不合时宜。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>简单地说，编译器会对initialization list一一处理并且重新排序，以反映出member的声明次序。它会安插部分代码到constructor体内，并置于任何explicit user code之前。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>49.模板元编程</title>
    <url>/2018/04/23/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>template metaprogramming(TMP 模板元编程)是编写template-based C++程序并执行于编译期的过程。<br>所谓TMP，指的是以C++写成、执行于C++编译器内的程序。一旦TMP程序结束执行，其输出，也就是template具现出的若干C++源码，便会一如既往地编译。</p>
<hr>
<h1 id="TMP的优点"><a href="#TMP的优点" class="headerlink" title="TMP的优点"></a>TMP的优点</h1><p>&nbsp;<br>TMP有两大优点：</p>
<ol>
<li>让某些事情变得容易，如果没有它，则可能无法完成某些任务。</li>
<li>由于TMP执行于编译期，所以可以将工作从运行期转移到编译期。这直接导致了运行期的错误可以提前到编译期。另外，程序的每一个方面效率都得到了提高（较小的执行文件、较短的运行期、较少的内存）。然而缺点是编译时间变得很长。</li>
</ol>
<hr>
<h1 id="TMP实例"><a href="#TMP实例" class="headerlink" title="TMP实例"></a>TMP实例</h1><p>&nbsp;<br>上一节所描述的traits解法就是TMP，它引发<strong>编译期</strong>发生于类型身上的if…else条件判断。traits-based TMP解法是针对不同类型执行不同代码，每个函数所使用的操作都确保可以实行于其类型。</p>
<p>TMP已被证明是图灵完备的，你可以使用它声明变量、执行循环、编写调用函数等等。但你写出来的东西肯定明显和正常的c++不同，我们之前那一张用TMP写出来的ifelse就是如此（重载），不过那毕竟是汇编语言层级的TMP。</p>
<p>为了大致地描述一下TMP的工作方式，我们首先看看循环操作。TMP没有循环构件，所以循环效果藉由递归完成。TMP主要是一个函数式语言，因此使用递归也十分自然。但是，TMP的递归也并非我们所熟知的递归，因为它并<strong>不涉及递归函数调用，而是涉及“递归模板具现化”</strong>。</p>
<h2 id="TMP版阶乘计算"><a href="#TMP版阶乘计算" class="headerlink" title="TMP版阶乘计算"></a>TMP版阶乘计算</h2><p>通过实现阶乘计算，我们来示范以“递归模板具现化”实现循环，以及创建使用变量。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;value = n*Factorial&lt;n<span class="number">-1</span>&gt;::value&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;0&gt;&#123;</span></span><br><span class="line">    <span class="keyword">enum</span>&#123;value =<span class="number">1</span>&#125;;<span class="comment">//递归基</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先，每一个Factorial template都是一个struct，value用来保存当前计算所得的阶乘。如果TMP有循环构件，value应该在每一次循环中更新，但实际上由于TMP系以“递归模板具现化”取代循环，每一个具现体有一份自己的value，每一个value有其循环内的适当值。</p>
<hr>
<h1 id="TMP可以达成的目标"><a href="#TMP可以达成的目标" class="headerlink" title="TMP可以达成的目标"></a>TMP可以达成的目标</h1><ol>
<li>确保量度单位正确。<br>在使用TMP时可以保证在编译期程序中所有量度单位的组合都正确，不论其计算多么复杂，这也就是为何TMP可被用来进行早期错误侦测。</li>
<li>优化矩阵运算。<br>比如五个矩阵的连乘会创建四个临时矩阵，甚至产生了四个作用于矩阵元素身上的循环。如果采用高级TMP技术，就能够削减内存消耗并合并循环，加速计算。</li>
<li>生成客户定制的设计模式。<br>将各种设计模式的某些特性加以整合，设计出独有的特性。这项技术已经超越了编程工艺领域如设计模式与智能指针，更广义地成为了generative programming的一个基础。</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>TMP可将工作由运行期移到编译期，因而得以较早完成错误侦测和高效运行。</li>
<li>TMP可以定制设计模式，也可以规避某些并不适合特殊类型的代码。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板与泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>48.正确的include</title>
    <url>/2018/04/21/%E6%AD%A3%E7%A1%AE%E7%9A%84include/</url>
    <content><![CDATA[<p>STL头文件概要：</p>
<ul>
<li>所有的容器都在同名的头文件中</li>
<li>几乎所有算法都在algorithm中</li>
<li>上一句之所以用”几乎”是因为accumulate、inner_product、adjacent_difference、partial_sum，它们4个在numeric中</li>
<li>特殊的迭代器在iterator中声明</li>
<li>标准仿函数(<code>less&lt;T&gt;</code>等)和仿函数适配器（<code>not1</code>、<code>bind2nd</code>等）在functional中声明</li>
</ul>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>6.注意C++的分析机制</title>
    <url>/2018/04/07/%E6%B3%A8%E6%84%8FC++%E7%9A%84%E5%88%86%E6%9E%90%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>假设我们有一个存有整数的文件，并试图把它们复制到一个list中，我们也许会写下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">dataFile</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(istream_iterator&lt;<span class="keyword">int</span>&gt;(dataFile), istream_iterator&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure><br>这里的想法是传一对istream_iterator给list的区间构造函数,尽管它不会发生编译错误（还不如发生），但运行效果和期望的相差很大。准确的说，它并没有声明一个list，也没有构造。</p>
<p>我们先从简单的部分开始解释，在c++中，以下三种声明均是合法且等价的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> (d))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>接着看三个函数声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//g是一个返回值为int的函数，其形参是一个函数指针，该指针指向一个不需要形参且返回值为double的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span> (*pf)())</span></span>; </span><br><span class="line"><span class="comment">//同上，pf其实是一个函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span> pf())</span></span>;</span><br><span class="line"><span class="comment">//同上，省略了参数名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span> ())</span></span>;</span><br></pre></td></tr></table></figure><br>请注意围绕参数名的括号，比如第一组第二个的(d)与独立的括号的区别。<strong>围绕参数名的括号可以被忽略，而独立的括号则表明参数列表的存在，它说明前面存在一个函数指针参数。</strong></p>
<p>返回到问题，我们仔细观察这一行语句：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(istream_iterator&lt;<span class="keyword">int</span>&gt;(dataFile), istream_iterator&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure><br>这其实是声明了一个函数，其返回值是list&lt;int&gt;，函数名为data，接受两个参数：</p>
<blockquote>
<p>第一个参数名为dataFile，是一个迭代器。（认为dataFile两侧括号多余）<br>第二个参数没有名称，它的类型是指向一个没有参数而且返回istream_iterator<int>的函数的指针</p>
</blockquote>
<p>顺便一提，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;; <span class="comment">// 假设Widget有默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>这种东西自然是不能构造对象的，因为它其实是声明了一个不接受参数且返回一个Widget的函数。</p>
<p>为了解决我们遇到的这种烦人的分析机制，我们可以给迭代器名字：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">"ints.dat"</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">dataBegin</span><span class="params">(dataFile)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; dataEnd;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(dataBegin, dataEnd)</span></span>;</span><br></pre></td></tr></table></figure><br>尽管这种命名式实参的风格与STL相违背，但是为了避免二义性并增加可读性，这不失为一种优雅的解决方式。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>34.混合使用C与C++</title>
    <url>/2018/04/30/%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8C%E4%B8%8EC++/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在混合编程前，首先确保你的C++编译器和C编译器兼容。确认兼容后，还有四个需要考虑的问题：名变换、静态初始化、内存动态分配、数据结构兼容。</p>
<hr>
<h1 id="名变换"><a href="#名变换" class="headerlink" title="名变换"></a>名变换</h1><p>&nbsp;<br>名变换，就是C++编译器给程序的每个函数换一个独一无二的名字。C没有函数重载，因此不需要该过程。重载不兼容于绝大部分链接程序，因为链接程序通常无法分辨同名的函数，它坚持函数名必须独一无二。名变换是C++对编译器的妥协。<br>在C++使用范围内用户无需考虑名变换，但在C运行库中，那么情况截然不同。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>举例而言，在Cpp包含的头文件中，drawline被声明为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>;</span><br></pre></td></tr></table></figure><br>代码体中通常也是调用drawLine，每一个这样的调用都被编译器转换为调用名变换后的函数，所以写下的是<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">drawLine(a, b, c, d);</span><br></pre></td></tr></table></figure><br>在obj中被调用的是：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">xyzzy(a, b, c, d);<span class="comment">//编译器变换了名称</span></span><br></pre></td></tr></table></figure><br>但如果drawline是一个C函数，obj文件（或者是动态链接库之类的文件）中包含的编译后的drawline函数仍然叫drawline，不会发生名变换动作。这意味着链接时将发生错误，因为链接程序找不到xyzzy函数的存在。</p>
<hr>
<h2 id="解决方案（extern-“C”"><a href="#解决方案（extern-“C”" class="headerlink" title="解决方案（extern “C”)"></a>解决方案（extern “C”)</h2><p>我们需要某种方法告诉C++编译器不要在这个函数上进行名变换，就是使用C++的<code>extern &quot;C&quot;</code>关键词：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>;</span><br></pre></td></tr></table></figure><br>不要以为有一个extern “C”，那么就应该同样有一个extern “Pascal”和extern “FORTRAN”之类。该关键词的意思是下述函数应该被当作C语言写的一样。所以汇编也是用extern “C”声明，甚至可以在C++函数上申明 extern “C”。（用C++写库给其他语言的客户使用），这样编译器就不会对你的函数执行名变换。<br>如果你需要批量地声明函数无需名变换，extern “C”可以对一组函数生效，只要将它们放入一对大括号中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">twiddleBits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> bits)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(<span class="keyword">int</span> iterations)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种技巧普遍适用于头文件中。假设当前头文件可能被C++编译器编译也可能会被C语言编译器编译。当用C++编译时，你应该加 extern “C”，但用C编译时则不必。通过只在C++编译器下定义的宏__cplusplus，头文件的写法很简单：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">twiddleBits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> bits)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(<span class="keyword">int</span> iterations)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>顺便提及一下，名变换没有标准规则，不同的编译器名变换不同。</p>
<hr>
<h1 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h1><p>&nbsp;<br>在C++中，main函数执行前和执行后都有大量代码被执行。具体来说，静态的类对象和定义在全局的、命名空间中的或文件体中的类对象的构造函数通常在main执行前就被调用。这个过程称为静态初始化。同样，通过静态初始化产生的对象也要在静态析构过程中调用其析构函数，这个过程通常发生在main结束<br>运行之后。<br>为了解决main应该首先被调用，而对象又需要在main执行前被构造的两难问题，许多编译器在main的最开始处插入了一个特别的函数，由它来负责静态初始化。同样地，编译器在main结束处插入了一个函数来析构静态对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    performStaticInitialization();</span><br><span class="line">    ...<span class="comment">//the statements you put in main go here;</span></span><br><span class="line">    performStaticDestruction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>示例中函数的名称不需要在意，关注要点是：如果一个C++编译器采用这种方法来初始化和析构静态对象，那么除非你用C++写了main函数，否则这些对象既不会构造也不会析构。因此只要代码中有C++部分，就应该使用C++的main函数。<br>但有时似乎用C写main更有意义————比如当前程序的大部分都是用C写的，C++部分只是一个支持库。然而，这个C++库很可能含有静态对象（即使现在没有，以后也可能会有），所以仍然需要用C++写main函数。但我们并不需要改写C语言代码，只要将C写的main改名为realmain，然后用C++版本的main调用realMain：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">realMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;<span class="comment">//in C++</span></span><br><span class="line">    <span class="keyword">return</span> realMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不这么写，就无法确保确保静态对象是否已经构造和析构。 </p>
<hr>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>&nbsp;<br>动态内存分配的规则很简单：C++部分使用new和delete，C部分使用malloc和free。用free释放new 分配的内存或用delete释放malloc分配的内存，其行为没有定义。<br>说起来容易，做起来未必简单。比如strdup函数，它并不存在于C和C++标准库中，却很常见：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ps)</span></span>; <span class="comment">// return a copy of the string pointed to by ps</span></span><br></pre></td></tr></table></figure><br>为了避免内存泄漏，strdup的调用者必须释放分配的内存。那是使用delete还是free呢？如果你调用的 strdup来自于C函数库中，使用free，否则使用delete.<br>在调用strdup后所需要做的操作，在不同的操作系统下不同，在不同的编译器下也不同。为了减少这种可移植性问题，应当尽可能避免调用那些既不在标准运行库中也没有固定形式的函数 。</p>
<hr>
<h1 id="数据结构兼容性"><a href="#数据结构兼容性" class="headerlink" title="数据结构兼容性"></a>数据结构兼容性</h1><p>&nbsp;<br>最后一个问题是在C++和C之间传递数据。<br>C与C++的交互必须限定在C可表示的概念上。因此，不可能传递给C语言对象或者成员函数指针。但C中存在着普通指针的概念，所以C和C++的函数可以安全地交换”指向对象的指针”和”指向非成员的函数或静态成员函数的指针”。同样，struct和内置类型的变量也可自由交换。<br>因为C++中struct兼容C中的规则，因此C编译器和C++编译器处理struct得到的结果一样。在C++ struct中增加非虚函数不会导致内存结构发生改变，因此，只有非虚函数的strcut的对象兼容于它们在C 中的孪生版本（C++成员函数并不在对象的内存布局中体现）。增加虚函数和加入继承体系会改变内存布局，此时无法完成C与C++的安全交换。<br>就数据结构而言，我们可以认为在C++和C之间相互传递数据结构是安全的（前提是结构式的定义在C和C++中都可编译）。在 C++版本中增加非虚成员函数或许不影响兼容性，但几乎其它的改变都将影响兼容。  </p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>45.查找算法</title>
    <url>/2018/04/21/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>假设我们需要在一个区间内进行搜寻，并且拥有众多的搜索策略:count、count_if、find、find_if、binary_search、lower_bound、upper_bound和equal_range。</p>
<hr>
<h1 id="区间的有序性"><a href="#区间的有序性" class="headerlink" title="区间的有序性"></a>区间的有序性</h1><p>&nbsp;<br>在查找之前，首先要判断区间的性质，如果是有序区间，可以用binary_search、lower_bound、upper_bound和equal_range，它们消耗对数时间。<br>如果不是，那你只能用线性时间的算法count、count_if、find和find_if。</p>
<h2 id="无序区间"><a href="#无序区间" class="headerlink" title="无序区间"></a>无序区间</h2><p>&nbsp;<br>如果你已经选择了find或者count，要明白它们针对的问题并不相同。</p>
<ul>
<li>count回答的问题是“是否存在，如果有，则存在几份”</li>
<li>find则回答“是否存在，如果有，它在哪儿”</li>
</ul>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>如果你想知道是否有一个特定的Widget值w在list中。<br>使用count的代码大概如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;Widget&gt; lw; </span><br><span class="line">Widget w;<span class="comment">//被搜索物</span></span><br><span class="line"><span class="keyword">if</span> (count(lw.<span class="built_in">begin</span>(), lw.<span class="built_in">end</span>(), w))<span class="comment">//true则存在</span></span><br></pre></td></tr></table></figure><br>如果使用find，则代码大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(lw.<span class="built_in">begin</span>(), lw.<span class="built_in">end</span>(), w) != lw.<span class="built_in">end</span>())<span class="comment">//true则存在</span></span><br></pre></td></tr></table></figure><br><strong>count在这里的效率要低于find</strong>，因为find一旦找到就终止算法，而count则一直搜索到结尾。同时，find能够提供对象所在的位置，这也是count做不到的。</p>
<hr>
<h2 id="有序区间"><a href="#有序区间" class="headerlink" title="有序区间"></a>有序区间</h2><p>对于有序区间，查找的效率得到了提高。但是因此导致了另一个问题，<strong>判同由相等变为了等价</strong>。别忘了，count和find算法都用相等来搜索，而binary_search、lower_bound、upper_bound和equal_range则基于等价。</p>
<p>binary_search只返回bool，也就是说，它只能告诉你某个值是否存在于区间内，如果你需要其具体的位置，那我们得使用equal_range，或者lower_bound。</p>
<h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>lower_bound在寻找时返回一个迭代器，它往往<strong>指向该值的第一个copy或者可以插入该值的位置</strong>，具体使用方略如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = lower_bound(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), w);</span><br><span class="line"><span class="keyword">if</span> (i != vw.<span class="built_in">end</span>() &amp;&amp; *i == w) &#123;<span class="comment">//存在bug</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>bug在于lower_bound使用等价判定，而非相等判定。</strong>尽管在大多数情况下他们确实是一致的，但正如Effective STL 19所指出的那样，总有例外。</p>
<h3 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h3><p>equal_range是一个非常好用的算法，它返回一对迭代器，第一个等于lower_bound返回的，第二个等于upper_bound返回的。因此，它返回了与你要搜索的值等价的区间。使用方略如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br><span class="line">sort(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Widget&gt;::iterator VWIter;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;VWIter, VWIter&gt; VWIterPair;</span><br><span class="line">VWIterPair p = equal_range(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), w);</span><br><span class="line"><span class="keyword">if</span> (p.first != p.second) &#123;</span><br><span class="line">    ...<span class="comment">//找到了，且p.first指向第一个</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ...<span class="comment">//不在区间内，不过找到了合适的插入位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>另外，对这两个迭代器作distance得到的就是count的功能。</p>
<hr>
<h1 id="寻找位置"><a href="#寻找位置" class="headerlink" title="寻找位置"></a>寻找位置</h1><p>&nbsp;<br>之前一直假设任务为在区间中搜索某个特定值，但有时候我们更感兴趣于在区间中寻找一个位置。</p>
<h2 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设我们有一个TimeStamp类与一个存储它的vector，它的排序方式是老的在新的前面：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timestamp</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Timestamp&amp; lhs,<span class="keyword">const</span> Timestamp&amp; rhs); <span class="comment">//按照时间比较</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Timestamp&gt; vt; </span><br><span class="line">sort(vt.<span class="built_in">begin</span>(), vt.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>现在我们有一个特殊的TimeStamp对象——ageLimit，而且我们需要从vt中删除所有比ageLimit老的TimeStamp。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在这种情况下，我们不需要在vt中搜索和ageLimit等价的Timestamp，因为可能不存在任何等价于这个精确值的元素。取而代之的是，我们需要在vt中找到一个位置<strong>：第一个不比ageLimit更老的元素</strong>。那无疑应当使用lower_bound.<br>那如果是删除所有至少和agelimit一样大的呢？那无疑是使用upper_bound.</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>我们可以根据下表来判断何时使用何种查找算法：<br><img src="http://static.zybuluo.com/zsmj2017/1mssi836j0zopjbej9dd8hte/image_1cbiseq7rd1919oe1s6a9pf1sjg9.png" alt="image_1cbiseq7rd1919oe1s6a9pf1sjg9.png-114.4kB"></p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.用auto代替显式类型声明</title>
    <url>/2018/06/26/%E7%94%A8auto%E4%BB%A3%E6%9B%BF%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>通过使用auto技术，我们省下了打字的时间，但可能会带来一些手动声明类型所不会造成的错误或性能问题。作为C++开发者，我们应当尽力掌握auto以期获取正确结果。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>在C++11中未曾出现之前，声明一个变量可能会出现三种令人厌恶的情况：</p>
<ol>
<li><strong>忘记初始化</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;<span class="comment">//x's value depends on the context</span></span><br></pre></td></tr></table></figure></li>
<li><strong>类型名过长</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dwim</span><span class="params">(It b, It e)</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">       <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;It&gt;::value_type currValue = *b;</span><br><span class="line">       …</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>变量类型不确定（闭包），只有编译器知道具体类型</strong></li>
</ol>
<p>C++11引入的auto技术完美解决了上述三点问题。使用auto声明的变量会从初始化语句中推断类型，因此它们必然会被初始化，并且无需写出繁复的类型名称：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">0</span>;<span class="comment">//must be initialized</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt; <span class="comment">// as before</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dwim</span><span class="params">(It b, It e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">        <span class="keyword">auto</span> currValue = *b;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> derefUPLess = []<span class="comment">//only compiler know return closure's type</span></span><br><span class="line">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp; p1,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp; p2)</span><br><span class="line">&#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure><br>C++14将这一特性再次升级，现在lambda表达式内部也可以使用auto了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> derefLess = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p1,<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p2)</span><br><span class="line">&#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;; <span class="comment">// to by anythin</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h1><p>&nbsp;<br>有人认为我们没有必要使用auto来声明一个持有closure的变量，因为我们可以使用std::function对象。前提是你了解function object。</p>
<p>std::function是C++11标准库中的一个模板，其类似于一个通用函数指针。函数只能指向一个函数，但std::function可以指向任何一个可调用对象。当你声明一个函数指针时你必须指出其指向函数的签名，function object亦是如此，其使用大致如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++11 signature for std::unique_ptr&lt;Widget&gt; comparison function</span></span><br><span class="line"><span class="keyword">bool</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp;, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp;,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp;)&gt; func;</span><br></pre></td></tr></table></figure><br>由于lambda表达式生成了可调用对象，因此closure可以保存在std::function对象之中，因此我们在不使用auto技术的前提下可以将derefUPLess函数声明为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp;,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp;)&gt;</span><br><span class="line">derefUPLess = [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp; p1,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;&amp; p2)</span><br><span class="line">&#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure><br>即使不考虑语句冗长与类型反复撰写，使用std::function与使用auto也截然不同。一个持有closure由auto声明的变量与闭包具备同样的类型，因此其只需要与闭包一致的内存即可。但持有closure的function对象是一个template的实例化，因此其所占有的内存与签名式相关，但该内存可能并不足以存放closure，那么此时function将会分配heap内存以存储closure。这一特性导致function对象往往比auto对象使用更多的内存。此外，由于限制内联及函数简介调用，由一个function对象触发closure往往会慢于auto对象。</p>
<p>总之，function对象往往占用较多的内存且慢于auto对象，并且可能会产生内存异常。使用function也没有auto简洁与直观。</p>
<hr>
<h1 id="auto的其他优点"><a href="#auto的其他优点" class="headerlink" title="auto的其他优点"></a>auto的其他优点</h1><p>&nbsp;<br>auto还有一个好处是可以避免”type shortcuts”，比如你可能看过甚至自己写过这样的程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">unsigned</span> sz = v.<span class="built_in">size</span>();<span class="comment">//其类型不应为unsigned，这里只是因为开发者偷懒</span></span><br></pre></td></tr></table></figure><br>有人认为unsigned类型与vector<int>::size_type一致，但实际上这是错误的，在64位电脑中vector<int>::size_type为64位，而unsigned只有32位，如果使用auto则可以避免这一问题。</p>
<p>又有实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; p : m)&#123;</span><br><span class="line">    … <span class="comment">// do something with p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个程序看起来并没有什么不对（如果你没有读过Effective STL或类似书籍的话），但实际上，pair的类型并非pair&lt;std::string,int&gt;,而是pair&lt;const std::string,int&gt;。由于类型不一致，编译器将会生成一个临时对象绑定到p上，并且在每一次循环结束后析构该对象。这不仅仅付出了构造、析构的成本，你所有的操作最终都将作用于临时对象之上，对m中的元素并没有发挥任何作用，但使用auto则可避免这一问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p:m)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="auto可读性"><a href="#auto可读性" class="headerlink" title="auto可读性"></a>auto可读性</h1><p>&nbsp;<br>当然，auto并非尽善尽美，原因在auto作类型推衍的根基在于其初始化表达式，而这可能会带来非你所想的类型推衍结果，在Item2与Item6中介绍了它们的产生原因与消除方案，因此本节不再赘述。接下来要讨论的是auto所带来的可读性问题。</p>
<p>首先我们需要明确的是，auto只是一个可选项而非强制性措施。根据以往的编程经验，代码应当尽可能在简洁的同时做到可维护，但auto并没有破坏这些原则，实际上无论是静态语言（C#，VB等），还是动态语言（Haskell，F#等），类似的功能早已出现，类型推衍与传统编程原则并没有任何冲突。</p>
<p>有些开发者会担心使用auto将导致他们无法快速了解某变量的类型，但实际上IDE会显示出这些变量的类型，并且在许多情况下，我们只需要知道对象的大概类型即可（例如只需要了解其是一个指针、迭代器、容器，而不需要知道具体类型）。一个好的变量名应当能够正确地反映出大致数据类型。</p>
<p>事实上，显式类型说明几乎没有特别明显的优点，它可能会引入微妙的错误，又或者会对效率产生一定影响，甚至二者兼而有之。此外，使用auto完成声明的对象会在其初始化表达式发生改变时自动更改类型，这对重构有着莫大帮助。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>使用auto声明对象意味着必须初始化，并且能够规避类型匹配错误与可移植性、效率低下等问题。在此基础之上，auto还能够简化重构过程，节约大量不必要的类型声明代码。</strong></li>
<li><strong>auto可能存在一些缺陷，这些在Item2与Item6中有所描述。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>42.less&amp;lt;T&gt;与operator&lt;</title>
    <url>/2018/04/20/%E7%94%A8less%E8%A1%A8%E7%A4%BAoperator/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设当前存在对象Widget，其具备重量与最高速度属性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">weight</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">maxSpeed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们默认以重量为排序方式，所以<code>Widget::operator&lt;</code>如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Widget&amp; lhs, <span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.weight() &lt; rhs.weight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但如果我们想建立一个按照最高速度排序的<code>multiset&lt;Widget&gt;</code>,而我们又知道默认的比较函数是<code>less&lt;Widget&gt;</code>，而默认的<code>less&lt;Widget&gt;</code>又调用<code>operator&lt;</code>工作。那似乎我们必须特化<code>less&lt;Widget&gt;</code>来切断<code>less&lt;Widget&gt;</code>与<code>operator&lt;</code>之间的纽带，让它只关心speed：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">//less针对Widget的一个特化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:less&lt;Widget&gt;:<span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;Widget,Widget,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget&amp; lhs, <span class="keyword">const</span> Widget&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.maxSpeed() &lt; rhs.maxSpeed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种行为是在特化std namespace里面的模板，虽然std禁止了大部分修改操作，但这种自定义模板特化还是允许的。（Effective C++ 26 也执行了这样的操作）<br>但<strong>令less做除operator&lt;以外的事情是对预期行为的无故破坏</strong>，就像你不应该把operator+重载成乘法一样。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br><strong>STL中没有一个用到less的地方你不能指定一个不同的比较类型</strong>。比如说我们可以建立一个名字不叫less的仿函数类:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MaxSpeedCompare</span>:</span><span class="keyword">public</span> binary_function&lt;Widget, Widget, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget&amp; lhs, <span class="keyword">const</span> Widget&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.maxSpeed() &lt; rhs.maxSpeed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">multiset</span>&lt;Widget, MaxSpeedCompare&gt; widgets;<span class="comment">//自定义比较器</span></span><br></pre></td></tr></table></figure><br>我们不应该切断<code>less&lt;T&gt;</code>与<code>operator&lt;</code>的关联性，如果你确有需要，应当在声明容器时同时声明自定义比较器。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>仿函数</tag>
      </tags>
  </entry>
  <entry>
    <title>19.相等与等价的区别</title>
    <url>/2018/04/11/%E7%9B%B8%E7%AD%89%E4%B8%8E%E7%AD%89%E4%BB%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>在STL中，对两个对象进行比较，并且判定它们是否具有相同的值，这种操作十分常见。举例而言，find算法可以定位区间中第一个具有某个特定值的元素，这种操作必须基于对象的比较。set的insert成员函数在执行插入前也必须明确该值是否已经存在于容器内部，这同样基于比较。</p>
<hr>
<h1 id="相等与等价"><a href="#相等与等价" class="headerlink" title="相等与等价"></a>相等与等价</h1><p>&lt;/br&gt;<br>上文所说的find算法与insert成员函数都需要判定两个值是否<strong>相同</strong>，但其实现则完全不同。<br><strong>find对“相同”的定义是相等，基于operator==</strong>。<br><strong>set::insert对“相同”的定义是等价，通常基于operator&lt;。</strong></p>
<h2 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h2><p>相等的概念基于<code>operator==</code>。如果表达式“x == y”返回true，我们认为x与y具有相等的值。这种相等是定义性的，只和<code>operator==</code>的返回值有关。也就是说，只要<code>operator==</code>撰写者愿意，我们完全可以判定猫和狗相等。</p>
<h2 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h2><p><strong>等价基于一个有序区间中对象值的相对位置</strong>。也就是说，等价仅在关联容器内部排序时存在意义。等价的定义是，<strong>如果对象x与对象y在关联容器c中的排序顺序并不分先后，则它们等价</strong>。从逻辑角度而言，基于<code>operator&lt;</code>的等价有这样的形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">!(x&lt;y) &amp;&amp; !(y&lt;x)</span><br></pre></td></tr></table></figure><br>一般情况下关联容器的比较函数不是<code>operator&lt;</code>或 <code>less</code>，是用户自定义的判断式。每个关联容器通过key_comp成员函数来访问排序判断式，因此真正意义上的等价有形式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">!c.key_comp()(x, y) &amp;&amp; !c.key_comp()(y, x) <span class="comment">//key_comp返回一个函数（或函数对象）</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><h2 id="建立case-insensitive-string-set"><a href="#建立case-insensitive-string-set" class="headerlink" title="建立case-insensitive string set"></a>建立case-insensitive string set</h2><p>假设需要建立一个忽略大小写的set&lt;string&gt;,显然，我们需要自行建立一个比较函数，该函数比较string对象的同时忽略大小写。<strong>set在声明时需要的是比较函数的类型，并非真的函数</strong>，因此我们构建了一个<strong>仿函数类</strong>（仿函数详见Effective STL·仿函数篇），并在operator()调用了忽略大小写的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CIStringCompare</span>:</span> <span class="keyword">public</span> binary_function&lt;<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//binary_function 详见Effective STL 40</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lhs,<span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ciStringCompare(lhs, rhs);<span class="comment">//具体实现见Effective STL 35</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该set的建立和使用如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&amp;lt;<span class="built_in">string</span>, CIStringCompare&gt; ciss;<span class="comment">//"case-insensitive string set"</span></span><br><span class="line">ciss.insert(<span class="string">"ABC"</span>); <span class="comment">// 一个新元素添加到set中</span></span><br><span class="line">ciss.insert(<span class="string">"abc"</span>); <span class="comment">// 没有新元素添加到set中</span></span><br></pre></td></tr></table></figure></p>
<h2 id="find成员函数与find算法的不同"><a href="#find成员函数与find算法的不同" class="headerlink" title="find成员函数与find算法的不同"></a>find成员函数与find算法的不同</h2><p>我们在新建立的容器中查找刚才加入的”abc”(大小写被忽略），find成员函数与find算法返回的值却并不相同：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ciss.<span class="built_in">find</span>(<span class="string">"abc"</span>) != ciss.<span class="built_in">end</span>())... <span class="comment">//true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(ciss.<span class="built_in">begin</span>(), ciss.<span class="built_in">end</span>(),<span class="string">"abc"</span>) != ciss.<span class="built_in">end</span>())... <span class="comment">//false</span></span><br></pre></td></tr></table></figure><br>这是十分自然的，因为<strong>find成员函数判定”abc”等价于”ABC”</strong>，而find算法判定二者并不相等。</p>
<hr>
<h1 id="关联容器为什么需要基于等价来判定相同？"><a href="#关联容器为什么需要基于等价来判定相同？" class="headerlink" title="关联容器为什么需要基于等价来判定相同？"></a>关联容器为什么需要基于等价来判定相同？</h1><p>&lt;/br&gt;<br><strong>标准关联容器默认有序，所以STL关联容器必须存在一个保证有序的比较函数less</strong>。如果以相等来决定二者是否具有相同的值，则关联容器除了比较器之外还需要定义一个判断相等的比较函数。这两个函数可能会引发冲突。<br>举例而言，假定存在一个类似set的STL容器叫做set2CF（set with two comparison functions）。第一个比较函负责定set内部元素的排序，第二个用来判定两个元素是否相同。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set2CF&lt;<span class="built_in">string</span>, CIStringCompare, equal_to&lt;<span class="built_in">string</span>&gt; &gt; s;</span><br></pre></td></tr></table></figure><br>排序函数判定字符串时不考虑大小写，而等价函数则认为，两个字符串对应字符完全相同时它们相同。（此时存在两个比较函数的逻辑混乱）当执行如下操作时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.insert(<span class="string">"ABC"</span>);</span><br><span class="line">s.insert(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><br>从第一比较器的角度而言，二者是等价的，第二个不会被插入。第二比较器则认为二者并不相同。<br>那如果遵循第二比较器，把两个string都放入set，那么它们又应该处于什么顺序呢？如果随意的插入，则等于放弃了顺序遍历set的能力。（set内无法保证有序）</p>
<p>综上，在关联容器中使用等价作为相同判定时具备先天优势。（关联容器必须有序，而等价的定义就和顺序相关）</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
        <tag>关联容器</tag>
      </tags>
  </entry>
  <entry>
    <title>23.理解std::move与std::forward</title>
    <url>/2018/07/11/%E7%90%86%E8%A7%A3stdmove%E4%B8%8Estdforward/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在开始叙述之前，我们首先需要明确，std::move并不执行移动，std::forward也并不转发，它们在运行期并不执行任何操作，也不生成任何代码。<br>std::move和std::forward只是执行强制转换的函数（实际上是函数模板）。std::move无条件地将其参数转换为rvalue，而std::forward仅在满足特定条件时才执行此转换，这就是关于它们的全部解释。</p>
<hr>
<h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h1><p>&nbsp;<br>C++11中std::move的大致实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// in namespace std</span></span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;</span><br><span class="line"><span class="built_in">move</span>(T&amp;&amp; param)&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数返回类型的“&amp;&amp;”部分意味着std::move返回一个右值引用，但正如Item28将要提及的，如果类型T碰巧是左值引用，则T&amp;&amp;将成为左值引用。为了防止这种情况发生，将type_traits（见Item9）std::remove_reference应用于T，从而确保将“&amp;&amp;”应用于不是引用的类型，这一操作保证std::move真正返回一个rvalue引用，这一点相当重要，因为函数返回的右值引用是一个右值，最终，move将其参数转为了一个右值。</p>
<p>在C++14中，move的实现可以更加简单（多亏了返回类型推衍与type_traits的福）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="move问题实例"><a href="#move问题实例" class="headerlink" title="move问题实例"></a>move问题实例</h2><p>&nbsp;<br>假设我们正在撰写一个表示注释的类，其构造函数参数为string，按照Item41的要求，我们将其设定为pass-by-value：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这时候你想到构造函数不会改变text，于是你把它声明为const：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>)</span></span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>为了避免对data member作无谓的复制，你在构造函数中使用std::move(亦遵从Item 41）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>)</span>: <span class="title">value</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(<span class="built_in">text</span>))</span></span>&#123; … &#125; <span class="comment">// doesn't do what it seems to!</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这段代码能跑，只是运行起来未必如你所愿，事实上它执行了copy而非move。text被强制转换为右值这一点没毛病，但由于text被声明为const string，因此在执行转换之前，text是一个左值const std::string,并且转换完成后它变成了一个右值const std::string,在转换过程中，const一直被保留着。</p>
<p>编译器需要考虑使用哪种string构造函数，一般来说有两种选择：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs); <span class="comment">// copy ctor</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; rhs); <span class="comment">// move ctor</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在Annotation构造函数的member initialization list中，std::move（text）的结果是const std::string类型的rvalue。该rvalue无法传递给st::string的移动构造函数，因为移动构造函数形参必须是一个rvalue non-const std::string。但该rvalue可以传递给复制构造函数，因为允许将lvalue-reference-to-const绑定到const rvalue。 因此，成员初始化调用std::string中的复制构造函数。理解这一点十分重要，因为移动构造必然会破坏某些对象，因此移动构造的参数不具备const属性。</p>
<p>从该实例中可以得出两条经验:</p>
<ol>
<li><strong>如果希望move某对象，不要将其声明为const，这将导致只会触发copy。</strong></li>
<li><strong>std::move并不保证对象被移动，它只能保证传递回一个右值而已。</strong></li>
</ol>
<hr>
<h1 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h1><p>&nbsp;<br>forward是一种条件式转换，仅仅在满足条件时才会将参数转为rvalue。要了解它何时进行转换以及何时不转换，只需要想想我们一般在何时使用std::forward。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>最常见的场景是一个函数模板，其形参为universal reference，该参数将被传递给另一个函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> Widget&amp; lvalArg)</span></span>; <span class="comment">// process lvalues</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>; <span class="comment">// process rvalues</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// template that passes</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    makeLogEntry(<span class="string">"Calling 'process'"</span>, now);</span><br><span class="line">    <span class="built_in">process</span>(<span class="built_in">std</span>::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>考虑下述两个函数调用，其中一个实参是左值，另一个是右值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">logAndProcess(w); <span class="comment">// call with lvalue</span></span><br><span class="line">logAndProcess(<span class="built_in">std</span>::<span class="built_in">move</span>(w)); <span class="comment">// call with rvalue</span></span><br></pre></td></tr></table></figure><br>在logAndProcess中，参数param被传递给函数process。当我们使用左值调用logAndProcess时，我们自然希望将左值作为左值转发到process，当我们用rvalue调用logAndProcess时，我们期望调用process的rvalue重载版本。</p>
<p>但是，与所有函数参数一样，param是一个左值。因此，对logAndProcess内的每个process调用都将调用左值重载版本。 为了防止这种情况，我们需要一种机制来将param强制转换为rvalue。这解释了为何forward是一种条件转换：只有当它的参数用rvalue初始化时才转换为rvalue。</p>
<p>你可能想知道std::forward是如何知道它的参数是否用rvalue初始化。简单地来说，该信息在logAndProcess的模板参数T中被编码，该参数传递给std::forward，后者恢复编码信息，具体可见Item28。</p>
<hr>
<h1 id="move与forward"><a href="#move与forward" class="headerlink" title="move与forward"></a>move与forward</h1><p>&nbsp;<br>鉴于std::move和std::forward的本质均为强制转换，唯一的区别在于std::move总是执行强制转换，而std::forward则为条件式转换，似乎总可以用forward代替move，从技术层来说确实如此，但却并无必要，毕竟真要取消的话不如干脆都写cast好了。</p>
<p>std::move的优势在于便捷，减少错误发生的可能性以及使代码更加清晰。假设当前我们需要跟踪移动构造函数的调用次数，那我们只需要增加一个static计数器。更进一步地，假设类中唯一的非静态数据是std::string，以std::move实现移动构造有如下实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(Widget&amp;&amp; rhs):s(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs.s))&#123; ++moveCtorCalls; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> moveCtorCalls;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果以forward替换move，则代码将如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(Widget&amp;&amp; rhs):s(<span class="built_in">std</span>::forward&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(rhs.s))&#123; ++moveCtorCalls;&#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看出，std::move只需要一个函数参数（rhs.s），而std::forward需要一个函数参数（rhs.s）和一个模板类型参数（std::string）。此外，我们传递给std::forward的类型应当是non-reference，因为这是编码的约定（见Item28）。总之，这些意味着move比forward在某些场合更加好用。<br>总而言之，std::move表示将参数无条件转为rvalue，而std::forward仅表示在传递参数时保持参数原有的左右值属性，此二者完全不同，因此需要两种不同的名称加以区分。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>std::move表示将参数无条件转为rvalue，并不执行任何移动操作。</strong></li>
<li><strong>std::forward将绑定至右值的参数转为右值。</strong></li>
<li><strong>move与forward均不在运行期执行任何操作。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>16.确保const成员函数线程安全</title>
    <url>/2018/07/03/%E7%A1%AE%E4%BF%9Dconst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设当前存在一个类以表征多项式，且该类存在一个成员函数以完成多项值求根功能。显然此类函数不可能对多项式造成任何修改，因此可将其声明为const:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    … </span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一般而言，求根操作成本高昂，我们理应避免重复计算，因此我们在某次计算完成后将其值作为缓存，每一次求根都从缓存中取值（此思想可见More Effective C++ Item18）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rootsAreValid) &#123; <span class="comment">// if cache not valid</span></span><br><span class="line">        … <span class="comment">// compute roots,store them in rootVals</span></span><br><span class="line">        rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootVals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>roots成员函数不可能修改Polynomial对象，但它可能会修改rootVals和rootsAreValid，此二者被声明为mutable，其本意便在于方便const函数修改。<br>假设当前存在两个线程同时在Polynomial对象上调用roots：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Polynomial p;</span><br><span class="line">…</span><br><span class="line"><span class="comment">/*-----  Thread 1 ----- */</span>       <span class="comment">/*-------  Thread 2 ------- */</span></span><br><span class="line"><span class="keyword">auto</span> rootsOfP = p.roots();      <span class="keyword">auto</span> valsGivingZero = p.roots();</span><br></pre></td></tr></table></figure><br>在客户端执行上述程序十分合理，因为roots具备const属性，客户可以认为其执行读操作，而多线程在无同步的条件下执行读取操作在概念上是安全的。但实际上我们知道，roots可能会改变对象内部的data member，这意味着可能存在不同的线程在无同步的条件下对同一块内存进行读取与写入操作，这就是data race的标准定义。因此，该程序可能会导致未定义行为。</p>
<p>关键问题在于roots的const属性。C++98中的const成员函数仅仅表示不会修改对象，但C++11中它需要在此基础之上更进一步：保证线程安全性。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>解决此问题最简单的方法（或许也是最常见的方法）是使用互斥锁：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>; <span class="comment">// lock mutex</span></span><br><span class="line">    <span class="keyword">if</span> (!rootsAreValid) &#123; <span class="comment">// if cache not valid</span></span><br><span class="line">        … <span class="comment">// compute and store roots</span></span><br><span class="line">        rootsAreValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootVals;</span><br><span class="line">&#125; <span class="comment">// unlock mutex</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们将std::mutex声明为mutable，因为锁定与解锁操作均在const成员函数中进行。此外需要注意的是，mutex是一种move-only type(无法被复制，仅能被移动），因此mutex的加入导致多项式对象也变成了一个move-only object，从此失去了被复制的能力。</p>
<hr>
<h1 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h1><p>&nbsp;<br>在某些情况下，使用mutex可能有些小题大做。例如我们当前正关注于一个成员函数被调用的次数，那么使用一个std::atomic计数器（见Item40）可能更加恰当（实际上是否比mutex更加好用取决于硬件与你所使用的mutex的实现）。下述实例展示了如何使用std::atomic计算成员函数被调用的次数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">        ++callCount; <span class="comment">// atomic increment</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>((x * x) + (y * y));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span>&gt; callCount&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>类似于mutex，atomic也属于move-only type，因此Point对象也必将是一个move-only object。</p>
<hr>
<h1 id="atomic的不足"><a href="#atomic的不足" class="headerlink" title="atomic的不足"></a>atomic的不足</h1><p>&nbsp;<br>由于atomic的使用成本相较于mutex较为低廉，因此我们可能会更倾向于使用atomic。举例而言，如果当前有一个很消耗计算量的int值需要被缓存，我们可能会倾向于使用一对atomic而非mutex来确保线程安全性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheValid) <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = expensiveComputation1();</span><br><span class="line">            <span class="keyword">auto</span> val2 = expensiveComputation2();</span><br><span class="line">            cachedValue = val1 + val2; <span class="comment">// part 1</span></span><br><span class="line">            cacheValid = <span class="literal">true</span>; <span class="comment">// part 2</span></span><br><span class="line">            <span class="keyword">return</span> cachedValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; cacheValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; cachedValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上述程序能够运行，只是运行流程未必如你所想，试考虑如下情形：</p>
<ol>
<li>某线程调用magicValue，发现当前cacheValid处于false状态，于是默默计算了一遍。</li>
<li>就在此时，第二个（或者其他）也调用了magicValue，也发现当前cacheValid处于false状态，于是进行了一次无意义的重复计算。</li>
</ol>
<p>这种行为与我们设定缓存的目标背道而驰。将颠倒cacheValid与cachedValue的赋值顺序可以解决上述问题，但你会发现我们将得到一个更糟的结果：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheValid) <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = expensiveComputation1();</span><br><span class="line">            <span class="keyword">auto</span> val2 = expensiveComputation2();</span><br><span class="line">            cacheValid = <span class="literal">true</span>; <span class="comment">// part 1</span></span><br><span class="line">            <span class="keyword">return</span> cachedValue = val1 + val2; <span class="comment">// part 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>假设当前cacheValid为false，此后：</p>
<ol>
<li>莫线程调用了Widget::magicValue 并且通过Point对象将caheValid设置为1；</li>
<li>就在此时，另一个线程发现当前cacheValid为1，于是直接把cachedValue拿去用了（此时第一个线程尚未完成计算）。</li>
</ol>
<p>由此我们可以发现，对于需要同步的单个变量或内存位置，std::atomic足以应对，但如果需要操作的两个或多个变量或内存位置，则应当使用mutex完成相关任务。因此，magicValue的正确实现应当为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>; <span class="comment">// lock m</span></span><br><span class="line">        <span class="keyword">if</span> (cacheValid) <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = expensiveComputation1();</span><br><span class="line">            <span class="keyword">auto</span> val2 = expensiveComputation2();</span><br><span class="line">            cachedValue = val1 + val2;</span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> cachedValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// unlock m</span></span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> cachedValue; <span class="comment">// no longer atomic</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> cacheValid&#123; <span class="literal">false</span> &#125;; <span class="comment">// no longer atomic</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="const成员函数的线程安全性"><a href="#const成员函数的线程安全性" class="headerlink" title="const成员函数的线程安全性"></a>const成员函数的线程安全性</h1><p>&nbsp;<br>本节内容的前提是可能存在多个线程同时在某对象上执行const成员函数，并且该const函数试图修改data member。如果你确保自己的程序不会应用于多线程环境下，那么const成员函数的线程安全性并不重要。随着多线程的普及度越来越高，这种可能性似乎越来越小。可以肯定的是，const成员函数必将受到并发编程的影响，这就是我们应当确保const成员函数是线程安全的原因所在。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>开发者应当致力于保证const成员函数的线程安全性，除非你的程序永不涉及并发编程。</strong></li>
<li><strong>std：：atomic变量可以提供相对于mutex更加优良的性能，但其仅适用于操作单个变量或内存位置。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>43.泛型算法优于显式循环</title>
    <url>/2018/04/20/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E4%BC%98%E4%BA%8E%E6%98%BE%E5%BC%8F%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>算法内部本身就存在循环，因此众多需要用循环实现的任务，算法可以轻松完成。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设当前有一个支持重画的class:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redraw</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果我们试图将某个list内所有Widget重画，其循环版本大致如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;Widget&gt; lw;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lw.<span class="built_in">begin</span>();i != lw.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">    i-&gt;redraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然了，也可以使用for_each算法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(lw.<span class="built_in">begin</span>(),lw.<span class="built_in">end</span>(),[](Widget&amp; w)&#123;w.redraw();&#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="泛型算法相较于显式循环的优点"><a href="#泛型算法相较于显式循环的优点" class="headerlink" title="泛型算法相较于显式循环的优点"></a>泛型算法相较于显式循环的优点</h1><p>&nbsp;<br>一般来说，程序员通常认为循环比算法易读，但本节内容将说明算法更可取，理由有三：</p>
<ol>
<li>效率高</li>
<li>正确性高</li>
<li>更直观</li>
</ol>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>相较于显式循环，算法的高效性体现在：</p>
<ol>
<li>避免了每一次循环结束迭代器都需要与end()作比较（<code>i != lw.end()</code>);</li>
<li>库的实现者可以用更优化的方式来遍历容器。</li>
<li>大佬们写的算法比我们的实现更高效。</li>
</ol>
<h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><p>众所周知，写循环时最麻烦的莫过于确保当前迭代器的有效性，并且保证它指向了正确的位置。</p>
<h3 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h3><p>假设有一个数组，我们试图将其中的每一个元素都加上41然后插入到deque的前端<br>，循环体如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> data[maxNumDoubles];<span class="comment">//C API</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;numDoubles;++i)</span><br><span class="line">    d.insert(d.<span class="built_in">begin</span>(),data[i]+<span class="number">41</span>]);</span><br></pre></td></tr></table></figure><br>这段代码的问题在于:插入的元素是反序的，因为每一次都把待插入元素放在了开头。<br>于是我们做出了如下修改：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> insertLocation = d.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numDoubles; ++i) &#123;</span><br><span class="line">    d.insert(insertLocation++, data[i] + <span class="number">41</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是实际上这个更不行，因为insert之后后面的迭代器都失效了，insertlocation自然也是如此，所有行为均未定义。<br>但最终我们还是解决了这个问题，就是每一次插入后都更新insertlocation…<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> insertLocation = d.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numDoubles; ++i) &#123;</span><br><span class="line">    insertLocation=d.insert(insertLocation, data[i] + <span class="number">41</span>);</span><br><span class="line">    ++insertLocation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然，使用插入迭代器也是不错的主意。</p>
<h3 id="使用算法"><a href="#使用算法" class="headerlink" title="使用算法"></a>使用算法</h3><p>刚才我们费了半天周折终于利用显示循环写出了正确的程序，那如果使用算法呢？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">transform(data, data + numDoubles,inserter(d, d.<span class="built_in">begin</span>()),[](<span class="keyword">int</span> i)&#123;i+=<span class="number">41</span>;&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="直观性"><a href="#直观性" class="headerlink" title="直观性"></a>直观性</h2><p>任何一个算法在我们读到其名字时就已经了解了它的行为，但显式循环则不然。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>相对于泛型算法，显式循环稍逊风骚。但它并非一无是处，使用循环能让人更清楚地明白加诸于迭代器上的操作。<br>我们可以认为泛型算法提升了软件的抽象层次，并且使得它更容易实现、文档化、增强、维护。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1.了解模板类型推衍</title>
    <url>/2018/06/20/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%A1%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>如果开发者在不了解某系统运行机制的前提下仍能高效地使用它，他们往往会给予该系统极高的赞美。由此说来，C++中的模板类型推衍无疑是一项巨大的成功，数以万计的开发者轻松获取了满意的结果，尽管他们不得不为了描述这些经由推衍得到的类型而做出相当大的努力。</p>
<p>如果你就是上述开发者中的一员，迎接你的是一个好消息与一个坏消息。好消息是模板类型推衍技术是<code>auto</code>技术的基础，如果你对于模板类型推衍感到满意，那么想必你也会认为<code>auto</code>老少咸宜。坏消息是<code>auto</code>技术中所使用的类型推衍技术相较于template可能不够直观。为了清楚地了解<code>auto</code>，我们首先最好认知一下模板类型推衍。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>考虑以下函数模板及其调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure><br>在编译期间，编译器会使用expr去推衍T、ParamType。这两者往往存在一定的差异，原因在于ParamType可能会带有一定的修饰，例如const或者reference之类。举例而言，如果该函数模板被声明和使用如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">f(x);</span><br></pre></td></tr></table></figure><br>那么T将被推衍为int类型，而ParamType将被推衍为const int&amp;。</p>
<p>认为实参类型类型等价于T的类型是一种十分自然的想法，就像刚才的T为int一样，但很多时候情况并不是这样，事实上，T的类型并不完全取决于expr的类型，也与ParamType的形式有关。以下将给出三组案例：</p>
<ol>
<li><strong>ParamType是一个pointer或reference，但其非universal reference。</strong>（universal reference将在Item24中给出解释，这里只需要明确其并非左值引用或右值引用）</li>
<li><strong>ParamTyp是一个universal reference。</strong></li>
<li><strong>ParamType既不是pointer也不是reference。</strong></li>
</ol>
<hr>
<h2 id="Refernece-or-Pointer，and-not-a-universal-reference"><a href="#Refernece-or-Pointer，and-not-a-universal-reference" class="headerlink" title="Refernece or Pointer，and not a universal reference"></a>Refernece or Pointer，and not a universal reference</h2><p>&nbsp;<br>这种情况是最简单的情况，在此情况下，类型推衍遵循以下原则：</p>
<p> <strong>1. 如果expr的类型是一个refernce，则忽略refernece部分。</strong><br> <strong>2. 根据expr与ParamType的类型完成T类型推衍</strong></p>
<p>举例而言，现有声明与应用如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function template declartion</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"><span class="comment">//variable declaration</span></span><br><span class="line"><span class="keyword">int</span> x =<span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx =x;</span><br><span class="line"></span><br><span class="line">f(x);<span class="comment">//T is int，param's type is int&amp;</span></span><br><span class="line">f(cx);<span class="comment">//T is const int,param's type is const int&amp;</span></span><br><span class="line">f(rx);<span class="comment">//T is const int,param's type is const int&amp;</span></span><br></pre></td></tr></table></figure><br>需要注意的是第二和第三个函数调用，由于cx与rx代表常量，因此T是一个const int，param的类型是const int&amp;。当你试图传递一个常量给引用参数时，编译器会认为对象仍然需要保持不可变性，因此param会成为一个reference-to-const。我们可以认为，const对象传递给引用类型的形参是安全的，编译器会推衍出T带有const属性。</p>
<p>在第三个函数调用中，rx本身是一个reference，而T被推衍为non-refernce，这是由于rx的reference属性在类型推衍中被忽略所致。</p>
<p>上述的三个实例都是左值引用，但实际上右值引用的类型推衍并没有什么不同，非要说的话就是只有右值实参才能被赋予右值形参。</p>
<p>如果我们将template function的形参由T&amp;改为const T&amp;，事情会发生一点点小小的变化。cx与rx的const属性仍然得到了关注，但由于我们已经认定param是一个reference-to-const，因此T将被推衍为int类型，即：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx =x;</span><br><span class="line"></span><br><span class="line">f(x);<span class="comment">//T is int，param's type is const int&amp;</span></span><br><span class="line">f(cx);<span class="comment">//T is int,param's type is const int&amp;</span></span><br><span class="line">f(rx);<span class="comment">//T is int,param's type is const int&amp;</span></span><br></pre></td></tr></table></figure><br>当然，这里rx的reference属性也被忽略了。</p>
<p>如果param是一个pointer或pointer-to-const，那么类型推衍结果几乎没什么变化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;</span><br><span class="line"></span><br><span class="line">f(&amp;x);<span class="comment">//T is int,param 's type is int*</span></span><br><span class="line">f(px);<span class="comment">//T is const int,param's type is const int *</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="ParamType-is-a-Universal-Reference"><a href="#ParamType-is-a-Universal-Reference" class="headerlink" title="ParamType is a Universal Reference"></a>ParamType is a Universal Reference</h2><p>&nbsp;<br>在上一案例中，一切推衍都十分自然。但当template以universal reference作为参数时，推衍法则将变得不再显然。某些parameters被声明为右值引用，但当左值传入时，其表现的结果将不再类似于右值引用。关于universal reference的详细介绍将在Item24展开,接下来将给出本案例的推衍法则：</p>
<ol>
<li><strong>如果expr是一个左值，那么T与ParamType都将被推衍为左值引用。</strong>这里存在两点不同寻常之处，首先，只有在此种情况下template才会将T推衍为引用类型；其次，尽管ParamType被声明为右值引用，但最终其推衍类型是一个左值引用。</li>
<li><strong>如果expr是一个右值，则遵照案例1中的法则执行</strong>。</li>
</ol>
<p>有问题实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x= <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx =x;</span><br><span class="line"></span><br><span class="line">f(x);<span class="comment">//x is lvalue,T is int&amp;,param's type is int&amp;</span></span><br><span class="line">f(cx);<span class="comment">//cx is lvalue,T is const int&amp;,param's type is const int&amp;</span></span><br><span class="line">f(rx);<span class="comment">//rx is lvalue,T is const int&amp;,param's type is const int&amp;</span></span><br><span class="line">f(<span class="number">27</span>);<span class="comment">//27 is rvalue,T is int,param's type is int&amp;&amp;</span></span><br></pre></td></tr></table></figure></p>
<p>在Item24中将会详细解释此处的类型推衍法则原理。在Universal reference案例中，关键点在于实参是左值还是右值会导致不同的推衍原则被执行，这在non-universal reference中不会出现。</p>
<hr>
<h2 id="ParamType-is-Neither-a-Pointer-nor-a-Reference"><a href="#ParamType-is-Neither-a-Pointer-nor-a-Reference" class="headerlink" title="ParamType is Neither a Pointer nor a Reference"></a>ParamType is Neither a Pointer nor a Reference</h2><p>&nbsp;<br>这种情况意味着执行值传递——产生了一个对象的copy，这一现象产生了本案例下的类型推衍法则：</p>
<ol>
<li><strong>如果expr为reference，则忽略其reference属性。</strong></li>
<li><strong>如果在忽略reference属性后，expr还留有const或volatile属性，则一并忽略。</strong></li>
</ol>
<p>有实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line">f(x);<span class="comment">//T is int,param's type is int</span></span><br><span class="line">f(cx);<span class="comment">//T is int,param's type is int</span></span><br><span class="line">f(rx);<span class="comment">//T is int,param's type is int</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是，即使cx与rx代表常量，param也并非const。我们应当明确，param是一个与cx或rx无关的对象，它由copy得到，这很好地解释了为什么param不会具备expr所带有的constness与volatileness。不过需要说明的是，constness或volatilness只在pass-by-value中会被忽视，pass-by-pointer或pass-by-reference则会保留其特性。最后，让我们看看以下这种情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> ptr = <span class="string">"Hello,world!"</span>;</span><br><span class="line">f(ptr);<span class="comment">//T is const char*, param's is const char*</span></span><br></pre></td></tr></table></figure><br>在本实例中，我们需要明确的是param是一个ptr的拷贝，因此底层const属性被丢失（bitwise copy），而顶层const则得到了保留。</p>
<hr>
<h2 id="Array-Arguments"><a href="#Array-Arguments" class="headerlink" title="Array Arguments"></a>Array Arguments</h2><p>&nbsp;<br>尽管我们经常在实际使用中将数组类型与指针混为一谈，但在类型推衍中它们存在一定的区别。我们首先复习一下数组名与指针的关系：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"J.P.Briggs"</span>;<span class="comment">//name's type is const char[13]</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ptrname = name;<span class="comment">//array decays to pointer</span></span><br></pre></td></tr></table></figure><br>显然，ptrname经由name得到了初始化，尽管它们的类型并不相同，但由于退化原则（array-to-pointer)，上述代码得以被编译。不妨试想，如果一个数组以pass-by-value方式传递给template，将会如何？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(name);</span><br></pre></td></tr></table></figure></p>
<p>为了解决这个问题，我们先从一个更加基础的问题开始回答：当数组作为一个函数的参数时会发生什么？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc</span><span class="params">(<span class="keyword">int</span> param[])</span></span>;</span><br></pre></td></tr></table></figure><br>此处的形参尽管被声明为数组，实际上编译器会将其视为一个指针，因此，myFunc声明式等价于<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc</span><span class="params">(<span class="keyword">int</span>* param)</span></span>;</span><br></pre></td></tr></table></figure><br>数组名与指针等价的规则起始于C语言，这一设定也被C++继承，这直接导致了开发者产生了数组等价于指针的错误观念。基于这一规则，我们在类型推衍中有设定如下：<strong>当一个数组以pass-by-value的形式被传递给template function时，其类型总是被推衍为指针</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(name);<span class="comment">//name is array，T deduced as const char*</span></span><br></pre></td></tr></table></figure><br>但是我们需要明确，尽管函数的形参不能够真正地声明为数组类型，但其可以声明为数组的引用，因此假若我们有template function声明如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><br>我们再次传入数组,<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(name);</span><br></pre></td></tr></table></figure><br>此时T的类型将是一个真正的数组。数组类型包含了数组的长度，因此在本例中，T将会被推衍为const char[13],ParamType的类型为const char（&amp;)[13]。这一特性也保证了模板可以推衍出数组包含元素的个数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//return size of an array as complie-time constant</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>constexpr意味着编译期间即可得到变量值，因此constexpr修饰的int形变量可以作为数组长度参数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> keyVals[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">35</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> mappedVals[arraySize(keyVals)];<span class="comment">//此处使用std::array更佳</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="Function-Arguments"><a href="#Function-Arguments" class="headerlink" title="Function Arguments"></a>Function Arguments</h2><p>&nbsp;<br>数组名并非是C++中唯一会退化成指针的东西，函数名亦然，因此我们针对数组的所有讨论都可以应用于函数，举例而言：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">double</span>)</span></span>;<span class="comment">//type is void(int,double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;/pass-by-value</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;<span class="comment">//pass-by-reference</span></span><br><span class="line"></span><br><span class="line">f1(someFunc);<span class="comment">//ParamType's type is void(*)(int,double)</span></span><br><span class="line">f2(someFunc);<span class="comment">//ParamType's type is void(&amp;)(int,double)</span></span><br></pre></td></tr></table></figure>
<p>好像在实际应用中没有什么差别，但知道总比不知道要好。 </p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>在普通模板参数推衍过程中，reference-ness会被忽略。</strong></li>
<li><strong>对于universal reference，lvalue作为实参传入时会保留reference-ness。</strong></li>
<li><strong>当以pass-by-value形式类型推衍时，const-ness与volatile-ness会被忽略。</strong></li>
<li><strong>在模板类型推衍过程中，数组名与函数名会退化为指针，除非形参以引用形式得到了初始化。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型推衍</tag>
      </tags>
  </entry>
  <entry>
    <title>5.确定对象被使用前已经初始化</title>
    <url>/2018/04/07/%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E7%BB%8F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="何时需要初始化？"><a href="#何时需要初始化？" class="headerlink" title="何时需要初始化？"></a>何时需要初始化？</h1><p>一般来说，使用c part of c++中的组件时，声明变量后不初始化就加以使用会得到未知结果，但non-c parts of C++的规则则略有变化。这也就是array不保证其内容被初始化，但vector却有保证的原因。<br>为了避免得到一些无谓的结果，我们的最佳处理方法就是永远在使用对象前对它进行初始化。</p>
<hr>
<h1 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h1><p>对于内置类型，我们以手工的形式完成初始化。但对于内置类型以外的其他任何东西，初始化交由构造函数来完成。我们的规则也十分简单：<strong>确保构造函数会初始化对象的每一个成员变量</strong>。关键在于不要混淆赋值和初始化的概念，从而导致效率降低。</p>
<h2 id="自定义类型的赋值与初始化"><a href="#自定义类型的赋值与初始化" class="headerlink" title="自定义类型的赋值与初始化"></a>自定义类型的赋值与初始化</h2><p>假定存在class Person，其定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name,<span class="keyword">const</span> <span class="built_in">string</span> &amp;phoneNumber);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> thename;</span><br><span class="line">    <span class="built_in">string</span> thephoneNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name,<span class="keyword">const</span> <span class="built_in">string</span> &amp;phoneNumber)&#123;</span><br><span class="line">    thename = name;<span class="comment">//此处并非初始化而是赋值</span></span><br><span class="line">    thephoneNumber = phoneNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>c++规定，<strong>成员变量的初始化动作发生在进入构造函数本体之前</strong>。也就是说，刚才thename等变量已被default构造函数初始化过了。但️内置类型除外,因为它不具备default初始化。<br>因此构造函数的最佳写法是使用member initialization list替换赋值操作，这样会比赋值高效很多。例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name,<span class="keyword">const</span> <span class="built_in">string</span> &amp;phoneNumber):</span><br><span class="line">                thename(name),thephoneNumber(phoneNumber) &#123;&#125;</span><br></pre></td></tr></table></figure><br>这里的成员变量分别以括号内的实参进行了copy或move构造（再次使用了某个构造函数）。</p>
<p>对于内置类型的成员变量，两种写法的效率差不多，但我们为了一致性最好还是统一使用member initialization list中.<br>甚至当我们只想用default构造函数时，也可以使用此方法，只需要制定nothing作为初始化实参即可，例如:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person::Person():thename(),thephoneNumber() &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种写法的高效性不言而喻，但我们必须记住在member initialization list中不允许遗忘任何一个成员变量。虽然非内置类型都具有自己的default构造函数，但是<strong>内置类型必须要手动初始化</strong>。<br>有时候即使成员变量是内置类型，也一定得使用初值列，比如const或者reference的成员变量必须初始化，且前者无法被赋值。<br>总之，我们只需要记住，对于自定义类型，我们在构造函数中总是使用member initialization list。</p>
<hr>
<h1 id="初始化次序"><a href="#初始化次序" class="headerlink" title="初始化次序"></a>初始化次序</h1><h2 id="自定义类型的初始化次序"><a href="#自定义类型的初始化次序" class="headerlink" title="自定义类型的初始化次序"></a>自定义类型的初始化次序</h2><p>c++有着固定的初始化次序：base class总是先于derived class被初始化，而class中的成员变量总是按照声明的次序初始化。<br>有可能初值列中的次序不是和声明次序一致，但是初始化的顺序却是始终按声明顺序完成的。因此我们<strong>最好严格地按照声明次序来写初值列</strong>。</p>
<hr>
<h2 id="“不同编译单元内定义之non-local-static对象”的初始化次序"><a href="#“不同编译单元内定义之non-local-static对象”的初始化次序" class="headerlink" title="“不同编译单元内定义之non-local static对象”的初始化次序"></a>“不同编译单元内定义之non-local static对象”的初始化次序</h2><h3 id="static对象"><a href="#static对象" class="headerlink" title="static对象"></a>static对象</h3><p>static对象的寿命从被构造出来直到程序结束为止，因此stack和heap-based对象都不是static。<br>static对象包括global对象，定义于namespace作用域内的对象、在classes内、以及在file作用域内被声明为static的对象。<br>函数内的static对象被称为local-static对象（对函数而言是local），其他static对象称为non-local static对象。<br>程序结束时static对象会被自动销毁，也就是说它们的析构函数会在main()结束时调用。</p>
<h3 id="编译单元"><a href="#编译单元" class="headerlink" title="编译单元"></a>编译单元</h3><p>所谓的编译单元，指的是产出单一目标文件的那些源码。基本上它是单一源码文件加上其引入的头文件。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我们现在所关心的问题至少涉及两个源码文件，每一个至少包含一个non-local static对象。<br>这个问题是这样的：某个编译内的某个non-local static对象的初始化动作使用了另一个编译单元内的某个non-local static对象。后者可能在前者之后初始化，这将导致问题的发生。</p>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>假设有一个FileSystem class,它的作用是让互联网上的文件看起来坐落于本机，由于这个class的作用在于构建一个单一文件系统，因此其产出的对象可能会位于global或namespace作用域内：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">FileSystem</span> tfs;</span><br></pre></td></tr></table></figure><br>假定某些客户建立了一个class以处理FileSystem的目录，那将不可避免地需要使用tfs:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(parms) &#123;disks=tfs.numDisks();&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当客户调用该构造函数时，可能tfs尚未被初始化，关键在于如何保证这两个不同源码建立的对象具有初始化的先后次序？</p>
<h3 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h3><p>将每一个non-local static对象搬到自己的专属函数中（在函数内声明为static），这些函数返回一个reference指向它所含的对象。用户调用这些函数，而不是直接指涉对象。换句话说，我们用local static对象替换了non-local static对象。这是<strong>singleton模式</strong>的一个常见实现。<br>具体代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span>...&#125;</span><br><span class="line"><span class="function"><span class="built_in">FileSystem</span>&amp; <span class="title">tfs</span><span class="params">()</span></span>&#123;<span class="comment">//具体实操可见More Effective C++ 26</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">FileSystem</span> fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法的基础是：函数内的local static对象会在函数被调用期间或者是首次遇到定义式时初始化。所以你在使用函数调用时必然会保证reference指向了一个经历了初始化的对象。而且更棒的是，如果你不调用，则不会触发构造和析构操作。这是真正的non-local static对象所不具备的。</p>
<h3 id="单例模式的纰漏"><a href="#单例模式的纰漏" class="headerlink" title="单例模式的纰漏"></a>单例模式的纰漏</h3><p>此操作在多线程下可能会引发问题，处理它的方式是在单线程启动阶段手工调用所有reference-returning函数。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>内置类型必须手工初始化</li>
<li>使用初值列代替构造函数中的赋值操作。初值列的次序应该与声明次序相同。</li>
<li>对于跨编译单元之初始化次序问题，请使用local static来代替non-local static。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>3.确保容器中的对象副本正确且高效</title>
    <url>/2018/04/06/%E7%A1%AE%E4%BF%9D%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%89%AF%E6%9C%AC%E6%AD%A3%E7%A1%AE%E4%B8%94%E9%AB%98%E6%95%88/</url>
    <content><![CDATA[<p>容器中保存的对象并不是你放进去的对象，取出的对象也不是容器内的对象，它们都是<strong>副本</strong>。<br>这种<strong>copy in，copy out</strong>就是STL 容器的工作方式。<br>一旦对象放入容器，它们可能会遭遇更多的复制，比如顺序容器内遭遇排序或者插入，删除，它们元素都会进行一次复制操作。复制操作由拷贝构造函数与拷贝构造运算符完成。那么问题来了，如果对象的复制操作很费时，填充对象这个操作可能会降低程序性能，而且放入的副本如果有特殊含义，可能会导致出错。<br>在存在继承关系的情况下，copy会导致slicing，举例而言，容器元素类型是bc，但我们试图放入dc对象，那么它的特有部分将会丢失。<br>总之，使copy操作高效且正确的方法是<strong>在容器内部包含指针而不是对象</strong>。当然，指针也有一些问题，后期我们会发现智能指针更好用。<br>听起来STL容器的疯狂复制这种行为很蠢，但是相对于array，它的可塑造性强了很多，我们在使用时只需要它总是在复制并且总是应该向其中加入对象的指针即可。</p>
<p>​</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>9.禁止异常离开析构函数</title>
    <url>/2018/04/08/%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%E7%A6%BB%E5%BC%80%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>C++并不禁止析构函数抛出异常，但需要明确：<strong>析构函数抛出异常存在风险</strong>。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>考虑如下代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~Widget() &#123;...&#125;<span class="comment">//可能抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Widget&gt; v;</span><br><span class="line">    ...<span class="comment">//v在此处被自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当vector被销毁时，所有的Widget对象都会被销毁。于是我们一一调用析构函数.假设在析构第一个元素时，有一个异常被抛出，但剩下的还是应该被销毁（否则就会资源泄漏），因此会接着销毁第二个，但如果第二个Widget被析构时又抛出了异常，于是现在有了两个同时作用的异常，<strong>C++不允许处理多个异常同时存在的情况</strong>。<strong>在两个异常同时存在的情况下，c++不是立刻结束运行就是导致不明确行为</strong>。在本例中就是会导致不明确行为。<br>我们需要记住的是：<strong>只要析构抛出异常，程序就可能过早结束或者行为不明确</strong>。</p>
<hr>
<h1 id="问题实例及解决方案"><a href="#问题实例及解决方案" class="headerlink" title="问题实例及解决方案"></a>问题实例及解决方案</h1><h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设我们建立了一个数据库连接类，其行为如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;<span class="comment">//返回对象 static成员函数不属于对象而是属于类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭连接，关闭失败则抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了确保DBConnection对象必然会关闭，很自然地，我们会建立一个类来管理DBConnection对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DBConn()&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();<span class="comment">//析构函数中可能抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果析构时抛出异常，DBConn会传播该异常（允许其离开析构函数），那么结果相当麻烦。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="修改析构函数"><a href="#修改析构函数" class="headerlink" title="修改析构函数"></a>修改析构函数</h3><h4 id="抛出异常就终结程序（调用abort）"><a href="#抛出异常就终结程序（调用abort）" class="headerlink" title="抛出异常就终结程序（调用abort）"></a>抛出异常就终结程序（调用abort）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123; db.<span class="built_in">close</span>():&#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        ...<span class="comment">//记录失败至日志</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这直接导致了程序突然结束，但至少它阻止了异常的传播。</p>
<h4 id="直接吞下异常，不对它进行处理"><a href="#直接吞下异常，不对它进行处理" class="headerlink" title="直接吞下异常，不对它进行处理"></a>直接吞下异常，不对它进行处理</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123; db.<span class="built_in">close</span>():&#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        ...<span class="comment">//记录失败至日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这基本上会导致雪崩，但有时我们不能立刻终结程序，毕竟能跑总比不能用要好。</p>
<h3 id="重新设计DBConn类接口（较优策略）"><a href="#重新设计DBConn类接口（较优策略）" class="headerlink" title="重新设计DBConn类接口（较优策略）"></a>重新设计DBConn类接口（较优策略）</h3><p>我们可以重新设计DBConn，使用户可以对发生异常做出反应。或者说追踪connection是否被关闭，如果未被关闭则由析构函数关闭。但如果析构函数调用close失败，我们还是又将退回“强迫结束程序”或者“吞下异常”的老路：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;<span class="comment">//供客户使用的关闭函数</span></span><br><span class="line">        db.<span class="built_in">close</span>();<span class="comment">//调用时不会在析构函数中抛出异常</span></span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBConn()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)&#123;<span class="comment">//如果用户没有手动关闭连接</span></span><br><span class="line">            <span class="keyword">try</span>&#123;db.<span class="built_in">close</span>();&#125;</span><br><span class="line">            <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">                <span class="comment">//使用上述两种处理方式之一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种写法把调用close的责任从析构函数转移到了客户手中。可能有人会认为这令接口变得不方便使用，但实际<strong>上如果某个操作可能在失败时抛出异常，又存在某种必要必须处理该异常，那么这个异常必须来自析构函数之外的某个函数</strong>。因为析构函数抛出异常必然会导致过早结束程序或者发生不明确行为的风险。<br>如果用户没用close来关闭连接,那至少析构函数中也适当的调用了它，这时候再发生错误用户也没资格抱怨，因为毕竟我们提供了接口，而他们选择了放弃使用。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>析构函数绝对不能吐出异常，如果一个被析构函数调用的函数可能会抛出异常，那我们的析构函数应该捕捉任何异常，然后吞下它们（不传播）或者结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>11.禁止异常信息传递到析构函数之外</title>
    <url>/2018/04/25/%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E5%88%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B9%8B%E5%A4%96/</url>
    <content><![CDATA[<p>（本节内容可参照Effective C++ 9共同阅读）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>析构函数只有2种情况会被调用：</p>
<ol>
<li>正常情况，对象离开作用域或被显式delete</li>
<li>对象被异常处理机制——异常传播过程中的stack-unwinding机制析构</li>
</ol>
<p>在这两种情况中，调用析构函数时异常可能处于激活状态也可能没有被激活（无法在析构函数内进行区分），我们只能假定异常处于激活状态。因为在一个异常被激活的同时，如果析构函数再次抛出异常，C++会立刻终止程序运行，甚至连局部变量都尚未释放。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>有一个session类用来跟踪在线计算机的sessions，session是计算机从登陆到注销时一直存在的某种文件。每个session对象关注的是它建立与释放的日期与时间：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Session();</span><br><span class="line">    ~Session();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logCreation</span><span class="params">(Session *objAddr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logDestruction</span><span class="params">(Session *objAddr)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>函数logCreation与logDestruction被分别用于记录对象的建立与释放。我们因此可以这样编写 Session 的析构函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Session::~Session()&#123;</span><br><span class="line">    logDestruction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果logDestruction抛出异常，会发生什么？</p>
<hr>
<h1 id="实例剖析"><a href="#实例剖析" class="headerlink" title="实例剖析"></a>实例剖析</h1><p>&nbsp;<br>析构函数抛出的异常并没有被捕获，因此它会被传递到调用位置。但是如果析构函数本身的调用就是源自于某些其它异常的抛出，那么terminate函数将被自动调用，彻底终止程序。为了保证logDestruction抛出的异常被传递到析构函数之外，我们必须手动地加以try-catch:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Session::~Session()&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logDestruction(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to log destruction of Session object "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看起来异常确实被捕获了，但如果operator &lt;&lt; 抛出了一个异常….程序又会被直接终止运行。<br>因此，最终解决方案是释放Session时忽略掉所有它抛出的异常：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Session::~Session()&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logDestruction(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>catch语句看起来像什么都没做，但他从实际上保证了异常不会被传递到析构函数之外，因此terminate不会被调用。</p>
<hr>
<h1 id="非完全析构"><a href="#非完全析构" class="headerlink" title="非完全析构"></a>非完全析构</h1><p>&nbsp;<br>除却保证程序不会因为多个异常同时激活导致termi，异常不得离开析构函数的第二个原因就是保证完全析构。如果一个异常被析构函数抛出但却没有在函数内部被捕获，那么析构函数就不会完全运行（停在抛出异常的那个地方）。如果析构函数不完全运行，就会发生非完全析构。</p>
<p>仍以session为例，假设在建立session时启动一个database transaction,析构session时结束它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Session::Session() &#123; </span><br><span class="line">    logCreation(<span class="keyword">this</span>);</span><br><span class="line">    startTransaction();</span><br><span class="line">&#125;</span><br><span class="line">Session::~Session()&#123;</span><br><span class="line">    logDestruction(<span class="keyword">this</span>);</span><br><span class="line">    endTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，如果logDestruction抛出一个异常，transaction就没有被终止。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>禁止异常传递到析构函数之外有两个原因：</p>
<ol>
<li>阻止terminate被调用</li>
<li>阻止非完全析构</li>
</ol>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>3.禁止对数组使用多态</title>
    <url>/2018/04/23/%E7%A6%81%E6%AD%A2%E5%AF%B9%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>多态的本质在于：通过操作指向bc对象的指针或引用来操作dc对象，这样子引用或指针看起来就如同有多种类型。数组也可以使用多态，但其结果几乎不可能与你的预期结果一致。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设有一个类BST（比如是搜索树对象）和继承自BST类的派生类BalancedBST：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalancedBST</span>:</span> <span class="keyword">public</span> BST &#123; ... &#125;;</span><br></pre></td></tr></table></figure><br>现有一个遍历函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s,<span class="keyword">const</span> BST <span class="built_in">array</span>[],<span class="keyword">int</span> numElements)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements;++i) &#123;</span><br><span class="line">        s &lt;&lt; <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们将含有BalancedBST对象的数组变量传递给遍历函数时，后果如何？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line">printBSTArray(<span class="built_in">cout</span>, bBSTArray, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><br>答案是编译通过，但无法正常运行。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>原因很简单：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements;++i) &#123;</span><br><span class="line">    s &lt;&lt; <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>array[i]等价于*(array+i),而指针的加法又等价于地址+=<code>i*sizeof(element）</code>，一般我们认为<code>sizeof(dc)&gt;=sizeof(bc)</code>,所以上述代码会产生不可预期的后果。</p>
<hr>
<h1 id="删除数组"><a href="#删除数组" class="headerlink" title="删除数组"></a>删除数组</h1><p>&nbsp;<br>如果我们试图通过一个bc指针去删除dc数组，那么结果也会崩溃，有实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteArray</span><span class="params">(BST <span class="built_in">array</span>[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line">BalancedBST *balTreeArray = <span class="keyword">new</span> BalancedBST[<span class="number">50</span>];</span><br><span class="line">...</span><br><span class="line">deleteArray(balTreeArray);</span><br></pre></td></tr></table></figure><br>当数组被删除时，每一个元素的destructor都会被调用，所以当执行<code>delete[] array</code>时，实际上执行了如下代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">    <span class="built_in">array</span>[i].BST::~BST(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>C++明确规定，由bc的引用或者指针删除dc，其结果未定义。</strong></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>简单的说，多态和指针算术不能混用.又由于数组总是会牵扯一些指针算术，所以多态和数组也不能混用。<br>一般而言，如果你尽量“不用一个具体类继承自另一个具体类”，那你应该会很少犯这种错误。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>站在对象模型的顶端——RTTI</title>
    <url>/2018/05/31/%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A1%B6%E7%AB%AF%E2%80%94%E2%80%94RTTI/</url>
    <content><![CDATA[<p>（本节内容可参见More Effective C++ RTTI一篇）</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>站在对象模型的顶端——Template</title>
    <url>/2018/05/30/%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A1%B6%E7%AB%AF%E2%80%94%E2%80%94Template/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>原本Template被视为对container的一项重要支持，但其现在已经成为了通用程序设计的基石。它也被用于属性混合或互斥机制的参数化技术中，此外，TMU的发现，使得程序效率得到了巨大的提升。</p>
<p>然而，template也是C++最为困难的主题。本节将重点描述template，以下是三个主要讨论方向：</p>
<ol>
<li><strong>template声明</strong><br>可以理解为当你声明一个template class或template class member function时会发生什么。</li>
<li><strong>如何具现出class object以及inline nonmember，以及member template function</strong><br>上述的这些每一个编译单位都将拥有一份实体</li>
<li><strong>如何具现出nonmember以及static template class members</strong><br>上述的这些每一个可执行文件中仅会存在一个实体。</li>
</ol>
<hr>
<h1 id="Template的具现行为"><a href="#Template的具现行为" class="headerlink" title="Template的具现行为"></a>Template的具现行为</h1><p>&nbsp;<br>现有Template Point class如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Status &#123;unallocated,normalized&#125;;</span><br><span class="line">    Point(Type x=<span class="number">0.0</span>,Type y=<span class="number">0.0</span>,Type z=<span class="number">0.0</span>);</span><br><span class="line">    ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Point&lt;Type&gt; *freeList;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line">    Type _x,_y,_z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当编译器看到template class声明时，不会执行任何操作。因此，上述的static data members并不可用。虽然enum Status的真正类型在所有Point instantiations中都一样，但它们只能通过template Point class的某个实体来存取或操作，因此我们可以这样写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>&gt;::Status s;</span><br></pre></td></tr></table></figure><br>而不能写为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point::Status s;</span><br></pre></td></tr></table></figure><br>static data member亦是如此。</p>
<p>如果我们定义一个指针指向特定的实体：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>&gt; *ptr =<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><br>也不会生成或执行任何操作。我们需要明确，一个指向class object的指针，本身并不是一个class object，编译器不需要知道任何与class相关的任何members数据或object布局数据，因此没有将某个template具现的必要。C++ standard禁止编译器对此情况作出具现化操作。<br>但如果是一个reference，那它真的会具现化出一个class，原因在于reference必须要绑定某个真正存在的对象。</p>
<p>假若我们明确定义表达式导致某个template class发生具现化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Point&lt;<span class="keyword">float</span>&gt; origin;</span><br></pre></td></tr></table></figure><br>在此情况下，float instantiation的真正对象布局被产生出来，回顾之前的声明我们可以得知，origin的配置空间需要足够容纳3个float成员。<br>然而，member functions（未使用过的）不应该被具现化，它们应当仅仅在被使用时才会发生具现化。之所以需要这个规则，主要出于两个原因：</p>
<ol>
<li><strong>时间与空间效率</strong><br>如果某个class存在大量的member functions，而真正具现化出的某些class只使用了其中的一部分，那么全部具现化会造成一种性能上的浪费。</li>
<li><strong>尚未实现的机能</strong><br>template class中定义的所有member functions并不一定适用于所有的Type，如果只具现那些真正使用到的member functions，那么template就能支持那些原本可能会造成编译器错误的类型。</li>
</ol>
<hr>
<h1 id="Template的错误报告"><a href="#Template的错误报告" class="headerlink" title="Template的错误报告"></a>Template的错误报告</h1><p>&nbsp;<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Mumble</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mumble(T t=<span class="number">1024</span>):tt(t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tt!=t) <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T tt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个Template的声明存在下述错误：</p>
<ol>
<li>t被初始化为整数常量1024，其可行程度视真实类型而定。</li>
<li>!=运算符可能尚未被定义，需要视实际使用情况而定。</li>
</ol>
<p>上述的两个潜在错误只能在具现操作完成后才能被发现，就目前的编译器而言，面对template声明只能执行有限的错误检查。Nonemember与member template functions在具现行为发生之前一样没有完全的类型检验，这直接导致了一些十分露骨的template错误声明居然能够通过编译，例如:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo();</span><br><span class="line">    <span class="function">type <span class="title">val</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">val</span><span class="params">(type v)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    type _val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下内容不会触发报错</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="keyword">double</span> Foo&lt;type&gt;::bogus_member() &#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;dbx;&#125;<span class="comment">//即使Foo并没有member function与data</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Template中的名称决议方式"><a href="#Template中的名称决议方式" class="headerlink" title="Template中的名称决议方式"></a>Template中的名称决议方式</h1><p>&nbsp;<br>在讲本小节之前，我们首先需要明确两种定义：</p>
<ol>
<li><strong>scope of the template defintion</strong><br>定义出template的程序，有实例如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">class</span> <span class="title">ScopeRules</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invariant</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _member = foo(_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">type <span class="title">type_dependent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foo(_member);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _val;</span><br><span class="line">    type _member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>scope of the template instantiation</strong><br>具现出template的程序:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ScopeRule&lt;<span class="keyword">int</span>&gt; sr0;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在ScopeRules template中有两个foo()调用操作，在”scope of template definition”中，只有一个foo()函数声明位于scope内，然而在”scope of template instantiation”中，两个foo()函数声明都位于scope之内，如果我们使用了一个函数调用操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sr0.invariant();<span class="comment">//调用哪一个foo()?</span></span><br></pre></td></tr></table></figure><br>本次调用操作存在两个函数可以调用，分别为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//scope of the template declaration</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="comment">//scope of the template instantiation</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>因为_val的类型是int，那么很多人会认为实际调用的是int，然而，调用的是double。</p>
<p>Template中，对于一个nonmember name的决议结果是根据这个name的使用与否与“用以具现出该template的参数类型”有关而决定的。如果其使用互不相关，那么就以“scope of the template declaration”来决定name，反之则使用“scope of the template instantiation”。</p>
<p>在刚才的实例中，foo()与用以具现ScopeRules的参数类型无关，因为_val是一个int，一个类型不会根据不同的具现化而发生改变的数据，因此，member的类型并不会影响哪一个foo()被选中，所以编译器会选择double（在该scope中，只有一个foo()候选者）。</p>
<p>我们再次给出一个实例，该实例内容为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sr0.type_dependent();<span class="comment">//调用哪一个foo()?</span></span><br></pre></td></tr></table></figure><br>这一次由于参数类型相关，当前候选域内有2个foo()候选者，int类型与当前类型一致，因此得以被选中。</p>
<p>上述两个实例表明编译器必须保持两个scope contexts：</p>
<ol>
<li><strong>“scope of the template declaration”，用以专注于一般的template class。</strong></li>
<li><strong>“scope of the template instantiation”，用以专注于特定的实体。</strong></li>
</ol>
<hr>
<h1 id="Member-Function的具现行为"><a href="#Member-Function的具现行为" class="headerlink" title="Member Function的具现行为"></a>Member Function的具现行为</h1><p>&nbsp;<br>template的具现化大致来说有两种策略：</p>
<ol>
<li><strong>编译时期策略，程序代码必须在program text file中备妥可用。</strong></li>
<li><p><strong>链接时期策略，通过某些工具导引编译器的具现化行为。</strong></p>
<p>接下来作者描述了如何具现化template function。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>站在对象模型的顶端——异常处理</title>
    <url>/2018/05/31/%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A1%B6%E7%AB%AF%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>想要支持exception handling，编译器的主要任务是找出catch子句，以处理被丢出来的exception。这需要追踪程序堆栈中的每一个函数的当前作用区域。同时，编译器必须提供某种查询exception objects的方法，以了解其实际类型（这直接引发了RTTI的出现）。最后，还需要某种机制用以管理被丢出的object。一般而言，exception handling机制需要与编译器所产生的数据结构以及执行期的一个exception library紧密合作。在程序大小和执行速度之间，编译期必须有所抉择：</p>
<ul>
<li><strong>维持执行速度</strong><br>编译器可以在编译时期建立起用于支持的数据结构，这会使程序代码膨胀。</li>
<li><strong>维持程序大小</strong><br>编译器在执行期建立用于支持的数据结构，这会影响程序的执行效率。</li>
</ul>
<hr>
<h1 id="Exception-Handling快速检阅"><a href="#Exception-Handling快速检阅" class="headerlink" title="Exception Handling快速检阅"></a>Exception Handling快速检阅</h1><p>&nbsp;<br>C++的exception handling由三个主要的词汇组件构成：</p>
<ol>
<li>一个throw子句。它在程序某处发出一个exception，被丢出的exception可以是内建类型，也可以是用户自定义类型。</li>
<li>一个或多个catch子句，每一个catch子句都是一个exception handler。其含义在于表明某子句处理某种类型的exception，并且在封闭区段中提供实际处理程序。</li>
<li>一个try区段，这个区段中的内容可能会引发catch子句起作用。</li>
</ol>
<p>当一个exception被丢出时，控制权会从函数调用中被释放出来，并寻找一个吻合的catch子句。如果不存在吻合者，那么默认的处理例程terminate()会被调用。当控制权被放弃后，堆栈中的每一个函数调用也就被推离，这个程序称为unwinding the stack。在每一个函数被推离堆栈之前，函数的local class objects的destructor会被调用。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>&nbsp;<br>Exception handling会给函数带来一定的影响，考虑下述函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point* <span class="title">mumble</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point *pt1,*pt2;</span><br><span class="line">    pt1=foo();</span><br><span class="line">    <span class="keyword">if</span>(!pt1) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Point p;</span><br><span class="line">    pt2=foo();</span><br><span class="line">    <span class="keyword">if</span>(!pt2) <span class="keyword">return</span> pt1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果有一个exception在第一次调用foo()时被抛出，那么这个mumble()函数会被推出程序堆栈。由于本函数不存在任何try语句，因此不会有任何catch子句需要和他结合，不过幸运地是这里也没有任何local class object需要析构。如果有一个exception在第二次调用foo()时被抛出，exception handling机制就必须在从程序堆栈中unwinding这个函数之前，先调用p的destructor。</p>
<p>在Exception handling之下，L2~L4以及L5~L7被视为两个语意不同的区域，因为当exception被抛出时，这两个区域存在不同的执行期语意。<br>（接下来作者探讨了exception对资源的影响，并且引出了RAII的概念）</p>
<hr>
<h1 id="对Exception-Handling的支持"><a href="#对Exception-Handling的支持" class="headerlink" title="对Exception Handling的支持"></a>对Exception Handling的支持</h1><p>&nbsp;<br>当一个exception发生时，编译系统必须完成以下事情：</p>
<ol>
<li><strong>检验发生throw操作的函数</strong></li>
<li><strong>判断throw操作是否发生在try语句中</strong></li>
<li><strong>如果在try中，则进行catch子句匹配</strong></li>
<li><strong>若发生匹配，则将流程控制转交catch子句</strong></li>
<li><strong>如果3、4并没有符合</strong>，<br>那么系统必须摧毁所有active local object，从堆栈中unwind当前函数，并且进行到程序堆栈中的下一个函数，重复2-5操作。</li>
</ol>
<h2 id="判断throw操作是否在try中"><a href="#判断throw操作是否在try中" class="headerlink" title="判断throw操作是否在try中"></a>判断throw操作是否在try中</h2><p>之前曾经介绍过，一个函数可以被划分为很多区域：</p>
<ul>
<li>try区段以外的区域，而且没有active local objects</li>
<li>try区段以外的区域，但存在active local objects需要析构</li>
<li>try区段以内的区域</li>
</ul>
<p>编译器必须标示上述区域的一个有效策略是构造 program counter-range表格。</p>
<p>program counter（Intel CPU中为EIP缓存器）内含一个即将执行的程序指令，为了在一个内含try区段的函数中标示出某个区域，可以把program counter的起始值和结束值存储在一个表格中。当throw操作发生时，当前的program counter值将会与表格内部存储值进行比对，从而确定当前是否在try区段中，从而进行下一步操作。</p>
<h2 id="catch子句匹配"><a href="#catch子句匹配" class="headerlink" title="catch子句匹配"></a>catch子句匹配</h2><p>对于每一个被抛出的exception，编译器必须产生一个类型描述器，对exception的类型进行编码。如果那是一个derived type，则编码内容必须涵盖其所有base class的类型信息。只编入public base class的信息是不够的，因为这个exception可能被一个member function捕获，而在一个member function的scope中，derived class与nonpublic base class之间允许相互转换。</p>
<p>由于exception handling发生在执行期，因此我们必然需要RTTI。编译器还必须为每一个catch子句产生一个类型描述器，它们会试图去与exception的类型描述器匹配，直到吻合，或者调用terminate()。</p>
<h2 id="抛出实际对象带来的后果"><a href="#抛出实际对象带来的后果" class="headerlink" title="抛出实际对象带来的后果"></a>抛出实际对象带来的后果</h2><p>当一个exception被丢出时，exception object会被产生出来并置于相同形式的exception数据堆栈中，从throw端传播至catch子句的是exception object的地址、类型描述器等等。</p>
<p>考虑一个catch子句如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(exPoint p)&#123;</span><br><span class="line">    <span class="comment">//do sth</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>并且有一个exception object，其类型为exVertex，派生自exPoint。当前p会发生什么？</p>
<ul>
<li><strong>p将以exception object作为初值。</strong><br>如果存在copy constructor或destructor，将会发生一次拷贝构造</li>
<li><strong>发生slice</strong><br>由于p是一个object而非reference，所以在copy过程中发生了slice off.p的vtbl将被设为exPoint的vtbl，vptr不会发生改变。</li>
</ul>
<p>如果我们再次抛出p，此时我们将建立一个临时对象，并且exVertex的性质将完全丢失。（本小节内容可参见More effective C++ 关于异常处理的几篇）</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>站在对象模型的顶端——弹性</title>
    <url>/2018/05/31/%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A1%B6%E7%AB%AF%E2%80%94%E2%80%94%E5%BC%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>传统C++对象模型提供高效的执行期支持，然而在某些领域，例如动态共享函数库、共享内存以及分布式对象方面，该对象模型仍然缺乏弹性。</p>
<hr>
<h1 id="动态共享函数库"><a href="#动态共享函数库" class="headerlink" title="动态共享函数库"></a>动态共享函数库</h1><p>&nbsp;<br>在理想情况下，一个动态链接的shared library应该如同“突然来访”。也就是说，当应用程序下一次再执行时，会透明化地取用新的library版本，新library的出现不应该对旧的应用程序产生侵略性，应用程序不应当需要重新编译。然而，当前的C++对象模型无法做到这一点。</p>
<hr>
<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>&nbsp;<br>当一个shared library被加载，它在内存中的位置由runtime linker决定，一般而言与执行中的process无关。然而，在C++对象模型中，当一个动态的shared library支持一个class object，其中含有置于shared memory中的virtual functions时，上述说法失效。</p>
]]></content>
      <categories>
        <category>Inside the C++ object model</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>20.类shared_ptr但可空悬的智能指针——std::weak_ptr</title>
    <url>/2018/07/05/%E7%B1%BBshared_ptr%E4%BD%86%E5%8F%AF%E7%A9%BA%E6%82%AC%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88weak_ptr/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>有时我们会想，如果有一种行为类似于shared_ptr，但不会参与资源共享权的智能指针该有多好。换而言之，我们需要一种不改变引用计数的shared_ptr。这种智能指针主要负责解决一样问题：指出shared_ptr指向的资源是否已遭到破坏。一个真正智能的指针可以通过跟踪它何时空悬来处理这个问题，这正是weak_ptr的精义所在。你可能想知道std::weak_ptr究竟有何用途，但你在查看其API时会发现它既不能解引用也不能检测资源是否为NULL，因为weak_ptr并非是一个独立的智能指针，它是shared_ptr的扩充形式。</p>
<hr>
<h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><p>&nbsp;<br>weak_ptr通常由shared_ptr创建，它们指向同样的资源，其区别在于weak_ptr不会改变该资源的引用计数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = <span class="built_in">std</span>::make_shared&lt;Widget&gt;();<span class="comment">// RC is 1</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>;<span class="comment">// RC remains 1</span></span><br><span class="line">spw = <span class="literal">nullptr</span>;<span class="comment">// RC goes to 0, and the Widget is destroyed.wpw now dangles</span></span><br></pre></td></tr></table></figure><br>你可以通过weak_ptr的成员函数来查看其是否空悬：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (wpw.expired()) … <span class="comment">// if wpw doesn't point to an object…</span></span><br></pre></td></tr></table></figure><br>但通常我们不仅仅想要查看其是否处于空悬状态，而是需要如果其不处于空悬状态，则直接使用它所指向的资源。但说起来容易做起来难，原因在于weak_ptr不存在解引用操作，就算它有解引用操作，如上文一般将空悬检查和解引用相分离也可能会导致问题产生：例如当前存在另一个线程对指向资源的最后一个std::shared_ptr进行了赋值或析构操作，从而导致资源释放。在此环境下，解引用操作将导致未定义行为。</p>
<p>为了确保线程安全，我们真正需要完成的是一个原子操作，它检查std::weak_ptr是否空悬，如果没有，则访问它指向的对象。 访问对象这一行为可以通过从std::weak_ptr创建std::shared_ptr来完成。该操作有两种形式，具体采用哪一种形式取决于你在明确指针空悬后会采取何种措施。<br>一种形式是std::weak_ptr::lock，它返回一个std::shared_ptr。如果std::weak_ptr已经空悬，则std::shared_ptr为null：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw1 = wpw.lock(); <span class="comment">// if wpw's expired,spw1 is null</span></span><br><span class="line"><span class="keyword">auto</span> spw2 = wpw.lock(); <span class="comment">// same as above,but uses auto</span></span><br></pre></td></tr></table></figure>
<p>另一种形式是以weak_ptr为实参构造shared_ptr,如果weak_ptr已然空悬，则抛出异常：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw3</span><span class="params">(wpw)</span></span>; <span class="comment">// if wpw's expired,throw std::bad_weak_ptr</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="问题实例一（工厂模式）"><a href="#问题实例一（工厂模式）" class="headerlink" title="问题实例一（工厂模式）"></a>问题实例一（工厂模式）</h1><p>&nbsp;<br>我们将以实例分析和探讨weak_ptr的真正使用场景，假设当前一个工厂函数，它根据唯一ID生成只读对象的智能指针。根据Item 18关于工厂函数返回类型的建议，它返回一个std::unique_ptr:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">const</span> Widget&gt; <span class="title">loadWidget</span><span class="params">(WidgetID id)</span></span>;</span><br></pre></td></tr></table></figure><br>如果loadWidget调用成本较为昂贵（例如执行文件或数据库I/O），并且重复使用ID这一行为较为常见（即经常需要获取指定ID的对象），那么我们可以采用一种合理的优化方式：cache。将所有Widget都置入缓存也可能会导致性能问题，因此我们也应当保证在适当时段删除缓存。<br>对于缓存式工厂函数，其返回值仍采用unique_ptr已然不再合适，调用者当然需要指向资源的智能指针，但调用者也需要了解资源是否已经遭到释放，cache里存放的智能指针应当具备检测空悬的能力（以便及时地清空缓存），因此缓存中存储的智能指针应当为weak_ptr类型，而工厂函数返回值应当为shared_ptr类型，因为weak_ptr只能检测shared_ptr所管理资源的空悬性，这是loadWidget的缓存版本的快速实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetID id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;WidgetID,<span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">const</span> Widget&gt;&gt; cache;</span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].lock();</span><br><span class="line">    <span class="keyword">if</span> (!objPtr) &#123;<span class="comment">// not in cache</span></span><br><span class="line">        objPtr = loadWidget(id);<span class="comment">//load it</span></span><br><span class="line">        cache[id] = objPtr;<span class="comment">//cache it</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个实现显然可以进一步改进，因为我们的cache目前只做到了增加元素，实际上还可以在检测到资源破坏后从cache中删除指定元素，但这个实现与本节主题无关，因此有兴趣者可自行尝试。</p>
<hr>
<h1 id="问题实例二（观察者模式）"><a href="#问题实例二（观察者模式）" class="headerlink" title="问题实例二（观察者模式）"></a>问题实例二（观察者模式）</h1><p>&nbsp;<br>让我们现在将目光转向第二个实例：Observer设计模式。该模式的主要组成部分是主体（状态可能发生变化的对象）和观察者（发生状态变化时要通知的对象）。在该模式的大多数实现中，每个主体包含一个数据成员，该成员持有指向其观察者的指针，这使得主体可以轻松发出当前状态已更改的通知。主体对观察者的生命周期毫无兴趣（即主体并不需要了解当前观察者的状态），但我们至少需要撰写某种操作保证当某观察者已被破坏时，主体从观察者列表中将其删除。一个合理的设计是每个主体均持有一个容器，其容器内部元素为指向观察者的std::weak_ptrs，从而使得主体可以判断观察者是否已经失效。</p>
<hr>
<h1 id="问题实例三"><a href="#问题实例三" class="headerlink" title="问题实例三"></a>问题实例三</h1><p>&nbsp;<br>考虑一个包含对象A，B，C的数据结构，其中A和C共享B的所有权，因此我们使用shared_ptr：<br><img src="http://static.zybuluo.com/zsmj2017/d4qdwqr4k57unpm1x38raaey/image_1chkntif01p2nnas112q152r1hc229.png" alt="image_1chkntif01p2nnas112q152r1hc229.png-14.3kB"><br>假设我们又发现B中也需要存在一个指向A的指针，那它应当是何种类型？<br><img src="http://static.zybuluo.com/zsmj2017/z2es54h9day63m3uw80r2okv/image_1chkohht0hdb1p4d71e1rl41c562m.png" alt="image_1chkohht0hdb1p4d71e1rl41c562m.png-20kB"><br>主要有三种选择：</p>
<ol>
<li><strong>原始指针</strong><br>如果使用原始指针，如果A已被销毁，但仍存在C继续指向B，而B中又包含指向A的指针。B无法确定A是否已经析构，因此可能会触发解引用空悬指针的行为，这将导致未定义后果。</li>
<li><strong>std::shared_ptr</strong><br>在此设计中，A和B中包含指向彼此的std::shared_ptrs。这种彼此指向的行为将阻止A和B被析构。即使A和B无法被其他数据结构访问(例如C不再指向B),A与B仍然具备引用计数为1。这种情况也是一种内存泄漏，因为A与B永远无法被访问，但分配给它们的资源将永远无法回收。</li>
<li><strong>std::weak_ptr</strong><br>使用weak_ptr完美避免了上述两个问题。如果A已被析构，B指向它的指针将保持空悬状态，并且B能够检测空悬。此外，虽然A和B指向彼此，但B并不对A存有任何引用计数，因此仍然可以析构自如。</li>
</ol>
<p>值得注意的是，需要使用std::weak_ptr取代std::shared_ptr的常见并不多见。在严格的分层数据结构（例如树）中，子节点通常仅由其父节点拥有。当父节点被销毁时，其子节点也应该被销毁。因此，父母与孩子之间的链接通常最好由std::unique_ptrs表示。此外，从子节点到父节点的反向链接可以安全地使用原始指针表示，因为子节点的生命周期永远不会超过其父节点。 因此，没有子节点解引用空悬父指针的风险。</p>
<hr>
<h1 id="weak-ptr的效率"><a href="#weak-ptr的效率" class="headerlink" title="weak_ptr的效率"></a>weak_ptr的效率</h1><p>&nbsp;<br>从效率的角度而言，std::weak_ptr与std::shared_ptr基本保持一致。std::weak_ptr对象与std::shared_ptr对象大小相同，并且它们也涉及control block，构造，析构和赋值等操作也需要atomic引用计数操作。在本节开头我们曾说weak_ptr不使用引用计数，这说明的是weak_ptr不涉及shared_ptr的引用计数，实际上control block中有专门关于weak_ptr的引用计数（详见Item21）。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>你可以将weak_ptr视为可空悬的shared_ptr。</strong></li>
<li><strong>weak_ptrs的使用场合包括cache、观察者模式、以及打破shared_ptr循环。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>37.禁止重定义继承而来的non-virtual函数</title>
    <url>/2018/04/18/%E7%A6%81%E6%AD%A2%E9%87%8D%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>假设我们有base class与derived class如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>：</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">mf</span>();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B &#123;...&#125;</span><br></pre></td></tr></table></figure><br>我们应该确定：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D x;</span><br><span class="line">B* pB = &amp;x;pB-&gt;mf();</span><br><span class="line">D* pD = &amp;x;pD-&gt;mf();</span><br></pre></td></tr></table></figure><br>两次函数调用的行为应当一致。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>仍以前文为例，如果我们在D中重定义了mf，也就是说造成了遮蔽名称的现象，那会有如下情况发生<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D x;</span><br><span class="line">B* pb= &amp;x</span><br><span class="line">D * pd = &amp;x；</span><br><span class="line">pb-&gt;mf();<span class="comment">//调用B::mf();</span></span><br><span class="line">pd-&gt;mf();<span class="comment">//调用D::mf();</span></span><br></pre></td></tr></table></figure><br>造成如上行为的原因是因为<strong>non-virtual静态绑定</strong>，具体来说，如果pb是一个pointer to B，通过pb调用的non-virtual函数永远是B的版本。<br>但如果mf是一个动态绑定的virtual，那么无论通过pb还是pd调用得到的都是D::mf().</p>
<hr>
<h1 id="non-virtual被重定义的危害"><a href="#non-virtual被重定义的危害" class="headerlink" title="non-virtual被重定义的危害"></a>non-virtual被重定义的危害</h1><p>&nbsp;<br>上述实例表明，在发生了non-virtual重定义的情况下，D对象的行为出现了不一致性。具体来说，<strong>当mf被调用时，对象的行为可能表现为基类也可能表现为派生类，其决定因素不在于对象自身而在于“指向该对象的指针”的声明类型。</strong></p>
<p>前文已述，public继承代表is-a，而non-virtual代表了class的某种不变性。如果derived class重定义了non-virtual函数，设计便出现了矛盾：如果D真的有必要实现出与B不同的non-virtual函数，也就表明其特异性超过了不变性，这也就违背了is-a关系。</p>
<p>base class的析构函数之所以要声明为virtual也是如此，因为derived class绝不应该重新定义一个继承而来的non-virtual函数。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>21.禁止直接修改set或mutiset的key</title>
    <url>/2018/04/12/%E7%A6%81%E6%AD%A2%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9set%E6%88%96mutiset%E7%9A%84key/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><br><br>正如所有标准关联容器，set和multiset保证元素有序，而且容器的行为之所以能够正确也是建立在内部元素有序的基础之上。如果你修改了关联容器里的元素的key，那么元素的有序可能得不到保证。</p>
<hr>
<h1 id="修改map的key"><a href="#修改map的key" class="headerlink" title="修改map的key"></a>修改map的key</h1><p>&lt;/br&gt;<br>本节标题只提到了set与mutiset，因此有读者会发生疑问：难道map或mutimap的key就可以改变吗？实则不然：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">...</span><br><span class="line">m.<span class="built_in">begin</span>()-&gt;first = <span class="number">10</span>; <span class="comment">//error</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mm;</span><br><span class="line">...</span><br><span class="line">mm.<span class="built_in">begin</span>()-&gt;first = <span class="number">20</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>map的key根本无法改变，任何试图改变其key的操作都无法通过编译，这也就是本节不涉及map的原因。<br>之所以map的key无法改变，那是因为<code>map&lt;K,V&gt;</code>或者<code>multimap&lt;K,V&gt;</code>类型的对象中元素的类型是<code>pair&lt;const K,V&gt;</code>，const保证了其key不可赋值。</p>
<hr>
<h1 id="为何set的key不能设为const"><a href="#为何set的key不能设为const" class="headerlink" title="为何set的key不能设为const"></a>为何set的key不能设为const</h1><p>&lt;/br&gt;<br>对于<code>set&lt;T&gt;</code>或<code>multiset&lt;T&gt;</code>类型的对象来说，储存在容器里的元素类型只不过是T，并非constT。因此，set或multiset里的元素可能在你想要的任何时候改变。那这个时候问题来了，为何set内的元素不能设置为const呢？</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设存在一个关于雇员的class:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">getTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(<span class="built_in">string</span>&amp; title)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idNumber</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>假定雇员ID唯一，建立一个内部元素为Employee对象的set，显然应该以ID来排序set：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IDNumberLess</span>:</span></span><br><span class="line">    <span class="keyword">public</span> binary_function&lt;Employee, Employee, <span class="keyword">bool</span>&gt; &#123; </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Employees lhs,<span class="keyword">const</span> Employee&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.idNumber() &lt; rhs.idNumber();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">set</span>&lt;Employee, IDNumberLess&gt; EmpIDSet;</span><br><span class="line">EmpIDSet se;</span><br></pre></td></tr></table></figure><br>在此实例中，ID是set的key，其他东西自然可以任意更改：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Employee selectedID;</span><br><span class="line"><span class="keyword">auto</span> i = se.<span class="built_in">find</span>(selectedID);</span><br><span class="line"><span class="keyword">if</span> (i != se.<span class="built_in">end</span>())&#123;</span><br><span class="line">    i-&gt;setTitle(<span class="string">"Corporate Deity"</span>);<span class="comment">//更换头衔</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以自由地改变set中对象的某一部分成员，那说明set内部的元素并没有用const修饰，那也就是说，set内部的一切都可以改变。改变set的key是存在巨大风险的，但编译器允许这种行为。</p>
<p>(Effective STL的作者接下来花了大量的篇幅讲述映射，我认为其内容并非一定需要了解）</p>
<hr>
<h1 id="如何安全地改变set内部的元素"><a href="#如何安全地改变set内部的元素" class="headerlink" title="如何安全地改变set内部的元素"></a>如何安全地改变set内部的元素</h1><p>&lt;/br&gt;<br>想要安全地更改set内部的元素，必须按照以下流程执行</p>
<ol>
<li>定位到需要修改的元素</li>
<li>拷贝并修改</li>
<li>从set中删除原元素</li>
<li>插入新元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EmpIDSet se; </span><br><span class="line">Employee selectedID; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> i =se.<span class="built_in">find</span>(selectedID);</span><br><span class="line"><span class="keyword">if</span>(i!=se.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">e</span><span class="params">(*i)</span></span>; <span class="comment">//copy</span></span><br><span class="line">    se.erase(i++);<span class="comment">//自增保证迭代器有效</span></span><br><span class="line">    e.setTitle(<span class="string">"Corporate Deity"</span>);<span class="comment">//修改副本</span></span><br><span class="line">    se.insert(i, e);<span class="comment">//在原先位置插入新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔者认为在关联容器内部指定位置插入的做法不足取，但本节也仅仅只是权宜之举。对于set，记住不要试图去修改key就好了。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
        <tag>关联容器</tag>
      </tags>
  </entry>
  <entry>
    <title>线程管理——线程管理基础</title>
    <url>/2019/04/07/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>每一个程序都至少存在一个线程：执行main函数的原始线程，其余线程与原始线程同时运行(并非同时启动)，并在执行完其入口函数后退出。本节将从如何启动线程说起，大致地为读者介绍C++并发编程中的线程管理基础。<br><a id="more"></a></p>
<hr>
<h1 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h1><p>&nbsp;<br>线程在<code>std::thread</code>对象创建完毕后启动(thread对象被指派了入口函数)。</p>
<h2 id="创建thread对象"><a href="#创建thread对象" class="headerlink" title="创建thread对象"></a>创建thread对象</h2><p>在最理想的情况下，入口函数既不需要任何参数也没有返回值，用这种函数来创建<code>std::thread</code>对象的过程如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br></pre></td></tr></table></figure><br>除此以外，<code>std::thread</code>也接受可调用类型构造，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span> &#123;</span> </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    do_something(); </span><br><span class="line">    do_something_else(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line">background_task f; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure><br>函数对象将会被<strong>拷贝</strong>至新线程自己的存储空间，因此需要保证副本与原本的执行结果具备一致性。<br>值得注意的是，当传递函数对象至<code>std::thread</code>构造函数时，需要避免<code>C++&#39;s Most vexing parse</code>。具体而言，当你将一个临时变量传入构造函数时，编译器可能会将该语句解析为一个函数声明，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(background_task())</span></span>;</span><br></pre></td></tr></table></figure>
<p>该语句声明了一个名为my_thread的函数，其接受一个函数指针，并返回一个thread对象。<br>规避方法很简单，如同上文一般采用命名对象，或使用C++11新引入的初始化语法即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread my_thread&#123;background_task()&#125;;</span><br></pre></td></tr></table></figure><br>更多关于C++11初始化语法的信息，可以参阅<a href="https://xander.wiki/post/71c8a4d5.html">Effective Mordern C++ Item 7</a>。<br><code>std::thread</code>亦可以使用<code>lambda</code>表达式完成构造，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">([]&#123; do_something(); do_something_else(); &#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="等待式与分离式"><a href="#等待式与分离式" class="headerlink" title="等待式与分离式"></a>等待式与分离式</h1><p>&nbsp;<br>在线程完成启动后，需要明确是否需要等待线程结束，或者令其在后台自主运行，具体而言，即明确对线程执行<code>join</code>或<code>detach</code>中的何种操作。如果在<code>std::thread</code>对象析构前仍未执行<code>join</code>或<code>detach</code>,则析构函数会调用<code>std::terminate</code>，强行终止程序。</p>
<h2 id="等待式-join"><a href="#等待式-join" class="headerlink" title="等待式(join)"></a>等待式(join)</h2><p><code>join</code>是简单粗暴地等待线程完成。值得注意的是，一个<code>std::thread</code>只能<code>join</code>一次，此后调用<code>joinable()</code>时将返回false。</p>
<h3 id="含有异常情况下的join"><a href="#含有异常情况下的join" class="headerlink" title="含有异常情况下的join"></a>含有异常情况下的join</h3><h4 id="join-in-catch"><a href="#join-in-catch" class="headerlink" title="join in catch"></a>join in catch</h4><p>如果入口函数具备<code>noexpect</code>属性，则直接对<code>std::thread</code>对象执行<code>join()</code>即可。若当前入口函数可能抛出异常，并且在<code>join()</code>语句执行前该异常被抛出，则<code>join()</code>操作将会被跳过，因此必须在catch语句中对<code>std::thread</code>对象执行<code>join()</code>，即：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>; </span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(my_func)</span></span>; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    do_something_in_current_thread(); </span><br><span class="line">  &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">throw</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如此一来，<code>std::thread</code>始终可执行<code>join()</code>操作。</p>
<h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p>另一种更为简洁的方法是使用<a href="https://xander.wiki/post/f6c7650f.html">RAII(Resource Acquisition Is Initialization)</a>,现以一个简单的class <code>thread_guard</code>加以说明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span> &#123;</span> </span><br><span class="line">  <span class="built_in">std</span>::thread&amp; t; <span class="comment">// data member</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(<span class="built_in">std</span>::thread&amp; t_)</span>:<span class="title">t</span><span class="params">(t_)</span> </span>&#123;&#125; </span><br><span class="line">  ~thread_guard() &#123; </span><br><span class="line">  <span class="keyword">if</span>(t.joinable())&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  thread_guard(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>; </span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(my_func)</span></span>; </span><br><span class="line">  <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>; </span><br><span class="line">  do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要注意的是，为了避免<code>thread_guard</code>中的<code>std::thread</code>丢失，我们手动禁止了所有的copy operation。当<code>thread_guard</code>对象析构时，它将检查线程状态，并调用<code>join()</code>。</p>
<hr>
<h2 id="分离式-detach"><a href="#分离式-detach" class="headerlink" title="分离式(detach)"></a>分离式(detach)</h2><p>使用<code>detach()</code>会让线程在后台运行，这意味着主线程不能与之产生直接交互。C++运行库保证，当分离线程退出时，相关资源能够得到正确回收。</p>
<h3 id="线程特点"><a href="#线程特点" class="headerlink" title="线程特点"></a>线程特点</h3><p>通常我们称分离线程为守护线程(daemon threads)。在UNIX中，守护线程指没有任何显式用户接口，并在后台运行的线程。守护线程的一大特点即为长时间运行，线程的生命周期可能会从某一个应用起始到结束。守护线程常用于后台监视文件系统，或者执行缓存清理，亦或对数据结构进行优化，是一种典型的“发后即忘”(fire and forget)操作。</p>
<p>只能对存在运行函数的<code>std::thread</code>对象执行<code>deatch()</code>(<code>join()</code>亦是如此），类似地，<code>detach()</code>也只能对一个<code>std::thread</code>对象执行一次，我们可以通过<code>joinable()</code>的返回值<code>true</code>来确认当前线程可执行分离操作。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>假设当前存在一个文字处理应用程序，该程序存在同时编辑多个文档的需求。显然，编辑多个文档需要打开多个窗口，这些窗口彼此独立且运行在同一个应用实例中。此时我们可以提出一种解决方案：令每一个文档处理窗口拥有自己独立的线程，这些线程入口程序均相同，只是所处理的数据不同而已。由于需要处理的文档彼此独立，因此线程之间不存在任何等待的需要，文档处理线程可以执行<code>detach()</code>操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_document</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename)</span> </span>&#123;</span><br><span class="line">  open_document_and_display_gui(filename); </span><br><span class="line">  <span class="keyword">while</span>(!done_editing()) &#123; </span><br><span class="line">    user_command cmd=get_user_input(); </span><br><span class="line">    <span class="keyword">if</span>(cmd.type==open_new_document) &#123; </span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::stringnew_name=get_filename_from_user(); </span><br><span class="line">      <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(edit_document,new_name)</span></span>;</span><br><span class="line">      t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      process_user_input(cmd); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="空悬引用及指针"><a href="#空悬引用及指针" class="headerlink" title="空悬引用及指针"></a>空悬引用及指针</h3><h4 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h4><p>如果明确某线程为守护线程，则必须明确在该线程运行完毕之前其使用的数据具备有效性。如果一个线程函数持有某个局部变量的引用或指针，则极有可能触发空悬，现有问题实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>&amp; i; </span><br><span class="line">  func(<span class="keyword">int</span>&amp; i_) : i(i_) &#123;&#125; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> j=<span class="number">0</span> ; j&lt;<span class="number">1000000</span> ; ++j) &#123; </span><br><span class="line">      do_something(i);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>; </span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>; </span><br><span class="line">  my_thread.<span class="built_in">detach</span>();</span><br><span class="line">&#125; <span class="comment">// 函数结束后新线程可能还在运行</span></span><br></pre></td></tr></table></figure></p>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>在上述实例中，<code>func</code>对象内含有局部变量的引用，在oops执行完毕后，局部变量<code>some_local_state</code>被析构，而此时依赖<code>some_local_state</code>的<code>my_thread</code>仍在执行，从而导致未定义行为。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>针对此类问题，最好的做法是将数据复制至线程内，可调用对象在作为构造函数参数时会被复制，但其内部所含有的引用或指针却仍然指向外部共享数据。使用一个能够访问局部变量的函数去初始化<code>std::thread</code>对象并不可取，除非你可以保证该线程结束于局部变量析构之前。如果不能做出上述保证，则应当使用join而非detach。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>线程在<code>std::thread</code>对象创建完毕后启动。</li>
<li>线程需要明确执行<code>join</code>或<code>detach</code>，在执行<code>join</code>时，最好以RAII保证<code>join</code>的必然执行，而<code>detach</code>则需要关注是否存在空悬数据的可能，是则最好对数据执行拷贝操作或选择使用<code>join</code>。</li>
</ol>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>38.禁止重定义继承而来的默认实参</title>
    <url>/2018/04/19/%E7%A6%81%E6%AD%A2%E9%87%8D%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>我们只能继承virtual和non-virtual函数，而重新定义一个non-virtual函数永远是错误的。所以本节讨论只基于”继承一个带有默认实参的virtual函数”。之所以需要讨论它，是因为<strong>virtual函数动态绑定，但默认实参静态绑定。</strong></p>
<hr>
<h1 id="静态绑定与动态绑定"><a href="#静态绑定与动态绑定" class="headerlink" title="静态绑定与动态绑定"></a>静态绑定与动态绑定</h1><h2 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h2><p>对象所谓的静态类型(static type)，就是它在程序中<strong>被声明为的类型</strong>。举例而言:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>：</span></span><br><span class="line"><span class="class">    <span class="title">enum</span> <span class="title">color</span>｛<span class="title">red</span>，<span class="title">green</span>，<span class="title">blue</span>｝；</span></span><br><span class="line"><span class="class">    <span class="title">virtual</span> <span class="title">void</span> <span class="title">draw</span>（<span class="title">color</span> <span class="title">c</span> = <span class="title">red</span>) <span class="title">const</span> = 0;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color c = green)</span> <span class="keyword">const</span></span>;<span class="comment">//重定义了默认实参</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">circle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color c)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//当客户通过对象调用此函数时必须使用实参，因为静态绑定不从base继承默认实参</span></span><br><span class="line">    <span class="comment">//但若以指针或引用调用则无需如此，因为动态绑定下该函数会从其base获取默认实参</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><br>此继承体系如图所示：<br><img src="http://static.zybuluo.com/zsmj2017/qw9s0ez5i1aspkgcjpo7r1fi/image_1cbdnpjs21jto1c72j5f1verkd09.png" alt="image_1cbdnpjs21jto1c72j5f1verkd09.png-13.2kB"><br>那么考虑这些指针：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shape* ps；<span class="comment">//静态类型为shape*</span></span><br><span class="line">shape* pc = <span class="keyword">new</span> <span class="built_in">circle</span>；<span class="comment">//同上</span></span><br><span class="line">shape* pr = <span class="keyword">new</span> rectangle;<span class="comment">//同上</span></span><br></pre></td></tr></table></figure><br>它们都被<strong>声明为</strong>pointer-to-shape类型，所以他们的静态类型都是shape*。</p>
<p><strong>动态类型则是指目前所指对象的类型，也就是说，动态类型可以表现出一个对象将会有怎样的行为。</strong><br>动态类型一如其名，可以在程序执行过程中改变:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps=pc;<span class="comment">//ps的动态类型改为Circle*</span></span><br><span class="line">ps=pr;<span class="comment">//ps的动态类型改为Rectangle*</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h2><p>virtual函数本身通过动态绑定来执行（也就是说如何执行取决于对象的动态类型），但如果遇到了带有默认实参的virtual函数，这个时候问题来了。<br>virtual是动态绑定，而缺省参数值却是静态绑定。也就是说，你<strong>可能会在调用“一个定义于derived class内的virtual函数”的同时却使用了base class为它指定的缺省参数</strong>，举例而言，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pr-&gt;draw();<span class="comment">//以为此时的默认实参是green</span></span><br><span class="line"><span class="comment">//但其实等价于调用rectangle::draw(shape::red);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="何种原因造成了这种分裂机制"><a href="#何种原因造成了这种分裂机制" class="headerlink" title="何种原因造成了这种分裂机制"></a>何种原因造成了这种分裂机制</h2><p><strong>C++将默认实参设为静态绑定的原因在于运行期效率</strong>。如果缺省参数设置为动态绑定，那么编译器就必须在<strong>运行期</strong>为virtual函数决定适当的参数缺省值，而静态绑定在编译期就完成了决定。动态绑定默认实参过于缓慢和复杂。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>就算严格遵守了本节所讲的内容，也未必就称得上最佳设计：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>：</span></span><br><span class="line"><span class="class">    <span class="title">enum</span> <span class="title">color</span>｛<span class="title">red</span>，<span class="title">green</span>，<span class="title">blue</span>｝；</span></span><br><span class="line"><span class="class">    <span class="title">virtual</span> <span class="title">void</span> <span class="title">draw</span>（<span class="title">color</span> <span class="title">c</span> = <span class="title">red</span>) <span class="title">const</span> = 0;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color c = red)</span> <span class="keyword">const</span></span>;<span class="comment">//不再重定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种写法无疑造成了代码重复。更为重要的是，代码重复造成了<strong>相依性</strong>：一旦作为base class的Shape内的默认实参需要改变，则所有derived class都必须发生改变，否则就造成了重定义默认实参。因此我们必须考虑某种替代手法。</p>
<h2 id="NVI"><a href="#NVI" class="headerlink" title="NVI"></a>NVI</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">enum</span> color｛red，green，blue｝；</span><br><span class="line">    <span class="keyword">void</span> draw（color c = red) <span class="keyword">const</span>&#123;</span><br><span class="line">        doDraw(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(color c)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color c)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于non-virtual不会被覆写，所以derived class继承得到的函数必然具备与base class相同的默认实参。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>禁止重定义默认实参，因为它们是静态绑定，而virtual函数是动态绑定。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>线程管理——向线程函数传递参数</title>
    <url>/2019/04/07/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E5%90%91%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在上一节中，所有的入口函数均为无参函数，若某个入口函数存在形参，则需要向线程函数传递参数。这一行为并不复杂，仅仅需要在函数名后加上参数即可，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">(<span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(do_some_work,<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h1 id="复制与引用"><a href="#复制与引用" class="headerlink" title="复制与引用"></a>复制与引用</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在执行参数传递时需要注意的是，在不加以说明的情况下，所传参数必然以拷贝的形式传入线程独立内存中，即使在入口函数中形参是一个引用。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">"hello"</span>)</span></span>;</span><br></pre></td></tr></table></figure><br><code>f</code>需要的是一个<code>string</code>对象，而我们传入的是一个字面值常量，即<code>const char *</code>，因此这里首先完成了字面值向<code>string</code>对象的转化，并将该<code>string</code>对象拷贝至t的独立存储空间，并在其后完成引用绑定。</p>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>当指向动态变量的指针作为参数传递给线程时需要特别注意：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">(<span class="keyword">int</span> some_param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(<span class="built_in">buffer</span>, <span class="string">"%i"</span>,some_param);</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,<span class="built_in">buffer</span>)</span></span>;</span><br><span class="line">  t.<span class="built_in">detach</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在函数<code>oops</code>中，buffer是一个指向本地char数组的指针。如果<code>oops</code>函数在线程对象t构造时意外退出(buffer转换成std::string对象之前)，那么依赖buffer隐式转为string的愿景将无法实现。解决方案是在<code>std::thread</code>构造函数中显式地执行转换操作，确保<strong>转换发生在构造之前</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_oops</span><span class="params">(<span class="keyword">int</span> some_param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(<span class="built_in">buffer</span>,<span class="string">"%i"</span>,some_param);</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="built_in">buffer</span>))</span></span>; <span class="comment">//免悬垂指针</span></span><br><span class="line">  t.<span class="built_in">detach</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>有时我们确实需要将变量以引用，而非复制的形式传入线程，比如我们需要处理一个被线程更新过的数据：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span> </span>&#123;</span><br><span class="line">  widget_data data; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>;</span><br><span class="line">  display_status(); </span><br><span class="line">  t.join(); </span><br><span class="line">  process_widget_data(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述写法中，线程结束后更新完毕的data将会被销毁，<code>process_widget_data</code>处理的永远是最初的原始数据。<br>解决方案是采用<code>std::ref</code>将参数转为引用即可，此时<code>update_data_for_widget</code>将接收到data的引用，而非是data的拷贝的引用，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,<span class="built_in">std</span>::ref(data))</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="以成员函数作为入口函数"><a href="#以成员函数作为入口函数" class="headerlink" title="以成员函数作为入口函数"></a>以成员函数作为入口函数</h1><p>&nbsp;<br>我们可以认为，成员函数本身也是一种普通函数，其特殊之处在于其第一个形参是<code>this</code>指针。因此，如下写法也不难理解：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_lengthy_work</span><span class="params">(<span class="keyword">int</span>)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">X my_x; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work, &amp;my_x, num)</span></span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h1><p>&nbsp;<br>入口函数同样支持移动传入的变量。具体而言，临时变量总是以移动形式传入，而命名变量则需要显式地使用<code>std::move</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_big_object</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;big_object&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;big_object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> big_object)</span></span>; </span><br><span class="line">p-&gt;prepare_data(<span class="number">42</span>); </span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(process_big_object,<span class="built_in">std</span>::<span class="built_in">move</span>(p))</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="thread的移动性"><a href="#thread的移动性" class="headerlink" title="thread的移动性"></a>thread的移动性</h2><p><code>std::thread</code>类似于<code>unique_ptr</code>，也是一种<code>move only object</code>。一个<code>std::thread</code>持有一个执行线程，执行线程的所有权可以在多个<code>std::thread</code>间转移。<code>std::thread</code>的不可复制性保证了在同一时间点，一个<code>std::thread</code>仅可持有一个执行线程，而其移动性则保证了程序撰写者可以决定哪个<code>std::thread</code>对象可以拥有执行线程的所有权。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程管理——转移线程所有权</title>
    <url>/2019/04/08/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E8%BD%AC%E7%A7%BB%E7%BA%BF%E7%A8%8B%E6%89%80%E6%9C%89%E6%9D%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在上一节中我们已经提及<code>std::thread</code>对象是一个<code>move only object</code>,而move的过程也正是转移线程所有权的过程。本节将对如何转移线程所有权，以及转移线程所有权的实际应用场景作出简单介绍。<br><a id="more"></a></p>
<hr>
<h1 id="转移实例"><a href="#转移实例" class="headerlink" title="转移实例"></a>转移实例</h1><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>下述实例创建了两个执行线程，并且展示了如何在<code>std::thread</code>实例(t1,t2和t3)之间转移所有权：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; </span><br><span class="line"><span class="built_in">std</span>::thread t2=<span class="built_in">std</span>::<span class="built_in">move</span>(t1); </span><br><span class="line">t1=<span class="built_in">std</span>::thread(some_other_function);<span class="comment">// 临时对象隐式触发了移动 </span></span><br><span class="line"><span class="built_in">std</span>::thread t3; </span><br><span class="line">t3=<span class="built_in">std</span>::<span class="built_in">move</span>(t2); </span><br><span class="line">t1=<span class="built_in">std</span>::<span class="built_in">move</span>(t3); <span class="comment">// 崩溃</span></span><br></pre></td></tr></table></figure><br>值得注意的是最后一个移动操作，该操作试图将t3拥有的执行线程转交t1，但由于t1已拥有执行线程，因此系统将调用<code>terminate()</code>，强行终止程序运行。之前我们已经提过，需要在<code>std::thread</code>对象析构前显式地<code>join</code>或<code>detach</code>，赋值操作亦是如此，不存在通过赋值来“丢弃”某个运行线程的概念。</p>
<h2 id="函数外传递"><a href="#函数外传递" class="headerlink" title="函数外传递"></a>函数外传递</h2><p>类似地，线程所有权也可以在函数外传递，例如将<code>std::thread</code>对象作为返回值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::thread(some_function);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(some_other_function,<span class="number">42</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> t; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>std::thread</code>也可以作为形参：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::thread t)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  f(<span class="built_in">std</span>::thread(some_function));</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(some_function)</span></span>;</span><br><span class="line">  f(<span class="built_in">std</span>::<span class="built_in">move</span>(t)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>为了保证线程总能被等待，我们可以创建RAII对象<code>scoped_thread</code>,该对象持有一个<code>std::thread</code>,和之前所提及的<code>thread_guard</code>不同的是，这里将在构造函数中作出检查，如果某个线程不可加入，则抛出异常：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span> &#123;</span> </span><br><span class="line">  <span class="built_in">std</span>::thread t; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(<span class="built_in">std</span>::thread t_)</span>:<span class="title">t</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(t_))</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!t.joinable()) </span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(“No thread”); </span><br><span class="line">  &#125; </span><br><span class="line">  ~scoped_thread() &#123; </span><br><span class="line">    t.join(); </span><br><span class="line">  &#125; </span><br><span class="line">  scoped_thread(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>; </span><br><span class="line">  scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state;</span><br><span class="line">  <span class="function">scoped_thread <span class="title">t</span><span class="params">(<span class="built_in">std</span>::thread(func(some_local_state)))</span></span>;</span><br><span class="line">  do_something_in_current_thread(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在f函数结束时，<code>scoped_thread</code>析构函数触发，执行对线程的等待。</p>
<h2 id="自动化管理"><a href="#自动化管理" class="headerlink" title="自动化管理"></a>自动化管理</h2><p><code>std::thread</code>也可以被装入容器(如果容器是移动敏感的)，这意味着我们可以批量生产一些线程：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">    threads.push_back(<span class="built_in">std</span>::thread(do_work,i));</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">std</span>::for_each(threads.<span class="built_in">begin</span>(),threads.<span class="built_in">end</span>(),<span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将<code>std::thread</code>置入<code>std::vector</code>是迈向线程自动化管理的第一步，这一行为揭示了在实际应用中我们无需为每一个<code>std::thread</code>创建独立的对象，可以通过批量操作的形式完成构造与加入(<code>join</code>)。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程间共享数据——共享数据导致的问题</title>
    <url>/2019/04/09/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>并发编程中的大多数数据问题都起因于共享数据被多个线程修改，读取只读属性的共享数据不会存在任何问题。</p>
<a id="more"></a>
<hr>
<h1 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h1><h2 id="条件竞争成因"><a href="#条件竞争成因" class="headerlink" title="条件竞争成因"></a>条件竞争成因</h2><p>在并发编程中，每一个线程都抢着完成自己的任务，但相对执行顺序却各不相同，这导致了条件竞争的产生。大多数情况下条件竞争是良性竞争，即线程执行的相对顺序不影响最终运行结果，如两个线程同时向一个容器中添加元素。自然地，也存在恶性竞争，例如在链表删除节点时另一个线程试图访问该节点。本书无意于关注与讨论良性竞争，提及的所有条件竞争均为恶性竞争。</p>
<p>恶性条件竞争通常发生在对多个数据块的修改操作中，但由于其出现概率较低，由此引发的问题很难查找与复现，仅有在系统负载增大时（执行线程数量增加），产生恶性竞争的执行序列复现概率才有所增大。此外，条件竞争通常是时间敏感的，因此在调试状态下很难定位到该bug，因为调试状态对执行时间存在一定的影响(虽然该影响并不甚大)。</p>
<hr>
<h2 id="避免恶性条件竞争"><a href="#避免恶性条件竞争" class="headerlink" title="避免恶性条件竞争"></a>避免恶性条件竞争</h2><p>避免恶性条件竞争的方案有很多，最直接的方案是对数据结构采用某种保护机制，从而保证<strong>仅有正在执行修改操作的线程</strong>才能够访问到<strong>结构正在被破坏时的中间状态</strong>。从其他执行线程的角度而言，修改操作不是还没执行，就是已经完成。C++标准库提供了很多类似的机制，后续将为读者们一一介绍。</p>
<p>另一种解决方案是修改数据结构，从而保证其必然能够完成一系列不可分割的修改，这也就是所谓的”无锁编程”。该解决方案十分复杂，你必须深入了解内存模型的差异性与线程对数据的可访问性。</p>
<p>此外，还存在一种名为“软件事务内存”(STM)的解决方案，简单来说，即使用事务的方式去处理数据结构的更新(类似于数据库)。所需的数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交。当数据结构被另一个线程修改后，或处于已经重启的情况下，提交将无法进行。C++并不直接支持STM，但相关思想将会在本书中有所说明。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程管理——运行期决定线程数量</title>
    <url>/2019/04/08/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%86%B3%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h1 id="hardware-concurrency"><a href="#hardware-concurrency" class="headerlink" title="hardware_concurrency"></a>hardware_concurrency</h1><p>&nbsp;<br>C++标准库提供了名为<code>std::thread::hardware_concurrency()</code>的函数，该函数将返回能<strong>同时并发</strong>在一个程序中的线程数量。举例而言，在多核系统返回值为CPU核芯数量；在无法获取系统信息时，该值为0。显然，该API是在运行期决定线程数量的重要提示。<br><a id="more"></a></p>
<hr>
<h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>&nbsp;<br>下述代码实现了一种并行版的<code>accumulate</code>函数，</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,T&amp; result)</span></span>&#123;</span><br><span class="line">    result=<span class="built_in">std</span>::accumulate(first,last,result);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length=<span class="built_in">std</span>::distance(first,last);</span><br><span class="line">  <span class="keyword">if</span>(!length) <span class="comment">// length == 0</span></span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> min_per_thread=<span class="number">25</span>; <span class="comment">// 线程处理的最小区间</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> max_threads= (length+min_per_thread<span class="number">-1</span>)/min_per_thread; <span class="comment">// 所需线程数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hardware_threads=<span class="built_in">std</span>::thread::hardware_concurrency(); <span class="comment">// 硬件支持线程数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_threads=<span class="built_in">std</span>::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);<span class="comment">// 实际运行线程数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size=length/num_threads;<span class="comment">// 实际区间大小</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;</span><br><span class="line">  Iterator block_start=first; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> i=<span class="number">0</span>; i &lt; (num_threads<span class="number">-1</span>); ++i) &#123;</span><br><span class="line">    Iterator block_end=block_start; </span><br><span class="line">    <span class="built_in">std</span>::advance(block_end,block_size);       </span><br><span class="line">    threads[i]=<span class="built_in">std</span>::thread( <span class="comment">// 计算每一段</span></span><br><span class="line">        accumulate_block&lt;Iterator,T&gt;(),</span><br><span class="line">        block_start,block_end,<span class="built_in">std</span>::ref(results[i]) <span class="comment">// 传入引用</span></span><br><span class="line">    );  </span><br><span class="line">    block_start=block_end;</span><br><span class="line">  &#125; </span><br><span class="line">  accumulate_block&lt;Iterator,T&gt;()(block_start,last,results[num_threads<span class="number">-1</span>]); <span class="comment">// 计算最后一小段</span></span><br><span class="line">  <span class="built_in">std</span>::for_each(threads.<span class="built_in">begin</span>(),threads.<span class="built_in">end</span>(),<span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join)); <span class="comment">// 逐一join</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(results.<span class="built_in">begin</span>(),results.<span class="built_in">end</span>(),init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="识别线程"><a href="#识别线程" class="headerlink" title="识别线程"></a>识别线程</h1><p>&nbsp;<br>在上个实例中我们使用了循环中设定的变量i作为标识来识别对应的线程。除这种方法以外，C++标准库为每一个线程附加了唯一标识符，其类型为<code>std::thread::id</code>。</p>
<h2 id="获取标识符"><a href="#获取标识符" class="headerlink" title="获取标识符"></a>获取标识符</h2><p>获取线程标识符有两种方法：</p>
<ol>
<li>调用<code>std::thread</code>对象的<code>get_id()</code>成员函数。如果当前对象没有绑定任何执行线程，则返回<code>std::thread::type</code>默认构造值。</li>
<li>在当前运行线程中使用全局函数<code>std::this_thread::get_id()</code>。</li>
</ol>
<h2 id="标识符性质"><a href="#标识符性质" class="headerlink" title="标识符性质"></a>标识符性质</h2><p><code>std::thread::id</code>可以执行拷贝与对比操作，如果两个对象<code>std::thread::id</code>相等，那它们为同一线程，或者均未绑定任何执行线程。如果不等，则可认为二者绑定的执行线程不同，亦或一个拥有执行线程而另一个没有。</p>
<p>由于<code>std::thread::id</code>可以比对，那么程序开发者可以将其作为有序关联容器的键值，又或者以此作为<code>std::thread</code>对象的排序基准。另外，C++标准库定义了关于<code>std::thread::id</code>的hash函数，因此<code>std::thread::id</code>也可以用于无序关联容器。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在实际使用环境下，通常通过<code>std::thread::id</code>识别线程,令它们执行不同操作。举例而言，在并行算法中主线程的任务可能与其他线程不同，为了实现这一需求，我们可以在启动其他线程前存储主线程id，在程序实际运行过程中根据id来分配具体工作任务：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread::id master_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">std</span>::this_thread::get_id()==master_thread) &#123;  </span><br><span class="line">    do_master_thread_work(); </span><br><span class="line">  &#125; </span><br><span class="line">  do_common_work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程间共享数据——保护共享数据的替代设施</title>
    <url>/2019/04/17/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%AE%BE%E6%96%BD/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>保护共享数据并非只有互斥量一种机制(尽管它是最通用的)，有很多替代方案可以在特定情况下提供比互斥量更合适的保护。<br><a id="more"></a></p>
<hr>
<h1 id="保护共享数据的初始化过程"><a href="#保护共享数据的初始化过程" class="headerlink" title="保护共享数据的初始化过程"></a>保护共享数据的初始化过程</h1><p>&nbsp;<br>一个极端却很常见的使用场景：共享数据仅在初始化过程中需要得到保护，之后便不再需要显式同步。</p>
<p>造成这种场景的原因很多，如数据一旦创建完成后即具备只读属性(因此不再存在同步问题)，又或者共享数据的日常操作过程已经隐式地包含了保护(因此在初始化完毕后不再需要显式保护)。</p>
<p>不管如何，出于保护共享数据初始化过程的目的，而在数据初始化完毕后锁住互斥量是一种不必要且影响性能的操作。因此，C++标准库提供了一种专门用于保护共享数据初始化过程的机制。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设当前存在一个构造代价十分昂贵的共享数据(该对象需要配置大量内存或者打开数据库连接)。在单线程环境中，<code>lazy initialization</code>是一种常规操作：任何需要该数据的操作都必须首先判断该源是否已经初始化完毕，若未完毕则执行初始化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr) &#123; </span><br><span class="line">    resource_ptr.reset(<span class="keyword">new</span> some_resource); <span class="comment">// 在并发环境下需要被保护</span></span><br><span class="line">  &#125; </span><br><span class="line">  resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h2><p>如果共享数据本身在并发环境下具备安全性，那么在将该函数转为多线程代码时需要保护的仅有初始化部分，那么某些开发人员可能会将其改为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr; </span><br><span class="line"><span class="built_in">std</span>::mutex resource_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>; <span class="comment">// 时间点1</span></span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr) &#123; </span><br><span class="line">    resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">  &#125; </span><br><span class="line">  lk.unlock(); </span><br><span class="line">  resource_ptr-&gt;do_something(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序显然造成了性能损耗：大多数线程被迫停在时间点1处排队，即使线程已经完成了初始化(即根本无需进入if语句)。</p>
<h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h2><p>部分开发者不满于解决方案1的低效，于是写出了声名狼藉的双重检查锁模式(<code>double-checked locking pattern</code>）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr) &#123; <span class="comment">// 时间点1</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>; <span class="comment">// 时间点2</span></span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr) &#123; </span><br><span class="line">      resource_ptr.reset(<span class="keyword">new</span> some_resource); <span class="comment">// 时间点3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在双重检查锁模式下，仅仅在资源指针为nullptr时才执行上锁操作，并在上锁后再次检查当前指针(以防止存在另一个线程在时间点1与时间点2之间完成了初始化操作）。</p>
<p>之所以说该模式声名狼藉，是因为它依旧存在触发条件竞争的风险。未被锁保护的读取操作(时间点1)并没有与数据写入操作(时间点3)同步，这将导致条件竞争，并且该条件竞争不仅涉及指针，还涉及指针指向的对象。即使某个线程明确了解当前指针正在被另一个线程执行写入操作，它也不一定明确了解刚刚创建的some_resource实例，从而造成<code>do_something()</code>在一个不正确的数据上执行操作。（我理解即对数据的初始化行为尚未完成，但锁外的进程已经检测到指针非空，从而执行<code>do_something()</code>）。C++ 标准将这种情形定义为将造成未定义行为的数据竞争。</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>C++标准委员会提供了<code>std::once_flag</code>与<code>std::call_once</code>来处理这种情况。比起锁住互斥量后显式地检查指针，线程只需要调用<code>std::call_once</code>即可安全可靠地了解到资源是否已被初始化。所有必需的同步数据均被存储于<code>std::once_flag</code>内，,每一个<code>std::once_flag</code>实例均与一个初始化相关联。<code>std::call_once</code>的使用成本要小于互斥量(尤其是在初始化操作已经完成后)，因此我们应当在条件适宜的情况下优先使用前者。下述代码将展示如何用<code>std::call_once</code>实现<code>lazy initialization</code>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="built_in">std</span>::once_flag resource_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_resource</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  resource_ptr.reset(<span class="keyword">new</span> some_resource); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::call_once(resource_flag,init_resource);</span><br><span class="line">  resource_ptr-&gt;do_something(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>std::call_once</code>既可以接受一个函数也可以接受一个可调用对象，此外，<code>std::call_once</code>也可用于类内成员的<code>lazy initialization</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  connection_info connection_details; </span><br><span class="line">  connection_handle connection; </span><br><span class="line">  <span class="built_in">std</span>::once_flag connection_init_flag; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open_connection</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    connection=connection_manager.<span class="built_in">open</span>(connection_details); </span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(connection_info <span class="keyword">const</span>&amp; connection_details_):</span><br><span class="line">    connection_details(connection_details_) &#123;&#125; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="keyword">const</span>&amp; data)</span> </span>&#123;   </span><br><span class="line">    <span class="built_in">std</span>::call_once(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);    </span><br><span class="line">    connection.send_data(data); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::call_once(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>); </span><br><span class="line">    <span class="keyword">return</span> connection.receive_data(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，仅有第一次在调用<code>send_data</code>或<code>receive_data</code>时才会执行初始化操作。此外还有老生常谈的一点：<code>std::once</code>调用成员函数时需要传入<code>this</code>指针，就像<code>std::thread</code>的构造函数或<code>std::bind</code>一样。</p>
<p>与<code>std::mutex</code>不同，<code>std::once_flag</code>是一个<code>move only object</code>，因此持有它的类需要保证unCopyable。</p>
<h2 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h2><p>除去<code>lazy initialization</code>以外，类内含有static成员时也将引发条件竞争。众所周知，static成员在声明后即完成初始化操作，在并发编程环境下这意味着条件竞争——存在多个线程抢着定义该变量。在一些旧版本编译器（不支持C++11）中这种条件竞争确实存在，不过C++11标准一劳永逸地解决了这个难题：初始化操作永远只在一个线程内完成，在初始化结束之前不会有任何线程能够继续执行。在需要单个全局实例的应用场景中，static对象可以作为<code>std::call_once</code>的一种替代：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_class</span>;</span> <span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> my_class instance;</span><br><span class="line">  <span class="keyword">return</span> instance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="保护很少更新的数据结构"><a href="#保护很少更新的数据结构" class="headerlink" title="保护很少更新的数据结构"></a>保护很少更新的数据结构</h1><p>&nbsp;<br>仅在初始化期间需要保护的数据结构只是一个特例，本节将重点讨论如何保护很少更新的数据结构。</p>
<p>假设存在这样一个应用场景：为了将域名解析为ip地址，我们在缓存中存放了一张DNS入口表。显然DNS入口表很少会发生变动，但它存在更新的可能性(当用户访问一个新网站时)。因此，我们需要在该数据结构更新时执行保护，以确保所有线程均可读取正确数据。</p>
<p>如果我们没有为此情况设计特殊的数据结构，那么势必需要执行更新的线程独占数据结构读取权限，直到更新操作完成，在此情况下使用互斥量无疑造成了性能上的浪费。我们需要的是一种新的名为“读写锁”(<code>read-write mutex</code>)的互斥量，该互斥量允许两种不同的操作：<code>writer</code>具备对数据的并发读写权限，而<code>reader</code>仅有对数据的读取权限。</p>
<p>C++ 17 标准库提供了两个现成的互斥锁<code>std::shared_mutex</code>和<code>std::shared_timed_mutex</code>（二者的区别将会在后文中体现）。C++14 只提供了 <code>std::shared_timed_mutex</code>，虽然 C++11这两种互斥锁都未提供，但开发者可以从Boost中获取<code>boost::shared_mutex</code>。</p>
<p>在此类使用环境下，以<code>std::lock_guard&lt;std::shared_mutex&gt;</code>和<code>std::unique_lock&lt;std::shared_mutex&gt;</code>完成上锁操作，即可保证仅有当前线程可对数据执行修改，而其他线程可通过<code>std::shared_lock&lt;std::shared_mutex&gt;</code>获得读取访问权。这个 RAII 类模板是在 C++14 中添加的，使用方法与<code>std::unique_lock</code>相同，只是多个线程可以在同一个<code>std::shared_mutex</code>上同时拥有一个共享锁。</p>
<p>下述程序展示了如何使用<code>std::shared_mutex</code>完成DNS入口表：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_cache</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,dns_entry&gt; entries;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex entry_mutex; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; domain)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,dns_entry&gt;::const_iterator <span class="keyword">const</span> it = entries.<span class="built_in">find</span>(domain);</span><br><span class="line">    <span class="keyword">return</span> (it == entries.<span class="built_in">end</span>()) ? dns_entry() : it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_or_add_entry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; domain,dns_entry <span class="keyword">const</span>&amp; dns_details)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;</span><br><span class="line">    entries[domain] = dns_details;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>find_entry()</code>使用<code>std::shared_lock&lt;&gt;</code>来保证了多线同时调用<code>find_entry()</code>的正确性。而<code>update_or_add_entry()</code>使用了<code>std::lock_guard&lt;&gt;</code>，在其调用过程中，不仅其他线程被阻止进行更新，而且调用 <code>find_entry()</code>的线程也会被阻塞。</p>
<hr>
<h1 id="嵌套锁"><a href="#嵌套锁" class="headerlink" title="嵌套锁"></a>嵌套锁</h1><p>&nbsp;<br>在一般情况下，<code>mutex</code>被锁住后仍对其反复执行上锁操作将产生未定义行为，但某些情况我们不得不这么做，于是标准库提供了<code>std::recursive_mutex</code>。它的行为与<code>std::mutex</code>非常类似，需要注意的是调用3次<code>lock</code>后必然需要调用3次<code>unlock</code>，当然，合理地使用<code>std::lock_guard&lt;std::recursive_mutex&gt;</code> 和 <code>std::unique_lock&lt;std::recursive_mutex&gt;</code>可以规避许多此类烦恼。</p>
<p>嵌套锁的使用并不常见，如果你觉得当前存在使用的必要，那么很有可能表明你的数据结构需要重新设计。嵌套锁一般应用于某种并发数据结构内，由于每个成员函数在执行前都执行了上锁操作，并且成员函数内调用了另一个成员函数，此时不得不进行多次上锁，使用<code>std::recursive_mutex</code>能够保证此类程序成功运行。当然这种做法非常草率，常规写法是将被调用成员函数设为私有，并在其内部不执行上锁操作(但需要检查是否已经上锁)，然后仔细斟酌该函数被调用时的上下文以及可能的数据状态。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程间共享数据——使用互斥量保护共享数据</title>
    <url>/2019/04/16/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在C++并发编程中，保护共享数据最简单的方法是使用互斥量。</p>
<p>在访问共享数据前，开发者可使用互斥量将相关数据锁住，并于访问结束后将数据解锁。因此，线程库需要保证当一个线程使用特定互斥量锁住共享数据时，其他线程仅可在数据被解锁后才能访问。</p>
<p>互斥量是C++中最通用的一种数据保护机制，但它并非“银弹”，在使用互斥量时，需要精心组织代码来保护正确的数据，并在接口内部避免竞争条件。此外，互斥量自身存在一定的问题，它可能会导致死锁，又或者将某些数据保护地太多或者太少。下文将针对上述情况逐一作出分析。</p>
<a id="more"></a>
<hr>
<h1 id="在C-中使用互斥量"><a href="#在C-中使用互斥量" class="headerlink" title="在C++中使用互斥量"></a>在C++中使用互斥量</h1><p>&nbsp;<br>C++中通过实例化<code>mutex</code>创建互斥量，并由其成员函数<code>lock</code>与<code>unlock</code>完成上锁与解锁操作。但在实际使用环境下并不推荐直接使用<code>mutex</code>成员函数，原因在于一旦调用<code>lock</code>,开发者必须保证在所有函数函数出口（包括异常）中调用<code>unlock</code>。</p>
<p>C++标准库为互斥量提供了一个具备RAII的模板类<code>std::lock_guard</code> ,该类对象总会在构造时提供已锁的互斥量，并在对象析构后完成解锁。<code>mutex</code>与<code>std::lock_guard</code>均被声明于头文件<code>mutex</code>头文件内。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>下述实例将表明如何在C++中使用互斥量对一个<code>list</code>内的数据提供访问保护。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; some_list; </span><br><span class="line"><span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  some_list.push_back(new_value); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_contains</span><span class="params">(<span class="keyword">int</span> value_to_find)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">find</span>(some_list.<span class="built_in">begin</span>(),some_list.<span class="built_in">end</span>(),value_to_find) != some_list.<span class="built_in">end</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述使用过程中，<code>some_list</code>是一个全局变量，它被一个全局互斥量<code>some_mutex</code>所保护。虽然某些情况下使用全局变量没问题，但在大多数应用场景中，互斥量通常会与保护的数据位于同一个类内，而非像上文一样作为全局变量。显然，这是面向对象设计准则：将互斥量作为<code>data member</code>置于类中。类似地，函数<code>add_to_list</code>和<code>list_contains</code>应当作为成员函数。需要注意的是，互斥量与要保护的数据在类中需要被定义为private成员，所有成员函数均需在调用时对数据上锁，结束时对数据解锁，如此则可保证数据不被破坏（这里说的并不完全正确，如果成员函数均内置有上锁操作，则内部调用时需要嵌套锁机制）。</p>
<p>当然，现实情况并非总是如此理想，应该意识到，如果一个成员函数返回的是保护数据的指针或引用，那么就一定存在数据破坏的可能性，原因在于使用者可以通过引用或指针直接访问数据，从而绕开互斥量的保护。因此，如果一个类使用互斥量来保护自身数据成员，其开发者必须谨小慎微地设计接口，确保互斥量能锁住任何对数据的访问，并且不留后门。</p>
<hr>
<h2 id="精心组织代码以保护共享数据"><a href="#精心组织代码以保护共享数据" class="headerlink" title="精心组织代码以保护共享数据"></a>精心组织代码以保护共享数据</h2><p>正如上文所述，使用互斥量来保护数据时并非只是在每一个成员函数中都加入一个<code>std::lock_guard</code>对象那么简单，任何一个传递至外界的指针或引用都将令这种保护形同虚设。某些开发者认为规避这项风险非常容易：仅仅需要在设计过程中检查接口是否返回指向内部数据的handle即可，但事实绝非如此。在确保成员函数不会传出指针或引用的同时，检查成员函数是否通过指针或引用的方式来调用也非常重要(尤其是该操作不在你的控制下时)。成员函数可能在没有互斥量保护的区域内存储着指针或引用，这是一种非常危险的行为，更危险地是：将保护数据作为一个运行时参数。下述实例展示了这一点。</p>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_wrapper</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_data data; </span><br><span class="line">  <span class="built_in">std</span>::mutex m; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">(Function func)</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>; </span><br><span class="line">    func(data);<span class="comment">// 将保护数据以参数形式传递给用户函数</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data* unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span> </span>&#123; </span><br><span class="line">  unprotected=&amp;protected_data; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.process_data(malicious_function); <span class="comment">// 传递一个恶意函数</span></span><br><span class="line">  unprotected-&gt;do_something(); <span class="comment">// 在无保护的情况下访问保护数据 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>看起来<code>process_data</code>没有任何问题，但调用用户自定义的<code>func</code>则意味着<code>foo</code>可以绕过保护机制将函数<code>malicious_function</code>传入，在没有互斥量锁定的情况下调用<code>do_something</code>。</p>
<p>从review结果来看，开发者只是单纯地将所有可访问的数据结构代码标记为互斥而已,但在<code>foo()</code>中调用 <code>unprotected-&gt;do_something()</code>的代码未能被标记为互斥。C++标准库并不能针对这种行为做出保护，因此必须谨记：切勿将受保护数据的指针或引用传递到互斥锁作用域之外。</p>
<hr>
<h2 id="发现接口内在的条件竞争"><a href="#发现接口内在的条件竞争" class="headerlink" title="发现接口内在的条件竞争"></a>发现接口内在的条件竞争</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设当前存在一个<code>stack class</code>,除去构造函数与swap外，其大致有5个接口：</p>
<ol>
<li>push()</li>
<li>pop()</li>
<li>top()</li>
<li>empty()</li>
<li>size()</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; &gt; </span><br><span class="line">class <span class="built_in">stack</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">stack</span>(<span class="keyword">const</span> Container&amp;); </span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(Container&amp;&amp; = Container())</span></span>; </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">explicit</span> <span class="title">stack</span>(<span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">stack</span>(<span class="title">const</span> <span class="title">Container</span>&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">stack</span>(<span class="title">Container</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">stack</span>(<span class="title">stack</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">  <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp;)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">stack</span>&amp;&amp;)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>出于性能的要求，我们一般会将<code>top()</code>返回一个引用而非拷贝，显然这与上文所要求的不符。但需要注意的是即使修改了<code>top()</code>，使其返回一个拷贝，该接口依然存在条件竞争。更进一步地说，该问题与使用互斥量并无关联，在无锁编程实现的接口中条件竞争也依然存在。总之，这是接口本身所具备的性质，与实现方式无关。</p>
<h3 id="条件竞争实例"><a href="#条件竞争实例" class="headerlink" title="条件竞争实例"></a>条件竞争实例</h3><p>虽然<code>empty()</code>与<code>size()</code>在被调用并返回时是正确的，但其结果并不可靠：当它们返回后，其他线程则可自由地访问栈，并且push()多个新元素至栈中；当然，也可能pop()一些已在栈中的元素。在这种情况下，<code>empty()</code>与<code>size()</code>返回值可认为是无效的。</p>
<p>更进一步地，当工作环境为单线程时，使用<code>empty()</code>判空后再调用<code>top()</code>是一种安全行为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; </span><br><span class="line"><span class="keyword">if</span> (!s.empty()) &#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> value = s.top();</span><br><span class="line">  s.pop(); </span><br><span class="line">  do_something(value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但在并发编程中上述代码将不再安全，因为在调用<code>empty()</code>和调用<code>top()</code>之间，可能有来自另一个线程的<code>pop()</code>调用，并且该调用可能删除了最后一个元素。这是一个经典的条件竞争问题，使用互斥量对栈内部数据进行保护并不能阻止条件竞争的发生，即接口固有问题。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>由于问题来源于接口设计，因此解决问题势必需要更改接口。有人提出这样一个方案：在调用<code>top()</code>时检查当前容器是否为空，若是则抛出异常。但该解决方案非常拙劣，也就是说，即使<code>empty()</code>返回了false，我们仍然需要异常捕获机制，本质上这令<code>empty()</code>成为了一个多余接口。</p>
<p>另一个潜在的条件竞争发生于<code>top()</code>与<code>pop()</code>之间。假设存在两个线程运行着上述程序，并且他们分享着同样的栈实例，若初始条件下栈内仅存在两个元素，由于stack对象含有互斥量，因此成员函数只能够交错运行，但<code>do_something</code>作为非成员函数可以并发运行。针对上述假设，可能存在某种执行顺序如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Thread A</th>
<th style="text-align:center">Thread B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">if (!s.empty())</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">if (!s.empty())</td>
</tr>
<tr>
<td style="text-align:center">int const value = s.top();</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">int const value = s.top();</td>
</tr>
<tr>
<td style="text-align:center">s.pop()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">do_something(value);</td>
<td style="text-align:center">s.pop()</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">do_something(value);</td>
</tr>
</tbody>
</table>
</div>
<p>我们的本意是线程A与线程B分别调用了<code>top()</code>与<code>pop()</code>，从而获取到了栈内的第一个与第二个元素，但在这种执行顺序下，线程A与线程B获取的均为同一个值，而另一个值被直接丢弃了。相对于未定义行为，这种条件竞争更加难以定位和排查。</p>
<p>可能有读者因为长期使用C++，因此在阅读上文的过程中一头雾水，并未了解这种接口设计有何不合理之处。一言以蔽之：在另一些语言中，<code>pop()</code>接口将直接移除顶端对象并返回其拷贝，这种接口设计将保证上述条件竞争不再发生（由于操作均集中在成员函数内部没有被分割，而成员函数本身是交错运行的）。具体来说，为了获取被移除的顶部元素，C++开发者必须写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = s.top();</span><br><span class="line">s.pop();</span><br></pre></td></tr></table></figure><br>而不能够像java开发者一样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; temp = s.pop();</span><br></pre></td></tr></table></figure></p>
<h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>部分读者可能会好奇为何C++标准库会存在这种设定，现有说明如下。</p>
<p>假设当前存在一个 <code>stack&lt;vector&lt;int&gt;&gt;</code> 。众所周知，vector是一个动态容器，其拷贝操作会令标准库在堆分配较多的内存（其大小等同于vector内所有元素的大小之和）。若当前系统处于重度负荷状态，或存在严重的资源限制，该内存分配行为将会失败，vector的拷贝构造函数将会抛出一个 <code>std::bad_alloc</code>异常。</p>
<p>试请读者回想一下，如果stack的<code>pop()</code>存在返回值，将导致一个潜在问题：由于仅在栈对象发生改变后（移除了顶层元素）拷贝值才会被传递至调用函数，但如果拷贝操作抛出了一个异常怎么办？显然，需要被弹出的数据将会丢失，但栈内元素却已经被移除。<code>std::stack</code>的设计人员为了规避上述可能，将其接口设置为<code>void pop()</code>。这种接口设计固然杜绝了上述问题，但却在并发编程环境下引入了条件竞争。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="传入引用"><a href="#传入引用" class="headerlink" title="传入引用"></a>传入引用</h4><p>一种实现思路是将元素的引用作为参数传入<code>pop()</code>以获取对应数据：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; &gt; </span><br><span class="line">class <span class="built_in">stack</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// member function declaration</span></span><br><span class="line">  <span class="keyword">void</span> pop(T&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result; </span><br><span class="line">some_stack.pop(result);</span><br></pre></td></tr></table></figure><br>该方案可以用于多数应用场景，但缺点也十分明显：需要构造出一个栈中类型的实例，用于接收目标值（即上述实例中的result）。构造实例主要存在三种问题：</p>
<ol>
<li>对于某些类型而言，这种做法不切实际，因为临时构造一个实例从时间和资源的角度来看都不划算。</li>
<li>部分类型不支持默认构造函数，而构造它所需要的参数此时是未知或者不确定的。</li>
<li>这种操作需要类型具备可赋值属性（<code>operator=</code>），而很多用户自定义类型可能并不支持赋值操作。</li>
</ol>
<h4 id="无异常抛出的拷贝构造函数或移动构造函数"><a href="#无异常抛出的拷贝构造函数或移动构造函数" class="headerlink" title="无异常抛出的拷贝构造函数或移动构造函数"></a>无异常抛出的拷贝构造函数或移动构造函数</h4><p>在设计之初之所以将<code>pop()</code>返回值设定为void，是因为返回一个具体的值存在异常安全问题。那么追本溯源之后，读者自然会想到设计某种不会抛出异常的拷贝或移动构造函数。</p>
<p>这种做法虽然安全，但决不能称之为可靠。尽管C++标准库能够令开发者在编译时使用<code>std::is_nothrow_copy_constructible</code>和<code>std::is_nothrow_move_constructible</code>类型特征来判断拷贝/移动构造函数是否抛出异常，但这种方式的局限性太强。大量的用户自定义类型的拷贝/移动构造函数不具备nothrow属性，将它们隔离于线程安全的stack之外似乎不太友好。</p>
<h4 id="返回指向弹出值的指针"><a href="#返回指向弹出值的指针" class="headerlink" title="返回指向弹出值的指针"></a>返回指向弹出值的指针</h4><p>第三种方案是返回一个指向弹出元素的指针，而不是直接返回值。指针的优势在于它可以自由拷贝，并且不会产生异常。但缺点在于指针也需要占据一定的内存空间，对于简单数据类型(比如int)，这种开销要远大于直接返回值。<br>在该解决方案下，推荐使用<code>std::shared_ptr</code>作为函数返回值。智能指针不仅能避免内存泄露，并且其内存分配全部由标准库完成，即不需要手动地new与delete(使用<code>make_shared</code>)。</p>
<h4 id="“方案1-方案2”或-“方案1-方案3”"><a href="#“方案1-方案2”或-“方案1-方案3”" class="headerlink" title="“方案1 + 方案2”或 “方案1 + 方案3”"></a>“方案1 + 方案2”或 “方案1 + 方案3”</h4><p>通用的代码不应当忽视灵活性，当你已经选择了方案2或3后，在此基础上增加方案1也并不困难。我们可以在确保安全的提前下提供足够多的选择给用户，让他们自己选择当前使用环境下最合适，最经济的方案。</p>
<h3 id="解决实例"><a href="#解决实例" class="headerlink" title="解决实例"></a>解决实例</h3><p>下述实例组合了方案1与方案3，并在其中封装了<code>std::stack</code>，其代码概述如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> <span class="built_in">std</span>::exception &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"empty stack!"</span>;</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data; </span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_stack() : data(<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt;())&#123;&#125;</span><br><span class="line">  threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other) &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">    data = other.data; <span class="comment">// 调用stack::operator=</span></span><br><span class="line">  &#125;</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    data.push(new_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data.top()))</span></span>;</span><br><span class="line">    data.pop(); </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">    value=data.top(); </span><br><span class="line">    data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>; </span><br><span class="line">    <span class="keyword">return</span> data.empty(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>&nbsp;</p>
<p>首先以一个最基本的例子来抽象什么是死锁：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">面试ing....</span><br><span class="line">面试官："如果你能够讲清楚什么是死锁，我就给你发offer。"</span><br><span class="line">候选人："如果你能够给我发offer，我就告诉你什么是死锁。"</span><br></pre></td></tr></table></figure><br>死锁是这样一种场景：存在一对线程，他们都需要执行一些操作，这些操作以锁住自己的互斥量作为开头，并且需要对方释放其持有的互斥量，在这种场景下没有线程能够正常工作，因为它们都在等待对方释放互斥量。当存在两个以上的互斥量锁定同一个操作时，死锁很容易发生。</p>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>一般来说，让两个互斥量总是以同样的顺序上锁即可避免死锁，如总是在锁住互斥量A之前锁住互斥量B。但是在某些应用场景下事情没这么简单，比如说多个互斥量保护同一个类的独立实例时。考虑如下场景：某类存在一个对象间数据交换操作（类似于<code>swap</code>），为了确保正确地交换数据而不受并发环境影响，我们需要锁定两个实例的互斥锁。由于<code>swap</code>需要接受两个参数（两个实例），假设第一个参数先加锁，第二个后加锁，当<code>swap()</code>两个操作对象实际为同一实例时将导致死锁。</p>
<p>幸运地是，C++标准库提供了同时锁住多个互斥量且没有死锁风险的操作：<code>std::lock</code>。下文将展示如何将<code>std::lock</code>应用于<code>swap</code>函数中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  <span class="built_in">std</span>::mutex m; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(some_big_object <span class="keyword">const</span>&amp; sd):some_detail(sd)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs) <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">std</span>::lock(lhs.m,rhs.m); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,<span class="built_in">std</span>::adopt_lock)</span></span>;        </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,<span class="built_in">std</span>::adopt_lock)</span></span>; </span><br><span class="line">    swap(lhs.some_detail,rhs.some_detail); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>首先执行的是判同操作，原因在于接下来的代码块试图加锁lhs与rhs内的mutex，如果lhs与rhs等价，那么反复加锁将导致未定义行为。(C++允许在一个线程内反复对mutex执行加锁操作，<code>std::recursive_mutex</code>提供了这样的功能)。然后调用<code>std::lock</code>锁住两个互斥量，并创建2个<code>std::lock_guard</code>对象用于管理锁。值得注意的是<code>std::lock_guard</code>对象在创建过程中使用了额外参数<code>std::adopt_lock</code>，该参数提醒<code>std::lock_guard</code>对象其所管理的<code>mutex</code>对象已经上锁，它需要做的是管理锁的拥有权而非是在构造函数中再次执行<code>lock</code>操作。</p>
<p>需要注意的是，当使用<code>std::lock</code>去加锁<code>lhs.m</code>或<code>rhs.m</code>时可能会抛出异常，并且该异常会传播到<code>std::lock</code>之外。当<code>std::lock</code>获取第一个<code>mutex</code>上的锁，并在试图获取第二个<code>mutex</code>上的锁失败抛出异常后，第一个锁也会随之解除。总而言之，<code>std::lock</code>要么都锁上，要么都不锁，即坚持所谓的“all or nothing”语义。</p>
<p>尽管<code>std::lock</code>可以保证在需要锁住多个互斥量的情况下不会出现死锁，但<code>std::lock</code>并不支持获取其中某一个锁。避免死锁是一种非常依赖开发者经验的高难度动作，不过话虽如此，也存在一些简单的规则能帮助你写出“无死锁”的代码。</p>
<h2 id="进一步地避免死锁"><a href="#进一步地避免死锁" class="headerlink" title="进一步地避免死锁"></a>进一步地避免死锁</h2><p>死锁这个名字总让人觉得仅有上锁操作才能触发死锁，但实际情况并非如此。举例而言，在无锁编程环境下，我们仅仅需要两个线程就能触发死锁：在它们的执行函数中调用对另一个线程的<code>join</code>即可。在这种情况下，两个线程均不能正常工作，因为他们都在等待对方结束(而这是不可能的)。此外，死锁并不一定仅仅发生于两个线程之间，而是多个线程。</p>
<p>以下将简单地给出一些如何鉴别与消除死锁的指导意见。</p>
<h3 id="避免一个线程持有多个锁"><a href="#避免一个线程持有多个锁" class="headerlink" title="避免一个线程持有多个锁"></a>避免一个线程持有多个锁</h3><p>尽可能令一个线程仅仅持有一个锁，如此则可避免由于锁的不正当使用造成的死锁问题。当然了，正如前文所说，死锁并不仅仅产生于锁的使用错误，线程相互等待也会造成死锁，不过总的来看，大部分死锁都源于互斥锁。如果你坚持在一个线程中持有多个锁，记得使用<code>std::lock</code>。</p>
<h3 id="避免在持有锁时调用用户自定义程序"><a href="#避免在持有锁时调用用户自定义程序" class="headerlink" title="避免在持有锁时调用用户自定义程序"></a>避免在持有锁时调用用户自定义程序</h3><p>用户自定义程序对于开发者而言是未知的，我们并不确定它们可能执行何种操作。它们有可能会去获取一个锁，如果当前线程已经持有了一个锁，那么再调用用户自定义程序将违反原则1：避免持有多个锁。但有时调用用户自定义程序在所难免，比如我们正在撰写一个类似于前文stack的泛型库，所有操作几乎均依赖于用户传入的数据类型(它们可能是用户自定义的)，在此情况下，我们需要参照新的指导原则。</p>
<h3 id="以固有顺序获取锁"><a href="#以固有顺序获取锁" class="headerlink" title="以固有顺序获取锁"></a>以固有顺序获取锁</h3><p>如果硬性条件约束我们不得不获取多个锁并且不可使用<code>std::lock</code>，那么指导意见是在每一个线程中均保证以同样的顺序获取这些锁。某些情况下这很容易做到，但在另外一些环境中却很难实现。总之，我们可以建立某种约定，一个线程必须在锁住A后才能获取B的锁，锁住B后才能获取C的锁，即以禁止反向遍历为代价消除死锁产生的可能性，类似的约束通常也被用于建立数据结构。</p>
<h3 id="使用层次锁"><a href="#使用层次锁" class="headerlink" title="使用层次锁"></a>使用层次锁</h3><p>层次锁是上一个指导意见的特例，用于检查运行期约定是否被遵守。该指导意见要求开发者将应用程序层次化，并能够识别给定层上所有可被上锁的互斥量。当代码试图执行上锁操作时，它会检查当前是否已持有来自低层次的锁，若有则禁止上锁当前互斥量。你可以在运行期检查这一约束条件，通过对每一个互斥量分配层级编号并记录所有被线程上锁的互斥量的方式。遗憾的是C++标准库并没有提供相关机制，因此我们不得不自己实现一个<code>hierarchical_mutex</code>,先不考虑其具体定义，它的使用机制应该与下文类似：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low_level_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> do_low_level_stuff(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="keyword">int</span> some_param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>;</span><br><span class="line">  high_level_stuff(low_level_func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  high_level_func(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  high_level_func();</span><br><span class="line">  do_other_stuff(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span>;</span><br><span class="line">  other_stuff(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们简单地分析一下<code>thread_a</code>与<code>thread_b</code>的运行情况。简单地来说，<code>thread_a</code>遵守了层级规则，而<code>thread_b</code>没有。我们可以注意到，<code>thread_a</code>调用了<code>high_level_func</code>，因此高层级互斥量<code>high_level_mutex</code>被上锁，随后又试图去调用<code>low_level_func</code>，此时低层级互斥量<code>low_level_mutex</code>被上锁，这与上文提及的规则一致：先锁高层级再锁低层级。<code>thread_b</code>的运行则没有这么乐观，它先锁住了层级为100的<code>other_mutex</code>，并在之后试图去锁住高层级的<code>high_level_mutex</code>，此时会发生错误，可能会抛出一个异常，又或者直接终止程序。</p>
<p>显然，使用层次锁时不可能由于错误的上锁顺序而产生死锁，因为互斥量必然以一定顺序逐一上锁。这也意味着你不可能在同一层级上同时持有多个锁，层次锁要求所有互斥量都处于一条链上，并且每个互斥量的层级值都必须低于它的前一个。</p>
<p><code>hierarchical_mutex</code>可以作为模板参数传入<code>std::lock_guard</code>，因此它必须实现三个接口：<code>lock</code>、<code>unlock</code>、<code>try_lock</code>，其大致实现如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hierarchical_mutex</span> &#123;</span> </span><br><span class="line">  <span class="built_in">std</span>::mutex internal_mutex;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hierarchy_value; </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> previous_hierarchy_value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(“mutex hierarchy violated”); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    previous_hierarchy_value=this_thread_hierarchy_value;</span><br><span class="line">    this_thread_hierarchy_value=hierarchy_value; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span>:</span></span><br><span class="line">    hierarchy_value(value), previous_hierarchy_value(0) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    internal_mutex.lock();</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    this_thread_hierarchy_value=previous_hierarchy_value;</span><br><span class="line">    internal_mutex.unlock(); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation(); </span><br><span class="line">    <span class="keyword">if</span>(!internal_mutex.try_lock()) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    update_hierarchy_value(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure><br>需要注意的是，<code>hierarchical_mutex</code>使用了一个static data member<code>this_thread_hierarchy_value</code>来表征当前线程层级值，它被初始化为最大值，因此在初始阶段任何互斥量均可被锁住。由于其具备<code>thread local</code>属性，因此每个线程都有其拷贝副本，各线程中变量状态完全独立。每次完成<code>lock</code>或<code>unlock</code>都将更新当前线程层级值。</p>
<hr>
<h1 id="更加灵活的std-unique-lock"><a href="#更加灵活的std-unique-lock" class="headerlink" title="更加灵活的std::unique_lock"></a>更加灵活的std::unique_lock</h1><p>&nbsp;<br>相较于<code>std::lock_guard</code>，<code>std::unqiue_lock</code>并不与互斥量的数据类型直接相关，因此使用起来更加灵活。它在构造时可以传入额外的参数，如<code>std::adopt_lock</code>与<code>std::defer_lock</code>，前者用于管理互斥量，后者则用于表明当前互斥量应当保持解锁状态。如此一来，可以通过<code>std::unique_lock</code>的成员函数<code>lock()</code>执行上锁操作，又或者将<code>std::unique_lock</code>对象传入<code>std::lock</code>完成上锁。</p>
<p><code>std::unqiue_lock</code>的时空间性能均劣于<code>std::lock_guard</code>，这也是它为灵活性付出的代价：<code>std::unqiue_lock</code>内存在某种标志用于表征其实例是否拥有特定的互斥量，显然，这些标志需要占据空间，并且标志的检查与更新也需要耗费时间。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>以下将简单地描述如何用<code>std::unique_lock</code>替换<code>std::lock_guard</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail; </span><br><span class="line">  <span class="built_in">std</span>::mutex m; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(some_big_object <span class="keyword">const</span>&amp; sd):some_detail(sd)&#123;&#125; </span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123; </span><br><span class="line">  	<span class="keyword">if</span>(&amp;lhs==&amp;rhs) <span class="keyword">return</span>; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,<span class="built_in">std</span>::defer_lock)</span></span>;   </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,<span class="built_in">std</span>::defer_lock)</span></span>; </span><br><span class="line">    <span class="built_in">std</span>::lock(lock_a,lock_b); </span><br><span class="line">    swap(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="互斥量所有权的传递"><a href="#互斥量所有权的传递" class="headerlink" title="互斥量所有权的传递"></a>互斥量所有权的传递</h2><p>由于<code>std::unique_lock</code>并没有与自身相关的互斥量，因此互斥量所有权可以在不同实例间相互传递，<code>std::unique_lock</code>是一个标准的`move only object”。</p>
<p>互斥量所有权传递十分常见，比如在某个函数内完成对互斥量的上锁，并在其后将其所有权转交至调用者以保证它可以在该锁的保护范围内执行额外操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">get_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  prepare_data();</span><br><span class="line">  <span class="keyword">return</span> lk;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">  do_something(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::unique_lock</code>的成员函数<code>lock</code>支持在其实例销毁之前放弃其拥有的锁。当锁没有必要长期持有时就应当主动释放，这对提升应用程序的性能十分有利。</p>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>锁的粒度是一个摆手术语(hand-waving term)，用来描述一个锁保护着的数据量大小。一个细粒度锁(a fine-grained lock)能够保护较小的数据量，一个粗粒度锁(a coarse-grained lock)能够保护较多的数据量。简而言之，我们应当针对待保护数据量的大小选择合适的粒度，太大则过犹不及，太小则不足以保护。</p>
<p>假设当前存在这样一个场景：很多线程正在等待同一个资源，若某个线程持有锁的时间过长（不必要地占用着资源），这将导致程序整体时间性能下降。在理想情况下，我们仅仅会在访问某个共享数据时才会上锁，任何非共享数据的处理操作都应当在锁外执行。我们万不可在持有锁时执行一些特别费时的操作，比如文件的输入/输出。文件的IO操作往往要比内存读写慢上百倍，因此，除非当前存在用锁去保护文件访问的必要，我们绝不应当在持有锁时执行文件IO，这将造成其他线程不必要地阻塞，最终导致多线程带来的性能优势被这种拙劣的操作抵消殆尽。</p>
<p>这种情况下<code>std::unique_lock</code>将运行地非常完美，当需要处理锁外数据时，它将调用成员函数<code>unlock</code>以解除锁定，并在需要访问共享数据时调用<code>lock</code>再次上锁：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">my_lock</span><span class="params">(the_mutex)</span></span>; </span><br><span class="line">  some_class data_to_process=get_next_data_chunk(); </span><br><span class="line">  my_lock.unlock(); <span class="comment">// 处理前解锁</span></span><br><span class="line">  result_type result=<span class="built_in">process</span>(data_to_process);</span><br><span class="line">  my_lock.lock(); <span class="comment">// 写入前加锁</span></span><br><span class="line">  write_result(data_to_process,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>正如上述实例所示，粒度并不仅仅表示锁保护的数据量，也表示控制锁的时间。通常情况下，持有锁的时间应当等价于执行操作所需的最短时间。因此除非必须执行，我们不应该在持有锁时执行耗时操作(比如获取另一个锁(即使你明确了解该操作不会造成死锁)或等待IO操作完成)。</p>
<p>在前文中我们曾经叙述过在并发编程下完成两个数据结构的交换操作，现在让我们试想下面这个场景：存在一个简单的数据结构Y，其内部数据仅仅含有一个int，现在需要完成两个Y实例之间的判同操作。由于复制一个int并不耗时，因此我们可以在持有锁的情况下完成拷贝操作，并返回两个被拷贝的int等价与否，这意味着我们不再需要同时持有两个锁，并且按照要求实现了仅仅在需要的时间段上锁：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> some_detail; </span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m; </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_detail</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(m)</span></span>; </span><br><span class="line">    <span class="keyword">return</span> some_detail; </span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Y(<span class="keyword">int</span> sd):some_detail(sd)&#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Y <span class="keyword">const</span>&amp; lhs, Y <span class="keyword">const</span>&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> lhs_value=lhs.get_detail();<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> rhs_value=rhs.get_detail();<span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> lhs_value==rhs_value;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>需要注意的是，如果该结果返回了true，我们仅仅只能够保证在时间点1上的lhs.some_detail与时间点2上的rhs.some_detail相同，这两个值在被读取后可能会被任意的方式所修改。因为我们持有锁的时间并没有达到整个操作所需要的时间，因此该判同语义未必符合预期。</p>
<p>在某些情况下并不存在一个合适的粒度大小，因为并非所有对数据结构的访问都需要相同的保护级别。因此，你可能需要另一种机制来替换<code>std::mutex</code>。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>36.考虑virtual以外的选择</title>
    <url>/2018/04/18/%E8%80%83%E8%99%91virtual%E4%BB%A5%E5%A4%96%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>（本节虽然带有面向对象标签，但描述的是如何跳出面向对象的思维看待问题）</p>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假定我们在编写一款游戏，其中的角色带有一个血条(int)，不同的人计算血量的方式不同，所以把该函数声明为virtual似乎很合适：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该函数并未定义为pure virtual，这说明我们有一个缺省方法。<br>让我们现在跳出面向对象设计的常规轨道，考虑一些其他的实现可能。</p>
<hr>
<h1 id="Template-Method-模式（Non-virtual-Interface"><a href="#Template-Method-模式（Non-virtual-Interface" class="headerlink" title="Template Method 模式（Non-virtual Interface)"></a>Template Method 模式（Non-virtual Interface)</h1><p><strong>有一些人主张virtual函数必须全是private</strong>。以实际问题举例，上个例子保留healthvalue为public non-virtual成员函数，并调用一个private virtual函数来进行实际操作。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        ...<span class="comment">//事前处理</span></span><br><span class="line">        <span class="keyword">int</span> retVal = getHealthValue();</span><br><span class="line">        ...<span class="comment">//事后处理</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getHealth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这一基本设计被称为non-virtual interface（NVI）手法。它是所<strong>谓template method设计模式（与c++的templates无关）的独特表现形式</strong>。我们习惯于把non-virtual函数称为virtual函数的外覆器（wrapper）。</p>
<h2 id="NVI的优点"><a href="#NVI的优点" class="headerlink" title="NVI的优点"></a>NVI的优点</h2><p>NVI手法的一大优点在于<strong>wrapper确保了virtual函数在调用前的场景已被设计好，并且调用结束后场景得到了清理。</strong>（实例中的注释处）举例而言，这些工作可能包括：锁定互斥器、记录日志、验证约束条件、互斥器解锁等等。如果你让客户直接调用virtual，那么可能没办法做好这些事。<br>在这里需要注意的是：NVI手法涉及在dc内重新定义了private virtual函数。<strong>重定义virtual函数表示“某事应当被如何完成”，外覆器的non-virtual属性则表示“某事应当何时完成”（函数何时被调用），这二者并不冲突。</strong></p>
<h2 id="NVI的不足"><a href="#NVI的不足" class="headerlink" title="NVI的不足"></a>NVI的不足</h2><p>在NVI手法下不一定virtual一定得是private，它们也可以是portected.(详见Effective C++ 28 Windows实例）有时候virtual甚至必须是public（具有多态性质的bc的析构函数），这么一来就不能实施NVI手法了。</p>
<hr>
<h1 id="Strategy模式（Function-Pointers"><a href="#Strategy模式（Function-Pointers" class="headerlink" title="Strategy模式（Function Pointers)"></a>Strategy模式（Function Pointers)</h1><p>&nbsp;<br>NVI手法本质上还是在用virtual函数，只是调用时颇为巧妙而已。针对游戏实例，另有一些人主张“人物血条的计算与人物类型无关”，这种计算不需要“人物”成分。<br>例如我们可能会要求<strong>每一个人物构造函数接受一个指针指向血条计算函数</strong>，我们调用该函数进行实际操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharcter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span></span>;<span class="comment">//默认计算函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    explicit GameCharcter(HealthCalc hc = defaultHealthCalc)：HealthFunc(hc) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalc healthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Strategy的优点"><a href="#Strategy的优点" class="headerlink" title="Strategy的优点"></a>Strategy的优点</h2><p>上述做法是strategy设计模式的一个简单应用，和普通的virtual函数相比，其优点如下：</p>
<ul>
<li>同一人物类型的不同实体可以有不同的计算函数（构造时绑定不同的函数指针）。</li>
<li>血条计算函数可以在人物的不同时期发生变更（比如设置个setHealthcalc函数接受一个函数指针并且替换私有成员）。</li>
</ul>
<h2 id="Strategy的缺点"><a href="#Strategy的缺点" class="headerlink" title="Strategy的缺点"></a>Strategy的缺点</h2><p>在Strategy模式下，血条计算函数已经不再是gamecharacter继承体系内的成员函数，也就是说，它将无法访问对象的non-public部分。<br>解决方法只有弱化class的封装：</p>
<ul>
<li>将函数声明为friends</li>
<li>为其需要的数据提供一个public访问接口</li>
</ul>
<p>至于strategy模式的优点（每个对象拥有各自的函数以及动态更改的能力）能否抵消缺点（降低class的封装程度），必须根据设计情况的不同进行抉择。</p>
<hr>
<h1 id="Strategy模式（Function"><a href="#Strategy模式（Function" class="headerlink" title="Strategy模式（Function)"></a>Strategy模式（Function)</h1><p>&nbsp;<br>为什么血条计算必须得是一个函数呢？它完全可以是一个类似函数的对象。如果我们使用function对象，很多刚才提及的约束一下子就消失了。funcion对象持有一切可调用物（函数指针、函数对象、成员函数指针),因此刚才的设计可以改为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharcter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span></span>;<span class="comment">//默认计算函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line">    function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; healthCalcFunc;</span><br><span class="line">    explicit GameCharcter(healthCalcFunc hcf = defaultHealthCalc)：HealthFunc(hcf) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHealthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    healthCalcFunc healthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>和前一个相比，这个设计几乎完全一样，唯一的不同之处是如今class持有的是一个function对象，相当于一个指向函数的泛化指针。然而这个改变为客户带来了更加惊人的弹性（原书中使用了bind增加了形参）也就是说，如今的设计允许客户在计算人物健康指数时使用任何兼容的可调用物。</p>
<hr>
<p>传统Strategy模式<br>&nbsp;<br><strong>传统Strategy模式更倾向于将当前virtual函数做成一个分离的继承体系中的virtual成员函数</strong>，其设计结果大概像这样：<br><img src="http://static.zybuluo.com/zsmj2017/96205qmwt5vn3xjwgmttayaq/image_1cbc0cklns971g0h14mt1fed1h3s9.png" alt="image_1cbc0cklns971g0h14mt1fed1h3s9.png-24.5kB"><br>其核心在于GameCharacter与HealthcalcFunc成为了base class，并且Gamecharacter中含有一个指针，指向HealthcalcFunc继承体系中的对象。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>&#123;...&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">                    :<span class="title">pHealthC</span><span class="params">(phcf)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc0&gt;calc(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>当你为解决当前问题而寻找设计方法时，不妨考虑virtual的以下几个替代方案：</p>
<ul>
<li>NVI手法，template method设计模式的特殊形式。<br>它以public non-virtual成员函数包裹较低访问性（private、protected）的virtual函数。</li>
<li>将virtual函数替换为函数指针</li>
<li>将函数指针变成function对象，以上两种都是strategy的某种表现形式。</li>
<li>将继承体系内的virtual换成另一个继承体系内的virtual，这是strategy设计模式的传统实现。</li>
</ul>
<p>面向对象固然博大精深，但这个世界上还有许多条路值得我们去探索。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>23.考虑用有序vector代替关联容器</title>
    <url>/2018/04/13/%E8%80%83%E8%99%91%E7%94%A8%E6%9C%89%E5%BA%8Fvector%E4%BB%A3%E6%9B%BF%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>（我认为本节内容强调的是底层数据结构的选择）</p>
<h1 id="各容器的查找速度"><a href="#各容器的查找速度" class="headerlink" title="各容器的查找速度"></a>各容器的查找速度</h1><p>&nbsp;<br>理论上，散列容器可以提供常数时间的查找。如果你仅仅需要对数时间的查找，和直觉相悖的是，有序vector性能可能会优于关联容器。</p>
<hr>
<h1 id="有序vector的优越性"><a href="#有序vector的优越性" class="headerlink" title="有序vector的优越性"></a>有序vector的优越性</h1><h2 id="为何有序vector在性能上优于关联容器"><a href="#为何有序vector在性能上优于关联容器" class="headerlink" title="为何有序vector在性能上优于关联容器"></a>为何有序vector在性能上优于关联容器</h2><p>关联容器的底层数据结构是平衡搜索二叉树，其设计是综合了插入，删除，查找下的最优，但我们在实际应用中<strong>这三种操作并非像在测试条件那样随机执行</strong>。一般而言，都是某一段时间都在插入，另一段时间都是在查找等等…在这种情况下，<strong>有序</strong>vector可能会比关联容器在时间和空间上性能更好。</p>
<h2 id="具体优越点"><a href="#具体优越点" class="headerlink" title="具体优越点"></a>具体优越点</h2><ol>
<li>空间问题</li>
<li>引用局部性问题</li>
</ol>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><h3 id="空间优越性"><a href="#空间优越性" class="headerlink" title="空间优越性"></a>空间优越性</h3><p>假设关联容器元素类型为Widget，在底层数据结构平衡二叉树中不仅仅存着一个Widget，更是存着左子、右子、父节点这三个指针。<br>vector不需要存储指针，并且可以通过swap技术可以消除多余的内存需求。空间占用比关联容器少了许多。</p>
<h3 id="引用局部性问题"><a href="#引用局部性问题" class="headerlink" title="引用局部性问题"></a>引用局部性问题</h3><p>假设我们有足够多数据结构，那么它们在存储时会分成多个内存页面，vector所占用的页面显然要少于关联容器（空间优越性），但这并不是最关键的。如果STL没有改进关联容器的引用局部性，二叉树节点会分散在各个页面，直接导致了更多的缺页中断。vector则不会如此，因为其内存连续，二分查找时不会发生太多的页面错误。</p>
<h2 id="vector的缺陷"><a href="#vector的缺陷" class="headerlink" title="vector的缺陷"></a>vector的缺陷</h2><p>上述所说的查找高效性仅限于vector处于有序状态。此外，对于动态操作，是vector的花销惊人（可能还伴随着扩容），所以<strong>只有当查找操作几乎不与插入删除混用时，使用有序vector代替关联容器才有意义。</strong></p>
<hr>
<h1 id="有序vector与关联容器的替换"><a href="#有序vector与关联容器的替换" class="headerlink" title="有序vector与关联容器的替换"></a>有序vector与关联容器的替换</h1><h2 id="替换set"><a href="#替换set" class="headerlink" title="替换set"></a>替换set</h2><p>用vector替换set十分自然，仅有在针对mutiset时记住排序应该使用stable_sort.关于具体的查找算法选择，详见Effective STL 45；</p>
<h2 id="替换map"><a href="#替换map" class="headerlink" title="替换map"></a>替换map</h2><h3 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h3><p>当我们试图用vector代替map或者mutimap时，需要注意的是，vector内部必须容纳pair对象。<br>当我们声明<code>map&lt;K,V&gt;</code>时，map内部其实存储的是<code>pair&lt;const K,V&gt;</code>,由于对vector排序时其值会通过赋值来移动，<strong>所以vector模拟map时内部只能是<code>pair&lt;K,V&gt;</code></strong>.</p>
<h3 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h3><p>map在排序时仅仅使用key来作为排序的依据，那么vector中的pair也一样。这导致我们必须自定义一个pair的比较函数，因为默认版本根据pair的两个组件来排序。（我还没排序过pair)</p>
<h3 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h3><p>用来排序的比较函数将作用于两个pair对象，但是查找只用到了key值，所以必须给用于查找的比较函数一个key类型的对象和一个pair，关键在于我们并不了解到底是<code>key</code>还是<code>pair</code>作为第一个实参传递，<strong>所以需要用两个用于查找的比较函数：一个key值先传递，另一个pair先传递。</strong></p>
<h3 id="比较类型实例"><a href="#比较类型实例" class="headerlink" title="比较类型实例"></a>比较类型实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Data; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataCompare</span> &#123;</span><span class="comment">// 用于比较的类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Data&amp; lhs,<span class="keyword">const</span> Data&amp; rhs)</span> <span class="keyword">const</span></span>&#123;<span class="comment">//用于排序的比较函数</span></span><br><span class="line">        <span class="keyword">return</span> keyLess(lhs.first, rhs.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下为基于查找的比较函数，因为无法确定是输入次序，因此构成重载</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Data&amp; Ihs, <span class="keyword">const</span> Data::first_type&amp; k)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyLess(lhs.first, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Data::first_type&amp; k,<span class="keyword">const</span> Data&amp; rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyLess(k, rhs.first);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//真正调用的比较函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">keyLess</span><span class="params">(<span class="keyword">const</span> Data::first_type&amp; k1,<span class="keyword">const</span> Data::first_type&amp; k2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k1 &lt; k2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>只要数据结构的使用过程确实符合本章所述，并且没有误用比较函数设计，有序vector的效率几乎绝对优于关联容器。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
        <tag>关联容器</tag>
      </tags>
  </entry>
  <entry>
    <title>类型推衍</title>
    <url>/2018/06/19/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%A1%8D%E7%AB%A0%E8%8A%82%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<h1 id="章节前言"><a href="#章节前言" class="headerlink" title="章节前言"></a>章节前言</h1><p>&nbsp;<br>C++98对于类型推衍有单独的一套规则，它们被应用于函数模板的使用过程中。C++11在此基础之上做了些许修改并增加了2条额外推衍规则，即<code>auto</code>与<code>decltype</code>。随后的C++14则扩展了<code>auto</code>与<code>decltype</code>的使用范围。类型推衍使开发者们得以免于反复输入那些直观明了的类型名称，并且大大增加了C++程序的可修改性，因为在存在类型推衍的情况下，一旦源码中某个变量的类型被更改，其他位置与其相关的类型也会自发进行更改。但是类型推衍并非完美无缺，它的存在使得代码更加难以理解，原因在于编译器所作出的类型推衍可能并非像你想象的那样显然。</p>
<p>如果你不能清楚认知类型推衍规则，这一悲惨的事实将导致你无法高效使用Modern C++。以上并非危言耸听，类型推衍在很多地方发挥着作用，例如函数模板、<code>auto</code>、<code>decltype</code>表达式，以及C++14中所出现的<code>decltype(auto) construct</code>。</p>
<p>本章将对C++开发者所必须了解的类型推衍规则作出介绍，其主要内容为：</p>
<ol>
<li>模板类型推衍的工作机制</li>
<li>auto的工作机制</li>
<li>decltype的工作机制</li>
</ol>
<p>在此基础之上，本章还将介绍如何令编译器将其类型推衍结果可视化，从而保证你可以放心大胆地认为它按照你的要求完成了类型推衍。</p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型推衍</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 自定义allocator的合理用法</title>
    <url>/2018/04/09/%E8%87%AA%E5%AE%9A%E4%B9%89allocator%E7%9A%84%E5%90%88%E7%90%86%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>（本节内容并未完全掌握，建议学习STL源码剖析相关章节后再次复习本章）</p>
<h1 id="何时需要自定义allocator？"><a href="#何时需要自定义allocator？" class="headerlink" title="何时需要自定义allocator？"></a>何时需要自定义allocator？</h1><p>&nbsp;<br>如果你对STL中默认的allocator感到不满，因为： </p>
<ol>
<li>你发现它太慢、浪费内存或造成过度的碎片</li>
<li>本次编写的程序无需考虑多线程，没必要支付同步开销</li>
<li>某些容器里的对象通常一同被使用，所以需要在一个特别的堆里把它们放得很近，使引用的区域性最大化</li>
<li>需要建立一个相当于共享内存的唯一的堆，然后把一个或多个容器放在那块内存里，使其他进程得以共享</li>
</ol>
<p>那你需要一种自定义allocator的方案（包括但不限定于上述几种情况）。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><h2 id="建立一个相当于共享内存的堆"><a href="#建立一个相当于共享内存的堆" class="headerlink" title="建立一个相当于共享内存的堆"></a>建立一个相当于共享内存的堆</h2><p>假定我们有一些特殊过程，采用malloc与free内存模型来管理一个位于共享内存的堆，并且需要把STL容器的内容放置于共享内存：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mallocShared</span><span class="params">(<span class="keyword">size_t</span> bytesNeeded)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeShared</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedMemoryAllocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type numObiects, <span class="keyword">const</span> <span class="keyword">void</span> *localityHint = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;pointer&gt;(mallocShared(numObiects * <span class="keyword">sizeof</span>(T)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer ptrToMemory, size_ type numObjects)</span></span>&#123;</span><br><span class="line">        freeShared(ptrToMiemory);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>SharedMemoryAllocator的使用方式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>, SharedMemoryAllocator&lt;<span class="keyword">double</span>&gt; &gt; SharedDoubleVec;</span><br><span class="line">...</span><br><span class="line">&#123; <span class="comment">// 开始某一个块</span></span><br><span class="line">    SharedDoubleVec v; <span class="comment">//v在共享内存中</span></span><br><span class="line">... <span class="comment">// 结束这个块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但值得注意的是：v使用了自定义allocator作为分配器，因此所分配的容纳元素的内存必然来自共享内存<strong>。但是v自己，包括其所有数据成员，必然不会出现在共享内存中，它们存在于栈内。</strong><br>为了把v的内容与v自身一起放入共享内存，有操作如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *pVectorMemory =  mallocShared(<span class="keyword">sizeof</span>(SharedDoubleVec));<span class="comment">// 分配内存容纳SharedDoubleVec对象</span></span><br><span class="line">SharedDoubleVec *pv = <span class="keyword">new</span> (pVectorMemory) SharedDoubleVec;<span class="comment">//placement new 操作详见Effective C++ 52</span></span><br><span class="line">...<span class="comment">//使用pv</span></span><br><span class="line">pv-&gt;~SharedDoubleVec(); <span class="comment">//销毁共享内存中的容器</span></span><br><span class="line">freeShared(pVectorMemory); <span class="comment">// 销毁共享内存块</span></span><br></pre></td></tr></table></figure><br>总地来说，使用步骤依次为：<br>分配➡️构造➡️析构➡️释放</p>
<h2 id="聚合容器内的元素"><a href="#聚合容器内的元素" class="headerlink" title="聚合容器内的元素"></a>聚合容器内的元素</h2><p>假设我们有Heap1与Heap2两个堆，每个堆都有相应的静态成员函数来执行内存分配和释放操作：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">alloc</span><span class="params">(<span class="keyword">size_t</span> numBytes, <span class="keyword">const</span> <span class="keyword">void</span> *memoryBlockToBeNear)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealloc</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap2</span> &#123;</span> ... &#125;; <span class="comment">//接口与Heap1类似</span></span><br></pre></td></tr></table></figure><br>进一步地,我们想自定义容器元素容纳于哪一个堆。因此，我们必须设定一个分配器，使用像heap1，heap2那样真实管理内存的类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenameT, <span class="keyword">typename</span> Heap&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecificHeapAllocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type numObjects, <span class="keyword">const</span> <span class="keyword">void</span> *localityHint = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;pointer&gt;(Heap::alloc(numObjects * <span class="keyword">sizeof</span>(T),localityHint));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer ptrToMemory, size_type numObjects)</span></span>&#123;</span><br><span class="line">        Heap::dealloc(ptrToMemory);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>然后再使用allocator把容器的元素集合到一起：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, SpecificHeapAllocator&lt;<span class="keyword">int</span>,Heap1&gt; &gt; v;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, SpecificHeapAllocator&lt;<span class="keyword">int</span>,Heap1&gt; &gt; s;</span><br><span class="line"><span class="built_in">list</span>&lt;Widget,SpecificHeapAllocator&lt;Widget,Heap2&gt; &gt; L;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, less&lt;<span class="keyword">int</span>&gt;,SpecificHeapAllocator&lt;pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">string</span>&gt;,Heap2&gt; &gt; m;</span><br></pre></td></tr></table></figure><br>值得注意的是，<strong>Heap1和Heap2是类型而不是对象</strong>。如果Heap1和Heap2是对象而不是类型，那么它们将是不等价的分配器，那就违反了分配器的等价约束。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>42.考虑以emplacement代替insertion</title>
    <url>/2018/07/19/%E8%80%83%E8%99%91%E4%BB%A5emplacement%E4%BB%A3%E6%9B%BFinsertion/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>如果当前有一个容器，其内部元素类型为std::string，当我们通过插入函数(insert、push_front、push_back或者是std::forward_list的insert_after)传递一个std::string类型的元素到容器中时，理论上容器内部将会存在这个元素。之所以说是“理论上”，是因为可能未必如此，考虑下述代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vs; <span class="comment">// container of std::string</span></span><br><span class="line">vs.push_back(<span class="string">"xyzzy"</span>); <span class="comment">// add string literal</span></span><br></pre></td></tr></table></figure><br>显然，我们插入的并不是一个string而是一个字符串常量，也就是说我们并没有插入容器持有的元素类型。</p>
<hr>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>&nbsp;<br>std::vector对左值和右值均进行了重载，其形式大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>; <span class="comment">// insert lvalue</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>; <span class="comment">// insert rvalue</span></span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在调用语句<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vs.push_back(<span class="string">"xyzzy"</span>);</span><br></pre></td></tr></table></figure><br>编译器将发现实参类型（const char [6]）与push_back声明的形参类型（reference-to-std::string）并不匹配，因此它们通过从字符串常量创建临时std::string对象来解决不匹配问题，并将该临时对象传递给push_back。 因此，调用语句可看作为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vs.push_back(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"xyzzy"</span>)); <span class="comment">// create temp. std::string and pass it to push_back</span></span><br></pre></td></tr></table></figure><br>尽管这段程序能够被正确编译和运行，但实际上存在着效率问题。在vector中创建一个元素必然会调用一次构造函数，但上述程序调用了2次string构造函数，并且还调用了一次string析构函数：</p>
<ol>
<li>字符串常量创建了匿名string对象，此处发生了一次string构造，该匿名对象是一个右值。</li>
<li>该临时对象被传递给push_back后触发其右值重载版本，因此在vector内部移动构造了一个string对象，此处为第二次构造。</li>
<li>push_back完成后临时对象被析构，此时触发析构函数。</li>
</ol>
<hr>
<h1 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back"></a>emplace_back</h1><p>&nbsp;<br>通过上述分析可以得知，如果我们能够在vector内部直接利用参数构造对象，则无需付出临时对象的构造与析构成本。为了达到这目的，我们应当将push_back替换为emplace_back，后者的功能正是将利用传入参数直接在容器内部完成构造，根本不需要任何临时对象插手：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vs.emplace_back(<span class="string">"xyzzy"</span>); <span class="comment">// construct std::string inside vs directly from "xyzzy"</span></span><br></pre></td></tr></table></figure><br>emplace_back使用完美转发，因此只要不使用Item30所述的任何禁形，开发者可以通过emplace_back传递任何数量、任何类型的参数，例如我们可以这样撰写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vs.emplace_back(<span class="number">50</span>, <span class="string">'x'</span>); <span class="comment">// insert std::string consisting of 50 'x' characters</span></span><br></pre></td></tr></table></figure><br>所有支持push_back的标准库容器都支持emplace_back，同理，所有支持push_front的标准库容器都支持emplace_front，此外，所有支持insert的标准库容器（除了std::forward_list和std::array）都支持emplace。关联容器以emplace_hint以补足传统的insert函数，而std::forward_list使用emplace_after来弥补其insert_after。</p>
<p>emplace的优势在于相对于insert，它的接口更加灵活。insert需要插入对象，而emplace值需要构造函数的参数即可直接在容器内部完成构造，这一特性避免了临时对象的生成。如果传递的就是容器元素类型，此时insert和emplace均不会产生临时对象，因此可以认为二者等价。</p>
<hr>
<h1 id="emplace的使用"><a href="#emplace的使用" class="headerlink" title="emplace的使用"></a>emplace的使用</h1><p>&nbsp;<br>emplace似乎能够完成insert可以完成的一切任务，并且在某些场合具备更高的性能，那我们为什么不直接使用emplace取代insert呢？<br>唉，理想很丰满，现实很骨感。目前标准库的实现在某些方面与我们的设想不大一致，虽然大多数场景下emplace的确优于insert，但可悲的是，某些场景下insert要比emplace快。此类场景不太好判断，因为这取决于传递的参数类型、使用的容器、插入容器的位置、容器元素类型构造函数的异常安全性、容器是否允许插入重复的值、要插入的元素是否已经在容器中了等等。</p>
<hr>
<h2 id="emplace的使用条件"><a href="#emplace的使用条件" class="headerlink" title="emplace的使用条件"></a>emplace的使用条件</h2><p>上文描述的很是含混，想必很难让读者满意，因此我们最终还是给出一组判断依据：如果以下条件全部符合，则emplace必然比insert高效：</p>
<ol>
<li><p><strong>元素必须被构造于容器内部，而非采取赋值形式。</strong><br>现在我们简单地修改问题实例，令newString占据已存在元素的内存：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vs; <span class="comment">// as before</span></span><br><span class="line">… <span class="comment">// add elements to vs</span></span><br><span class="line">vs.emplace(vs.<span class="built_in">begin</span>(), <span class="string">"xyzzy"</span>); <span class="comment">// add "xyzzy" to beginning of vs</span></span><br></pre></td></tr></table></figure>
<p>很少有编译器会将上述代码实现为构造一个std::string对象然后放到vs[0]位置上，大多数编译器的实现是进行移动赋值，将传入的参数直接移动赋值到目标位置。但是移动赋值需要传入的是一个对象，这就需要构建一个临时对象，然后移动过去，等操作完成后再将该对象析构。显然这种做法并没有发挥emplace的优势，我们依旧需要生成一个临时对象。<br>当然少有代码能够明确判断出当前执行的是构造还是赋值，但依然存在一条通用准则以供参考。基于节点的容器往往倾向于采用构造方式，并且大多数标准库容器均基于节点（std::vector、std::deque、std::string并非基于节点）。对于非节点式容器而言，push_back几乎总是触发构造（当然，deque的push_front也总是构造）。</p>
</li>
<li><p><strong>传递的参数类型和容器中的类型不同</strong><br>emplace的优势便在于避免临时对象的构造和析构，如果传递的参数类型和容器中的类型相同，则不会产生临时对象，因此emplace也就毫无优势可言。</p>
</li>
<li><p><strong>容器并不因元素重复而拒绝接纳</strong><br>这意味着容器允许内部元素重复，或者我们添加的大部分元素都是唯一的。为了检测某值是否已经存在于容器内部，emplace通常会创建一个具有新值的节点，以便将此节点的值与现有容器节点进行比较。如果不存在重复则加入该节点，否则emplace将负责析构该节点。一旦节点被析构，这意味着之前的构造成本均付诸东流。emplace构造节点的频率要高于insert，因此在使用前最好判断一下该条件。</p>
</li>
</ol>
<hr>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>在上述条件之外还有两点需要考虑，其一在于资源管理。假设当前存在一个容器，其元素类型为std::shared_ptr&lt;Widget&gt;：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; &gt; ptrs;</span><br></pre></td></tr></table></figure><br>并且我们想添加一个具备自定义删除器的shared_ptr，由于此种情况无法通过make_shared获取shared_ptr(见Item27），因此必须使用new获取原始指针。<br>假定现有删除器如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">killWidget</span><span class="params">(Widget* pWidget)</span></span>;</span><br></pre></td></tr></table></figure><br>那么insert版本大致如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptrs.push_back(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget, killWidget));</span><br></pre></td></tr></table></figure><br>当然也可以写为如下形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptrs.push_back(&#123; <span class="keyword">new</span> Widget, killWidget &#125;);</span><br></pre></td></tr></table></figure><br>无论哪种方式，在调用push_back之前都会构造一个临时的std::shared_ptr，原因在于push_back的形参是一个reference-to-shared_ptr，因此必须存在一个shared_ptr才行。emplace可以规避临时对象的产生，但我们可能需要为此付出更大的代价。试考虑以下事件序列</p>
<ol>
<li>在上述的任一调用期间，编译器构造了一个临时的std::shared_ptr&lt;Widget&gt;对象以保存由“new Widget”产生的原始指针，将此对象称为temp。</li>
<li>push_back通过引用获取temp，在分配节点以保存临时副本期间，抛出了out-of-memory异常。</li>
<li>当异常传播出push_back时，temp被析构，作为当前唯一指向Widget的sptr，它将自动调用killWidget以释放Widget。</li>
</ol>
<p>可以看出，push_back版本具备一定的异常安全性，即使抛出异常也能够保证资源不被泄露。</p>
<p>假若当前以emplace替换insert版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptrs.emplace_back(<span class="keyword">new</span> Widget, killWidget);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>通过new Widget产生的裸指针，经过完美转发后进入push_back函数内部，然后容器开始分配内存用于构造新元素，在分配内存时抛出out-of-memory异常。</li>
<li>emplace_back发生异常后指向Widget的原始指针析构，但其所指向的内存还没有释放，已经无法获取Widget占用的内存，触发资源泄露事件。</li>
</ol>
<p>显然，使用emplace_back会导致程序可能产生内存泄漏，对于需要自定义删除器的unique_ptr亦同样存在这一问题，这也从侧面反映出std::make_shared和std::make_unique的重要性。</p>
<p>对于持有资源管理类的容器(例如std::list&lt;std::shared_ptr&lt;Widget&gt; &gt;)来说，insert确保在获取资源与资源管理类初始化之间不存在任何阻塞，而emplace的完美转发延迟了资源管理对象的创建（直到容器完成内存分配才执行构造），因此在异常触发时易于导致内存泄漏。所有标准库容器均存在此类问题，因此你必须在效率与异常安全性之间做出权衡。</p>
<p>在Item21中我们便已提及资源管理类初始化语句必须独立，我们不应当将new Widget这样的表达式作为参数传递给emplace_back、push_back，或是其他任何函数。正确的做法是完成资源管理对象构造后将其传递给emplace_back或push_back:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget,killWidget)</span></span>;  <span class="comment">// create Widget and have spw manage it</span></span><br><span class="line">ptrs.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(spw)); <span class="comment">// add sp</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, killWidget)</span></span>;</span><br><span class="line">ptrs.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(spw));</span><br></pre></td></tr></table></figure><br>上述两种方案均存在spw对象的构造和析构的开销，而我们使用emplace_back替换push_back的目的就是为了避免临时对象的构造和析构开销，而spw与临时对象等价。但使用emplace_back往容器中插入资源管理对象时，必须要以某种策略保证资获取与资源管理对象构造之间不被干涉，这也就是spw对象存在的意义。</p>
<hr>
<h3 id="emplace与explicit的交互"><a href="#emplace与explicit的交互" class="headerlink" title="emplace与explicit的交互"></a>emplace与explicit的交互</h3><p>第二个因素是和explicit构造函数交互相关。C++11引入了正则表达式，下述程序试图创建一组正则表达式对象并将其存放至容器内：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::regex&gt; regexes;</span><br></pre></td></tr></table></figure><br>出于疏忽，你不小心写下了如下看似毫无意义的程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">regexes.emplace_back(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><br>众所周知，正则表达式对象可由字符串(这里并非特指std::string)构造：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">upperCaseWord</span><span class="params">(<span class="string">"[A-Z]+"</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>从string创建std::regex需要较大的运行期成本，为了最大限度地降低开销，以const char *为形参的std::regex构造函数被声明为explicit，因此下述程序无法编译：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::regex r = <span class="literal">nullptr</span>; <span class="comment">// error! won't compile</span></span><br><span class="line">regexes.push_back(<span class="literal">nullptr</span>); <span class="comment">// error! won't compile</span></span><br></pre></td></tr></table></figure><br>上述两条语句均需要执行隐式转换，但explict拒绝了此类转换。</p>
<p>然而在对emplace_back的调用中，我们并未明确声明传入std::regex对象，而是正在为std::regex对象传递构造函数参数，这并不被视为隐式转换请求，反而被编译器视为等价于如下程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">r</span><span class="params">(<span class="literal">nullptr</span>)</span></span>; <span class="comment">// compiles</span></span><br></pre></td></tr></table></figure><br>编译通过并不是什么好事，原因在于以nullptr初始化的正则表达式对象行为未知，可能对开发者最好的结局就是运行期崩溃。</p>
<p>暂且抛开push_back与emplace_back,我们将注意力投向这些非常相似的初始化语法，它们将产生不同的结果：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::regex r1 = <span class="literal">nullptr</span>; <span class="comment">// error! won't compile</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">r2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>; <span class="comment">// compiles</span></span><br></pre></td></tr></table></figure><br>用于初始化r1（使用等号）的语法对应于所谓的拷贝初始化，用于初始化r2的语法（使用小括号，其实也可以使用大括号）产生所谓的直接初始化。拷贝初始化禁止使用显式构造函数，而直接初始化允许，这也就是二者一个可以编译一个不能编译的原因所在。</p>
<p>emplace使用直接初始化，而insert使用拷贝初始化，因此：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">regexes.emplace_back(<span class="literal">nullptr</span>); <span class="comment">// compiles. Direct init permits use of explicit std::regex ctor taking a pointer</span></span><br><span class="line">regexes.push_back(<span class="literal">nullptr</span>); <span class="comment">// error! copy init forbids use of that ctor</span></span><br></pre></td></tr></table></figure></p>
<p>综上所述，使用emplace时需要保证传递的实参正确，因为编译器为了找到某种方法将代码有效化会不惜使用显式构造函数。</p>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>23.考虑变更程序库</title>
    <url>/2018/04/27/%E8%80%83%E8%99%91%E5%8F%98%E6%9B%B4%E7%A8%8B%E5%BA%8F%E5%BA%93/</url>
    <content><![CDATA[<p>程序库的设计就是一个折衷的过程。理想的程序库应该是短小的、快速的、强大的、灵活的、可扩展的、直观的、普遍适用的、具有良好的支持、没有使用约束、没有错误的。当然，上述所描述的东西不存在。为尺寸和速度而进行优化的程序库一般不能被移植。具有大量功能的的程序库不会具有直观性。没有错误的程序库在使用范围上会有限制。没有十全十美。<br>不同的设计者给这些条件赋予了不同的优先级。他们从而在设计中牺牲了不同的东西。因此一般两个提供相同功能的程序库可能有着完全不同的性能特征。<br>因为不同的程序库在效率、可扩展性、移植性、类型安全和其他一些领域上蕴含着不同的设计理念，通过使用给予性能更多考虑的程序库，有时可以大幅度地提高软件的效率。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>26.自定义一个不抛异常的swap函数</title>
    <url>/2018/04/14/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>swap原先只是STL的一部分，而后成为异常安全性编程的脊柱，以及用来处理自赋值的常见机制。（详见Effective C++ 12）。swap实现的复杂程度极高，本节主要探讨其复杂程度以及应对策略。</p>
<hr>
<h1 id="swap的具体实现"><a href="#swap的具体实现" class="headerlink" title="swap的具体实现"></a>swap的具体实现</h1><h2 id="STL的swap实现"><a href="#STL的swap实现" class="headerlink" title="STL的swap实现"></a>STL的swap实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要类型T支持copying操作，该swap就一定能正常运行。<br>该行为必然是正确的，只是对于某些类型而言，其copying行为是不必要的，降低了程序运行的性能。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>对于”内部仅含指针，指针指向具体数据”的class而言，STL版本的swap函数过于低效。这种类型的常见表现形式是所谓的“pimpl”(pointer to implementation)(详见Effective C++ 32)。具体如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span><span class="comment">//具体实现类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;<span class="comment">//内部存有大量数据,复制占用时间极大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;<span class="comment">//复制具体实现（其实这里也可以直接复制指针，引用计数）</span></span><br><span class="line">        *pImpl=*(rhs.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然,如果我们需要swap两个widget对象，只需要交换两个指针值。如果使用STL::swap，它<strong>不仅复制3个widget，还复制了3个widgetImpl.</strong>何以说是三个？</p>
<ol>
<li>temp(a)<br>此时调用拷贝构造，复制了一个Widget,在复制Widget时，其拷贝构造必然构造了一个WidgetImpl</li>
<li>a=b<br>调用Widget::operator=,复制了一个WidgetImpl</li>
<li>b=temp<br>同上</li>
</ol>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>我们希望告诉std::swap,置换widget只需要置换内部指针。无疑我们需要将std::swap针对Widget特例化，以下是无法通过编译的基本构思：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>｛</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp;a,Widget&amp;b)&#123;</span><br><span class="line">        swap(a.Impl,b.Impl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在一般情况下不允许改变std命名空间的任何东西，但是这里只是添加了某个特例化版本，属于安全行为。（Effective STL 42 也这样做了）<br>之所以无法编译是因为我们试图去访问private成员。使用friend函数当然是可耻的：封装性被破坏。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>定义一个member function做真正的swap工作，然后再令STL的swap函数调用它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;<span class="comment">//必须声明</span></span><br><span class="line">        swap(pImpl.other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">namesapce <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)&#123;</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种写法不仅能够通过编译，并且还与stl容器兼容，因为stl容器也提供了public swap成员函数与std::swap特例化版本。</p>
<h2 id="template下的swap实现"><a href="#template下的swap实现" class="headerlink" title="template下的swap实现"></a>template下的swap实现</h2><h3 id="无法完成function-template偏特化"><a href="#无法完成function-template偏特化" class="headerlink" title="无法完成function template偏特化"></a>无法完成function template偏特化</h3><p>假定现在Widget与WidgetImpl都是template class：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>...&#125;;</span><br></pre></td></tr></table></figure><br>此时在Widget::swap照旧，但试图特化std::swap时却遇到了麻烦：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;<span class="comment">//无法编译</span></span><br><span class="line">    <span class="keyword">template</span>&lt;typenmae T&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)&#123;</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不能编译的理由是：<strong>我们企图偏特化（partially specialize)一个function template(std::swap),但C++只允许对class template执行偏特化</strong>。（所谓偏特化就是针对某个部分执行特例化，但特例化之后得到的却仍然是一个模板而非实例，在本例中，swap本身是一个function template，我们试图针对其参数为Widget&lt;T&gt;时特例化，但特例化得到的仍然是一个function template，而非像上文那样的实例函数。关于偏特化的介绍，详见C++ Primer P628）</p>
<h3 id="std命名空间禁止添加新的重载template"><a href="#std命名空间禁止添加新的重载template" class="headerlink" title="std命名空间禁止添加新的重载template"></a>std命名空间禁止添加新的重载template</h3><p>如果你需要偏特化一个template function，那么常规做法为其添加一个重载版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;<span class="comment">//这也是不合法的</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于std命名空间，客户可以全特化其中的template，但不允许添加任何新的template进入，上述代码属于新的swap。</p>
<h3 id="声明non-member-swap"><a href="#声明non-member-swap" class="headerlink" title="声明non-member swap"></a>声明non-member swap</h3><p>我们将定义一个non-member swap函数，由它调用member swap，但不再将non-member swap声明为std::swap的特例化，为了简化说明，我们将一切与Widget相关的机能都置入WidgetStuff命名空间：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;typenmae T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如此一来，根据C++的名称查找法则，每当试图swap Widgte对象时，都会第一时间找到我们所定义的non-member版本，这并非令客户失去了定制操作的能力。只要加上<code>using std::swap</code>,那么他们的swap又会回归STL版本，这也是我们的member swap使用using的原因。</p>
<hr>
<h1 id="swap与异常"><a href="#swap与异常" class="headerlink" title="swap与异常"></a>swap与异常</h1><p>&lt;/br&gt;<br><strong>member swap禁止抛出异常</strong>，但非成员版允许抛出异常，因为默认swap以copying函数为基础，而copying行为允许抛出异常。<br>自定义swap意味着高效交换，并且不抛出异常。这两个特性其实彼此相关：高效交换的基础是基于内置类型的操作，而内置类型的操作绝不会抛出异常。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>当std::swap对class效率不高时，提供一个swap成员函数并且确定其noexcept</li>
<li>如果你提供了member swap函数，也应该提供一个non-member来调用前者。对于classes（并非templates），也请特例化std::swap</li>
<li>调用swap时应该先声明使用的是哪个命名空间内的swap</li>
<li>std命名空间允许全特例化，但禁止在其内部加入一些对std而言全新的东西</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>51.自定义new与delete</title>
    <url>/2018/04/24/%E8%87%AA%E5%AE%9A%E4%B9%89new%E4%B8%8Edelete/</url>
    <content><![CDATA[<h1 id="为何需要自定义opertaor-new与operator-delete？"><a href="#为何需要自定义opertaor-new与operator-delete？" class="headerlink" title="为何需要自定义opertaor new与operator delete？"></a>为何需要自定义opertaor new与operator delete？</h1><p>&nbsp;<br>有三个理由:</p>
<ol>
<li>检测运用上的错误<br>如果new所得的内存delete失败，会导致内存泄漏。如果试图多次delete，则又会导致未定义行为。针对该误操作的解决方法是：令operator new持有一串动态分配所得地址，delete将地址从中移除。<br>各式各样的编程错误可能会导致数据overruns(写入点在分配区段尾部之后）或者underruns（起点之前）。其解决方法是：自定义operator new，分配超额内存，以额外空间放置特定的byte patterns（signature）operator delete执行时先检查这段签名是否原封不动，若否则表明出现了overrun或者underrun，log此事实以及这个指针。</li>
<li>强化效能<br>编译器所带的operator new与operator delete总是惯于采取通用解（不针对特殊情况使用最优解），如果你针对自己的程序作出特定优化（内存大小，分配形态，持续分配与归还），性能将会得到极大的提高。</li>
<li>统计使用数据<br>在自定义内存管理服务前我们当然需要采集目前程序对内存的使用情况，我们可以通过自定义operator new与operator delete来搜集内存使用信息。</li>
</ol>
<hr>
<h1 id="自定义operator-new实例"><a href="#自定义operator-new实例" class="headerlink" title="自定义operator new实例"></a>自定义operator new实例</h1><p>&nbsp;<br>以下是一个帮助检查overruns或underruns的operator new实例，其中存在着一些小错误：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> signature = <span class="number">0xDEADBEEF</span>;<span class="comment">//签名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Byte;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存在一些小错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(bad_alloc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span>::<span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">size_t</span> realSize = <span class="built_in">size</span>+<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//实际需要额外塞入两个signature</span></span><br><span class="line">    <span class="keyword">void</span>* pMem = <span class="built_in">malloc</span>(realSize);</span><br><span class="line">    <span class="keyword">if</span>(!pMem) <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">    *(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pMem) = signature;</span><br><span class="line">    *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="keyword">sizeof</span>(<span class="keyword">int</span>))) = signature;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem) +<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其缺点主要在于operator new应该内含某一个循环，反复调用某个new-handler函数。这个问题会在下一节具体说明，本节针对该实例讨论重点是齐位（alignment）。</p>
<hr>
<h1 id="齐位"><a href="#齐位" class="headerlink" title="齐位"></a>齐位</h1><p>&nbsp;<br>许多计算机体系结构会要求特定类型存放于特定的地址，比如指针的地址必须是4倍数或者double的地址必须是8倍数。有的体系不遵循该规则会导致硬件异常，有的体系则无此要求，只是如果遵循齐位则提供较佳焦虑。<br>在上一个实例中，malloc返回的指针必然是齐位的，但是自定义的operator new并没有返回得自malloc的指针，而是做了一些偏移，这可能会造成错误或效率低下。事实上，各个库的内存管理函数或者部分开源内存管理器均考虑了齐位特性。如果我们也有自定义内存管理的需求，记得考虑诸如可移植性，齐位，线程安全等等细节。</p>
<hr>
<h1 id="何时需要自定义opertaor-new与operator-delete"><a href="#何时需要自定义opertaor-new与operator-delete" class="headerlink" title="何时需要自定义opertaor new与operator delete"></a>何时需要自定义opertaor new与operator delete</h1><ul>
<li>需要检测运用错误（如前所述）</li>
<li>需要收集使用信息（如前所述）</li>
<li>需要增加分配与归还的速度<br>举例而言，如果在profile时发现线程安全性降低了运行速度，而我们的程序只在单线程下运行，则没必要使用线程安全的operator new。</li>
<li>需要降低默认内存管理器带来的空间额外开销</li>
<li>弥补默认分配器带来的非最佳齐位</li>
<li>需要将对象成簇集中<br>如果每个数据结构往往被一起使用，而你有希望使用它们时page faults的频率降至最低，那么为此创建一个heap就很有必要。new与delete的placement版本可以完成这样的行为。</li>
<li>需要获得非传统行为<br>例如分配和归还共享内存。</li>
</ul>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>5.自定义隐式转换函数</title>
    <url>/2018/04/24/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>除了c++提供的四种强制类型转换操作外，自定义类型在建立时我们可以提供某些函数以供编译器拿来作隐式转换。有两种函数允许编译器执行这样的转换：<strong>单自变量构造函数与隐式类型转换操作符。</strong></p>
<hr>
<h1 id="隐式类型转换函数"><a href="#隐式类型转换函数" class="headerlink" title="隐式类型转换函数"></a>隐式类型转换函数</h1><h2 id="单自变量构造函数"><a href="#单自变量构造函数" class="headerlink" title="单自变量构造函数"></a>单自变量构造函数</h2><p>所谓单自变量构造函数，指的是能够以单一自变量成功调用的构造函数。该构造函数分为两种情况：</p>
<ol>
<li>拥有单一形参</li>
<li>具备多个形参，但第一个形参之后的所有形参均具备默认值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Name(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>,<span class="keyword">int</span> denominator = <span class="number">1</span>); <span class="comment">// 有理数类</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="隐式类型转换操作符"><a href="#隐式类型转换操作符" class="headerlink" title="隐式类型转换操作符"></a>隐式类型转换操作符</h2><p>隐式类型转换操作，是一个拥有奇怪名字的成员函数：operator关键词之后加一个类型名称。我们无法指定其返回值类型，因为其返回类型就体现在名称上。举例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该函数会在以下情况被自动调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d=<span class="number">0.5</span>*r;<span class="comment">//转换r，从Rational至double</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="自定义类型转换函数的弊端"><a href="#自定义类型转换函数的弊端" class="headerlink" title="自定义类型转换函数的弊端"></a>自定义类型转换函数的弊端</h1><p>隐式转换可能会在你并未打算调用他们的时候被调用，从而产生不正确的后果，我们很难调试中发现这一问题。</p>
<h2 id="隐式类型转换操作符-1"><a href="#隐式类型转换操作符-1" class="headerlink" title="隐式类型转换操作符"></a>隐式类型转换操作符</h2><h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>假设存在一个如上所述的 Rational类，我们希望他能够像内置类型一样兼容opertaor&lt;&lt;。但由于我们的疏忽，忘记了为Ration对象定义opertaor&lt;&lt;，你会惊奇地发现，如下语句还是能够编译和运行：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r;<span class="comment">//本意是打印“1/2”，现在打印出了“0.5”</span></span><br></pre></td></tr></table></figure><br>这揭示了隐式转换符的缺点：<strong>它们可能会导致非预期的函数被调用</strong>。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方法很简单，以一个功能对等的函数取代它，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">asDouble</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在多数情况下，这种显式转换函数的使用不够方便，但是至少我们保证了一切按照预期运行，付出一些代价也是值得的。</p>
<hr>
<h2 id="单自变量构造函数-1"><a href="#单自变量构造函数-1" class="headerlink" title="单自变量构造函数"></a>单自变量构造函数</h2><p>通过单自变量constructors完成的隐式转换难于消除，且其破坏性也较大。</p>
<h3 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h3><p>现有一个针对数组结构写的class template。这些数组允许用户指定索引值的上界与下界：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> lowBound, <span class="keyword">int</span> highBound);</span><br><span class="line">    Array(<span class="keyword">int</span> <span class="built_in">size</span>);<span class="comment">//单自变量构造函数</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>以下代码试图比较Array&lt;int&gt;对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==( <span class="keyword">const</span> Array&lt;<span class="keyword">int</span>&gt;&amp; lhs,<span class="keyword">const</span> Array&lt;<span class="keyword">int</span>&gt;&amp; rhs);</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">if</span> (a == b[i]) &#123;<span class="comment">//误将a[i]写作a</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>编译器对此并不会报错，事实上，它调用构造函数，将b[i]转为了一个Array&lt;int&gt;对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">static_cast</span>&lt; Array&lt;<span class="keyword">int</span>&gt; &gt;(b[i]))</span><br></pre></td></tr></table></figure></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们不能禁止单参数构造函数，但同时我们也希望防止编译器不加鉴别地调用这个构造函数，因此我们可以使用explicit关键词。构造函数用 explicit 声明后，编译器会拒绝为了隐式类型转换而调用构造函数，同时显式类型转换依然合法。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>让编译器进行隐式类型转换所带来的弊端要大于它所带来的好处，因此除非确实需要，否则不要定义隐式类型转换函数。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类型转换</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>6.自增，自减操作符前置与后置的区别</title>
    <url>/2018/04/24/%E8%87%AA%E5%A2%9E%EF%BC%8C%E8%87%AA%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%89%8D%E7%BD%AE%E4%B8%8E%E5%90%8E%E7%BD%AE%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前置与后置操作符"><a href="#前置与后置操作符" class="headerlink" title="前置与后置操作符"></a>前置与后置操作符</h1><p>&nbsp;<br>重载函数间的区别在于它们参数类型上的差异，但是无论increment还是decrement的前缀与后缀都只有一个参数。为了解决问题，<strong>c++规定后缀形式有一个int类型参数，当函数被调用时编译器传递一个0作为int参数的值</strong>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPInt</span> &#123;</span> <span class="comment">//unlimited precision int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">const</span> UPInt <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>--();</span><br><span class="line">    <span class="keyword">const</span> UPInt <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">UPInt i;</span><br><span class="line">++i; <span class="comment">//i.operator++();</span></span><br><span class="line">i++; <span class="comment">//i.operator++(0);</span></span><br></pre></td></tr></table></figure><br><strong>仔细观察可以发现，前缀返回的是引用，后缀返回的则是一个const对象。</strong></p>
<hr>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>&nbsp;<br>以自增为例，前缀表达的意思是“增加然后取出”，后缀表达的意思是“取出然后增加”，以下是具体实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">    UPInt oldValue = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>&nbsp;<br>很明显一个后缀操作符必须返回一个对象，但是为什么必须是const对象呢？<br>假设返回值不是const 对象，下面的代码就是正确的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPInt i;</span><br><span class="line">i++++;<span class="comment">//i.operator++(0).operator++(0);</span></span><br></pre></td></tr></table></figure><br>我们拒绝表达式编译通过，理由有二：</p>
<ol>
<li>保证与内置类型具备行为一致</li>
<li>直觉上我们认为i++++应该自增2次，但实际上它只自增了一次，只有最后一个++生效</li>
</ol>
<p>如果后缀返回const对象，那么第二个++由于是non-const成员函数，将无法通过编译。</p>
<hr>
<h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><p>&nbsp;<br>由于后缀操作符需要返回对象的原因（不可避免的构造与析构），前缀比后缀的效率要高，在用户自定义类型上更是明显，因此我们在能用前缀的时候应该使用前缀。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>25.虚拟工厂模式</title>
    <url>/2018/04/28/%E8%99%9A%E6%8B%9F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>工厂模式在C++中体现为构造函数虚拟化，即针对不同的已知对象，调用不同的构造函数，生成不同的新对象。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设现有一个程序负责生成新闻报道，每篇报道由文字或者图片组成:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span> &#123;</span><span class="comment">//abstract class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>:</span><span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span>:</span> <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsLetter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;NLComponent*&gt; components;<span class="comment">//以链表存储数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>classes之间的关系如下：<br><img src="http://static.zybuluo.com/zsmj2017/njkzzlzp8y80mgfnt7edyaqg/image_1cc4spmjh1ivl249m7r1o1jo3319.png" alt="image_1cc4spmjh1ivl249m7r1o1jo3319.png-107.4kB"><br>我们给NewsLetter class添加一个以istream作为参数的构造函数，其伪代码大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsLetter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NewsLetter(istream&amp; str);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">NewsLetter::NewsLetter(istream&amp; str)&#123;</span><br><span class="line">    <span class="keyword">while</span> (str) &#123;</span><br><span class="line">        ...<span class="comment">//从 str 读取下一个component对象;</span></span><br><span class="line">        ...<span class="comment">//将component对象加入链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>又或者，我们为此建立一个独立函数readComponent：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsLetter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//为建立下一个 NLComponent 对象从 str 读取数据,</span></span><br><span class="line">    <span class="comment">//建立 component 并返回一个指针。</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NLComponent * <span class="title">readComponent</span><span class="params">(istream&amp; str)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">NewsLetter::NewsLetter(istream&amp; str)&#123;</span><br><span class="line">    <span class="keyword">while</span> (str) &#123;</span><br><span class="line">        components.push_back(readComponent(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，readComponent根据str建立了一个新对象，其类型是text或者graphic.它的行为类似于构造函数，但又能构建不同的对象，因此被称为虚构造函数。其特性在于，根据不同的输入构造出不同的对象。（虚拟工厂模式）</p>
<hr>
<h1 id="虚拷贝构造函数"><a href="#虚拷贝构造函数" class="headerlink" title="虚拷贝构造函数"></a>虚拷贝构造函数</h1><p>&nbsp;<br>虚拷贝构造函数返回一个指针，指向调用该函数的对象的新拷贝，一般命名该函数为copyself或者clone，其大致实现细节如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> NLComponent * <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>:</span> <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TextBlock * <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TextBlock(*<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span>:</span> <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Graphic * <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Graphic(*<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看出，虚拷贝构造完全调用了拷贝构造，因此具备其拥有的一切特性，诸如引用计数之类。<br>值得注意的是，虚拷贝构造的一大特点:<strong>派生类重定义的虚函数不必与基类对应函数具备一致的返回类型</strong>，这也就是我们上例中返回Text*的原因。</p>
<p>这种虚拷贝构造函数让对象的正常拷贝构造变得很容易:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsLetter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NewsLetter(<span class="keyword">const</span> NewsLetter&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;NLComponent*&gt; components;</span><br><span class="line">&#125;;</span><br><span class="line">NewsLetter::NewsLetter(<span class="keyword">const</span> NewsLetter&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it =rhs.components.<span class="built_in">begin</span>();it != rhs.components.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">        components.push_back((*it)-&gt;clone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虚拷贝构造函数的最大特性在于，无论对象的真正类型是什么，它都能轻易地完成拷贝。</p>
<hr>
<h1 id="非成员函数虚拟化"><a href="#非成员函数虚拟化" class="headerlink" title="非成员函数虚拟化"></a>非成员函数虚拟化</h1><p>&nbsp;<br>我们可能希望存在这么一个非成员函数，能够根据参数的不同类型而执行不同的行为。<br>以上文中的NewsLetter为例，我希望为text或graphic实现一个输出操作符，但operator&lt;&lt;默认把ostream&amp;作为它的lhs，那注定了它无法变成成员函数。<br>解决方案是建立一个虚成员函数print，在operator&lt;&lt;中调用print函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>:</span> <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span>:</span> <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; s, <span class="keyword">const</span> NLComponent&amp; c)&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，虚拟非成员函数的实现过程如下：</p>
<ol>
<li>完成一个虚成员函数</li>
<li>在非成员函数中调用虚成员函数</li>
<li>为了避免额外的调用开销，inline该虚非成员函数</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>以上均为以单一参数完成虚拟化的实例，根据多参数完成虚拟化详见More Effective C++ 31。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>2.视C++为语言联邦</title>
    <url>/2018/04/06/%E8%A7%86C++%E4%B8%BA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/</url>
    <content><![CDATA[<p>C++作为一个多重范型编程语言，应该将其视作一个语言联邦而非单一语言，其主要的sublanguage共有四个：</p>
<blockquote>
<ul>
<li>c</li>
<li>object-oriented c++</li>
<li>template c++</li>
<li>STL</li>
</ul>
</blockquote>
<p>四个次语言各有特性及约束，C++高效编程原则视情况而定，具体取决于我们当前使用的那一部分。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>27.要求或禁止在堆中产生对象</title>
    <url>/2018/04/28/%E8%A6%81%E6%B1%82%E6%88%96%E7%A6%81%E6%AD%A2%E5%9C%A8%E5%A0%86%E4%B8%AD%E4%BA%A7%E7%94%9F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>有时候我们希望可以自由的构造与析构对象，这要求它们存在于heap中。又有时我们希望对象不会产生资源泄漏的问题，那我们必须保证某个类不会在heap中构造对象。</p>
<hr>
<h1 id="仅允许在heap中建立对象"><a href="#仅允许在heap中建立对象" class="headerlink" title="仅允许在heap中建立对象"></a>仅允许在heap中建立对象</h1><p>&nbsp;<br>显然，为了达成这一目的，我们必须找到一种方法，禁止所有new之外的能够构造对象的手段。<br>non-heap object在定义它的地方被自动构造，生存时间结束后自动释放，所以只需要禁止隐式的构造和析构函数就可以实现这种限制。<br>最直接的手法就是把构造函数和析构函数声明为private，但这样的副作用太大，我们只需要令其中一个声明为private即可。</p>
<ol>
<li>构造函数为public，析构函数为private<br>这会导致对象依旧可以构造在stack中，只是在析构时会报错。</li>
<li>构造函数为private，析构函数为public<br>一般来说，一个class会存在多个构造函数，因此必须将所有构造函数都声明为private。</li>
</ol>
<p>通过限制访问一个类的析构或构造函数来阻止建立非堆对象固然很好，但这种方法也同时禁止了继承与containment.但我们有两种技术来克服这些缺陷：</p>
<ol>
<li>对于继承而言，可以把构造或析构函数声明为protected。</li>
<li>对于包含来说，可以把包含对象改为包含指向对象的指针。（pimpl）</li>
</ol>
<p>以下给出具体实例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//derived</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span> ... &#125;;<span class="comment">//protected:~UPNumber</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonNegativeUPNumber</span>:</span><span class="keyword">public</span> UPNumber &#123; ... &#125;;</span><br><span class="line"><span class="comment">//containment</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Asset(<span class="keyword">int</span> initValue);</span><br><span class="line">    ~Asset();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber *value;<span class="comment">// RAII is better</span></span><br><span class="line">&#125;;</span><br><span class="line">Asset::Asset(<span class="keyword">int</span> initValue):value(<span class="keyword">new</span> UPNumber(initValue))&#123; ... &#125;</span><br><span class="line">Asset::~Asset()&#123;value-&gt;destroy();&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="判断一个对象是否在堆中"><a href="#判断一个对象是否在堆中" class="headerlink" title="判断一个对象是否在堆中"></a>判断一个对象是否在堆中</h1><p>&nbsp;<br>如果采用上述方法，当我们写下如下表达式时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NonNegativeUPNumber n;<span class="comment">//n处于stack中</span></span><br></pre></td></tr></table></figure><br>n的base部分是否处于stack中却是根据具体实现来确定的，如果现在我们需要作出强制性的保证：一个对象，哪怕是作为派生类的基类部分，也必须出现在堆中。该如何执行这种约束？</p>
<p>没有特别简单的办法来完成这个功能，因为构造函数在调用不可能检测当前环境。简而言之，UPNumber的构造函数无法区分如下两种构造环境：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NonNegativeUPNumber *n1 = <span class="keyword">new</span> NonNegativeUPNumber;<span class="comment">//in heap</span></span><br><span class="line">NonNegativeUPNumber n2;<span class="comment">//in stack</span></span><br></pre></td></tr></table></figure></p>
<h2 id="操作符修改"><a href="#操作符修改" class="headerlink" title="操作符修改"></a>操作符修改</h2><p>也许你可能会试图在new操作符上玩儿一些小花样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HeapConstraintViolation</span> &#123;</span>&#125;;<span class="comment">//如果建立一个非堆对象，抛出一个异常</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    UPNumber();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> onTheHeap; <span class="comment">//指示当前是否在堆中</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> UPNumber::onTheHeap = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *UPNumber::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    onTheHeap = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line">UPNumber::UPNumber()&#123;</span><br><span class="line">    <span class="keyword">if</span> (!onTheHeap) &#123;</span><br><span class="line">        <span class="keyword">throw</span> HeapConstraintViolation();</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//构造</span></span><br><span class="line">    onTheHeap = <span class="literal">false</span>; <span class="comment">// 为下一个对象清除标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们在heap中调用时势必会使用new，因此建立判断位，确保每一次构建时都完美运行。<br>这个方法很好，但不能应用于实际中。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPNumber *numberArray = <span class="keyword">new</span> UPNumber[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><br>new[]只申请了一次内存，然后调用了100次构造函数，z这和我们预期的根本不一致。<br>就算不考虑operator[]，我们也未必能够取得成功:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPNumber *pn = <span class="keyword">new</span> UPNumber(*<span class="keyword">new</span> UPNumber);</span><br></pre></td></tr></table></figure><br>我们在堆中建立两个UPNumber，让pn先指向一个对象，这个对象利用另一个对象的值进行初始化。就算不用顾忌内存泄漏，编译器的行为也未必会按照预期执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">预期行为：</span><br><span class="line">调用第一个对象的 operator new</span><br><span class="line">调用第一个对象的构造函数</span><br><span class="line">调用第二个对象的 operator new</span><br><span class="line">调用第二个对象的构造函数</span><br><span class="line"></span><br><span class="line">可能发生的实际行为：</span><br><span class="line">调用第一个对象的 operator new</span><br><span class="line">调用第二个对象的 operator new</span><br><span class="line">调用第一个对象的构造函数</span><br><span class="line">调用第二个对象的构造函数</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="通过地址判断对象处于何处"><a href="#通过地址判断对象处于何处" class="headerlink" title="通过地址判断对象处于何处"></a>通过地址判断对象处于何处</h2><p>在很多系统中，程序的地址空间被作为线性地址管理，程序的栈自顶而下，堆则自底而上，如下图所示：<br><img src="http://static.zybuluo.com/zsmj2017/rqgn1ejuqze9xekgoav3u8wj/image_1cc5qj8cd7eqsckjee1oe2q9g9.png" alt="image_1cc5qj8cd7eqsckjee1oe2q9g9.png-66kB"><br>因此我们试图使用这么一个函数来判断某个特定的地址是否在堆中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onHeap</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *address)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> onTheStack;</span><br><span class="line">    <span class="keyword">return</span> address &lt; &amp;onTheStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该函数的原理很简单：新建的局部变量必然是栈的最底层，如果某个地址比他还低，那必然是存在于heap中。但是，谁告诉你内存空间只有栈和堆了？static变量也会有特定的位置，一般情况下它们会出现在heap的下面，如下所示：<img src="http://static.zybuluo.com/zsmj2017/vbqdc97zjsdzxsd7p53ww4uv/image_1cc5qp2o01jht12ih1jcbue71tge16.png" alt="image_1cc5qp2o01jht12ih1jcbue71tge16.png-88.7kB"><br>那么该函数不能工作的原因就很清楚了：无法判断堆对象与静态对象。</p>
<hr>
<h2 id="安全delete"><a href="#安全delete" class="headerlink" title="安全delete"></a>安全delete</h2><p>令人悲伤的是我们无法找到一个通用方法来判断对象到底在不在堆上，但我们迫切地需要了解某个对象在不在heap中的初衷很简单：我们需要判断该对象能不能被安全delete。<br>“能否安全删除一个指针”与“一个指针是否指向堆中的事物”并不相同，因为不是所有heap中的事物都能被安全delete：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Asset *pa = <span class="keyword">new</span> Asset;</span><br><span class="line"><span class="keyword">delete</span> pa-&gt;value;<span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>报错的原因在于value并非是一个由new返回的指针，而是一个由new返回的指针初始化的指针。<br>但判断“能否删除一个指针”比判断“一个指针指向的对象是否在堆上”容易，因为对于前者我们只需要每一次new的时候记录一下返回的地址（以一个vector或list保存之），每一次delete之前判断一下地址在不在记录，在的话就把地址从记录中移除。这一系列操作只需要重载一下operator new与delete就好了。<br>但是，在实际使用中，这种方法也不是特别受欢迎，因为：</p>
<ol>
<li>重载后的operator new与operator delete必须在全局作用域，这会引发一些不兼容</li>
<li>不是所有客户都需要这项功能，记录地址未必需要</li>
<li>记录地址未必不出错，比如说多继承或者继承自虚基类的类往往有多个地址。</li>
</ol>
<hr>
<h3 id="mixin-class"><a href="#mixin-class" class="headerlink" title="mixin class"></a>mixin class</h3><p>我们希望存在某些函数提供以上功能，但不污染全局命名空间，没有额外开销，这时mixin class出场了(“mix in” Effective C++ 7中的uncopyable也是一个mixin class）。具体来说，mixin是一个抽象类，其功能可以与其派生类的功能相融合，以上述要求为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapTracked</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MissingAddress</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~HeapTracked() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOnHeap</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">void</span>* RawAddress;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">list</span>&lt;RawAddress&gt; addresses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;RawAddress&gt; HeapTracked::addresses;</span><br><span class="line">HeapTracked::~HeapTracked() &#123;&#125;<span class="comment">//析构函数必须被定义 即使是纯虚函数 详见Effective C++ 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* HeapTracked::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *memPtr = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">    addresses.push_front(memPtr);<span class="comment">//把地址放到list前端</span></span><br><span class="line">    <span class="keyword">return</span> memPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> HeapTracked::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), ptr);</span><br><span class="line">    <span class="keyword">if</span> (it != addresses.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        addresses.erase(it);</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> MissingAddress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HeapTracked::isOnHeap</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *rawAddress = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(<span class="keyword">this</span>);<span class="comment">//动态转换</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), rawAddress);</span><br><span class="line">    <span class="keyword">return</span> it != addresses.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在判定函数中使用了动态转换，这是为了解决我们之前提出的第三个问题，将指针永远指向当前对象起始地址。<br>mixin class使用范式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span>:</span> <span class="keyword">public</span> HeapTracked &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inventoryAsset</span><span class="params">(<span class="keyword">const</span> Asset *ap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ap-&gt;isOnHeap()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>遗憾的是这种mixin不能用于内置类型，因为内置类型无法继承自某类。但我们的本意就是为了安全地delete某对象，内置类型无法delete。</p>
<hr>
<h1 id="禁止建立堆对象"><a href="#禁止建立堆对象" class="headerlink" title="禁止建立堆对象"></a>禁止建立堆对象</h1><p>&nbsp;<br>对象的建立无非三种情况：</p>
<ol>
<li>直接实例化</li>
<li>对象作为派生类的基类被实例化</li>
<li>对象被嵌入到其他对象内</li>
</ol>
<h2 id="直接实例化"><a href="#直接实例化" class="headerlink" title="直接实例化"></a>直接实例化</h2><p>禁止直接实例化很简单，把operator new和delete设为private，如果你需要同时禁止堆对象数组，也可以把operator new[]与operator delete[]设为private:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">UPNumber *p = <span class="keyword">new</span> UPNumber;<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<h2 id="派生类基类"><a href="#派生类基类" class="headerlink" title="派生类基类"></a>派生类基类</h2><p>把operator new声明为private会导致派生类对象的基类无法被实例化。因为operator new与operator delete是自动继承的，除非你手动声明派生类中的它们为public，否则它们默认为基类中的private版本：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonNegativeUPNumber</span>:</span><span class="keyword">public</span> UPNumber &#123;...&#125;;<span class="comment">//默认operator new为private</span></span><br><span class="line">NonNegativeUPNumber *p = <span class="keyword">new</span> NonNegativeUPNumber;<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<h2 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h2><p>operator new是private这一特性，不会对包含产生任何影响：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Asset(<span class="keyword">int</span> initValue);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber value;</span><br><span class="line">&#125;;</span><br><span class="line">Asset *pa = <span class="keyword">new</span> Asset(<span class="number">100</span>);<span class="comment">//调用Asset::operator new或::operator new</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>25.若所有参数均需类型转换，请为此采用non-member函数</title>
    <url>/2018/04/13/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E5%9D%87%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>前文曾说过，令classes支持隐式转换通常会带来风险，但这也有例外，比如当你建立的是一个数值类型。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假设我们建立了一个有理数类，它允许整数隐式转换为有理数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator=<span class="number">0</span>,<span class="keyword">int</span> denominator=<span class="number">1</span>);<span class="comment">//刻意不写为explict</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//成员的访问函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来需要纠结的就是运算符到底是写为member还是non-member呢？</p>
<hr>
<h1 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h1><p>&lt;/br&gt;<br>首先考虑声明为member函数的情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><br>那么很自然地，两个Rational对象可以很自由地相乘。但你会发现这个函数没法做到混合类型计算，比如说,一个int乘以一个ratioanl对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">res = oneHalf * <span class="number">2</span>;<span class="comment">//正确，因为执行了隐式转换</span></span><br><span class="line">res = <span class="number">2</span> * oneHalf;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><br>不能编译的原因很简单，int并没有成员函数<code>operator*</code>。解决的方法也很简单，把<code>operator*</code>声明为non-member函数即可：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure><br>如此一来，混合类型计算的问题就得到了完美解决，哪怕两个参数都不是Rational，但只要它们存在<strong>直接</strong>变为Rational对象的隐式转换即可顺利编译与运行。</p>
<hr>
<h1 id="friend函数"><a href="#friend函数" class="headerlink" title="friend函数"></a>friend函数</h1><p>&lt;/br&gt;<br>那运算符是否需要成为friend函数呢？答案也是否定的。friend函数可以直接访问内部数据，这大大降低了封装性。当然friend函数也有优点，但我们应该牢记：<strong>不能因为函数不该成为member，就自动让它成为friend.</strong></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&lt;/br&gt;<br>本节叙述的内容仅在OO领域内生效，当我们进入template领域并令Rational成为一个class template后，又会出现新的争议、解法、以及设计思路。<br>但至少在OO领域内我们应当牢记：<strong>如果某个函数的所有参数都可能需要进行类型转换，那么这个函数必须是个non-member.</strong></p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次懵懂的源码阅读经历————static_cast，priavte继承与friend杂烩</title>
    <url>/2022/07/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%87%B5%E6%87%82%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%BB%8F%E5%8E%86%E2%80%94%E2%80%94static_cast%E4%B8%8Efriend%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>由于工作需要，最近在读folly库src，在阅读源码过程中产生了一些关于private继承，static_cast，friend之间的疑问。   </p>
<a id="more"></a>
<hr>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="private继承"><a href="#private继承" class="headerlink" title="private继承"></a>private继承</h2><p>C++在业务逻辑中很少涉及private继承，实际上private继承仅仅是一种实现技术，如果class d以private形式继承class b，这说明d仅仅为了采用某些b中已经存在的特性，而不是b和d有任何观念上的交集。<br>一般来说，private继承主要用于EBO（Empty Base Optimization）。<br>更多信息可以参考Effective C++中关于private继承的说明。</p>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>四种类型转换之一，相较于<code>dynamic_cast</code>，<code>static_cast</code>在做向下类型转换时（Base class to Derived class)，不验证正确性。<br>当用作向下转换时，<code>static_cast</code>需要保证待转换对象间存在public继承关系，否则无法通过编译。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">private</span> B &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> B();</span><br><span class="line">    D1 *d1 = <span class="keyword">static_cast</span>&lt;D1*&gt;(b); <span class="comment">// ok</span></span><br><span class="line">    D2 *d2 = <span class="keyword">static_cast</span>&lt;D2*&gt;(b); <span class="comment">// error, cannot cast private base class 'B' to 'D2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="case"><a href="#case" class="headerlink" title="case"></a>case</h1><p>&nbsp;<br>根据前置知识，下文内的代码无疑是无法通过编译的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> d = *(<span class="keyword">static_cast</span>&lt;Derived&lt;T&gt; *&gt;(<span class="keyword">this</span>)); <span class="comment">// error, cannot cast private base class 'Base&lt;T&gt;' to 'Derived&lt;T&gt;'</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="title">final</span> :</span> <span class="keyword">private</span> Base&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    b.dosth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果在<code>Derived</code>内添加<code>friend base class</code>，则可正常通过编译<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> d = *(<span class="keyword">static_cast</span>&lt;Derived&lt;T&gt; *&gt;(<span class="keyword">this</span>)); <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="title">final</span> :</span> <span class="keyword">private</span> Base&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;T&gt;;</span> <span class="comment">// add friend</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    b.dosth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>&nbsp;<br>我对<code>friend</code>的了解仅仅是改变了class之间的符号访问关系，为什么通过增加friend修饰，可以做到cast private base to derived?  </p>
<hr>
<h1 id="一些猜想与结论"><a href="#一些猜想与结论" class="headerlink" title="一些猜想与结论"></a>一些猜想与结论</h1><p>&nbsp;<br>根据 <a href="https://stackoverflow.com/questions/56673706/inaccessible-base-class-despite-friendship" target="_blank" rel="noopener">https://stackoverflow.com/questions/56673706/inaccessible-base-class-despite-friendship</a><br>得到了一些初步的结论：<br>简单来说，private继承令d无法访问b的内部具体实现（这也是private的特性），从而<code>d*</code>与<code>b*</code>不具备相互转换的能力（inaccessible-base-class）。<br>但加上friend后，在<strong>指定的上下文内</strong>d可以<strong>访问</strong>b的内部实现，因此static_cast是合法的。示例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="title">final</span> :</span> <span class="keyword">private</span> Base&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;T&gt;;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    Derived&lt;<span class="keyword">int</span>&gt; * d1 = <span class="keyword">static_cast</span>&lt;Derived&lt;<span class="keyword">int</span>&gt; *&gt;(&amp;b); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    Derived&lt;<span class="keyword">int</span>&gt; * d1 = <span class="keyword">static_cast</span>&lt;Derived&lt;<span class="keyword">int</span>&gt; *&gt;(&amp;b); <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>20.设计class犹如设计type</title>
    <url>/2018/04/12/%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/</url>
    <content><![CDATA[<p>设计良好的class如同内置类型（type)一样，接口自然，目的明确。</p>
<hr>
<p>在设计class之前，设计者必须扪心自问：</p>
<ul>
<li><p>新type的对象应该如何被创建和销毁？<br>该问题的回答决定了构造函数、析构函数、内存分配和释放函数</p>
</li>
<li><p>对象的初始化和赋值有何区别？<br>该问题的回答决定了构造函数与赋值操作符的的行为。尤其需要注意的是，“初始化”、“赋值”是完全不同的概念，它们调用了不同的函数。</p>
</li>
<li><p>新type的对象如果被pass by value，意味着什么？<br>具体实现方式可参考Effective C++ 14；</p>
</li>
<li><p>新type的合法值是什么？<br>对于成员变量而言，可能仅有某些数值集有效。这些数值集决定了class的约束条件，同时也决定了setting函数（构造、赋值等）必须进行的错误检查，同时，它也影响函数抛出的异常。</p>
</li>
<li><p>新type需要配合某个继承体系吗？<br>如果当前type继承自某些class，那你必然受到了那些class设计的束缚，尤其是virtual或者non-virtual成员函数的影响。（详见Effective C++ 34/36/37/38）<br>如果你允许别的类继承该type，那请谨慎考虑析构函数是否需要virtual。（Effective C++ 8）</p>
</li>
<li><p>新type需要什么样的转换？<br>如果你允许T1被隐式转换为T2，就必须在T1内写一个类型转换函数，或者为T2写一个non-explicit-one-argument(可被单一实参调用）的构造函数。（More Effective C++ 5)<br>如果你只允许explicit构造函数存在，就必须撰写显式类型转换函数，并且禁止定义类型转换操作符或者non-explicit-one-argument构造函数。</p>
</li>
<li><p>新type需要哪些操作符和成员函数？<br>该问题的回答决定了class中需要声明的函数，其中有一些是成员函数，有些则不应该是。（Effective C++ 24,25,47）</p>
</li>
<li><p>新type应当明确禁止哪些函数？<br>该问题的回答决定了class中哪些函数需要声明为没有定义的private成员函数。（Effective C++ 6）</p>
</li>
<li><p>谁会试图使用新type的成员？<br>该问题的回答决定了成员函数的可见性，并且也决定了friend。</p>
</li>
<li><p>type的一般化程度如何？<br>如果一般化的程度足够高，或许我们不应该定义一个class，而是应该定义一个class template。</p>
</li>
<li><p>是否真的需要一个新type？<br>如果你只是想增加了一个derived class为原有的class添加功能，先试试看能不能用一些non-member函数或者templates解决。</p>
</li>
</ul>
<hr>
<p>每一次写下class之前请默读本章所有问题。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>36.自定义copy_if算法</title>
    <url>/2018/04/18/%E8%87%AA%E5%AE%9A%E4%B9%89copy_if%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>(C++ 11 已经引入copy_if,本节虽过时，了解copy_if的实现也是好的）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>STL的一大奇特之处在于有11个关于copy的算法，但却没有名为copy_if的算法，也就是说<strong>如果你仅仅想要复制区间内某个符合条件的值的话，你得自己动手</strong>。<br><img src="http://static.zybuluo.com/zsmj2017/a5oq32p501hit026augvaqwf/image_1cbb8bpl0tsj1ho01qaiaj9bqf9.png" alt="image_1cbb8bpl0tsj1ho01qaiaj9bqf9.png-27.2kB"></p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设我们有一个谓词判定widget是否有缺陷，然后把一个vector内所有有缺陷的Widget放进cerr，如果我们有copy_if的话：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDefective</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; widgets;</span><br><span class="line">copy_if(widgets.<span class="built_in">begin</span>(), widgets.<span class="built_in">end</span>(),ostream_iterator&lt;Widget&gt;(<span class="built_in">cerr</span>, <span class="string">"\n"</span>), isDefective);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="copy-if的具体实现"><a href="#copy-if的具体实现" class="headerlink" title="copy_if的具体实现"></a>copy_if的具体实现</h1><h2 id="错误版本"><a href="#错误版本" class="headerlink" title="错误版本"></a>错误版本</h2><p>大神们认为实现copy_if是微不足道的琐事，但这并不意味着对我等来说实现起来很容易，比如说下面这个（不正确的）具体实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator,<span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">copy_if</span><span class="params">(InputIterator <span class="built_in">begin</span>,InputIterator <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                       OutputIterator destBegin, Predicate p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove_copy_if(<span class="built_in">begin</span>, <span class="built_in">end</span>, destBegin, not1(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述实现并不能用于函数中，因<strong>为not1不能直接作用于函数指针</strong>，最起码也得用一个std::function修饰一下。但算法不应该要求仿函数具有可适配性。</p>
<h2 id="真正实现"><a href="#真正实现" class="headerlink" title="真正实现"></a>真正实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">copy_if</span><span class="params">(InputIterator <span class="built_in">begin</span>,InputIterator <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                       OutputIterator destBegin,Predicate p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p(*<span class="built_in">begin</span>))  *destBegin++ = *<span class="built_in">begin</span>;</span><br><span class="line">        ++<span class="built_in">begin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> destBegin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>泛型算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计基于锁的并发数据结构——并发数据结构实例</title>
    <url>/2021/07/13/%E8%AE%BE%E8%AE%A1%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>设计基于锁的数据结构的核心要旨：在持有锁时间最短的前提下，访问数据时锁住<strong>正确的</strong>互斥锁。若使用不同的互斥锁来保护数据结构中不同的部分，操作不当可能会导致死锁，因此更需小心。</p>
<a id="more"></a>
<hr>
<h1 id="使用锁的线程安全栈"><a href="#使用锁的线程安全栈" class="headerlink" title="使用锁的线程安全栈"></a>使用锁的线程安全栈</h1><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> <span class="built_in">std</span>::exception &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data; </span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_stack()&#123;&#125;</span><br><span class="line">  threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other) &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>; </span><br><span class="line">    data=other.data;</span><br><span class="line">  &#125;</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    data.push(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data.empty()) </span><br><span class="line">      <span class="keyword">throw</span> empty_stack();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(data.top())))</span></span>;</span><br><span class="line">    data.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack(); </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(data.top());</span><br><span class="line">    data.pop(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data.empty(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><ol>
<li>线程安全<br>通过使用互斥锁保护每个成员函数，确保任一时刻均只有一个线程在访问数据。</li>
<li><p>条件竞争<br>2.1 在<code>empty</code>和<code>pop</code>成员函数间有潜在的竞争条件(调用<code>empty</code>时是正确的，但其结果并不可靠：其返回后可能其他线程执行了<code>pop</code>操作），但<code>pop</code>在持有锁时将显式地判空，因此条件竞争无影响。<br>2.2 <code>pop</code>函数将直接返回栈顶数据，避免操作分离后<code>top</code>与<code>pop</code>潜在的竞争条件（具体可见<code>线程间共享数据——使用互斥量保护共享数据</code>一章）。</p>
</li>
<li><p>异常<br>3.1 对互斥锁上锁可能会抛出异常，但这种情况不仅极其罕见(互斥锁存在问题，或缺乏系统资源)，并且上锁是每个成员函数的第一个操作。由于没有数据被修改，因此异常安全。<br>3.2 解锁互斥锁不会失败，所以总是安全的，并且<code>std::lock_guard&lt;&gt;</code>确保了互斥锁不会一直处于上锁的状态。<br>3.3 在第一个重载的<code>pop</code>中，程序可能抛出一个<code>empty_stack</code>异常，由于没有数据被修改，所以是安全的。创建<code>res</code>可能会抛出一个异常，原因可能为：<code>std::make_shared</code>可能因为无法为新对象以及引用计数需要的数据分配出足够的内存而抛出异常，亦或在拷贝/移动数据到新分配内存时构造函数抛出异常。C++运行库与标准库将保证上述两种情况没有内存泄露，同时正确销毁新创建的对象（如有），由于没有数据被修改，因此异常安全。调用<code>data.pop</code>保证不会抛出异常。综上，该<code>pop</code>函数异常安全。<br>3.4 第二个重载的<code>pop</code>在拷贝赋值或移动赋值时可能抛出异常,但依旧没有数据修改，异常安全。<br>3.5 <code>empty</code>不会修改数据，异常安全。</p>
</li>
<li><p>死锁<br>由于持有锁时调用了用户代码——数据的拷贝/移动构造或拷贝/移动赋值运算符，亦或是自定义的new操作运算符，因此可能出现死锁，例如：<br>4.1 这些函数调用了栈上的成员函数(而栈正在插入或移除数据项)<br>4.2 这些函数内部持有一种锁，而在调用栈成员函数时又lock了内部的互斥锁，二者可能存在关联<br>因此必须令用户保证上述情况不会发生。</p>
</li>
<li><p>构造与析构<br>构造函数与析构函数没有上锁保护，因此可能存在安全问题。但不管并发与否，调用一个不完全构造的对象或是部分销毁的对象的成员函数永远都不可取。因此，用户必须确保2点：<br>5.1 其他线程直到栈完全构造才能访问它<br>5.2 在栈对象销毁前，所有线程都已经停止访问栈</p>
</li>
</ol>
<h2 id="实例缺陷"><a href="#实例缺陷" class="headerlink" title="实例缺陷"></a>实例缺陷</h2><p>尽管该数据结构安全性很高，但其性能非常差——每次只有一个线程能够操作栈内数据，而其他线程在等待锁时什么也干不了，过度的串行化抑制了性能。<br>同时，栈也未能提供等待添加一个数据项的方法——因此线程必须周期性地调用<code>empty</code>或<code>pop</code>，并捕获<code>empty_stack</code>异常。这逼迫用户要么浪费宝贵的计算资源来检查数据，要么编写等待——通知机制（如条件变量），这使得内部上锁没有必要。</p>
<hr>
<h1 id="使用锁的线程安全队列"><a href="#使用锁的线程安全队列" class="headerlink" title="使用锁的线程安全队列"></a>使用锁的线程安全队列</h1><h2 id="代码实例1"><a href="#代码实例1" class="headerlink" title="代码实例1"></a>代码实例1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue; </span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_queue.push(<span class="built_in">std</span>::<span class="built_in">move</span>(data)); </span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(data_queue.front())))</span></span>;</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(data_queue.front()); </span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(data_queue.front())))</span></span>; </span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.empty(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实例1分析"><a href="#实例1分析" class="headerlink" title="实例1分析"></a>实例1分析</h2><p>相对栈的实现，主要差别有2点：</p>
<ol>
<li>新增了条件变量，不再需要线程持续调用<code>empty</code></li>
<li><code>try_pop</code>不再抛出异常，转为返回bool量</li>
</ol>
<p>在异常安全性方面存在一个细微变化：由于使用的是<code>notify_one</code>，因此在多线程等待时，只会有一个线程被唤醒。但如果该线程在<code>wait_and_pop</code>中抛出一个异常(如构造<code>std::shared_ptr&lt;&gt;</code>对象时），此时队列不为空，但不会有其他线程被唤醒。若当前使用环境无法接受这种情况，存在三种修改方案：</p>
<ol>
<li>将<code>notify_one</code>调用可以替换成<code>notify_all</code>，它将唤醒所有的工作线程，代价是大多数线程发现队列依旧是空时将重新进入休眠状态。</li>
<li>有异常抛出时令<code>wait_and_pop</code>调用<code>notify_one</code>，从而让另一个线程尝试检索队列内数据。</li>
<li>将<code>std::shared_ptr&lt;&gt;</code>的初始化过程移到<code>push</code>中，队列由存储数据实例转为存储<code>std::shared_ptr&lt;&gt;</code>实例，由于<code>std::shared_ptr&lt;&gt;</code>拷贝不会抛出异常，由此即可保证异常安全性。</li>
</ol>
<h2 id="代码实例2"><a href="#代码实例2" class="headerlink" title="代码实例2"></a>代码实例2</h2><p>根据方案3，有代码实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; &gt; data_queue; </span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(*data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(*data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">data</span><span class="params">( <span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; </span><br><span class="line">    data_queue.push(data);</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.empty(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="实例2分析"><a href="#实例2分析" class="headerlink" title="实例2分析"></a>实例2分析</h2><p>除去解决前文所述的问题外，使用<code>std::shared_ptr&lt;&gt;</code>还有一大优点：<code>push</code>内数据实例的构造可以在锁外完成。一般来说，内存分配的性能开销较大，若将其置于锁内将增加持有锁的时间，不利于数据结构的性能。</p>
<hr>
<h1 id="使用细粒度锁和条件变量的线程安全队列"><a href="#使用细粒度锁和条件变量的线程安全队列" class="headerlink" title="使用细粒度锁和条件变量的线程安全队列"></a>使用细粒度锁和条件变量的线程安全队列</h1><p>&nbsp;<br>上文所提及的两种线程安全数据结构，本质上均为使用互斥锁保护<code>STL</code>容器，尽管易于实现，但其并发程度较低。通过精心设计底层数据结构，开发者可以提供更细粒度的锁定，从而进一步提高并发程度。</p>
<h2 id="基于单链表实现的队列"><a href="#基于单链表实现的队列" class="headerlink" title="基于单链表实现的队列"></a>基于单链表实现的队列</h2><p>最简单的队列是单链表，如下图所示。<br><img src="http://static.zybuluo.com/zsmj2017/p0pm8bxn760i6if798hii7mj/image.png" alt="image.png-84.7kB"><br>队列维护着一个头指针和一个尾指针，分别指向链表的首项数据与末项数据。<code>push</code>操作为添加新数据为tail的next，并更新tail，<code>pop</code>操作即为更新head为其next，此后切断联系。<br>当<code>head==tail==nullptr</code>时，链表为空。具体实例如下。</p>
<h3 id="代码实例（单线程版）"><a href="#代码实例（单线程版）" class="headerlink" title="代码实例（单线程版）"></a>代码实例（单线程版）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    T data; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">    node(T data_): data(<span class="built_in">std</span>::<span class="built_in">move</span>(data_)) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">  node* tail; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">queue</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(head-&gt;data)))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head=<span class="built_in">std</span>::<span class="built_in">move</span>(head); </span><br><span class="line">    head=<span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>; </span><br><span class="line">    node* <span class="keyword">const</span> new_tail=p.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span>(tail) &#123;</span><br><span class="line">      tail-&gt;next=<span class="built_in">std</span>::<span class="built_in">move</span>(p); <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      head=<span class="built_in">std</span>::<span class="built_in">move</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    tail=new_tail;<span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p>该队列使用了<code>std::unique_ptr&lt;node&gt;</code>来管理节点，从而保证了节点和其引用数据将在不需要时自动删除，tail是指向最后一个节点的裸指针，因为它需要引用<code>std::unique_ptr&lt;node&gt;</code>已经拥有的节点(代码1处p已经被move)。</p>
<p>在多线程下使用细粒度锁时，开发者可能会倾向于使用2个互斥锁分别保护两个数据项<code>head</code>与<code>tail</code>，但存在以下问题：</p>
<ol>
<li><code>push</code>可能同时修改head与tail，因此它必须锁住两个互斥锁——虽然很少见，但同时锁住两个互斥锁还不算太诡异。</li>
<li><code>push</code>和<code>try_pop</code>都能访问next指针指向的节点:<code>push</code>更新tail-&gt;next，然后<code>try_pop</code>读取head-&gt;next。若队列中只有一个元素（head==tail），此时head-&gt;next和tail-&gt;next是同一个需要保护的对象。若不同时读取head和tail，开发者无法区分它们是否是同一个对象，因此必须在<code>push</code>与<code>try_pop</code>内锁住同一个锁（用来保护next数据）。</li>
</ol>
<hr>
<h3 id="实例改进（增加尾部哨兵）"><a href="#实例改进（增加尾部哨兵）" class="headerlink" title="实例改进（增加尾部哨兵）"></a>实例改进（增加尾部哨兵）</h3><p>开发者可以通过分配尾哨兵来解决问题，此时tail将不再指向具体数据，而是承担哨兵角色。为了允许哨兵的存在（没有数据），需要增加额外的一层间接性——通过指针来存储数据，具体代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next; </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">  node* tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">queue</span>():head(<span class="keyword">new</span> node),tail(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>()==tail) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(head-&gt;data)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head=<span class="built_in">std</span>::<span class="built_in">move</span>(head); </span><br><span class="line">    head=<span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    tail-&gt;data=new_data; <span class="comment">// 若tail==head,此时head亦被赋值</span></span><br><span class="line">    node* <span class="keyword">const</span> new_tail=p.<span class="built_in">get</span>(); </span><br><span class="line">    tail-&gt;next=<span class="built_in">std</span>::<span class="built_in">move</span>(p);</span><br><span class="line">    tail=new_tail; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="实例比较"><a href="#实例比较" class="headerlink" title="实例比较"></a>实例比较</h4><ol>
<li><p>构造函数中新增了对虚拟节点的创建</p>
</li>
<li><p><code>try_pop</code>的改动为：<br>2.1 将检查head是否为nullptr替换为比较head与tail，因为引入虚拟节点后head将不可能为nullptr。<br>2.2 直接返回指针，不再需要创建新一个新实例。</p>
</li>
<li><p><code>push</code>的改动为:<br>3.1 必须先在堆上创建一个T类型的实例，并让一个<code>std::shared_ptr&lt;&gt;</code>拥有该实例。<br>3.2 将原有哨兵节点数据替换为新实例，连接至新哨兵，并更新哨兵节点。</p>
</li>
</ol>
<h4 id="改进收益"><a href="#改进收益" class="headerlink" title="改进收益"></a>改进收益</h4><ol>
<li><code>push</code>只需访问tail，不再访问head，这意味着不需要持有2个互斥锁。</li>
<li><code>try_pop</code>与<code>push</code>将永远不可能对同一节点做操作（head-&gt;next与tail-&gt;next一致时，队列为空，此时直接返回），因此不再需要一个总的互斥锁。</li>
</ol>
<hr>
<h3 id="代码实例（加锁）"><a href="#代码实例（加锁）" class="headerlink" title="代码实例（加锁）"></a>代码实例（加锁）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next; </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::mutex head_mutex; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head; </span><br><span class="line">  <span class="built_in">std</span>::mutex tail_mutex; </span><br><span class="line">  node* tail;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">node* <span class="title">get_tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>() == get_tail()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head=<span class="built_in">std</span>::<span class="built_in">move</span>(head); </span><br><span class="line">    head = <span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue(): head(<span class="keyword">new</span> node),tail(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp; other)=<span class="keyword">delete</span>; </span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = pop_head();</span><br><span class="line">    <span class="keyword">return</span> old_head ? old_head-&gt;data : <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    node* <span class="keyword">const</span> new_tail = p.<span class="built_in">get</span>(); </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>; </span><br><span class="line">    tail-&gt;data = new_data;</span><br><span class="line">    tail-&gt;next = <span class="built_in">std</span>::<span class="built_in">move</span>(p);</span><br><span class="line">    tail=new_tail;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例分析-3"><a href="#实例分析-3" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>为了实现最大程度的并发，上锁的时间越少越好。因此<code>push</code>与<code>try_pop</code>有设计思路如下：</p>
<ol>
<li>push<br>访问tail期间均必须完成上锁，因此分配完成性哨兵节点后上锁开始，直至函数完成。</li>
<li>try_pop<br>首先必须锁住head，直至head完成改变（该操作决定了哪一个线程执行pop操作）。其次，由于判空需要获取tail，因此在此期间必须完成对tail的锁定。<br>将<code>pop_head</code>与<code>get_tail</code>封装为函数不仅提高了代码可读性，同时也使得互斥区更加明确。</li>
</ol>
<h4 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h4><h5 id="不变量"><a href="#不变量" class="headerlink" title="不变量"></a>不变量</h5><p>针对该基于单链表实现的队列，有不变量如下:</p>
<ul>
<li>tail-&gt;next==nullptr</li>
<li>tail-&gt;data==nullptr</li>
<li>head==tail意味着空链表</li>
<li>单元素链表有head-&gt;next==tail</li>
<li>x-&gt;next==tail意味着x是链表中最后一个节点</li>
<li>以head为起点迭代，必将访问至tail</li>
</ul>
<h5 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h5><ol>
<li>push<br>如前文所述，数据被正确保护，不变量未遭到破坏。</li>
<li>try_pop<br>2.1 该函数需要在读取head，tail时加锁以避免数据竞争。如果tail不加锁，则可能出现数据竞争或UB：一个线程调用try_pop的同时，另一个线程调用push，此时可能两个线程在访问同一个tail对象（尽管每个成员函数都加锁了，但<code>pop</code>与<code>try_pop</code>持有的是不同的锁）。加锁后<code>get_tail</code>将会锁住和<code>push</code>相同的锁，因此调用将存在明确顺序：要么<code>get_tail</code>将在<code>push</code>前被调用，线程看到的是tail旧值；要么在<code>push</code>后被调用，线程将观察到tail新值。<br>2.2 <code>get_tail</code>的调用必须发生于<code>head_mutex</code>互斥区内<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error version</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  node* <span class="keyword">const</span> old_tail = get_tail();</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>(head.<span class="built_in">get</span>() == old_tail) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = <span class="built_in">std</span>::<span class="built_in">move</span>(head); </span><br><span class="line">  head=<span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">  <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当进入<code>head_mutex</code>的互斥区后，很有可能tail与head的值已经发生了改变（另一个线程完成了push或者正在调用pop_head修改head），此后的判空无意义。若<code>get_tail</code>在<code>head_mutex</code>保护范围内，即可保证没有其他线程对head进行修改，判空符合预期。</li>
</ol>
<h5 id="异常安全分析"><a href="#异常安全分析" class="headerlink" title="异常安全分析"></a>异常安全分析</h5><ol>
<li><code>try_pop</code>锁住互斥锁时可能产生异常，但由于在获得锁前数据不会被修改，因此<code>try_pop</code>异常安全。</li>
<li><code>push</code>在堆上分配数据实例和node实例时（new语句）可能会产生异常，但智能指针保证了异常安全性。获得锁后，<code>push</code>内操作不会产生异常，因此<code>push</code>异常安全。</li>
</ol>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p><code>pop_head</code>获取锁的顺序永远是先head_mutex再tail_mutex，因此永远不会死锁。</p>
<h4 id="并发性分析"><a href="#并发性分析" class="headerlink" title="并发性分析"></a>并发性分析</h4><p>细粒度锁的引入带来了更高的并发性，并且本实例已尽可能将操作置于锁外。举例而言，<code>push</code>中新节点和新数据项的分配都未曾持有锁，这保证了多个线程可以并发地分配新节点新数据项。在<code>try_pop</code>中较为耗时的<code>delete</code>同样置于锁外，这增加了并发调用<code>try_pop</code>的次数。</p>
<hr>
<h3 id="实例完善（增加wait-and-pop）"><a href="#实例完善（增加wait-and-pop）" class="headerlink" title="实例完善（增加wait_and_pop）"></a>实例完善（增加wait_and_pop）</h3><p>本节将针对上述实例做进一步完善，新增<code>wait_and_pop</code>接口，并补充<code>pop</code>接口重载版本。</p>
<h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><ol>
<li>push<br>简单来看，只需要在函数末尾添加<code>data_cond.notify_one()</code>调用即可，但此时处于tail_mutex被锁住的状态，若被通知的线程在tail_mutex解锁前醒来，则需要等待该互斥锁解锁，因此可以考虑在调用<code>notify_one</code>前解锁互斥锁以获得最大并发性。</li>
<li>wait_and_pop<br>首先，仅有在队列非空时（head != tail）需要等待，因此似乎需要同时锁住两个互斥锁，但正如前文所述（只有在读取时需要持有互斥锁），因此谓词可设定为<code>head!=get_tail()</code>即可，然后使用head_mutex对data_cond.wait()调用进行保护。</li>
<li>重载pop<br>若将从old_head检索得到的数据项拷贝赋值至value，若拷贝赋值操作抛出异常，则数据量将彻底丢失（队列中已不存在数据）。因此必须新增一个重载的<code>pop_head</code>函数，在改动链表前检索数据。</li>
</ol>
<h4 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next; </span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex head_mutex; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head; </span><br><span class="line">  <span class="built_in">std</span>::mutex tail_mutex;</span><br><span class="line">  node* tail; </span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue(): head(<span class="keyword">new</span> node),tail(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp; other)=<span class="keyword">delete</span>; </span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = try_pop_head();</span><br><span class="line">    <span class="keyword">return</span> old_head?old_head-&gt;data:<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head = try_pop_head(value);</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head = wait_pop_head();</span><br><span class="line">    <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head = wait_pop_head(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(new_value)))</span></span>; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>; </span><br><span class="line">      tail-&gt;data=new_data;</span><br><span class="line">      node* <span class="keyword">const</span> new_tail=p.<span class="built_in">get</span>(); </span><br><span class="line">      tail-&gt;next=<span class="built_in">std</span>::<span class="built_in">move</span>(p);</span><br><span class="line">      tail=new_tail; </span><br><span class="line">    &#125;</span><br><span class="line">    data_cond.notify_one(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (head.<span class="built_in">get</span>()==get_tail());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">node* <span class="title">get_tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head=<span class="built_in">std</span>::<span class="built_in">move</span>(head);</span><br><span class="line">    head=<span class="built_in">std</span>::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> old_head; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    data_cond.wait(head_lock,[&amp;]&#123;<span class="keyword">return</span> head.<span class="built_in">get</span>()!=get_tail();&#125;); </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">move</span>(head_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保数据被修改时持有同一把锁</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> pop_head(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> pop_head();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">try_pop_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>()==get_tail()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pop_head(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">try_pop_head</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>; </span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>()==get_tail()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    value=<span class="built_in">std</span>::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> pop_head(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计基于锁的并发数据结构——并发设计纲要</title>
    <url>/2021/07/08/%E8%AE%BE%E8%AE%A1%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E7%BA%B2%E8%A6%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>选择与设计正确的数据结构是解决方案设计的重中之重，并发编程亦不例外。若某种数据结构存在被多线程访问的可能性，除非其具备只读属性，否则必然需要保证数据变化在线程间被正确同步，对于此，一般有两种设计方案：</p>
<ol>
<li>使用独立的互斥锁以及外部加锁来保护数据</li>
<li>设计自身支持并发访问的数据结构</li>
</ol>
<p>本章将重点论述第二点。<br><a id="more"></a></p>
<hr>
<h1 id="何谓并发设计"><a href="#何谓并发设计" class="headerlink" title="何谓并发设计"></a>何谓并发设计</h1><p>&nbsp;<br>线程安全(thread-safe)：若存在某种数据结构，支持多线程并发访问，所有线程均可观察到该结构<strong>前后一致</strong>的视图，施加于该数据结构的任意操作均保证不会造成数据丢失或损坏，且不会造成数据竞争，则称该数据结构线程安全。通常场景下，数据结构可能仅需要保证特定的并发访问“安全”即可，例如“保证在多线程读与单线程写的情景下安全”，或者“多线程执行不同操作时安全”。</p>
<p>前文曾提及的互斥锁可以为数据结构提供保护(一次仅能有一个线程获得互斥锁)，究其本质，即显式阻止对被保护数据的真正并发访问。这被称为串行化(serialization)——各线程轮流，以串行而非并行的方式访问保护数据。</p>
<p>使用互斥锁包裹<strong>全部</strong>数据显然不是并发设计——真正的设计意味着需要为多线程提供并发访问保护数据的机会。尽管不同场景，不同数据结构所需要的并发范围大小各有差异，但基本设计思想是一致的：保护区越小，串行化操作就越少，并发的潜力就越大。</p>
<hr>
<h1 id="并发设计纲要"><a href="#并发设计纲要" class="headerlink" title="并发设计纲要"></a>并发设计纲要</h1><p>&nbsp;</p>
<p>如上文所说，并发设计主要需要考虑2点：</p>
<ol>
<li>确保访问安全</li>
<li>允许真正的并发访问</li>
</ol>
<h2 id="访问安全"><a href="#访问安全" class="headerlink" title="访问安全"></a>访问安全</h2><p>在<code>线程间共享数据</code>一章中曾对保证数据结构线程安全的基础要点有所介绍：</p>
<ul>
<li>除修改线程外，没有线程能看到数据被修改时的中间状态。</li>
<li>提供完整操作（而非一个个操作步骤）的函数以避免接口固有的竞争条件。</li>
<li>避免异常行为暴露数据的中间状态。</li>
<li>限制锁的范围，避免嵌套锁，尽力避免死锁。</li>
</ul>
<p>同时，我们也需要考虑对数据结构的使用者施加何种约束：若当前存在线程A通过一个特定函数对数据结构进行访问，那么其他线程能安全使用哪些函数？<br>通常，构造函数和析构函数需要互斥地访问数据结构，但需要用户保证不会在构造函数完成前/析构函数完成后访问数据结构。若该数据结构支持<code>copy assignment</code>，<code>swap</code>或<code>copy ctor</code>，则我们必须决定这些操作与其他操作并发调用时使用安全，或者它们是否必须要求用户保证互斥访问。</p>
<h2 id="并发访问"><a href="#并发访问" class="headerlink" title="并发访问"></a>并发访问</h2><p>在设计数据结构之前，我们必须扪心自问</p>
<ul>
<li>是否可以限制锁的作用范围，以允许操作的某些部分在锁外执行？</li>
<li>数据结构不同部分能否被不同的互斥锁保护?</li>
<li>所有的操作需要同一级别的保护吗?</li>
<li>是否可以在不影响操作语义的前提下修改数据结构，增加其得以被并发访问的可能？</li>
</ul>
<p>上述问题的核心是——如何最小化必须的串行操作，使真实的并发最大化?<br>就实际使用场景而言，只读线程并发访问，修改线程互斥访问的案例较为常见（可以通过使用<code>std::shared_thread</code>实现）。后文将提及另一种常见场景:串行执行执行同一操作，并发执行不同操作。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计基于锁的并发数据结构——更复杂的数据结构</title>
    <url>/2021/07/22/%E8%AE%BE%E8%AE%A1%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>上一节所提及的栈和队列均是非常简单的数据结构，使用场景有限。本节将针对【查找表】，【链表】两种使用场景较丰富的数据结构，提供设计实例。<br><a id="more"></a></p>
<hr>
<h1 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h1><h2 id="设计前提与使用场景"><a href="#设计前提与使用场景" class="headerlink" title="设计前提与使用场景"></a>设计前提与使用场景</h2><p><code>std::map</code>是STL提供的现成查找表，其接口重度基于迭代器。从并发视角看，迭代器的线程安全性很难（并非不可能）保证，比如另一个线程可能正在删除本线程迭代器所引用的元素，此时很难验证迭代器是否已经失效。因此本次数据结构接口设计并不基于STL传统思想。</p>
<p>不同于栈和队列，查找表的主要使用场景是查找指定元素，而非修改表内数据（例如前文提及的DNS缓存）。本次设计的查找表具备几个基本操作：</p>
<ul>
<li>添加一个新的键/值对</li>
<li>修改给定键对应的值</li>
<li>删除一个键及其关联的值</li>
<li>通过给定键，获取对应的值（如有）</li>
</ul>
<p>除此以外还可以考虑增加一些全容器范围的操作，例如检查容器是否为空，提供当前完整键的快照，提供当前完整键值对的快照等。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>查找表接口的固有条件竞争在于：若两个线程同时试图添加key相同的KV对，则只有一个线程能够添加成功，因此必须修改接口，合并<strong>添加</strong>与<strong>修改</strong>为同一个成员函数。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>为了提高并发性，可以使用<code>std::shared_mutex</code>，保证支持多线程读取，单线程写入。</p>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>实现查找表的底层数据结构一般有三种；</p>
<ol>
<li>二叉树（AVL或红黑树）</li>
<li>有序数组</li>
<li>哈希表</li>
</ol>
<p>二叉树并没有为扩展并发提供太多可能，每一个查找或者修改操作都需要从访问根节点开始，因此，根节点需要上锁。虽然随着访问线程沿着树向下移动，这个锁可以释放，但相比横跨整个数据结构的单一锁，提升并不大。有序数组则更不适合，每一次修改或查找都必须锁住整个数组，毫无并发性可言。</p>
<p>对于哈希表而言，一个键属于哪个桶纯粹由键的属性以及哈希函数决定，每个桶都可以有一个独立的锁。若桶的数量为N，则并发访问的可能性约为数组的N倍（虽然需要挑选一个好的哈希函数）。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash=<span class="built_in">std</span>::hash&lt;Key&gt; &gt;</span><br><span class="line">class threadsafe_lookup_table &#123;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// member class</span></span><br><span class="line">  class bucket_type &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> bucket_value = <span class="built_in">std</span>::pair&lt;Key, Value&gt;;</span><br><span class="line">    <span class="keyword">using</span> bucket_data = <span class="built_in">std</span>::<span class="built_in">list</span>&lt;bucket_value&gt;;</span><br><span class="line">    <span class="keyword">using</span> bucket_iterator = <span class="keyword">typename</span> bucket_data::iterator;</span><br><span class="line">    <span class="keyword">using</span> bucket_const_iterator = <span class="keyword">typename</span> bucket_data::const_iterator;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    bucket_data data;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex mutex; <span class="comment">// C++17</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">bucket_const_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::find_if(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [&amp;](bucket_value <span class="keyword">const</span> &amp;item) &#123; <span class="keyword">return</span> item.first == key; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::find_if(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [&amp;](bucket_value <span class="keyword">const</span> &amp;item) &#123; <span class="keyword">return</span> item.first == key; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="keyword">const</span> &amp;key, Value <span class="keyword">const</span> &amp;default_value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">      bucket_const_iterator <span class="keyword">const</span> found_entry = find_entry_for(key);</span><br><span class="line">      <span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? default_value : found_entry-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="keyword">const</span> &amp;key, Value <span class="keyword">const</span> &amp;value)</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">      bucket_iterator found_entry = find_entry_for(key);</span><br><span class="line">      <span class="keyword">if</span> (found_entry == data.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        data.push_back(bucket_value(key, value));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        found_entry-&gt;second = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">      bucket_iterator found_entry = find_entry_for(key);</span><br><span class="line">      <span class="keyword">if</span> (found_entry != data.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        data.erase(found_entry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;bucket_type&gt;&gt; buckets;</span><br><span class="line">  Hash hasher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">bucket_type &amp;<span class="title">get_bucket</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="keyword">const</span> bucket_index = hasher(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">threadsafe_lookup_table</span><span class="params">(<span class="keyword">unsigned</span> num_buckets = <span class="number">19</span>, Hash <span class="keyword">const</span> &amp;hasher_ = Hash())</span> :</span></span><br><span class="line">      buckets(num_buckets), hasher(hasher_) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; num_buckets; ++i) &#123;</span><br><span class="line">      buckets[i].reset(<span class="keyword">new</span> bucket_type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_lookup_table(threadsafe_lookup_table <span class="keyword">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  threadsafe_lookup_table &amp;<span class="keyword">operator</span>=(threadsafe_lookup_table <span class="keyword">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="keyword">const</span> &amp;key, Value <span class="keyword">const</span> &amp;default_value = Value())</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get_bucket(key).value_for(key, default_value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="keyword">const</span> &amp;key, Value <span class="keyword">const</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    get_bucket(key).add_or_update_mapping(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="keyword">const</span> &amp;key)</span> </span>&#123;</span><br><span class="line">    get_bucket(key).remove_mapping(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取快照</span></span><br><span class="line">  std::map&lt;Key, Value&gt; get_map() const &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt;&gt; locks;</span><br><span class="line">    <span class="comment">// 以相同顺序加锁，确保不会死锁</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      locks.push_back(<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt;(buckets[i]-&gt;mutex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;Key, Value&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> it = buckets[i]-&gt;data.cbegin(); it != buckets[i]-&gt;data.cend(); ++it) &#123;</span><br><span class="line">        res.insert(*it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="设计前提与使用场景-1"><a href="#设计前提与使用场景-1" class="headerlink" title="设计前提与使用场景"></a>设计前提与使用场景</h2><p>如前文所述，本次接口设计依然避免基于迭代器（STL风格迭代器生命周期不受容器控制，很难确保线程安全性）。</p>
<p>链表的常用场景有以下几点：</p>
<ul>
<li>添加一个项到链表</li>
<li>从链表中删除满足某个条件的项</li>
<li>从链表中查找满足某个条件的项</li>
<li>更新链表中满足某个条件的项</li>
<li>拷贝链表中的每一项到另一个容器中</li>
</ul>
<h2 id="基本设计思想"><a href="#基本设计思想" class="headerlink" title="基本设计思想"></a>基本设计思想</h2><p>令链表的每一个节点持有一个互斥锁，即可最大程度实现并发性（尽管互斥锁个数将随着链表长度增长而增长），每个操作仅需要锁住它需要的节点，并在关注点转向其他节点时释放该锁。</p>
<h2 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_list</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// member class</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;T&gt; data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span> &lt;node&gt; next;</span><br><span class="line"></span><br><span class="line">    node() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">node</span><span class="params">(T <span class="keyword">const</span> &amp;value)</span> : <span class="title">data</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(value))</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  node head; <span class="comment">// 哨兵节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_list() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~threadsafe_list() &#123; remove_if([](node <span class="keyword">const</span> &amp;) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;); &#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_list(threadsafe_list <span class="keyword">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  threadsafe_list &amp;<span class="keyword">operator</span>=(threadsafe_list <span class="keyword">const</span> &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(T <span class="keyword">const</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span> &lt;node&gt; new_node(<span class="keyword">new</span> node(value));</span><br><span class="line">    <span class="built_in">std</span>::lock_guard &lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">    new_node-&gt;next = <span class="built_in">std</span>::<span class="built_in">move</span>(head.next);</span><br><span class="line">    head.next = <span class="built_in">std</span>::<span class="built_in">move</span>(new_node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">for_each</span><span class="params">(Function f)</span> </span>&#123;</span><br><span class="line">    node *current = &amp;head;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">    <span class="keyword">while</span> (node *<span class="keyword">const</span> next = current-&gt;next.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">      lk.unlock();</span><br><span class="line">      f(*next-&gt;data);</span><br><span class="line">      current = next;</span><br><span class="line">      lk = <span class="built_in">std</span>::<span class="built_in">move</span>(next_lk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;T&gt; find_first_if(Predicate p) &#123;</span><br><span class="line">    node *current = &amp;head;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">    <span class="keyword">while</span> (node *<span class="keyword">const</span> next = current-&gt;next.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">      lk.unlock();</span><br><span class="line">      <span class="keyword">if</span> (p(*next-&gt;data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">      &#125;</span><br><span class="line">      current = next;</span><br><span class="line">      lk = <span class="built_in">std</span>::<span class="built_in">move</span>(next_lk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_if</span><span class="params">(Predicate p)</span> </span>&#123;</span><br><span class="line">    node *current = &amp;head;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">    <span class="keyword">while</span> (node *<span class="keyword">const</span> next = current-&gt;next.<span class="built_in">get</span>()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">      <span class="keyword">if</span> (p(*next-&gt;data)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span> &lt;node&gt; old_next = <span class="built_in">std</span>::<span class="built_in">move</span>(current-&gt;next);</span><br><span class="line">        current-&gt;next = <span class="built_in">std</span>::<span class="built_in">move</span>(next-&gt;next);</span><br><span class="line">        next_lk.unlock(); <span class="comment">// 若无此语句，则将导致销毁已上锁的互斥锁——未定义行为</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lk.unlock();</span><br><span class="line">        current = next;</span><br><span class="line">        lk = <span class="built_in">std</span>::<span class="built_in">move</span>(next_lk);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><p>首先在锁外构建新节点，并默认初始化其next节点为nullptr。此后，在锁内获取当前头部节点，完成节点链接。由于只需要锁住一个互斥锁，因此死锁发生率为0。性能开销较大的内存分配位于锁外，无性能问题。</p>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><p>与大多数标准库算法类似，for_each将对Function对象执行值传递（确保无论是函数还是函数对象都能正常工作）。需要关注的点在于交叉(hand-over-hand)上锁。首先，锁住cur节点的互斥锁以安全访问其next节点。若该节点不为nullptr，则锁住该节点互斥锁，同时释放cur节点互斥锁，此后待函数执行完毕后，更新cur节点，并重新上锁cur。</p>
<h3 id="find-first-if"><a href="#find-first-if" class="headerlink" title="find_first_if"></a>find_first_if</h3><p>与for_each类似，区别在于一旦符合谓词则直接返回。</p>
<h3 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h3><p>交叉上锁的步骤与for_each类似。<br>若谓词返回true，此时更新cur-&gt;next断开链接，释放next对应的互斥锁，std::unique_ptr<node>将负责删除节点，cur无需更新（仍需检查后续节点）。<br>若谓词返回false，正常迭代。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计无锁并发数据结构——概述</title>
    <url>/2021/07/31/%E8%AE%BE%E8%AE%A1%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>互斥锁的理解成本很低，带来的收益却很高——可以保证在多线程情况下安全地访问数据结构，而不会产生竞争条件或破坏不变量。<br>但互斥锁并非完美无缺，不正确地使用可能带来死锁，粗粒度地上锁将影响并发性。<br>如果能写出一个不使用锁的并发数据结构，则可避免上述互斥锁引入的问题，这样的数据结构被被称为无锁(lock-free)数据结构。<br>无锁结构的核心是前文提及的内存顺序属性，设计无锁结构时需要万分小心——它不仅很难正确实现，同时其内部bug很难稳定复现与定位原因。<br><a id="more"></a></p>
<hr>
<h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>&nbsp;<br>使用互斥锁、条件变量，以及期望来同步数据的算法和数据结构被称为阻塞式 (blocking)数据结构和算法——线程在block消失前无法跨越。一般情况下，操作系统会完全挂起一个阻塞的线程(并将其时间片分配给其他线程)，直到另一个线程排除障碍（解锁一个互斥锁、通知一个条件变量，或令期望就绪）。</p>
<h2 id="非阻塞数据结构的3种类型"><a href="#非阻塞数据结构的3种类型" class="headerlink" title="非阻塞数据结构的3种类型"></a>非阻塞数据结构的3种类型</h2><p>前文曾用<code>std::atomic_flag</code>实现了一个简单的自旋锁，其代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic_flag flag; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  spinlock_mutex(): flag(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.test_and_set(<span class="built_in">std</span>::memory_order_acquire)); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(<span class="built_in">std</span>::memory_order_release); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该实例内没有调用任何阻塞函数，<code>lock</code>不断循环，直到<code>test_and_set</code>返回false，这就是自旋锁（spin lock）名字的由来——代码在循环中“旋转”。<br>因为不存在阻塞调用，所以使用这个互斥锁来保护共享数据的代码均为非阻塞式，不过并非无锁，毕竟这还是一个只能被一个线程锁住的互斥锁。显然，仅仅定义“阻塞”，“非阻塞”是不够用的，因此为了后续展开详细叙述，这里引入以下定义：</p>
<ul>
<li>无障碍——若其他线程均处于暂停状态，唯一操作线程都将在有限的步骤内完成其操作。</li>
<li>无锁——若存在多个线程同时对该数据结构进行操作，其中某个线程将在有限的步骤内完成其操作。</li>
<li>无等待——若存在多个线程同时对该数据结构进行操作，每个线程都将在有限步骤内完成其操作。</li>
</ul>
<p>显然，无障碍算法在实际场景中使用性很低（很少存在其他线程都暂停的场景），因此它主要用于刻画一个失败的无锁实现。</p>
<hr>
<h1 id="无锁数据结构"><a href="#无锁数据结构" class="headerlink" title="无锁数据结构"></a>无锁数据结构</h1><p>&nbsp;<br>无锁数据结构性质：支持多个线程并发访问，这些线程的操作无需相同（例如无锁队列支持一个线程push数据时另一个线程pop数据）。此外，当其中一个正在访问数据的线程被调度器中途挂起时，其他线程必须仍然能够继续完成工作，而无需等待挂起线程。</p>
<p>使用“比较-交换”原子操作的算法，通常都包含一个循环，之所以需要使用“比较-交换”操作，是因为与此同时另一个线程可能已经修改了数据，此时在再次尝试“比较-交换”之前，代码需要重新执行部分操作。若此时其他线程均被挂起，该算法可被称为“无锁”，否则的话等价于持有自旋锁，仅能称之为“非阻塞算法”。</p>
<p>带有循环的无锁算法可能导致某线程处于饥饿状态：若存在某一线程在“错误”时机执行操作，其他线程可能运行良好，但某倒霉线程则可能此时需要不断重复试错。</p>
<hr>
<h1 id="无等待数据结构"><a href="#无等待数据结构" class="headerlink" title="无等待数据结构"></a>无等待数据结构</h1><p>&nbsp;<br>根据前文定义，无等待数据结构是无锁数据结构的子集，其特征在于每个线程都都将在有限步骤内完成其操作（不管其他线程行为如何）。因此，由于与其他线程发生冲突而可能陷入无限次重试的算法并不是无等待的（本章的大多数实例都都具备这一特性——存在一个在<code>compare_exchange_weak</code>或<code>compare_exchange_strong</code>操作上的循环，并且循环次数没有上限）。</p>
<p>显然，正确实现一个“无等待”数据结构极其困难。为了保证每个线程都能在有限的步骤内完成操作，开发者必须保证线程内的所有操作均能一次执行完毕，并且不会给其他线程带来负面影响。这些要求无疑增加了数据结构与算法的复杂程度。</p>
<hr>
<h1 id="无锁结构的优缺点"><a href="#无锁结构的优缺点" class="headerlink" title="无锁结构的优缺点"></a>无锁结构的优缺点</h1><p>&nbsp;<br>在学习无锁结构前我们已经充分强调了其实现复杂性，因此开发者在撰写前必须充分审度开发成本与性能收益。下文将简单叙述无锁结构的优缺点，以供权衡。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>归根结底，使用无锁结构的主要原因在于并发最大化。在使用基于锁的数据结构时，一个线程总会阻塞某个节点并等待另一个线程完成操作（此即为互斥）。无锁结构可以保证某些线程持续性向前推进，而无等待结构则能保证所有线程均能有效向前推进（尽管很难实现）。</p>
<h3 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h3><p>若一个线程在持有锁时死亡，那么数据结构将会遭到永久性破坏。但无锁结构可以规避这一点，仅有当前死亡的线程数据被丢失。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="开发成本"><a href="#开发成本" class="headerlink" title="开发成本"></a>开发成本</h3><p>如果不能让线程互斥地访问数据结构，那开发者必须严格地关注与维持不变量。为了避免和数据竞争相关的未定义行为，开发者必须在修改时使用原子操作，并且确保修改以正确的顺序对其他线程可见。上述要求意味着极大的开发成本与心智投入。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>无锁编程不会导致死锁，但可能造成活锁（live lock）——多个线程试图同时修改数据结构，此时线程不断循环与重试，导致性能降低。无等待算法不存在活锁问题，但必然其算法复杂性更高（可能需要更多步骤来完成相应操作）。</p>
<p>无锁结构虽然提高了操作并发的潜力，减少了单个线程的等待时间，但其可能会导致整体性能下降，理由如下：</p>
<ol>
<li>无锁代码中的原子操作比非原子操作要慢得多，并且很可能无锁数据结构中原子操作大大多于基于锁的数据结构中互斥锁锁住的代码。</li>
<li>访问相同原子变量的硬件必须在线程间同步，这会导致严重的性能损耗。</li>
</ol>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计无锁并发数据结构——无锁结构实例</title>
    <url>/2021/08/04/%E8%AE%BE%E8%AE%A1%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%97%A0%E9%94%81%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>为了演示一些在设计无锁数据结构中用到的技术，本节将给出一系列简单数据结构的无锁实现。<br>如前文所述，无锁结构依赖原子操作和相关的内存顺序保证来确保数据以正确的顺序对其他线程可见。在本节之初，所有的原子操作将使用默认的<code>memory_order_seq_cst</code>内存顺序，因为它最好理解(所有的<code>memory_order_seq_cst</code>操作构成一个全序)，但后续将逐渐减少约束至<code>memory_order_acquire</code>，<code>memory_order_release</code>，甚至<code>memory_order_relaxed</code>。<br>虽然实例中没有直接使用互斥锁，但需要注意，仅有<code>std::atomic_flag</code>保证无锁实现。如<code>C++内存模型与原子类型操作</code>一章所述，在某些平台上C++标准库内的原子类型可能是基于锁实现的，此时倒不如选择直接使用基于锁的数据结构。<br><a id="more"></a></p>
<hr>
<h1 id="无锁线程安全栈"><a href="#无锁线程安全栈" class="headerlink" title="无锁线程安全栈"></a>无锁线程安全栈</h1><p>&nbsp;<br>栈的最简底层结构是链表，其内部维持一个<code>head</code>节点指向当前栈顶。</p>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>在上述方案下，添加一个节点有步骤如下：</p>
<ol>
<li>创建一个新节点。</li>
<li>设置它的next指针指向当前的head节点。 </li>
<li>设置head节点指向新节点。</li>
</ol>
<h3 id="条件竞争分析与解决"><a href="#条件竞争分析与解决" class="headerlink" title="条件竞争分析与解决"></a>条件竞争分析与解决</h3><p>单线程下上述步骤没有问题，但当有两个线程同时添加节点时，第2步与第3步之间会产生竞争条件:在线程1执行第2步读取<code>head</code>的值和第3步更新<code>head</code>的值之间，线程2可能会修改<code>head</code>的值——这会导致其他线程的修改被丢弃，或造成更加严重的后果。在解决这个竞争条件之前，还需要注意一点:一旦<code>head</code>更新并指向了新节点，另一个线程就能读到这个节点。因此，在<code>head</code>设置为指向新节点前，新节点必须准备就绪——此后将无法修改此节点。</p>
<p>如何解决该条件竞争？答案是在第3步时使用原子的比较/交换操作，来确保步骤2读取到<code>head</code>以来，不会对<code>head</code>进行修改;若有修改，则循环后重试。有<code>push</code>代码实例如下。</p>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    node *next;</span><br><span class="line">    node(T <span class="keyword">const</span> &amp;data_) : data(data_) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;node *&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;data)</span> </span>&#123;</span><br><span class="line">    node *<span class="keyword">const</span> new_node = <span class="keyword">new</span> node(data);</span><br><span class="line">    new_node-&gt;next = head.load();</span><br><span class="line">    <span class="keyword">while</span> (!head.compare_exchange_weak(new_node-&gt;next, new_node));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>在本实例中，使用<code>compare_exchange_weak</code>以规避条件竞争：</p>
<ul>
<li>若被存储到<code>new_node-&gt;next</code>的<code>head</code>指针和之前load到的一样，<code>head</code>将被设置为<code>new_node</code>。</li>
<li>若返回false，意味着比较失败(<code>head</code>已被另一个线程修改)，此时参数1(<code>new_node-&gt;next</code>)将更新为<code>head</code>的最新值，并试图再次执行该循环。</li>
</ul>
<p>由于本次失败后将直接进行循环，因此我们使用比较/交换的weak版本而非strong版本，在某些架构上，前者效率优于后者（详见<code>C++内存模型与原子类型操作——原子操作与原子类型</code>一节）。</p>
<h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>pop的步骤在单线程下并不复杂：</p>
<ol>
<li>读取head的当前值保存到node。 </li>
<li>读取head-&gt;next。</li>
<li>设置head为head-&gt;next。</li>
<li>返回node中的数据。</li>
<li>删除node节点。</li>
</ol>
<h3 id="条件竞争分析与解决-1"><a href="#条件竞争分析与解决-1" class="headerlink" title="条件竞争分析与解决"></a>条件竞争分析与解决</h3><p>但在多线程场景下，两个线程可能在步骤1中读取到相同的<code>head</code>值。存在一种场景：线程1处理到步骤5时，线程2还在处理步骤2，这将导致线程2试图解引用空悬指针——为了规避此问题，只能跳过步骤5，泄漏该节点，但问题并没有解决——这两个线程将返回同一个节点，这不符合栈语义。<br>解决问题的思路类似于push操作:在步骤3处使用比较/交换操作更新head。当比较/交换操作失败时，不是一个新节点已被推入，就是另一个线程弹出了节点。无论是哪种情况，都得返回步骤1(比较/交换操作会重新读取head)。一旦比较/交换成功，则当前线程是从栈上弹出指定节点的唯一线程，此后即可执行步骤4。</p>
<h3 id="代码实例1"><a href="#代码实例1" class="headerlink" title="代码实例1"></a>代码实例1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; result)</span> </span>&#123;</span><br><span class="line">    node* old_head = head.load(); </span><br><span class="line">    <span class="keyword">while</span>(!head.compare_exchange_weak(old_head,old_head-&gt;next)); </span><br><span class="line">    result=old_head-&gt;data;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例1分析"><a href="#实例1分析" class="headerlink" title="实例1分析"></a>实例1分析</h3><p>实例1虽然仅有3行代码，但是问题却不少，以下将一一分析。<br>首先，这段代码在链表为空时将触发UB——当<code>head</code>是空指针时，尝试访问其next指针的行为未定义。解决方案很简单:在while循环内判空，并在空栈上抛出一个异常，或者pop函数返回一个bool 值来表明成功与否。<br>其次，这段代码存在异常安全问题。在前文中读者已经了解到拷贝对象作为返回值可能存在问题——若在拷贝返回值时如果抛出异常，该值将丢失（栈内没有，返回值也没有）。传入引用能解决该问题——至少异常发生时栈没有发生变更。但pop操作需要从栈上移除元素，因此通过引用获取返回值的方式并不可取——开发者依旧需要按值返回，那只能使用智能指针。智能指针意味着需要在堆上分配内存，但分配内存同样可能造成异常（此时又造成了数据丢失或pop失败），因此开发者可以在<code>push</code>内分配内存。</p>
<h3 id="代码实例2"><a href="#代码实例2" class="headerlink" title="代码实例2"></a>代码实例2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">    node *next;</span><br><span class="line"></span><br><span class="line">    node(T <span class="keyword">const</span> &amp;data_) : data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;node *&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;data)</span> </span>&#123;</span><br><span class="line">    node *<span class="keyword">const</span> new_node = <span class="keyword">new</span> node(data);</span><br><span class="line">    new_node-&gt;next = head.load();</span><br><span class="line">    <span class="keyword">while</span> (!head.compare_exchange_weak(new_node-&gt;next, new_node));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node *old_head = head.load();</span><br><span class="line">    <span class="keyword">while</span> (old_head &amp;&amp; !head.compare_exchange_weak(old_head, old_head-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> old_head ? old_head-&gt;data : <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例2分析"><a href="#实例2分析" class="headerlink" title="实例2分析"></a>实例2分析</h3><p>需要注意一点，尽管该栈结构是无锁的，但并非无等待。因为只要<code>compare_exchange_weak</code>保持失败，push和pop函数中的while循环理论上可以无限循环下去。</p>
<hr>
<h1 id="在无锁数据结构中管理内存"><a href="#在无锁数据结构中管理内存" class="headerlink" title="在无锁数据结构中管理内存"></a>在无锁数据结构中管理内存</h1><p>&nbsp;<br>在上一小节中，为了避免当线程A删除某节点的同时，线程B还持有指向该节点的指针并需要解引用导致竞争条件，我们选择了泄漏节点。对于C++开发者而言，内存泄漏是不可接受的，本小节将致力于解决该问题。</p>
<p>该问题的核心在于如何保证释放节点时没有其他线程持有该节点。可能访问指定节点的线程只有2种：</p>
<ol>
<li>把节点添加到栈中的线程</li>
<li>调用<code>pop</code>的线程</li>
</ol>
<p>所有节点均在<code>push</code>内创建，一旦节点入栈，<code>push</code>将不再触碰该节点，此时仅剩下调用<code>pop</code>的线程——如果只有一个这样的线程，那么删除该节点是安全的。</p>
<p>当然，并发场景下往往是同一个栈实例上存在多个线程调用<code>pop</code>，此时我们需要为节点写一个专用GC，虽然听起来很麻烦，但实际上也还算凑活：只需要检查哪些被<code>pop</code>访问到的节点即可。该GC的任务如下:将所有待删除节点推入队列，若当前无任何进程执行<code>pop</code>，则安全清除队列内所有节点。GC内部持有一个原子变量，用以统计当前进入pop的线程。根据以上需求，有<code>pop</code>修订版如下。</p>
<h2 id="pop实例"><a href="#pop实例" class="headerlink" title="pop实例"></a>pop实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span>&gt; threads_in_pop;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">try_reclaim</span><span class="params">(node *old_head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++threads_in_pop; <span class="comment">// 增加计数</span></span><br><span class="line">    node *old_head = head.load();</span><br><span class="line">    <span class="keyword">while</span> (old_head &amp;&amp; !head.compare_exchange_weak(old_head, old_head-&gt;next));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">      res.swap(old_head-&gt;data); <span class="comment">// 交换而非拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">    try_reclaim(old_head); <span class="comment">// 尝试回收删除的节点，递减计数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要关注的点在于：数据的传出使用了<code>swap</code>而非单纯拷贝，原因很简单——旧节点已经无需再持有数据，如果拷贝的话，数据的引用计数+1，从而致使即使<code>pop</code>调用方已经完成数据使用，数据仍未能立即释放（压入待删除队列的节点依然持有数据）—— 本质上是分离了节点与数据的生命周期。</p>
<h2 id="try-reclaim实例"><a href="#try-reclaim实例" class="headerlink" title="try_reclaim实例"></a>try_reclaim实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;node *&gt; to_be_deleted;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_nodes</span><span class="params">(node *nodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nodes) &#123;</span><br><span class="line">      node *next = nodes-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> nodes;</span><br><span class="line">      nodes = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">try_reclaim</span><span class="params">(node *old_head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threads_in_pop == <span class="number">1</span>) &#123;</span><br><span class="line">      node *nodes_to_delete = to_be_deleted.exchange(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == --threads_in_pop) &#123; <span class="comment">// 3</span></span><br><span class="line">        delete_nodes(nodes_to_delete);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodes_to_delete) &#123;</span><br><span class="line">        chain_pending_nodes(nodes_to_delete); <span class="comment">// 2</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> old_head; <span class="comment">// 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      chain_pending_node(old_head);</span><br><span class="line">      --threads_in_pop;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node *nodes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取链表尾部</span></span><br><span class="line">    node *last = nodes;</span><br><span class="line">    <span class="keyword">while</span> (node * <span class="keyword">const</span> next = last-&gt;next) &#123;</span><br><span class="line">      last = next;</span><br><span class="line">    &#125;</span><br><span class="line">    chain_pending_nodes(nodes, last);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新待删除列表</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node *first, node *last)</span> </span>&#123;</span><br><span class="line">    last-&gt;next = to_be_deleted;</span><br><span class="line">    <span class="keyword">while</span> (!to_be_deleted.compare_exchange_weak(last-&gt;next, first));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">chain_pending_node</span><span class="params">(node *n)</span> </span>&#123;</span><br><span class="line">    chain_pending_nodes(n, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h2><p>若当前仅有一个线程在<code>pop</code>内，则此时可安全删除待移出节点（步骤1）。若当前存在多个线程在<code>pop</code>内，删除任何节点均不安全，因此将当前节点添加至未决（pending）链表。</p>
<p>若当前仅有一个线程在<code>pop</code>内，需要尝试回收所有的未决节点（如前文所说，当前节点必然被回收）。首先通过原子<code>exchange</code>操作获取未决链表，并递减计数，若此时计数为0，则意味着可安全删除链表内所有内容（虽然删除时可能会出现新的未决节点）。若计数递减后不为0(此时存在其他线程在获取<code>threads_in_pop</code>和获取链表之间调用<code>pop</code>），则需要将未决节点加入未决链表内(步骤2），具体情形可见下图。</p>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>如图，线程C添加节点Y到<code>to_be_deleted</code>链表，而此时线程B仍在通过old_head引用它，并且尝试读其next指针。因此线程A必须再次效验<code>threads_in_pop</code>，否则将误删节点。<br><img src="http://static.zybuluo.com/zsmj2017/0mf5wmeqjpva3wl6p82gzoke/image.png" alt="sth"><br><img src="http://static.zybuluo.com/zsmj2017/znsinrqgczs44hfrs1pdn84b/image.png" alt="image.png-589.8kB"></p>
<h2 id="方案优劣"><a href="#方案优劣" class="headerlink" title="方案优劣"></a>方案优劣</h2><p>在低负载场景下，这一方案运行良好，因为总有时间点没有线程运行<code>pop</code>。但这些时间点稍纵即逝，这直接导致了：</p>
<ol>
<li>回收前，需要效验<code>threads_in_pop</code>计数为0</li>
<li>在delete（步骤1）前执行效验</li>
</ol>
<p>删除节点是一个耗时的操作，因此线程修改链表的时间窗口越小越好。从第一次发现<code>threads_in_pop == 1</code>到尝试删除节点耗费的时间越长，就越有可能有另一个线程会调用<code>pop</code>，导致此线程看见的<code>threads_in_pop</code>不再等于1，从而无法直接删除节点。</p>
<p>在高负载场景下，可能永远不会存在能回收节点的时间点，此时链表将会无限增长，导致再次泄漏内存。</p>
<hr>
<h1 id="使用风险指针检测不可回收的节点"><a href="#使用风险指针检测不可回收的节点" class="headerlink" title="使用风险指针检测不可回收的节点"></a>使用风险指针检测不可回收的节点</h1><p>&nbsp;<br>“风险指针”这个术语引自Maged Michael发现的一项技术。其基本思想为，如果线程A准备访问线程B想要删除的对象，A将设置风险指针来引用此对象，然后通知其他线程使用这个指针是危险的。一旦不再需要此对象，则可清除风险指针。以划船比赛机制举例——比赛开始（删除对象）前，每个船上的舵手可以举手示意他们还没有准备好。只要有舵手举手，裁判就不能开始比赛。当所有舵手把手放下后，比赛才能开始，舵手可以在比赛开始前随意举手，无次数限制。</p>
<h2 id="pop实例-1"><a href="#pop实例-1" class="headerlink" title="pop实例"></a>pop实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;T&gt; pop() &#123;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span> *&gt; &amp;hp = get_hazard_pointer_for_current_thread();</span><br><span class="line">    node *old_head = head.load();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node *temp;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            temp = old_head;</span><br><span class="line">            hp.store(old_head);</span><br><span class="line">            old_head = head.load();</span><br><span class="line">        &#125; <span class="keyword">while</span> (old_head != temp); <span class="comment">// 一直循环，直到将风险指针设为head</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (old_head &amp;&amp; !head.compare_exchange_strong(old_head, old_head-&gt;next)); <span class="comment">// 1 重新设置head</span></span><br><span class="line">    hp.store(<span class="literal">nullptr</span>); <span class="comment">// 取出头结点后，清除风险指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">        res.swap(old_head-&gt;data);</span><br><span class="line">        <span class="comment">// 在删除之前检查是否有风险指针引用该节点(因为在上面那个内部循环中可能多个线程都把某个head设置为自己线程的风险指针)</span></span><br><span class="line">        <span class="keyword">if</span> (outstanding_hazard_pointers_for(old_head))</span><br><span class="line">        &#123;</span><br><span class="line">            reclaim_later(old_head); <span class="comment">// 加入链表内，稍后删除</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> old_head;</span><br><span class="line">        &#125;</span><br><span class="line">        delete_nodes_with_no_hazards();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h2><p>首先，设置风险指针的循环置于外部循环1内，该外部循环会在“比较/交换”操作失败的时候重新加载old_head，需要注意这里使用了<code>compare_exchange_strong</code>，因为在while循环内部有事可做(若使用<code>compare_exchange_weak</code>伪失败后，会导致不必要地重新设置风险指针）。若已成功取出节点，此时即可清除风险指针，并检查当前节点是否为其他线程的风险指针。若是，则置于链表内，留待后续回收;否则立刻删除节点。最后<code>delete_nodes_with_no_hazards</code>将检测所有由<code>reclaim_later</code>收集的节点，若当前没有任何风险指针引用这些节点，则可安全删除这些节点，否则留待下一个调用pop的线程继续检测。</p>
<h2 id="get-hazard-pointer-for-current-thread的简单实现"><a href="#get-hazard-pointer-for-current-thread的简单实现" class="headerlink" title="get_hazard_pointer_for_current_thread的简单实现"></a>get_hazard_pointer_for_current_thread的简单实现</h2><p><code>get_hazard_pointer_for_current_thread</code>的具体实现方案对程序逻辑影响不大。目前可以先设计一个简单（但不高效）的结构:一个定长数组，其元素类型是一个KV对——K是线程ID，V为风险指针。通过搜索这个数组来找到空闲槽位，并设置KV对。当线程退出时，重置ID为默认值，表征该槽位已空闲。具体实例如下。</p>
<h3 id="get-hazard-pointer-for-current-thread实例"><a href="#get-hazard-pointer-for-current-thread实例" class="headerlink" title="get_hazard_pointer_for_current_thread实例"></a>get_hazard_pointer_for_current_thread实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">const</span> max_hazard_pointers = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hazard_pointer</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::atomic &lt;<span class="built_in">std</span>::thread::id&gt; id&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span> *&gt; pointer&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">hazard_pointer hazard_pointers[max_hazard_pointers];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hp_owner</span> &#123;</span></span><br><span class="line">    hazard_pointer *hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    hp_owner(hp_owner <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    hp_owner <span class="keyword">operator</span>=(hp_owner <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    hp_owner() :</span><br><span class="line">            hp(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; hazard_pointer : hazard_pointers) &#123;</span><br><span class="line">            <span class="built_in">std</span>::thread::id old_id;</span><br><span class="line">             <span class="comment">// 找到第一个空闲槽位</span></span><br><span class="line">            <span class="keyword">if</span> (hazard_pointer.id.compare_exchange_strong(old_id, <span class="built_in">std</span>::this_thread::get_id())) &#123;</span><br><span class="line">                hp = &amp;hazard_pointer;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"No hazard pointers available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span> *&gt; &amp;<span class="title">get_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hp-&gt;pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~hp_owner() &#123;</span><br><span class="line">        hp-&gt;pointer.store(<span class="literal">nullptr</span>);</span><br><span class="line">        hp-&gt;id.store(<span class="built_in">std</span>::thread::id());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span> *&gt; &amp;<span class="title">get_hazard_pointer_for_current_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">static</span> hp_owner hazard;</span><br><span class="line">    <span class="keyword">return</span> hazard.get_pointer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前指针是否为风险指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">outstanding_hazard_pointers_for</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; max_hazard_pointers; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hazard_pointers[i].pointer.load() == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例分析-3"><a href="#实例分析-3" class="headerlink" title="实例分析"></a>实例分析</h3><p><code>get_hazard_pointer_for_current_thread</code>的实现如下:它有一个hp_owner类型的thread_local变量，用来存储当前线程的风险指针。每个线程第一次调用这个函数时，一个新的<code>hp_owner</code>实例被创建，该实例将通过<code>compare_exchange_strong</code>获取空闲槽位，停止搜索，若遍历完毕尚未找到空闲槽位，则抛出异常。显然，这种遍历对工作线程只需要一次，<code>hp_owner</code>承载了缓存的作用。当线程退出时其专属的<code>hp_owner</code>实例将被销毁，数组内将新增一个空闲槽位。</p>
<h2 id="回收实例"><a href="#回收实例" class="headerlink" title="回收实例"></a>回收实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;T *&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_to_reclaim</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span> *)&gt; deleter;</span><br><span class="line">    data_to_reclaim *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    data_to_reclaim(T *p): data(p), deleter(&amp;do_delete&lt;T&gt;), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~data_to_reclaim() &#123; deleter(data); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;data_to_reclaim *&gt; nodes_to_reclaim; <span class="comment">// 回收链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_reclaim_list</span><span class="params">(data_to_reclaim *node)</span> </span>&#123;</span><br><span class="line">    node-&gt;next = nodes_to_reclaim.load();</span><br><span class="line">    <span class="keyword">while</span> (!nodes_to_reclaim.compare_exchange_weak(node-&gt;next, node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reclaim_later</span><span class="params">(T *data)</span> </span>&#123;</span><br><span class="line">    add_to_reclaim_list(<span class="keyword">new</span> data_to_reclaim(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_nodes_with_no_hazards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data_to_reclaim *current = nodes_to_reclaim.exchange(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        data_to_reclaim *<span class="keyword">const</span> next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!outstanding_hazard_pointers_for(current-&gt;data)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add_to_reclaim_list(current);</span><br><span class="line">        &#125;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例分析-4"><a href="#实例分析-4" class="headerlink" title="实例分析"></a>实例分析</h3><p>首先，以<code>data_to_reclaim</code>作为链表内的元素类型，其构造函数是一个函数模板（主要是为了支持各类型的deleter）。<code>reclaim_later</code>的职责很简单——将该指针构建为<code>data_to_reclaim</code>类型后添加至链表内。</p>
<p><code>delete_nodes_with_no_hazards</code>使用<code>exchange</code>函数获取需要回收的整个链表。这个简单但很关键的步骤确保了只有一个线程回收该链表。其他线程现在自由地将其他节点添加到新回收链表中，甚至尝试对节点进行回收，而不影响本回收线程。当获取到链表头后，遍历该链表内节点，若该节点为非风险指针，则可安全删除，否则将该节点重新置于回收链表内（已不再是本链表）。</p>
<p>虽然这个简单的实现确实安全地回收了被删除的节点，不过开销极大。每次<code>pop</code>调用都需要扫描一次风险指针数组，这意味着检查max_hazard_pointers个原子变量。原子操作本来就慢(在台式CPU上，原子操作比非原子操作慢100倍)。每一次调用<code>outstanding_hazard_pointers_for</code>时开发者需要意识到：可能会有max_hazard_pointers个节点在链表中，并且它们需要和max_hazard_pointers个存储的风险指针做比较。是时候做性能优化了。</p>
<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>上文只是描述了一个简单的风险指针实现，用以辅助解释该技术。以下将简单介绍一些优化点。<br>首先可以用内存换性能。不同于每次调用<code>pop</code>都检查回收链表上的每个节点，如果一直等到2&times;max_hazard_pointers个节点在链表中时，由于最多有max_hazard_pointers个节点是活跃的，即可保证至少有max_hazard_pointers个节点可以被回收，并且再次尝试回收任意节点前，至少会对<code>pop</code>有 max_hazard_pointer次调用。比起每次<code>pop</code>调用检查大约max_hazard_pointers个节点(不一定能回收到节点)，每max_hazard_pointers次<code>pop</code>调用，检查2&times;max_hazard_pointers个节点，就会有max_hazard_pointers个节点可回收。这等价于<code>pop</code>调用检查两个节点，其中有一个被回收。<br>不过，这个方案不仅使得回收链表增加了内存使用，同时还增加了计数需求，这意味着需要使用原子计数器，并且有多线程争竞争访问回收链表本身。当然，如果内存充裕，可以考虑令每个线程通过线程局部变量，持有自己的回收链表，如果一个线程在它的所有节点被回收前退出，它的本地链表可以像之前一样存储到全局链表中，然后添加到下一个线程的本地回收链表内，令该线程执行回收操作。</p>
<hr>
<h1 id="使用引用计数检测节点是否在使用"><a href="#使用引用计数检测节点是否在使用" class="headerlink" title="使用引用计数检测节点是否在使用"></a>使用引用计数检测节点是否在使用</h1><p>&nbsp;<br>区别于风险指针通过把使用中的节点存储到链表中，引用计数通过统计每个节点上访问的线程数量来判断当前节点是否正在被使用。</p>
<h2 id="使用std-shared-ptr"><a href="#使用std-shared-ptr" class="headerlink" title="使用std::shared_ptr"></a>使用std::shared_ptr</h2><p>理论上我们可以直接使用<code>std::shared_ptr&lt;&gt;</code>完成引用计数，但需要注意一点，在部分平台上，<code>std::shared_ptr&lt;&gt;</code>并不保证无锁，尽管其部分操作能够保证原子性。毕竟标准库中的<code>std::shared_ptr&lt;&gt;</code>旨在广泛用于多种上下文内，令其原子操作无锁可能会带来额外的开销。</p>
<p>若我们运气足够好，本平台<code>std::atomic_is_lock_free(&amp;some_shared_ ptr)</code>返回true，那实现就简单多了，具体实例如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt; next;</span><br><span class="line"></span><br><span class="line">        node(T <span class="keyword">const</span> &amp;data_) :</span><br><span class="line">                data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt; <span class="keyword">const</span> new_node = <span class="built_in">std</span>::make_shared&lt;node&gt;(data);</span><br><span class="line">        new_node-&gt;next = <span class="built_in">std</span>::atomic_load(&amp;head);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">std</span>::atomic_compare_exchange_weak(&amp;head,</span><br><span class="line">                                                  &amp;new_node-&gt;next, new_node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt; old_head = <span class="built_in">std</span>::atomic_load(&amp;head);</span><br><span class="line">        <span class="keyword">while</span> (old_head &amp;&amp; !<span class="built_in">std</span>::atomic_compare_exchange_weak(&amp;head,</span><br><span class="line">                                                              &amp;old_head, old_head-&gt;next));</span><br><span class="line">        <span class="keyword">if</span> (old_head) &#123;</span><br><span class="line">            <span class="built_in">std</span>::atomic_store(&amp;old_head-&gt;next, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;node&gt;()); <span class="comment">// 避免当最后一个std::shared_ptr引用的给定节点被销毁时，删除后续数据，因此需要清空next指针</span></span><br><span class="line">            <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~lock_free_stack() &#123;</span><br><span class="line">        <span class="keyword">while</span> (pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="手动管理引用计数"><a href="#手动管理引用计数" class="headerlink" title="手动管理引用计数"></a>手动管理引用计数</h2><p>一种技术是对每个节点使用两个而不是一个引用计数:一个内部计数和一个外部计数，两个值的和就是对这个节点的引用总数。<br>外部计数与指向节点的指针一起保存，并且每次读取指针的时候外部计数增加。当读线程使用完节点后，递减内部计数。一个读指针操作完成后，外部计数将加1，内部计数会减1。<br>当不再需要外部计数&amp;&amp;指针时(该节点不再位于可以被多个线程访问的位置)，内部计数将加上外部计数-1的值，并丢弃外部计数。若此时内部计数等于0，则认为没有对该节点的引用，可以将该节点安全的删除。</p>
<h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">counted_node_ptr</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> external_count;</span><br><span class="line">        node *ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">        <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; internal_count;</span><br><span class="line">        counted_node_ptr next;</span><br><span class="line"></span><br><span class="line">        node(T <span class="keyword">const</span> &amp;data_) : data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_)), internal_count(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;counted_node_ptr&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~lock_free_stack() &#123;</span><br><span class="line">        <span class="keyword">while</span> (pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp;data)</span> </span>&#123;</span><br><span class="line">        counted_node_ptr new_node;</span><br><span class="line">        new_node.ptr = <span class="keyword">new</span> node(data);</span><br><span class="line">        new_node.external_count = <span class="number">1</span>;</span><br><span class="line">        new_node.ptr-&gt;next = head.load();</span><br><span class="line">        <span class="keyword">while</span> (!head.compare_exchange_weak(new_node.ptr-&gt;next, new_node));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase_head_count</span><span class="params">(counted_node_ptr &amp;old_counter)</span> </span>&#123;</span><br><span class="line">        counted_node_ptr new_counter;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            new_counter = old_counter;</span><br><span class="line">            ++new_counter.external_count;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.compare_exchange_strong(old_counter, new_counter));</span><br><span class="line">        old_counter.external_count = new_counter.external_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counted_node_ptr old_head = head.load();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            increase_head_count(old_head);</span><br><span class="line">            node *<span class="keyword">const</span> ptr = old_head.ptr;</span><br><span class="line">            <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">                <span class="comment">// 理论上需要减少该节点的外部计数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.compare_exchange_strong(old_head, ptr-&gt;next)) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res;</span><br><span class="line">                res.swap(ptr-&gt;data);</span><br><span class="line">                <span class="keyword">int</span> <span class="keyword">const</span> count_increase = old_head.external_count - <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;internal_count.fetch_add(count_increase) == -count_increase) &#123; <span class="comment">// 引用计数和为0</span></span><br><span class="line">                    <span class="keyword">delete</span> ptr;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该节点已不再是head节点，需要重新读取，此时令该节点内部计数-1</span></span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;internal_count.fetch_sub(<span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 节点已被删除</span></span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p>首先，外部计数和节点指针一起包装在<code>counted_node_ptr</code>结构中，并作为<code>node</code>结构的next指针，同时<code>node</code>内持有内部计数。因为counted_node_ptr是一个简单的结构体，因此可以和std::atomic&lt;&gt;模板一起用作链表的head。在支持“双字比较和交换”（double-word-compare-and-swap）操作的平台上，由于这个结构体足够小，因此std::atomic<counted_node_ptr>支持无锁。若当前平台不支持的话，则只能使用<code>std::shared_ptr</code>作为引用计数工具。当类型的体积对平台的原子指令来讲太大的话，std::atomic&lt;&gt;将使用互斥锁来保证其操作的原子性(使“无锁”算法退化为“基于锁”的算法)。又或者，限制计数器大小，将其填充至指针内空余的bit位(比如，地址空间只有48位，而一个指针占64位。例如intel平台)，这样就可以塞进一个机器字当中。</p>
<p><code>push</code>很简单——构造了一个counted_node_ptr实例，引用新分配出来带有相关数据的node，并将node的next指针设置为当前head。此时internal_count为0，external_count为1（这是一个新节点，当前只有一个外部引用指向它，也就是head指针本身)。</p>
<p><code>pop</code>操作相对复杂一些。一旦加载了head的值，首先必须增加对head节点的外部引用计数，以表明正在引用这个节点并且确保解引用是安全的。如果在引用计数增加前解引用指针，另一个线程可能在你访问这个节点之前释放它，从而使你持有一个空悬指针。这就是使用内外引用计数的主要原因:通过增加外部引用计数，保证了指针在访问期间是有效的。递增操作通过compare_exchange_strong循环完成，该循环保证了指针不会在同一时间内被另一个线程修改。<br>一旦计数增加，则可安全地解引用head值的ptr字段，以便访问指向的节点。如果指针为空，说明此时链表为空，否则尝试对head调用compare_exchange_strong以移除该节点。</p>
<ol>
<li>若compare_exchange_strong成功，则意味着此时该线程掌握了节点所有权，可置换出data数据。此后使用原子操作fetch_add将外部计数加到内部计数。若此时引用计数为0，那么之前的值(fetch_add返回值)则为增加值的负数，此时可安全删除节点。需要注意的是，增加的值要比外部引用计数少2——节点已经从链表中删除，需要将外部计数-1，并且由于不再从这个线程访问节点，因此内部计数-1。无论是否删除节点，操作都已经完成，因此直接返回数据。</li>
<li>若compare_exchange_strong失败，则说明另一个线程已移除了该节点，或者另一个线程添加了一个新的节点到栈中。无论是何种情况，都需要用compare_exchange_strong返回的新的head值再次启动操作。不过，首先需要递减尝试移除的节点上的引用计数，因为该线程不会再访问此节点。如果当前线程是最后一个持有引用(另一个线程已经将这个节点从栈上移除了)的线程，此时内部引用为1，减1后为0，此时判定节点可安全删除。</li>
</ol>
<hr>
<h1 id="应用内存模型顺序至无锁栈"><a href="#应用内存模型顺序至无锁栈" class="headerlink" title="应用内存模型顺序至无锁栈"></a>应用内存模型顺序至无锁栈</h1><p>&nbsp;<br>目前为止，本文实例一直使用默认的<code>std::memory_order_seq_cst</code>内存顺序。在大多数系统上，<code>std::memory_order_seq_cst</code>在执行时间和同步开销方面比其他内存顺序更为昂贵，也许是时候做进一步优化了~</p>
<p>在对内存顺序做优化之前，首先需要明确数据结构的使用场景，<br>在修改内存顺序之前，定提供所需关系的最小内存顺序。为了做到这一点，需要在几种不同的场景中从线程的视 角查看相关情况。最简单的场景是一个线程将数据项推入栈，然后另一个线程在一段时间 过后弹出数据项，因此我们将从这开始。</p>
]]></content>
      <categories>
        <category>C++并发编程实战</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>22.该返回对象时则返回对象</title>
    <url>/2018/04/12/%E8%AF%A5%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%88%99%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>pass-by-reference固然很好，但是实际应用时可能会发生一些很尴尬的场景，比如reference指向并不存在的对象。<br>具体而言，就是你试图用一个reference去绑定一个局部变量（local对象），这直接引发了雪崩。</p>
<p>可能你会在函数内部定义一个static对象，并用一个reference去绑定它，最终返回一个指向static对象的reference。在多线程下这种操作极易导致安全问题，并且它还有更致命的错误。举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                          <span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">static</span> Rational res;</span><br><span class="line">        res = ...;<span class="comment">//乘法操作</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们试图去使用operator<em>时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational a,b,c,d;</span><br><span class="line"><span class="keyword">if</span>(a*b)==(c*d)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>事实上if判定永远是true，因为​reference是static对象的别名，而那个对象和自己比对必然是相等的（虽然两次operator</em>的确各自改变了它的值，但最终仅返回了最终修改后的对象的reference）</p>
<p>固执的人可能会试图去使用static array.. 这比使用static对象还要令人发指。首先无法判定array的大小，小了不够用，多了又浪费。而且n太大了还会造成效率低下（执行了n次构造与析构）。这个愚蠢的想法无法优化，就算把array换成vector也不会改善情况</p>
<p>因此，不如就坦然地返回一个新对象，值得注意的是这里可以配合返回值优化使构造与析构的成本降到最低：(返回值优化详见 More Effective C++ 20)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">       <span class="keyword">return</span> Rational(...);<span class="comment">//返回值优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络与互联网</title>
    <url>/2020/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91/</url>
    <content><![CDATA[<p>本篇为《Computer Network-A Top-Down Approach》第一章读书笔记。</p>
<a id="more"></a>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>连接至计算机网络的计算设备被称为<strong>主机（hosts）</strong>或<strong>终端（end system）</strong>。<ul>
<li>终端间通过<strong>通信链路（communication link）</strong>与<strong>分组交换机（packet switch）</strong>相连。<ul>
<li>通信链路由同轴电缆，光纤，双绞线等物理媒介构成，其传输速率被定义为bits/second。</li>
<li>路由器（router）与链路层交换机（link-layer switch）均属于分组交换机。</li>
</ul>
</li>
</ul>
</li>
<li>终端通过<strong>ISP（Internet Service Provider）</strong>提供的服务连接至互联网。</li>
<li>计算机网络中信息的收发均遵从<strong>协议（protocols）</strong>, <strong>TCP（Transmission Control Protocol ）与 Internet Protocol (IP)</strong> 是其中最重要的两个。</li>
<li>为了保证所有人都遵从协议，IETF（Internet Engineering Task Force）制定了互联网标准（Internet standard）。</li>
<li>分布式应用程序（distributed application）——包含多个彼此交换数据的终端。</li>
<li>连接至互联网的终端，通<strong>过套接字接口（Socket Interface）</strong>指定数据如何传递至另一个终端上的特定应用程序。</li>
<li>协议是实体间为完成通信所必须遵从的规则，它包含了信息格式，信息顺序，以及发送/接受信息所必须执行的操作。</li>
</ul>
<hr>
<h1 id="网络边沿"><a href="#网络边沿" class="headerlink" title="网络边沿"></a>网络边沿</h1><ul>
<li>接入网络（access network）——将终端系统以物理方式连接到首个路由器的网络。<ul>
<li>原书对诸如DSL,FTTH及各物理媒介的介绍与对比不再赘述。</li>
<li>接入网络在网络体系中的位置如图中蓝色高亮所示。<br><img src="http://static.zybuluo.com/zsmj2019/de8blil0iqur1lod8pehp0il/WX20200504-143411@2x.png" alt="WX20200504-143411@2x.png-696.6kB"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><p>本节所研究内容如下图蓝色高亮位置所示。<br><img src="http://static.zybuluo.com/zsmj2019/ojdknbtilpd7n5c0zhr7aeup/WX20200504-144038@2x.png" alt="WX20200504-144038@2x.png-712.9kB"></p>
<ul>
<li>分组交换（packet switch）：终端间通过<strong>报文（message）</strong>通信，较长的报文将被切割为<strong>分组/包（packet）</strong><ul>
<li>存储-转发（store-and-forward transmission）机制：交换机仅在接收完<strong>整个</strong>包后才开始向外发送数据，这造成了一定的时延。</li>
<li>排队时延（Queuing Delay）与丢包（Packet Loss）：每一个交换机均持有一个<strong>输出队列</strong>（output queue），所有待发送包均需在此队列中排队（当前通信链路正忙于发送数据），若<strong>队列已满</strong>时到达了新包，新包将被<strong>丢弃</strong>。</li>
<li>在因特网中，IP地址的多级结构信息和路由器的<strong>转发表（forwarding table）</strong>，决定了路由器拿到包后送往哪条链路，转发表是由路由选择协议自动设置的。</li>
</ul>
</li>
<li>电路交换（Circuit Switch）：另一种端与端通信手段，特点是源和目标点建立起名副其实的连接，称为电路，这条路上的带宽全部为这个连接空出来，所以电路交换的速度非常可靠（电话就采用了这种通信方式）。<ul>
<li>频分复用，时分复用等不再赘述。 </li>
</ul>
</li>
<li>分组交换 VS 电路交换：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">电路交换</th>
<th style="text-align:center">分组交换</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实现</td>
<td style="text-align:center">复杂，成本高</td>
<td style="text-align:center">简单,成本低</td>
</tr>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center">可靠</td>
<td style="text-align:center">延时不可预测</td>
</tr>
<tr>
<td style="text-align:center">利用率</td>
<td style="text-align:center">低，有空闲浪费</td>
<td style="text-align:center">高，可共享空闲资源</td>
</tr>
<tr>
<td style="text-align:center">特点</td>
<td style="text-align:center">专线专用</td>
<td style="text-align:center">共享路由</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ISP架构图：<br>其中IXP （Internet Exchange Point）用以令各ISP相互peer。<br><img src="http://static.zybuluo.com/zsmj2019/7nwbcb17m4o0j3c5ez2pt7q4/WX20200504-184743@2x.png" alt="WX20200504-184743@2x.png-244.8kB"></li>
</ul>
<hr>
<h1 id="时延，丢包与吞吐量"><a href="#时延，丢包与吞吐量" class="headerlink" title="时延，丢包与吞吐量"></a>时延，丢包与吞吐量</h1><ul>
<li>分组交换中时延的分类<ul>
<li>处理时延（Processing Delay）：<strong>检查分组首部和决定将该分组导向何处</strong>，是节点处理时延（nodal processing delay）的一部分，其他部分有包括检查比特级差错处理（通常是微秒级以下）等。在这之后，路由器将包引向通往路由器B链路之前的队列。</li>
<li>排队时延（Queuing Delay）：在队列中，当分组在链路缓存中<strong>等待传输</strong>时，它经受排队时延。 到达组的分组数量是到达该队列的流量强度的函数。实际的排队时延通常在毫秒到微秒级。 </li>
<li>传输时延（Transmission Delay）：假定包长度为L，从路由器A到路由器B的链路传输速率为R （b/s），则有传输时延L/R。这是<strong>将所有比特推向链路所需要的时间</strong>。实际的传输时延通常在毫秒到微秒级。传输时延与包体长度正相关，与路由间距无关。 </li>
<li>传播时延（Propagation Delay）：一旦一个比特被A推向链路向路由器B传播，从该链路的<strong>起点到路由器B的传播所需要的时间</strong>为传播时延，其速率范围等于或略小于光速，时延范围在毫秒级。传播时延等于两台路由器之间的距离d除以传播速率s。 </li>
<li><strong>传输时延与传播时延的区别</strong>：传输时延可以看做是车队（包）过收费站（路由器）的时间（车队头需要等待车队尾通过），而传播时延可看作在高速上花费的时间。</li>
<li>节点总时延 = 处理时延（可忽略） + 排队时延 + 传输时延 + 传播时延。</li>
</ul>
</li>
<li>排队时延与丢包<ul>
<li>流量强度（ traffic intensity）：假定包（packet）进入队列的速率为a（packets/sec）,当前所有包总长度为L（bits）,链路传输速度为R，则有流量强度=La/R。<ul>
<li>如果La/R &gt; 1，则意味着队列进入端速度大于流出端速度，此时排队时延将趋向无穷大。因此，流量工程中设计系统时流量强度不能大于1。在因特网中，接近1时将容易发生丢包。</li>
<li>若La/R &lt;= 1，此时排序时延取决于流量本身的特点（即突发还是平稳）。</li>
<li>排序时延与流量强度的关系大致如下图所示：<br><img src="http://static.zybuluo.com/zsmj2019/2a6s7phknrnuq9bdh6hdp4af/WX20200504-192241@2x.png" alt="WX20200504-192241@2x.png-84.8kB"></li>
</ul>
</li>
<li>丢包：在理想状态下丢包不会发生（将队列容量视作无穷大），实际上队列容量有限。若新包到达时队列已满，此时将发生丢包，在后续章节中我们将了解到丢失的包将会被再次传递至目的地，以保证数据的完整性。</li>
</ul>
</li>
<li>端到端时延（End-to-End Delay）<ul>
<li>假定源主机和目的主机之间有N-1台路由器，并且该网络是无拥塞的（此时可无视排队时延）。那么端到端时延为：<script type="math/tex">d_{end-end} = N (d_{proc} + d_{trans} + d_{prop})</script></li>
</ul>
</li>
<li>吞吐量（Throughput）<ul>
<li>在如以太网路及封包无线电之类的电信网络之中，吞吐量或网络吞吐量是指于一通讯通道上单位时间能成功传递的平均资料量，资料可以于实体或逻辑链接上传递，或通过某个网络节点。吞吐量的单位通常表示为bit/s或bp。</li>
<li>在因特网内表现为网速。</li>
<li>整个通信网络的吞吐量由所有通信链路中的最低吞吐量决定（短板效应）。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h1><ul>
<li><p>五层模型与七层模型：<br><img src="http://static.zybuluo.com/zsmj2019/3wjcflxrm66esvgwvwdors7c/WX20200504-195027@2x.png" alt="WX20200504-195027@2x.png-195kB"></p>
</li>
<li><p>五层协议栈</p>
<ul>
<li>应用层：应用程序的协议。<ul>
<li>我们把应用层的信息称为<strong>报文（message）</strong>。</li>
<li>典型协议如<code>HTTP</code>、<code>FTP</code>、<code>SMTP(电邮)</code>、<code>DNS</code>。</li>
</ul>
</li>
<li>运输层：在应用程序端点之间传输应用层报文的协议。<ul>
<li>因特网中常用的有两个，即<code>TCP</code>和<code>UDP</code>。</li>
<li>TCP：面向连接，提供分割长报文，拥塞控制机制。</li>
<li>UDP：无连接，无特殊功能。</li>
<li>处于运输层的分组叫做<strong>报文段（segement）</strong></li>
</ul>
</li>
<li>网络层：负责将<strong>数据报(datagram)</strong>从主机移动到另一主机，使两端能够互连且决定最佳路径。<ul>
<li>从运输层拿到报文段和目标地址。然后进行<code>路由</code>。</li>
<li>网络层的典型协议是<code>IP</code>协议，用来识别目标地址。</li>
<li>另一典型协议是<code>网络控制消息协定（ICMP）</code>，它是IP的主要部分，一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了<code>ping</code>和<code>traceroute</code>这两个特例。</li>
</ul>
</li>
<li>链路层：在两个网络实体之间提供数据链路连接的创建、维持和释放管理。<ul>
<li>传输<strong>数据帧（frame）</strong>，并对帧定界、同步、收发顺序的控制。</li>
<li>负责传输过程中的流量控制,差错检测和差错控制等方面。</li>
<li>数据链路层中的数据封装是指：封装的数据信息中，包含了地址段和数据段等。地址段含有点对点发送节点和接收节点的地址（如<code>MAC</code>），控制段用来表示数格连接帧的类型，数据段包含实际要传输的数据。</li>
<li>网络层将数据报下发给链路层，链路层传输后，上报给目标结点的网络层。</li>
<li>典型协议：<code>异步传输模式（ATM）</code>、<code>帧中继（frame relay）</code>、<code>高级数据链路控制（HDLC）</code>。</li>
<li>交换机、桥接器是本层设备。而集线器是物理层设备。</li>
</ul>
</li>
<li>物理层：移动比特。<ul>
<li>典型协议如：<code>蓝牙协议</code>、<code>数字用户线路（DSL）</code>等等。</li>
<li>常见物理层设备：网卡、光纤、集线器 。</li>
</ul>
</li>
</ul>
</li>
<li>封装：<ul>
<li>因特网协议栈自顶向下传输时，各层会将上层信息包装，上层信息包装为<code>负载字段（payload field）</code>，本层信息包装为<code>首部字段（header field）</code>。</li>
<li>应用层报文 -&gt; 运输层报文段 -&gt; 网络层数据报 -&gt; 链路层帧</li>
<li><img src="http://static.zybuluo.com/zsmj2019/ludlhii7p63so2srpbkaxw50/WX20200504-200252@2x.png" alt="WX20200504-200252@2x.png-261.9kB"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h1><ul>
<li>因特网攻击举例<ol>
<li>利用病毒和木马形成僵尸网络（botnet），即肉鸡。</li>
<li>弱点攻击（攻击bug）、带宽洪泛（较为常见，多采用分布式攻击）、连接洪泛（伪造大量TCP连接）。</li>
<li>分组嗅探（packet sniffer）：抓包，窃取隐私。</li>
<li>伪造分组：IP哄骗等。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer Networking A Top-Down Approach</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>15.资源管理类中的copying行为</title>
    <url>/2018/04/10/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E7%9A%84copying%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>在上一节的末尾，我已经提到RAII和智能指针并无直接关联，并且给出了例证。事实上，smart_ptr适用于管理heap-based资源。如果你所需要的资源不是heap-based，往往需要建立自己的资源管理类。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假定我们有类型为murtex的互斥器对象，共有lock与unlock两个函数作用其上：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;<span class="comment">//锁定互斥器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;<span class="comment">//解除锁定</span></span><br></pre></td></tr></table></figure><br>基于RAII思想，我们建立一个资源管理类Lock:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line"><span class="function">        :<span class="title">mutexPtr</span><span class="params">(pm)</span> </span>&#123;lock(mutexPtr);&#125;</span><br><span class="line">    ~Lock() &#123;unlock(mutexPtr);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果资源管理类发生了复制行为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line"><span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br></pre></td></tr></table></figure><br>将会产生何种后果？</p>
<hr>
<h1 id="资源管理类的复制行为"><a href="#资源管理类的复制行为" class="headerlink" title="资源管理类的复制行为"></a>资源管理类的复制行为</h1><p>&lt;/br&gt;<br>常见做法有以下两种：</p>
<ol>
<li><strong>禁止复制</strong><br>有时允许RAII对象被复制并不合理，所以我们应该禁止它们的copy行为。如何禁止，详见Effective C++ 6</li>
<li><strong>对底层资源使用引用计数</strong><br>这种方法的最佳实现就是使用shared_ptr。通常我们只要内含一个shared_ptr成员变量，RAII classes便可以实现出reference-counting copying行为</li>
</ol>
<h2 id="引用计数在RAII中的应用"><a href="#引用计数在RAII中的应用" class="headerlink" title="引用计数在RAII中的应用"></a>引用计数在RAII中的应用</h2><p>针对Lock class，可以把接受的指针从mutex*，转为shared_ptr&lt;Mutex&gt;。<br>但shared_ptr的default析构行为是“引用次数为0时删除所指物”，也就是析构时delete指针。（我们仅仅需要解除互锁）为了改变默认行为，我们必须<strong>手动地将删除器unlock作为shared_ptr的第二参数</strong>。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line"><span class="function">        :<span class="title">mutexSP</span><span class="params">(pm,unlock)</span> </span>&#123;lock(mutexSP.<span class="built_in">get</span>());&#125;</span><br><span class="line">    <span class="comment">//无需析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexSP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Lock类此时无需再声明析构函数，因为当shared_ptr析构时，unlock就会被调用。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>复制RAII对象必须一并复制它所管理的资源，资源的copying行为决定了RAII对象的copying行为。</li>
<li>对于RAII class copying，其常见做法无非是禁止拷贝和引用计数。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4.调用empty而不是检查size==0</title>
    <url>/2018/04/06/%E8%B0%83%E7%94%A8empty%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A3%80%E6%9F%A5size==0/</url>
    <content><![CDATA[<p>​<br>理论上而言，这二者等价，但是优先使用empty的理由很简单：<br><strong>对于所有标准容器，empty都是常数时间操作，而某些list的size耗费线性时间。</strong></p>
<p>list独有的splice操作导致了这种情况，举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list2;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//将list2中从第一次出现5到第二次出现10的所有节点移动到list1的末尾</span></span><br><span class="line">list1.splice(list1.<span class="built_in">end</span>(), list2, </span><br><span class="line"><span class="built_in">find</span>(list2.<span class="built_in">begin</span>(), list2.<span class="built_in">end</span>(), <span class="number">5</span>), </span><br><span class="line"><span class="built_in">find</span>(list2.rbegin(),list2.rend(), <span class="number">10</span>).base());</span><br></pre></td></tr></table></figure><br>这段程序只有在list2中在含5的节点之后含有10的节点时才工作。<br>关键在于list1中有多少个元素？应该是list1之前的元素加上之后链接过来的元素.除非遍历一次，不然编译器不会知道具体个数。<br>list的设计者主要希望它在插入删除操作中具有较好性能，如果list的size希望有常数时间，那么splice必须遍历自身然后更新size，这样造成了splice具有线性时间。不管怎么说，list总要在size或者splice之间做出取舍。<br>但是，empty必然是常数时间，那我们为啥不用呢？</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>46.运用member function template接受所有兼容类型</title>
    <url>/2018/04/21/%E8%BF%90%E7%94%A8member%20function%20template%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>所谓智能指针，指的是一些行为像指针的对象，它们可以提供指针没有的机能。STL容器的迭代器几乎总是智能指针，你不会奢望使用operator++将指针从list的一个node移至另一个node，但是迭代器可以。</p>
<p>真实指针有一个很好用的功能：支持隐式转换。举例来说：</p>
<ul>
<li>derived class指针可以隐式转为base class指针</li>
<li>指向non-const对象的指针可以指向const对象</li>
</ul>
<p>既然智能指针是行为如同原始指针的对象，那么我们当然希望智能指针也具备上述功能。具体来说，我们希望下述代码能够通过编译：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span>:</span><span class="keyword">public</span> Top;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Smartptr</span>&#123;</span><span class="comment">//自定义的智能指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Smartptr</span><span class="params">(T* realPtr)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Smartptr&lt;Top&gt; pt1 =Smart&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br><span class="line">Smartptr&lt;<span class="keyword">const</span> Top&gt; pt2 = pt1;</span><br></pre></td></tr></table></figure><br>但是，同一个template的不同具现化之间并不存在继承关系，所以，<code>smartptr&lt;top&gt;</code>与<code>smartptr&lt;middle&gt;</code>完全无关，为了达到我们期望的smart classes之间的转换能力，我们必须明确地编写它们。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>我们关注的重点是应该如何编写智能指针的构造函数。经过分析不难得出结论：我们永远无法写出所有需要的构造函数。我们真正需要撰写的是一个构造模板。<br>构造函数模板具体如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="方案剖析"><a href="#方案剖析" class="headerlink" title="方案剖析"></a>方案剖析</h1><p>&nbsp;<br>该构造函数模板声明：对于任何类型T和任何类型U，总可以根据一个<code>SmartPtr&lt;U&gt;</code>对象来构造一个<code>SmartPtr&lt;T&gt;</code>对象。我们把这种构造函数称为泛化copy构造函数。之所以不用explicit声明，是因为原始指针之间的转换就是隐式的，我们需要保证智能指针与原始指针之间的兼容性。<br>声明固然已经完成，但是实现却值得花一番心思。并非任意的U型智能指针都能转为T型智能指针（比如把base转为derived），所以我们必须在某方面对这一member template所创建的成员函数群进行筛选。</p>
<hr>
<h1 id="解决方案的实现"><a href="#解决方案的实现" class="headerlink" title="解决方案的实现"></a>解决方案的实现</h1><p>&nbsp;<br>假设SmartPtr遵循shared_ptr的接口，存在一个get函数返回原始指针的副本，那我们则可以在构造模板中实现代码约束，具体如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt; &amp;other)</span><br><span class="line">        :helder(other.<span class="built_in">get</span>()) &#123;....&#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> heldptr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在，仅在“存在某个隐式转换将U*指针转为T*指针”时才能通过编译,而这正是我们想要的。</p>
<hr>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>&nbsp;<br>member function template不仅仅单纯用于构造函数，它还常常在赋值操作时发挥作用。<br>在class中声明泛化copy构造函数并不会阻止编译器生存自己的copy构造函数（一个non-template），因此如果需要控制copy构造的方方面面（比如禁止拷贝之类），我们必须同时声明泛化copy构造函数与non-template构造函数，同样的规则也适用于赋值操作。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>可使用member function template生成“可接受所有兼容类型”的函数</li>
<li>如果你声明了member template用于泛化操作，你还是需要声明正常的copy构造函数与copy assignment运算符。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板与泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>39.通过复合塑造出&quot;has-a&quot;或&quot;根据某物实现出&quot;</title>
    <url>/2018/04/19/%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E9%80%A0%E5%87%BAhas-a%E6%88%96%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>复合（composition）是类型之间的一种关系，其意义为：<strong>某种类型的对象内含其它类型的对象</strong>。举例而言，Address、Name是独立的class，而Person class将它们作为成员变量，这便是一种复合。</p>
<hr>
<h1 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h1><p>&nbsp;<br>众所周知，public继承意味着is-a关系<strong>。复合则意味着has-a（有一个）或者is-implemented-in-terms-of（根据某物实现出）。</strong>其意义具体是has-a，还是根据某物实现出，取决于你当前软件系统中处理的领域(domain)。</p>
<h2 id="应用域与实现域"><a href="#应用域与实现域" class="headerlink" title="应用域与实现域"></a>应用域与实现域</h2><p>在软件设计中，对象有的是<strong>真实世界的某些事物在计算机逻辑层面的映射</strong>，比如人物，汽车，住址等等，这些对象属于应用域。<br>有些对象是<strong>实现细节上的人工制品</strong>，比如缓冲区，互斥器，查找树等等。这些对象属于实现域。<br>当复合发生于应用域内时，类型之间表现出has-a的关系。当它发生于实现域内时，类型之间则表现出“根据某物实现出”的关系。</p>
<h2 id="关系判定"><a href="#关系判定" class="headerlink" title="关系判定"></a>关系判定</h2><p>很少有人会把把has-a与is-a搞混，比如说人有一个地址，而绝非人是一个地址。关系判定的难点在于区分is-a与is-implemented-in-terms-of.</p>
<h3 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h3><p>假设当前我们希望由list派生出一个set（不基于平衡树实现的理由是此应用场景空间性能比时间性能更重要）我们可能会写出这样的东西：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span>:</span><span class="keyword">public</span> <span class="built_in">list</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><br>这种设计显然是错误的，public继承意味着is-a，也就是每一个set必然也是一个list，但我们都知道list可以存放多个相同元素，set则不行，它们之间绝非is-a关系，因为对list对象成立的某些东西在set对象中并不成立。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>正确的做法是根据list实现出set，也就是判定它们之间的关系为“根据某物实现出”：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">member</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;T&gt; rep;<span class="comment">//复合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>复合与public继承的意义完全不同</li>
<li>在应用域，复合意味着has-a。在实现域，符合意味着根据某物实现出。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>21.通过重载避免隐式转换</title>
    <url>/2018/04/27/%E9%80%9A%E8%BF%87%E9%87%8D%E8%BD%BD%E9%81%BF%E5%85%8D%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPInt</span> &#123;</span><span class="comment">// unlimited precision integers</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UPInt();</span><br><span class="line">    UPInt(<span class="keyword">int</span> value);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> UPInt <span class="keyword">operator</span>+(<span class="keyword">const</span> UPInt&amp; lhs, <span class="keyword">const</span> UPInt&amp; rhs);</span><br><span class="line">UPInt upi1, upi2;</span><br><span class="line">...</span><br><span class="line">UPInt upi3 = upi1 + upi2;</span><br></pre></td></tr></table></figure>
<p>这段程序不足为奇，再接着看如下表达式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">upi3 = upi1 + <span class="number">10</span>;</span><br><span class="line">upi3 = <span class="number">10</span> + upi2;</span><br></pre></td></tr></table></figure><br>这也能够运行，原因在于隐式转换建立临时对象把int转成了UPInt（More Effective C++ 5)。显然，这是需要一定的开销。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>其实我们并不是想要做类型转换，我们只不过是想让int能和upint相加而已，既然当前不具备可适配性，那我们完全可以通过重载函数适配所有可能出现的情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UPInt <span class="keyword">operator</span>+(<span class="keyword">const</span> UPInt&amp; lhs,<span class="keyword">const</span> UPInt&amp; rhs);</span><br><span class="line"><span class="keyword">const</span> UPInt <span class="keyword">operator</span>+(<span class="keyword">const</span> UPInt&amp; lhs,<span class="keyword">int</span> rhs);</span><br><span class="line"><span class="keyword">const</span> UPInt <span class="keyword">operator</span>+(<span class="keyword">int</span> lhs,<span class="keyword">const</span> UPInt&amp; rhs);</span><br></pre></td></tr></table></figure><br>如此则不会产生任何由于隐式转换所带来的开销。<br>看起来我们忘记了做两个int相加返回UPInt的operator+重载，但是实际上我们无法这么做，因为c++规定<strong>每一个operator重载函数都必须有一个用户自定义类型作为参数</strong>，否则容易出现混乱的修改。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>利用重载避免生成临时对象的方法不仅仅只适用于操作符，而是适用于任何可能产生隐式转换之处。<br>不过，必须谨记80－20准则（More Effective C++ 16）。我们没有必要实现大量的重载函数，除非你有理由确信整体效率会有显著的提高。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>47.避免产出write-only code</title>
    <url>/2018/04/21/%E9%81%BF%E5%85%8D%E4%BA%A7%E5%87%BAwrite-only%20code/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设现有一个vector，我们需要删除vector中<strong>值小于x且出现在至少和y一样大的最后一个元素之后的所有元素</strong>，现有实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">v.erase(remove_if(find_if(v.rbegin(), v.rend(),[](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i&gt;=y;&#125;).base(),v.<span class="built_in">end</span>(),[](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i&lt;x;&#125;),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>虽然该实现用一条语句就解决了问题，但看起来…emm…似乎不是很好维护。<br>那接着考虑如下实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ypedef <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator VecIntIter;</span><br><span class="line">VecIntIter rangeBegin = find_if(v.rbegin(),v.rend(),[](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i&gt;=y;&#125;).base();</span><br><span class="line">v.erase(remove_if(rangeBegin, v.<span class="built_in">end</span>(), [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i&lt;x;&#125;), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>这一段代码的可读性无疑强了很多。</p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>让我们回到问题本身：去除值小于x且出现在至少和y一样大的最后一个元素之后的所有元素。<br>那我们很自然的会想到下面的方案：</p>
<ol>
<li>找到一个元素的最后一次出现需要用反向迭代器，并且需要使用find或者find_if</li>
<li>去除元素需要使用erase-remove惯用法</li>
</ol>
<p>那么写出如下伪代码也顺理成章：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.erase(remove_if(find_if(v.rbegin(), v.rend(), something).base(),v.<span class="built_in">end</span>(),something)),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>读者不难发现这种形式的程序写出来很容易，但如果逆向从代码去推导最初的需求则很难，这种风格被称为write-only，可读性极差。</p>
<p>代码的可读性十分重要，从某种意义上来说，它直接影响了软件开发的高效性。码农何苦为难码农，write-only类型的代码虽然写起来很舒服，但在工作中应当尽力避免。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>31.让函数根据一个以上的对象类型来决定如何虚化</title>
    <url>/2018/04/29/%E8%AE%A9%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%86%B3%E5%AE%9A%E5%A6%82%E4%BD%95%E8%99%9A%E5%8C%96/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设我们在设计一个游戏，游戏的背景发生在太空，有宇宙飞船、太空站和小行星等对象。这些对象可能会发生碰撞，有规则如下：</p>
<ul>
<li>如果飞船和空间站以低速接触，飞船将泊入空间站。否则，它们将有正比于相对速度的损坏。</li>
<li>如果飞船与飞船，或空间站与空间站相互碰撞，参与者均有正比于相对速度的损坏。</li>
<li>如果小行星与飞船或空间站碰撞，小行星毁灭。如果是小行星体积较大，飞船或空间站也毁坏。</li>
<li>如果两个小行星碰撞，将碎裂为更小的小行星，并向各个方向溅射。</li>
</ul>
<hr>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&nbsp;<br>首先开始分析对象共性。显然，它们都在运动，都有一个速度描述运动，因此应该存在一个抽象基类，让各对象从抽象基类中派生出来。继承体系如下：<img src="http://static.zybuluo.com/zsmj2017/gd97vru83myvlbpioi22nfph/image_1cc8b0o0hd4smo21uu2166j18fc9.png" alt="image_1cc8b0o0hd4smo21uu2166j18fc9.png-53.9kB"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceStation</span>:</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asteroid</span>:</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br></pre></td></tr></table></figure><br>接着我们准备撰写最关键的碰撞函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkForCollision</span><span class="params">(GameObject&amp; object1,GameObject&amp; object2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (theyJustCollided(object1, object2)) &#123;</span><br><span class="line">        processCollision(object1, object2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>processCollision函数必然是一个虚函数，但关键问题在于，该函数的虚化并非由一个对象类型决定，而是由两个对象类型共同决定。<br>这种二重调度问题被称为double dispatch，相应地当然也有multiple dispatch。C++并没有提供相应的功能，因此我们必须手动模拟编译器来进行实现。</p>
<hr>
<h1 id="虚函数-RTTI"><a href="#虚函数-RTTI" class="headerlink" title="虚函数+RTTI"></a>虚函数+RTTI</h1><p>&nbsp;<br>我们在GameObject中申明一个虚函数collide。这个函数被派生类以通常的形式重载：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>为了节约篇幅，下文只针对派生类SpaceShip做出详细描述，其他派生类的情况类似于SpaceShip。<br>实现double-dispatch最常见的写法就是if-else逻辑链。在这种方法中，我们首先判断rhs的真实类型，然后测试所有可能：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollisionWithUnknownObject</span> &#123;</span><span class="comment">//异常类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CollisionWithUnknownObject(GameObject&amp; whatWeHit);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject&amp; otherObject)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type_info&amp; objectType = <span class="keyword">typeid</span>(otherObject);</span><br><span class="line">    <span class="keyword">if</span> (objectType == <span class="keyword">typeid</span>(SpaceShip)) &#123;</span><br><span class="line">        SpaceShip&amp; ss = <span class="keyword">static_cast</span>&lt;SpaceShip&amp;&gt;(otherObject);</span><br><span class="line">        ...<span class="comment">//process a SpaceShip-SpaceShip collision;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objectType == <span class="keyword">typeid</span>(SpaceStation)) &#123;</span><br><span class="line">        SpaceStation&amp; ss = <span class="keyword">static_cast</span>&lt;SpaceStation&amp;&gt;(otherObject);</span><br><span class="line">        ...<span class="comment">//process a SpaceShip-SpaceStation collision;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objectType == <span class="keyword">typeid</span>(Asteroid)) &#123;</span><br><span class="line">        Asteroid&amp; a = <span class="keyword">static_cast</span>&lt;Asteroid&amp;&gt;(otherObject);</span><br><span class="line">        <span class="built_in">process</span> a SpaceShip-Asteroid collision;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> CollisionWithUnknownObject(otherObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们完全放弃了封装:每一个object都必须了解其同胞类的版本，一旦增了新类，我们必须更新每一个RTTI体系。<br>在没有虚函数的概念时，这种写法就是虚函数的粗陋实现，显然这种程序毫无维护性。</p>
<hr>
<h1 id="只使用虚函数"><a href="#只使用虚函数" class="headerlink" title="只使用虚函数"></a>只使用虚函数</h1><p>&nbsp;<br>这个方法架构与RTTI版本其实无二，只不过其collide函数增加了各种重载版本，每一个重载处理一个类型：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceStation</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asteroid</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceShip&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceStation&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(Asteroid&amp; otherobject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceShip&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceStation&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(Asteroid&amp; otherobject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其基本原理就是用两个单一调度实现二重调度，也就是说有两个单独的虚函数调用：以rhs作为函数调用的对象再次调用虚函数，*this的静态类型已知，可以直接匹配。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject&amp; otherObject)</span></span>&#123;</span><br><span class="line">    otherObject.collide(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法的缺陷和RTTI一样：每一个类都必须知道其同胞类，当增加新类时，所有代码必须更新，而且必须为每一个新类增加一个新的虚函数。如果当前依赖于某个运行库，这样的改动会导致整个运行库都必须重新编译。</p>
<hr>
<h1 id="模拟虚函数表"><a href="#模拟虚函数表" class="headerlink" title="模拟虚函数表"></a>模拟虚函数表</h1><p>&nbsp;<br>在More Effective C++ 24中我们提及了vtbl，虚函数实现的基础。使用vtbl，编译器避免了使用if…then…else链，并能在所有调用虚函数的地方生成同样的代码。我们没有理由无法在之前的RTTI体系中模拟vtbl。<br>首先，我们对GameObjcet继承体系中的函数作一些修改,为每个子类添加对应的碰撞函数:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceShip</span><span class="params">(SpaceShip&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceStation</span><span class="params">(SpaceStation&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitAsteroid</span><span class="params">(Asteroid&amp; otherobject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceShip</span><span class="params">(SpaceShip&amp; otherObject)</span></span>&#123;</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-SpaceShip collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceStation</span><span class="params">(SpaceStation&amp; otherObject)</span></span>&#123;</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-SpaceStation collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitAsteroid</span><span class="params">(Asteroid&amp; otherObject)</span></span>&#123;</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-Asteroid collision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Spaceship::collide中，我们需要一个方法来映射参数otherObject的动态类型到一个成员函数指针，我们使用一个中间函数lookup来完成此工作:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(SpaceShip::*HitFunctionPtr)</span><span class="params">(GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> GameObject&amp; whatWeHit)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>既然有了lookup，那么collide的实现就很简单了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject&amp; otherObject)</span></span>&#123;</span><br><span class="line">    HitFunctionPtr hfp = lookup(otherObject);</span><br><span class="line">    <span class="keyword">if</span>(hfp) &#123;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;*hfp)(otherObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> CollisionWithUnknownObject(otherObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来要做的就是保证动态类型与成员函数之间的映射了。</p>
<hr>
<h2 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h2><p>首先要做的是一个映射表。该映射表应该在它被使用前构造与初始化，并在不被需要时析构。以上操作应该由编译器自动完成，所以我们将映射表设为lookup函数中的static对象，在第一次调用lookup时构造，在main退出后自行析构：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(SpaceShip::*HitFunctionPtr)</span><span class="params">(GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, HitFunctionPtr&gt; HitMap;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SpaceShip::HitFunctionPtr</span><br><span class="line">SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whatWeHit)&#123;</span><br><span class="line">    <span class="keyword">static</span> HitMap collisionMap;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过使用map的find函数，lookup实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SpaceShip::HitFunctionPtr</span><br><span class="line">SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whatWeHit)&#123;</span><br><span class="line">    <span class="keyword">static</span> HitMap collisionMap;</span><br><span class="line">    <span class="keyword">auto</span> mapEntry = collisionMap.<span class="built_in">find</span>(<span class="keyword">typeid</span>(whatWeHit).name());</span><br><span class="line">    <span class="keyword">if</span> (mapEntry == collisionMap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> mapEntry-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="初始化映射表"><a href="#初始化映射表" class="headerlink" title="初始化映射表"></a>初始化映射表</h3><p>我们需要写一个私有的静态成员函数initializeCollisionMap来构造和初始化映射表，然后用其返回值来初始化collisionMap：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> HitMap <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SpaceShip::HitFunctionPtr</span><br><span class="line">SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whatWeHit)&#123;</span><br><span class="line">    <span class="keyword">static</span> HitMap collisionMap = initializeCollisionMap();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种写法意味着我们需要拷贝赋值，如果初始化函数返回指针则可以避免该问题，但堆中对象又可能会发生资源泄露。考虑到RAII，我们可以将 collisionMap改为一个智能指针，它将在自己被析构时delete 所指向的对象：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line">    <span class="keyword">private</span>:<span class="function"><span class="keyword">static</span> HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SpaceShip::HitFunctionPtr</span><br><span class="line">SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whatWeHit)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">auto_ptr</span>&lt;HitMap&gt; <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SpaceShip::HitMap * <span class="title">SpaceShip::initializeCollisionMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">    (*phm)[<span class="string">"SpaceShip"</span>] = &amp;hitSpaceShip;</span><br><span class="line">    (*phm)[<span class="string">"SpaceStation"</span>] = &amp;hitSpaceStation;</span><br><span class="line">    (*phm)[<span class="string">"Asteroid"</span>] = &amp;hitAsteroid;</span><br><span class="line">    <span class="keyword">return</span> phm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但这无法通过编译，因为HitMap内包容的是一堆指向成员函数的指针，他们的参数类型都是GameObject，而hitSpaceShip等函数带的不一样。虽然对象类型可以隐式转换，但函数指针并没有这种转换关系。<br>使用reinterpret_cast并不是好主意，而且存在极大风险，当spaceship位于多继承体系下时，编译器可能会传输错误的地址。为了不采取类型转换，我们不得不把hit函数的形参改为统一的gameobject，然后在每一个函数中使用dynamic_cast：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceShip</span><span class="params">(GameObject&amp; spaceShip)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceStation</span><span class="params">(GameObject&amp; spaceStation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitAsteroid</span><span class="params">(GameObject&amp; asteroid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceShip</span><span class="params">(GameObject&amp; spaceShip)</span></span>&#123;</span><br><span class="line">    SpaceShip&amp; otherShip = <span class="keyword">dynamic_cast</span>&lt;SpaceShip&amp;&gt;(spaceShip);</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-SpaceShip collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceStation</span><span class="params">(GameObject&amp; spaceStation)</span></span>&#123;</span><br><span class="line">    SpaceStation&amp; station = <span class="keyword">dynamic_cast</span>&lt;SpaceStation&amp;&gt;(spaceStation);</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-SpaceStation collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitAsteroid</span><span class="params">(GameObject&amp; asteroid)</span></span>&#123;</span><br><span class="line">    Asteroid&amp; theAsteroid = <span class="keyword">dynamic_cast</span>&lt;Asteroid&amp;&gt;(asteroid);</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-Asteroid collision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="使用非成员碰撞函数"><a href="#使用非成员碰撞函数" class="headerlink" title="使用非成员碰撞函数"></a>使用非成员碰撞函数</h1><p>&nbsp;<br>之前我们一直以成员函数指针存放于map中，这直接导致如果添加新类的话，依然存在更新成员函数的问题，这也导致了重新编译。<br>另外，当发生A撞B时，应该调用谁的成员函数呢?我们总以左侧参数决定调用对象，实际上我们应该认定，A与B的碰撞应该既不在A中处理也不在B中处理。<br>当我们把碰撞函数从类中移除，其文件组织形式大致如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SpaceShip.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SpaceStation.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Asteroid.h"</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">//无名命名空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shipAsteroid</span><span class="params">(GameObject&amp; spaceShip,GameObject&amp; asteroid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shipStation</span><span class="params">(GameObject&amp; spaceShip,GameObject&amp; spaceStation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asteroidStation</span><span class="params">(GameObject&amp; asteroid,GameObject&amp; spaceStation)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asteroidShip</span><span class="params">(GameObject&amp; asteroid,GameObject&amp; spaceShip)</span></span>&#123; </span><br><span class="line">        shipAsteroid(spaceShip, asteroid); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stationShip</span><span class="params">(GameObject&amp; spaceStation,GameObject&amp; spaceShip)</span></span>&#123; </span><br><span class="line">        shipStation(spaceShip, spaceStation); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stationAsteroid</span><span class="params">(GameObject&amp; spaceStation,GameObject&amp; asteroid)</span></span>&#123;                            asteroidStation(asteroid, spaceStation); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;, GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">map</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;, HitFunctionPtr &gt; HitMap;</span><br><span class="line">    pair&lt;string,string&gt; makeStringPair(const char *s1,const char *s2);</span><br><span class="line">    <span class="function">HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; class1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; class2)</span></span>;</span><br><span class="line">&#125;<span class="comment">//end namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processCollision</span><span class="params">(GameObject&amp; object1,GameObject&amp; object2)</span></span>&#123;</span><br><span class="line">    HitFunctionPtr phf = lookup(<span class="keyword">typeid</span>(object1).name(),<span class="keyword">typeid</span>(object2).name());</span><br><span class="line">    <span class="keyword">if</span>(phf) </span><br><span class="line">        phf(object1, object2);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> UnknownCollision(object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意这里使用了无名命名空间，其特点在于命名空间内所有东西均被本文件所私有（类似于声明在文件范围内的static函数)<br>非成员映射需要两个类型名与一个HitFunctionPtr，但只要用pair把那两个string绑一起就好了。于是映射表初始化函数实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    pair&lt;string,string&gt; makeStringPair(const char *s1,const char *s2)&#123; </span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;(s1, s2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end namespace</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function">HitMap * <span class="title">initializeCollisionMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">        (*phm)[makeStringPair(<span class="string">"SpaceShip"</span>,<span class="string">"Asteroid"</span>)] =&amp;shipAsteroid;</span><br><span class="line">        (*phm)[makeStringPair(<span class="string">"SpaceShip"</span>, <span class="string">"SpaceStation"</span>)] =&amp;shipStation;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> phm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end namespace</span></span><br></pre></td></tr></table></figure><br>lookup 函数也必须被修改以处理pair&lt;string,string&gt;对象，并将它作为映射表的第一部分:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; class1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; class2)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">auto_ptr</span>&lt;HitMap&gt; <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> mapEntry = collisionMap-&gt;<span class="built_in">find</span>(make_pair(class1, class2));</span><br><span class="line">        <span class="keyword">if</span> (mapEntry == collisionMap-&gt;<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> (*mapEntry).second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end namespace</span></span><br></pre></td></tr></table></figure><br>因为上述函数的声明都在无名命名空间中，因此实现也必须在无名命名空间中。</p>
<hr>
<h1 id="继承与模拟虚函数表"><a href="#继承与模拟虚函数表" class="headerlink" title="继承与模拟虚函数表"></a>继承与模拟虚函数表</h1><p>&nbsp;<br>假设我们当前需要区分贸易飞船与军事飞船的区别，无疑，继承体系需要更改：<br><img src="http://static.zybuluo.com/zsmj2017/oyk370ogwudt9e1nin8tyzcu/image_1cc8g09pf18qt12ag5u1hmh1r0am.png" alt="image_1cc8g09pf18qt12ag5u1hmh1r0am.png-76.5kB"><br>我们会发现lookup根本找不到这两个子类，除非我们再次更新表，这样再次造成了重编译。</p>
<hr>
<h1 id="再次讨论初始化vtbl"><a href="#再次讨论初始化vtbl" class="headerlink" title="再次讨论初始化vtbl"></a>再次讨论初始化vtbl</h1><p>&nbsp;<br>之所以会出现上一个问题完全是由于我们的map是完全静态的，每当我们注册一个碰撞函数，其行为便被完全固定。从面向对象的角度而言，我们应该建立一个class存放映射表，并且为它提供动态修改映射关系的成员函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollisionMap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;, GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; type2,</span></span></span><br><span class="line"><span class="function"><span class="params">                  HitFunctionPtr collisionFunction,<span class="keyword">bool</span> symmetric = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeEntry</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; type2)</span></span>;</span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; type2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> CollisionMap&amp; <span class="title">theCollisionMap</span><span class="params">()</span></span>;<span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CollisionMap();</span><br><span class="line">    CollisionMap(<span class="keyword">const</span> CollisionMap&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该类使用了单例模式，保证只存在一张表。同时允许增加对称性碰撞，自动添加对称关系。<br>为了确保发生碰撞前映射关系已存在，我们可以创建一个register类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterCollisionFunction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RegisterCollisionFunction(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; type2,</span><br><span class="line">                              CollisionMap::HitFunctionPtr collisionFunction,</span><br><span class="line">                              <span class="keyword">bool</span> symmetric = <span class="literal">true</span>)&#123;</span><br><span class="line">        CollisionMap::theCollisionMap().addEntry(type1, type2,collisionFunction,symmetric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>用户于是可以使用此类型的一个全局对象来自动地注册他们所需要的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">RegisterCollisionFunction <span class="title">cf1</span><span class="params">(<span class="string">"SpaceShip"</span>, <span class="string">"Asteroid"</span>,&amp;shipAsteroid)</span></span>;</span><br><span class="line"><span class="function">RegisterCollisionFunction <span class="title">cf2</span><span class="params">(<span class="string">"SpaceShip"</span>, <span class="string">"SpaceStation"</span>,&amp;shipStation)</span></span>;</span><br><span class="line"><span class="function">RegisterCollisionFunction <span class="title">cf3</span><span class="params">(<span class="string">"Asteroid"</span>, <span class="string">"SpaceStation"</span>,&amp;asteroidStation)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为这些全局对象在main被调用前就构造了，它们在构造函数中注册的函数也在main被调用前就加入了映射表。如果以后增加了一个派生类或新的碰撞对象，也只需要在主函数执行前加入即可，不需要修改库文件。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>34.避免遮蔽继承而来的名字</title>
    <url>/2018/04/16/%E9%81%BF%E5%85%8D%E9%81%AE%E8%94%BD%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本节内容与继承相关性不大，重点基本上在作用域（scope）方面。</p>
<hr>
<h1 id="名称遮蔽规则"><a href="#名称遮蔽规则" class="headerlink" title="名称遮蔽规则"></a>名称遮蔽规则</h1><p>&nbsp;<br>在下述代码中，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;<span class="comment">//global变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;<span class="comment">//local变量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>作用域形势如下图所示：<br><img src="http://static.zybuluo.com/zsmj2017/exa5wqo7zk3xoga1w8tpuvx1/image_1cb6lbv3l58g189p1oi8ndo1kqh9.png" alt="image_1cb6lbv3l58g189p1oi8ndo1kqh9.png-9.5kB"><br>当编译器遭遇名称x时，它会首先在doSth的作用域内搜寻，如果找到就不再查找。<br><strong>c++的name-hiding rules只做一件事：遮掩名称。至于名称所对应的类型,它并不关注。</strong></p>
<hr>
<h1 id="继承体系下的名称遮蔽规则"><a href="#继承体系下的名称遮蔽规则" class="headerlink" title="继承体系下的名称遮蔽规则"></a>继承体系下的名称遮蔽规则</h1><p>&nbsp;<br>我们都很清楚当一个derived class成员函数内refer to base class内的某物（成员函数，typedef，成员变量）时，编译器可以找出我们所refer to的东西，这是因为derived class继承了声明于base class内的所有东西。<br>实际上的运作方式是，derived class的作用域被嵌套在base class作用域内。它们的关系如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/zsmj2017/vhq5dwamjisrkoxegjz9lskt/image_1cb6lluob1dis16fq1vg41bk11jdtm.png" alt="image_1cb6lluob1dis16fq1vg41bk11jdtm.png-18.3kB"><br>可以看出类中有着复杂的类型，但名称遮蔽体系对类型什么的根本无感。<br>假设derived class中的mf4实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::mf4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mf2();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当编译器处理到mf2时，必须了解它refer to的是何种东西。于是它按照以下顺序一一搜寻：</p>
<ol>
<li>mf4所覆盖的local作用域</li>
<li>Derived class作用域内</li>
<li>base class中作用域</li>
<li>含有base的namespace</li>
<li>global作用域</li>
</ol>
<hr>
<h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p>&nbsp;<br>考虑如下程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span><span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/zsmj2017/bq487su6tv3qcky2qexd0jng/image_1cb6m4s0m1e5ai8b15s7o481l1013.png" alt="image_1cb6m4s0m1e5ai8b15s7o481l1013.png-17.8kB"><br>因为名称遮蔽原则的作用，base class内部所有名为mf1与mf3的函数都被derived class内的mf1函数与mf3函数遮蔽。我们可以认为，<strong>此时base中的mf1与mf3不再被继承。（无论它们的参数如何，是否virtual）</strong><br>这些行为背后的基本理由是为了防止在程序库或者应用框架内建立新derived class时附带地从疏远的base class继承重载函数。<br>不幸的是，如果我们不继承这些重载函数，那就违反了is-a原则。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="using语句"><a href="#using语句" class="headerlink" title="using语句"></a>using语句</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span><span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;<span class="comment">//让bc中一切名为mf1,mf2的一切东西在dc作用域内可见</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;<span class="comment">//且为public可见度</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/zsmj2017/a899emcphif3z0x7rxyg5kjl/image_1cb6mrf3l13m0ku2tog17va6dr1g.png" alt="image_1cb6mrf3l13m0ku2tog17va6dr1g.png-19.2kB"><br>这种操作意味着<strong>如果继承了带有重载函数的base class，而我们又希望重定义或override其中的一部分，我们必须使用using语句引入它们，否则某些你希望继承的名称将会被覆盖。</strong></p>
<hr>
<h2 id="转交函数"><a href="#转交函数" class="headerlink" title="转交函数"></a>转交函数</h2><p>有时候我们并不想继承bc的所有函数，这可以理解，但在public继承中绝无可能。（同时这也是using放在dc的public部分的原因：bc的public名称在publicly dc中也应该是public）<br>但是在private继承体系中是可能并且有意义的。假如dc以private形式继承bc，而它只是想继承那个mf1函数的无参数版本，此时我们有了新的方案::转交函数（forwarding function）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span><span class="keyword">private</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>&#123;base::mf1();&#125;<span class="comment">//转交函数</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line">d.mf1();</span><br><span class="line">d.mf1(<span class="number">5</span>);<span class="comment">//error！Base::mf1()被遮蔽</span></span><br></pre></td></tr></table></figure><br>至此，我们已经讲完了继承和名称遮掩的完整故事，但是一旦继承结合了templates，我们又将面对“继承名称被遮掩”的新形式。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;</p>
<ol>
<li>dc内的名称会遮掩bc内的名称，在public继承体系中此行为等于作死。</li>
<li>为了让被遮蔽的名称重见天日，我们可以使用using语句或者转交函数。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>20.返回值优化</title>
    <url>/2018/04/27/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>一个返回对象的函数难以保持高效，因为构造与析构所带来的开销无法避免。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>以与Rational类相关的operator*函数为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)</span><br></pre></td></tr></table></figure><br>在Effective C++中已经多次以它为例，显然，任何以不返回对象为目的做出的修改都是徒劳的。</p>
<hr>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>&nbsp;<br>必须返回对象并不意味着不可以优化，从效率的角度而言，我们更应该把注意力集中到临时对象所带来的开销上，而不是去消除对象。</p>
<h2 id="返回构造函数表达式"><a href="#返回构造函数表达式" class="headerlink" title="返回构造函数表达式"></a>返回构造函数表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，我们通过构造函数构造了一个临时的Rational对象，函数把它拷贝给了返回值。<br>这种不存在局部对象的方法依旧存在开销，比如说，函数体内临时对象的构造与释放依旧需要开销。但是，<strong>C++允许编译器优化不出现的临时对象（temporary objects out of existence）</strong>因此，在如下的语句中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational a = <span class="number">10</span>;</span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational c = a * b;</span><br></pre></td></tr></table></figure><br>其实并没有出现临时对象，你仅仅付出了一个构造函数的成本，因为<strong>编译器直接在为c分配的内存中构造return表达式定义的对象。</strong></p>
<p>如果还要更进一步的话，可以把operator*声明为inline，减少函数的调用开销，这已经达到了优化的最高水平：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,<span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>4.避免无意义的默认构造函数</title>
    <url>/2018/04/23/%E9%81%BF%E5%85%8D%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>所谓默认构造函数，指的是无需任何信息即可构造对象。有些对象需要它，诸如容器默认构造为空之类。但也有很多对象不需要它，比如工厂里每一个设备对应一个id，不存在没有id就能创建的设备。</p>
<hr>
<h1 id="缺乏默认构造函数所带来的限制"><a href="#缺乏默认构造函数所带来的限制" class="headerlink" title="缺乏默认构造函数所带来的限制"></a>缺乏默认构造函数所带来的限制</h1><p>&nbsp;<br>一般来说，如果一个类不存在默认构造函数，那么它的使用会有诸多限制。举例而言，现有一个class表示公司内部设备，其对象必须通过id才能生成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquipmentPiece</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EquipmentPiece(<span class="keyword">int</span> IDNumber);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>因为EquipmentPiece类没有默认构造函数，在以下三种情况下使用它会出现问题：</p>
<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>我们无法构建一个由Equipment对象构成的数组，因为在产生数组时无法为数组中的对象指定构造参数:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EquipmentPiece bestPieces[<span class="number">10</span>]; <span class="comment">//error</span></span><br><span class="line">EquipmentPiece *bestPieces = <span class="keyword">new</span> EquipmentPiece[<span class="number">10</span>];<span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>以下给出解决方案。</p>
<hr>
<h3 id="使用non-heap数组-不在堆中给数组分配内存）"><a href="#使用non-heap数组-不在堆中给数组分配内存）" class="headerlink" title="使用non-heap数组(不在堆中给数组分配内存）"></a>使用non-heap数组(不在堆中给数组分配内存）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ID1, ID2, ID3, ..., ID10; </span><br><span class="line">...</span><br><span class="line">EquipmentPiece bestPieces[] = &#123;</span><br><span class="line">   EquipmentPiece(ID1), </span><br><span class="line">   EquipmentPiece(ID2),</span><br><span class="line">   EquipmentPiece(ID3),</span><br><span class="line">   ...,</span><br><span class="line">   EquipmentPiece(ID10)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过此法无法延伸至heap数组。</p>
<h3 id="使用指针数组而非对象数组"><a href="#使用指针数组而非对象数组" class="headerlink" title="使用指针数组而非对象数组"></a>使用指针数组而非对象数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> EquipmentPiece* PEP; </span><br><span class="line">PEP *bestPieces = <span class="keyword">new</span> PEP[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    bestPieces[i] = <span class="keyword">new</span> EquipmentPiece(ID Number);</span><br></pre></td></tr></table></figure>
<p>不过该方案有两个缺点：</p>
<ol>
<li>删除数组前必须现删除数组里每个指针所指向的对象，否则内存泄漏。</li>
<li>增加了内存分配量，比一般性数组多存储了指针。</li>
</ol>
<p>这两个缺点均可解决，针对第一条，我们可以使用RAII避免内存泄漏。针对第二条，我们可以使用placement new操作完成构造（Effecive C++ 53）。具体如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *rawMemory = <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="number">10</span>*<span class="keyword">sizeof</span>(EquipmentPiece));</span><br><span class="line">EquipmentPiece *bestPieces = <span class="keyword">static_cast</span>&lt;EquipmentPiece*&gt;(rawMemory);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">new</span>(&amp;bestPieces[i]) EquipmentPiece(ID Number);<span class="comment">//placement new 在指定位置构造对象</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="不适用于template-based-container-classes"><a href="#不适用于template-based-container-classes" class="headerlink" title="不适用于template-based container classes"></a>不适用于template-based container classes</h2><p>对于那些基于模板的容器类而言，被实例化的目标类型必须要有一个默认构造函数，因为那些template中几乎总会有一个以template类型参数作为元素类型的数组，举例而言：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Array</span>&lt;T&gt;:</span>:Array(<span class="keyword">int</span> <span class="built_in">size</span>)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> T[<span class="built_in">size</span>]; <span class="comment">// 为每个数组元素依次调用 T::T()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该问题可以通过良好的模板设计习惯来加以避免。</p>
<hr>
<h2 id="virtual-base-class"><a href="#virtual-base-class" class="headerlink" title="virtual base class"></a>virtual base class</h2><p>不提供缺省构造函数的虚基类，使用起来及其低效。因为几乎所有的派生类在实例化时都必须给虚基类构造函数提供参数，这就要求所有由没有缺省构造函数的虚基类继承下来的派生类(无论有多远)都必须知道并理解提供给虚基类构造函数的参数的含义。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>如果构造函数可以确保对象的所有字段正确初始化，默认构造函数就可以不必出现。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>24.针对性地使用map::operator[]与map::insert</title>
    <url>/2018/04/13/%E9%92%88%E5%AF%B9%E6%80%A7%E5%9C%B0%E4%BD%BF%E7%94%A8map_operator%5B%5D%E4%B8%8Emap_insert/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假设有一个Widget类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    Widget(<span class="keyword">double</span> weight);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">double</span> weight);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们试图建立起int、widget之间的映射关联，那么使用使用map是再恰当不过的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Widget&gt; m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1.50</span>;<span class="comment">//一一添加映射关系</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">3.67</span>;</span><br></pre></td></tr></table></figure><br>然而这种写法对性能的冲击极大。</p>
<hr>
<h1 id="map-operator-与map-insert"><a href="#map-operator-与map-insert" class="headerlink" title="map::operator[]与map::insert"></a>map::operator[]与map::insert</h1><h2 id="map-operator-的具体实现"><a href="#map-operator-的具体实现" class="headerlink" title="map::operator[]的具体实现"></a>map::operator[]的具体实现</h2><p>map的<code>operator[]</code>与别的容器的<code>operator[]</code>颇有不同<strong>，它所执行的功能是“更新或添加”</strong>，具体来说，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m[k] = v;</span><br></pre></td></tr></table></figure><br>上述表达式所执行的操作依次为：</p>
<ol>
<li>检查键k是否在map中，如果没有，则insert<code>pair&lt;const k,v&gt;</code></li>
<li>有，则更新k所对应的value</li>
</ol>
<p><code>operator[]</code>默认返回一个value的引用，这在更新操作中再正常不过，<strong>但对于insert操作，它会使用value的默认构造函数构造一个</strong>，然后返回这个新建立对象的引用。具体来说，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m[<span class="number">1</span>] = <span class="number">1.50</span>;<span class="comment">//m中不存在k==1</span></span><br></pre></td></tr></table></figure><br>等价于<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Widget&gt; IntWidgetMap;</span><br><span class="line">pair&lt;IntWidgetMap::iterator, <span class="keyword">bool</span>&gt; result = m.insert(IntWidgetMap::value_type(<span class="number">1</span>, Widget()));</span><br><span class="line">result.first-&gt;second = <span class="number">1.50</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="用insert直接取代operator-中的插入操作"><a href="#用insert直接取代operator-中的插入操作" class="headerlink" title="用insert直接取代operator[]中的插入操作"></a>用insert直接取代operator[]中的插入操作</h2><p>显然，上述代码在map中插入了一个pair，其first是我们指定的key，second则是默认初始化的widget，最后再执行了赋值操作。<br>以value初始化widget自然会比上述代码更加高效，所以，我们<strong>应该直接使用insert代替<code>operator[]</code></strong>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.insert(IntWidgetMap::value_type(<span class="number">1</span>, <span class="number">1.50</span>));</span><br></pre></td></tr></table></figure><br>这种写法一共节约了3次函数调用：</p>
<ul>
<li>一次建立widget临时对象</li>
<li>一次销毁widget临时对象</li>
<li>一次widget赋值操作</li>
</ul>
<hr>
<h1 id="两全其美的方法"><a href="#两全其美的方法" class="headerlink" title="两全其美的方法"></a>两全其美的方法</h1><p>&lt;/br&gt;<br>出于对更高效的渴望，我们能否扬长避短，实现如下的功能？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果k在m中，调用operator[],否则执行insert</span></span><br><span class="line"><span class="comment">//返回被指向pair的迭代器</span></span><br><span class="line">iterator affectedPair = efficientAddOrUpdate(m, k, v);</span><br></pre></td></tr></table></figure><br>实现该函数实际上并不困难：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> MapType,<span class="keyword">typename</span> KeyArgType, <span class="keyword">typename</span> ValueArgtype&gt;</span><br><span class="line"><span class="keyword">typename</span> MapType::iterator <span class="comment">//利用typename强调此处是一个类型而非成员</span></span><br><span class="line">efficientAddOrUpdate(MapType&amp; m,<span class="keyword">const</span> KeyArgType&amp; k,<span class="keyword">const</span> ValueArgtype&amp; v)&#123;</span><br><span class="line">    <span class="keyword">typename</span> MapType::iterator Ib = m.lower_bound(k);<span class="comment">//找出合理插入位置</span></span><br><span class="line">    <span class="keyword">if</span>(Ib != m.<span class="built_in">end</span>() &amp;&amp; !(m.key_comp()(k, Ib-&gt;first))) &#123;<span class="comment">//关联容器判同</span></span><br><span class="line">        Ib-&gt;second = v; <span class="comment">//更新</span></span><br><span class="line">        <span class="keyword">return</span> Ib;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> MapType::value_type MVT;</span><br><span class="line">        <span class="keyword">return</span> m.insert(Ib, m::value_type(k, v));<span class="comment">//常数时间完成插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述实例中，keytype与valuetype不必是存储在map里的类型，它们只需要能够完成隐式转换即可。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&lt;/br&gt;<br>本节的重点并不在于如何去实现AddOrUpdate这样的函数，而在于强调<code>operator[]</code>与insert在不同情况下效率的不同，如果我们能明确程序行为，那我们应当谨慎地选用它们中的一个。</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
        <tag>关联容器</tag>
      </tags>
  </entry>
  <entry>
    <title>29.避免返回指向对象内部成分的handles</title>
    <url>/2018/04/15/%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86%E7%9A%84handles/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设存在一个矩形类，以左上角和右下角的一个坐标表示其形状。为了让该类尽可能小，我们决定将定义矩形的点移出该类，放在一个辅助的struct中，再用Rectangle指向它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Struct RectData&#123;</span><br><span class="line">    Point ulhc;<span class="comment">//upper left-hand corner</span></span><br><span class="line">    Point lrhc;<span class="comment">//lower right-hand corner</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，用户需要了解矩形的范围，因此矩形类有成员函数如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;<span class="comment">//返回引用</span></span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;lrhc;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种设计是错误的，因为存在自我矛盾。</p>
<hr>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="bitwise-constness"><a href="#bitwise-constness" class="headerlink" title="bitwise constness"></a>bitwise constness</h2><p>在上述代码中，我们用const修饰函数，因为我们希望该函数不能修改point。但是事实上，尽管该函数并未修改数据，但是我们却可以通过其返回值修改对象的private数据，从而丧失了const性质。（详见Effective C++ 4 bitwise constness与logical constness）</p>
<h2 id="指向对象内部成分的handles"><a href="#指向对象内部成分的handles" class="headerlink" title="指向对象内部成分的handles"></a>指向对象内部成分的handles</h2><p>这个案例提供了两个教训：</p>
<ol>
<li><strong>成员变量的封装性最多只等于返回其reference的函数的访问级别</strong><br>在上述代码中，尽管ulhc与lrhc被声明为private,但它们实际上是public，因为我们可以通过public成员函数获取其reference。</li>
<li>如果const函数返回了一个reference，那么该函数的调用者可以修改数据，不受const的制约。<br>这个道理很简单，函数本身受到了const制约，但其返回值却可以自由修改。</li>
</ol>
<h3 id="handles定义"><a href="#handles定义" class="headerlink" title="handles定义"></a>handles定义</h3><p>并非仅有reference是handles，指针、迭代器都属于handles，它们都具备返回一个“代表对象内部数据”的能力。</p>
<h3 id="对象内部成分"><a href="#对象内部成分" class="headerlink" title="对象内部成分"></a>对象内部成分</h3><p>不仅仅成员变量才算是某个对象的内部成分，<strong>被声明为protected与private的成员函数同样算是对象的内部成分</strong>，注意不要返回它们的handles，因为如果你这么做了，<strong>后者的访问级别可能会得到提高</strong>。（不再受到protected、private的保护，而是可能任由客户调用）</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>为了避免封装性遭到大幅度破坏，我们针对此案例的解决方法是<strong>：使用const来修饰返回的handles</strong>。我们出让了对象内部的读取权，写入仍然是被禁止的。</p>
<h2 id="空悬handle"><a href="#空悬handle" class="headerlink" title="空悬handle"></a>空悬handle</h2><p>但即使如此，返回对象内部成分的handles还有可能造成其他问题，比如dangling handles（所指向的对象不复存在）。其最常见翻车现场就是函数返回值。<br>假设某个函数返回一个GUI对象的外框，其外框是一个矩形：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIObject</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rectangle <span class="title">boundingBox</span><span class="params">(<span class="keyword">const</span> GUIObject&amp; obj)</span></span>;</span><br></pre></td></tr></table></figure><br>客户可能会这么使用它：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GUIobject *pgo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> Point* pUpperLeft = &amp;(boundingBox(*pgo).upperLeft());</span><br></pre></td></tr></table></figure><br>在本次使用中，boundingBox函数建立了一个局部无名的Rectangle对象，并将其内部handles绑定到了一个指针中。关键在于，当该语句执行结束后，无名对象被销毁，可pUpperLeft仍然指向着其内部成分，也就是说，pUpperLeft成为了一个空悬指针。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>函数返回一个指向对象内部成分的handle总是带有风险的，但这并不意味着你绝不可以返回handle，比如operator[]总是返回容器内部元素的reference.但这样的函数终究是例外而非常态。<br>如果无法避免的话，记得为const成员函数的返回值也添上const属性。</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>18.避免使用vector&amp;lt;bool&gt;</title>
    <url>/2018/04/11/%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8vector%20bool/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>vector&lt;bool&gt;只有两个问题：</p>
<ol>
<li>它不是一个STL容器</li>
<li>它没有容纳bool</li>
</ol>
<hr>
<h1 id="vector-lt-bool-gt-的特点"><a href="#vector-lt-bool-gt-的特点" class="headerlink" title="vector&lt;bool&gt;的特点"></a>vector&lt;bool&gt;的特点</h1><h2 id="STL的一个必要条件"><a href="#STL的一个必要条件" class="headerlink" title="STL的一个必要条件"></a>STL的一个必要条件</h2><p>STL容器的一个要求是：如果c是stl容器，且支持operator[],则以下代码可编译：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T *p = &amp;c[<span class="number">0</span>]; <span class="comment">// 无论operator[]返回什么，都可以用这个地址初始化一个T*</span></span><br></pre></td></tr></table></figure><br>具体来说就是，<strong>如果你可以使用operator[]来得到Container&lt;T&gt;中的一个T对象，那你必然可以通过取它的地址而获得指向那个对象的指针</strong>。<br>看起来很正常的要求，但vector&lt;bool&gt;做不到。</p>
<h2 id="vector-lt-bool-gt-的内存分布"><a href="#vector-lt-bool-gt-的内存分布" class="headerlink" title="vector&lt;bool&gt;的内存分布"></a>vector&lt;bool&gt;的内存分布</h2><p>vector<bool>是一个伪容器，并不保存真正的bool，而是打包bool以节约空间。确切的说，bool在vector内仅仅只占用了一个bit，我们无法创建指向单个bit的指针。</p>
<p>同样的，也不可能存在单个bit引用.为了解决这个问题，vector&lt;bool&gt;使用了proxy class（详见More Effective C++ 30),从本质上来说，vector<bool>看起来像这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Allocator&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">reference</span> &#123;</span>...&#125;; <span class="comment">//proxy class</span></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n); <span class="comment">//return a proxy object</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这也说明了为什么上面的代码无法编译，因为返回的并不是bool类型，而是一个代理对象。</p>
<hr>
<h1 id="使用deque-lt-bool-gt-与bitset来替换vector"><a href="#使用deque-lt-bool-gt-与bitset来替换vector" class="headerlink" title="使用deque&lt;bool&gt;与bitset来替换vector"></a>使用deque&lt;bool&gt;与bitset来替换vector<bool></h1><ol>
<li>deque&lt;bool&gt;<br>deque提供了几乎所有vector所提供的成员函数（缺是reserve和capacity）。并且，deque&lt;bool&gt;是一个STL容器，它保存真正的bool值。</li>
<li>bitset<br>bitset不是一个STL容器，但它是C++标准库的一部分。其内存分布和vector&lt;bool&gt;差不多，其具体实现与应用可参照数据结构·Bitamap篇。</li>
</ol>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>26.限制某个类所能产生的对象数量</title>
    <url>/2018/04/28/%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AA%E7%B1%BB%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本节内容的极端情况即为禁止建立对象与单例模式。</p>
<hr>
<h1 id="禁止对象实例化"><a href="#禁止对象实例化" class="headerlink" title="禁止对象实例化"></a>禁止对象实例化</h1><p>&nbsp;<br>如果我们需要阻止建立某个类的对象，应该把它的构造函数设为private:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CantBeInstantiated</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CantBeInstantiated();</span><br><span class="line">    CantBeInstantiated(<span class="keyword">const</span> CantBeInstantiated&amp;);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>&nbsp;<br>假设我们现在只允许生成一个打印机对象，我们应当把这个对象封装置入某个函数，允许所有人访问，但只有一个对象存在：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintJob</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Printer p; <span class="comment">// 单个打印机对象</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个设计有三部分：</p>
<ol>
<li>printer无法构造</li>
<li>全局函数thePrinter被设为friend，因此可以调用private构造函数。</li>
<li>thePrinter包含一个静态Printer对象，这意味着只有一个对象被建立。我们只能通过thePrinter函数来使用这个对象。</li>
</ol>
<hr>
<h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>有人会认为thePrinter没必要污染全局命名空间，为此解决方法是把thePrinter声明为printer内部的静态函数，那顺便去除了friend属性：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Printer&amp; <span class="title">Printer::thePrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Printer p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>就是调用函数的时候麻烦了一些：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Printer::thePrinter().reset();</span><br><span class="line">Printer::thePrinter().submitJob(<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="新建命名空间"><a href="#新建命名空间" class="headerlink" title="新建命名空间"></a>新建命名空间</h2><p>另一种做法是将class与thePrinter移出全局域，放入专属namespace，防止命名冲突：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> PrintingStuff&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob&amp; job)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Printer p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只不过这样一来调用每一次调用都必须提及命名空间：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PrintingStuff::thePrinter().reset();</span><br><span class="line">PrintingStuff::thePrinter().submitJob(<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure><br>又或者使用using：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PrintingStuff::thePrinter; </span><br><span class="line">thePrinter().reset();</span><br><span class="line">thePrinter().submitJob(<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="单例模式实现细节"><a href="#单例模式实现细节" class="headerlink" title="单例模式实现细节"></a>单例模式实现细节</h2><p>thePrinter的实现有两个微妙之处：</p>
<ol>
<li>p是函数中的静态对象而非类中的静态对象<br>如果是类中的静态对象，则该对象总是会被构造和析构。（即使你根本没有试图去使用）函数中的则不同，只有第一次调用函数时才会被构造。当然，我们也为此付出了代价：每一次都必须检查是否需要建立对象。<br>如果对象是类中的静态成员，它的初始化时间难以确定，我们清楚的了解函数的静态对象初始化于函数的第一次调用，而类则说不准。</li>
<li>关注内联与函数内静态对象的关系<br>我们看得出thePrinter的函数体非常简短，很适合内联，但我们不能内联它。因为对于非成员函数，内联会导致复制obj中的代码，简单来说，就连静态对象也被复制了。所以不要<strong>内联包含局部静态数据的非成员对象。</strong></li>
</ol>
<hr>
<h1 id="多例模式-限制数目）"><a href="#多例模式-限制数目）" class="headerlink" title="多例模式(限制数目）"></a>多例模式(限制数目）</h1><p>&nbsp;<br>一般来说，限制对象数目的核心思想在于：实时跟踪当前已生成的对象数目，如果超出则抛出异常：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span>&#123;</span>&#125;;<span class="comment">//异常类</span></span><br><span class="line">    Printer();</span><br><span class="line">    ~Printer();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);<span class="comment">//禁止拷贝</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line">Printer::Printer()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> TooManyObjects();</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//执行构造</span></span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line">Printer::~Printer()&#123;</span><br><span class="line">    ...<span class="comment">//执行析构;</span></span><br><span class="line">    --numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种方法相当直观，就是设计起来存在些许小小的问题。</p>
<hr>
<h2 id="建立对象的环境"><a href="#建立对象的环境" class="headerlink" title="建立对象的环境"></a>建立对象的环境</h2><p>假设我们有一个彩色打印机，继承自printer：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPrinter</span>:</span> <span class="keyword">public</span> Printer &#123;...&#125;;</span><br><span class="line">Printer p;</span><br><span class="line">ColorPrinter cp;</span><br></pre></td></tr></table></figure><br>上述定义产生了两个Printer对象,于是，在构造cp的基类部分时抛出了异常（More Effective C++ 33提出设计时避免非尾端类为具象类）。<br>如果有其他对象包含Printer对象，也会有同样的问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPFMachine</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer p;<span class="comment">//有打印能力</span></span><br><span class="line">    FaxMachine f;<span class="comment">//有传真能力</span></span><br><span class="line">    CopyMachine c;<span class="comment">//有复印能力</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">CPFMachine m1;<span class="comment">//运行正常</span></span><br><span class="line">CPFMachine m2;<span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure><br>这些问题的根源在于Pointer对象可以在3种不同状态下生存：</p>
<ol>
<li>仅有自身</li>
<li>作为派生对象的base成分</li>
<li>内嵌于较大对象</li>
</ol>
<p>这直接导致了我们心目中的“目标个数”与编译器看到的目标个数不一致。</p>
<h3 id="private构造函数"><a href="#private构造函数" class="headerlink" title="private构造函数"></a>private构造函数</h3><p>通常情况下我们只对状态1感兴趣，那把构造函数设为private可以很有效地满足我们。<strong>带有private构造函数的类无法作为基类，也无法内嵌到其他对象中。</strong><br>private构造函数是一种阻止产生派生类的好手段，具体来说，假如你有一个类FSA（finite state automata），我们允许它产生多个对象，但禁止从它派生出新类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FSA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FSA * <span class="title">makeFSA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FSA * <span class="title">makeFSA</span><span class="params">(<span class="keyword">const</span> FSA&amp; rhs)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FSA();</span><br><span class="line">    FSA(<span class="keyword">const</span> FSA&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FSA* <span class="title">FSA::makeFSA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FSA(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FSA* <span class="title">FSA::makeFSA</span><span class="params">(<span class="keyword">const</span> FSA&amp; rhs)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FSA(rhs); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不同于thePrinter函数总是返回一个对象的引用（引用的对象是固定的），每个 makeFSA的伪构造函数则是返回一个指向对象的指针，也就是说允许建立的 FSA 对象数量没有限制。<br>为了防止资源泄漏，最佳方案自然是RAII：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;FSA&gt; <span class="title">pfsa1</span><span class="params">(FSA::makeFSA())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;FSA&gt; <span class="title">pfsa2</span><span class="params">(FSA::makeFSA(*pfsa1))</span></span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="允许对象自由生灭"><a href="#允许对象自由生灭" class="headerlink" title="允许对象自由生灭"></a>允许对象自由生灭</h2><p>在之前的设计手法中，首次我们调用thePrinter时，对象被构造，但我们无法控制对象的销毁，也就是说无法达成这样的功能：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">建立Printer对象 p1;</span><br><span class="line">使用p1;</span><br><span class="line">释放p1;</span><br><span class="line">建立Printer对象 p2;</span><br><span class="line">使用p2;</span><br><span class="line">释放p2;</span><br></pre></td></tr></table></figure></p>
<p>解决方法就是把对象计数和伪构造函数合并：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    ~Printer();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line">Printer::Printer()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> TooManyObjects();</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//执行构造</span></span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line">Printer::~Printer()&#123;</span><br><span class="line">    ...<span class="comment">//执行析构;</span></span><br><span class="line">    --numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了用户必须调用伪构造函数之外，这一切使用起来就如同其他类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Printer p1;<span class="comment">//error 构造函数为private</span></span><br><span class="line">Printer *p2 =Printer::makePrinter();</span><br><span class="line">Printer p3 = *p2; <span class="comment">//error 禁止拷贝</span></span><br><span class="line">p2-&gt;performSelfTest();</span><br><span class="line">p2-&gt;reset();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p2;<span class="comment">//避免资源泄漏</span></span><br></pre></td></tr></table></figure><br>如果我们需要制定最多生成N个，那只要在class中定义一个static const maxsize=N就ok：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer&amp; rhs)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;<span class="comment">//声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxObjects = <span class="number">10</span>;<span class="comment">//内置static类型可以直接在class中声明时定义</span></span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;<span class="comment">//在类外定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Printer::maxObjects;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="建立具有计数功能的基类"><a href="#建立具有计数功能的基类" class="headerlink" title="建立具有计数功能的基类"></a>建立具有计数功能的基类</h2><p>如果我们需要大量这种限制产出对象数量的class，难道我们要一遍一遍地重复编写？当然不是。<br>理想做法是编写一个具有实例计数功能的基类，然后让产出受限的类继承该类。我们使用一种方法封装计数功能，这种做法不但封装维护实例计数器的函数，也封装实例计数器本身。<br>下面给出该类的具体实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Counted</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span>&#123;</span>&#125;;<span class="comment">//异常类</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">objectCount</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> numObjects;&#125;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//仅作为基类使用</span></span><br><span class="line">    Counted();</span><br><span class="line">    Counted(<span class="keyword">const</span> Counted&amp; rhs);</span><br><span class="line">    ~Counted() &#123;--numObjects;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> numObjects;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxObjects;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;<span class="comment">//避免代码重复</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Counted</span>&lt;BeingCounted&gt;:</span>:Counted()&#123;</span><br><span class="line">    init(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Counted</span>&lt;BeingCounted&gt;:</span>:Counted(<span class="keyword">const</span> Counted&lt;BeingCounted&gt;&amp;)&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Counted</span>&lt;BeingCounted&gt;:</span>:init()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= maxObjects) <span class="keyword">throw</span> TooManyObjects();</span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>于是最终的Printer类如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span><span class="keyword">private</span> Counted&lt;Printer&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer&amp; rhs)</span></span>;</span><br><span class="line">    ~Printer();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::objectCount;</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::TooManyObjects;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>用户有权得知当前的对象数目以及最大数目，private继承使得它们被隐藏，因此需要在public中使用using来获取他们。<br>最后需要注意的就是定义counted内部的静态成员，对于numobject，我们只需要在counted的实现中定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Counted</span>&lt;BeingCounted&gt;:</span>:numObjects;<span class="comment">//自动初始化为0</span></span><br></pre></td></tr></table></figure><br>max的定义则略微麻烦，我们不初始化它，而是留待客户进行初始化。以Printer举例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Counted&lt;Printer&gt;::maxObjects = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>如果客户没写，那么在连接时会报错。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>29.需要依次录入字符时考虑使用istreambuf_iterator</title>
    <url>/2018/04/14/%E9%9C%80%E8%A6%81%E4%BE%9D%E6%AC%A1%E5%BD%95%E5%85%A5%E5%AD%97%E7%AC%A6%E6%97%B6%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8istreambuf_iterator/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设我们需要拷贝一个文本文件到一个字符串：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该程序仅作示例，实际编译效果与设想不符，原因见Effective STL 6）</span></span><br><span class="line"><span class="function">ifstream <span class="title">inputFile</span><span class="params">(<span class="string">"interestingData.txt"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">fileData</span><span class="params">((istream_iterator&lt;<span class="keyword">char</span>&gt;(inputFile)), </span></span></span><br><span class="line"><span class="function"><span class="params">                 istream_iterator&lt;<span class="keyword">char</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure><br>实际上这并没有完全copy文本，因为istream_iterator使用<code>operator&gt;&gt;</code>，该操作符在默认情况下忽略空格。<br>如果你不想所有空格都莫名消失，那你应该覆盖默认情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inputFile</span><span class="params">(<span class="string">"interestingData.txt"</span>)</span></span>;</span><br><span class="line">inputFile.unset(ios::skipws); <span class="comment">// 关闭inputFile的忽略空格标志</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">fileData</span><span class="params">((istream_iterator&lt;<span class="keyword">char</span>&gt;(inputFile)), istream_iterator&lt;<span class="keyword">char</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure><br>然而你会发现这种拷贝速度很慢，因为operator&gt;&gt;采取格式化输入，它需要建立sentry对象（为每个<code>operator&gt;&gt;</code>调用进行建立和清除活动的特殊的iostream对象），必须检查流标志位，以及是否需要抛出异常等等操作，这些操固然很重要，但当我们需要的只是从输入流中抓取下一个字符时，这一切都是不必要的。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>istreambuf_iterator的特性是直接进入输入流缓冲区读取字符，使用方法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//再次重申这个没法正常运行，只是示例</span></span><br><span class="line"><span class="function">ifstream <span class="title">inputFile</span><span class="params">(<span class="string">"interestingData.txt"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">fileData</span><span class="params">((istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(inputFile)),</span></span></span><br><span class="line"><span class="function"><span class="params">                 istreambuf_iterator&lt;<span class="keyword">char</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure><br>istreambuf_iterator也无需考虑空格的因素，因为空格不会被输入流摒弃。<br>同样的，逐个输出字符时也应该使用ostreambuf_iterator.</p>
]]></content>
      <categories>
        <category>Effective STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>32.面向未来编程</title>
    <url>/2018/04/29/%E9%9D%A2%E5%90%91%E6%9C%AA%E6%9D%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>唯一不变的就是变化本身。</p>
<hr>
<h1 id="软件的变化性"><a href="#软件的变化性" class="headerlink" title="软件的变化性"></a>软件的变化性</h1><p>&nbsp;<br>好的软件能够适应变化。软件的灵活性、健壮性、可靠性是程序员们在满足当前需求并关注将来的可能后设计和实现出来的。优秀的软件是那些时刻关注未来的人们编写的。<br>什么会发生变化呢？继承体系会变，现在的派生类将会是以后的基类；运行平台会变；程序的维护人员会更替，因此程序应该被设计得易于被别人理解、维护和扩充 。</p>
<hr>
<h1 id="如何表达设计条件的约束"><a href="#如何表达设计条件的约束" class="headerlink" title="如何表达设计条件的约束"></a>如何表达设计条件的约束</h1><p>&nbsp;<br>我们应该<strong>习惯于使用C++语言自身来约束程序的性质，而不是依赖注释或文档</strong>。<br>如果一个类不可继承，那么应该按照More Effective C++ 26中的方法阻止。<br>如果一个类的实例必须创建于heap中，应该用More Effective C++ 27中的方法来强迫完成。<br>如果一个类的拷贝构造或赋值无意义，则应该将它们设置为private。<br>当我们定义成员函数时，应该判明其意义，以及派生类中的它是否有意义。如果它在派生类中依然存在意义，则令它为虚函数，即使当前并不需要override。如果不存在任何意义，声明为非虚函数。确保更改是为了整个类的运行环境和类所表示的抽象，而非仅仅满足某个需求。（Effetive C++ 35）<br>处理每个类的赋值和拷贝构造函数，以防止有人误调编译器提供的默认版本而产生意料之外的结果。（Effective C++ 07）<br>当我们建立一个类时，努力保证其操作和语法自然且直观，自定义数据类型的行为尽量与内置类型保持一致。（Effective C++ 19）<br>要确信用户必然会犯错，因此你的类必须设计得可以预防、检测、及修正这些错误。（Effective C++ 18）<br>努力去写可移植的代码。只有在性能极其重要时采用不可移植的结构才是可取的。<br>尽可能地封装,将实现细节申明为私有。（Effective C++ 23、29）<br>尽可能使用无名命名空间和文件内的静态对象或函数。(More Effective C++ 31）<br>避免导致虚基类的设计，因为这种类需要每个派生类都直接初始化它－－即使是间接派生类。（Effective C++ 41)<br>避免需要RTTI的设计，因为它需要多重的if-else逻辑判断，每当继承层次改变，都需要更新原有的逻辑。(More Effective C++ 31）<br><strong>面向未来编程认为：在设计一个类时，不要去关注现在该如何使用该类，而是关注该类被设计为如何使用。</strong>如果一个类被设计为作一个基类使用（即使现在还没有被这么使用），它就应该有一个虚析构函数。这样的类在现在和将来都行为正确，并且当新类从它们派生时并不影响其它库用户。</p>
<hr>
<h1 id="活在当下与面向未来"><a href="#活在当下与面向未来" class="headerlink" title="活在当下与面向未来"></a>活在当下与面向未来</h1><p>&nbsp;<br>当然，我们依旧活在当下，首先要做的应该是确保完成当下的任务，但未来时态仅仅只是增加了一些额外的约束：</p>
<ol>
<li>尽可能提供完备的类， 确保当产生新需求时不用去更改它们。</li>
<li>将你的接口设计得直观且高效，使class不易被错误使用。</li>
<li>尽量通用化代码。例如，如果在写树的遍历算法，考虑将其通用化至可以处理任何有向无环图。</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>面向未来编程增加了代码的可重用性、可维护性、健壮性，并且保证了在运行环境发生改变时易于修改。但面向未来编程的前提是完成当前问题已经得到有效解决。</p>
]]></content>
      <categories>
        <category>More Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>26.避免针对universal reference作出重载</title>
    <url>/2018/07/13/%E9%81%BF%E5%85%8D%E9%92%88%E5%AF%B9universal%20reference%E4%BD%9C%E5%87%BA%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设当前需要一个以name作为参数的函数，该函数负责记录当前日期和时间，然后将name添加到一个全局数据结构中，它的一大可能实现如下所示:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names; <span class="comment">// global data structure</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">"logAndAdd"</span>); <span class="comment">// make log entry</span></span><br><span class="line">    names.emplace(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该程序能够运行，但存在性能上的提升空间，考虑下述三种调用情况：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">petName</span><span class="params">(<span class="string">"Darla"</span>)</span></span>;</span><br><span class="line">logAndAdd(petName); <span class="comment">// pass lvalue std::string</span></span><br><span class="line">logAndAdd(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Persephone"</span>)); <span class="comment">// pass rvalue std::string</span></span><br><span class="line">logAndAdd(<span class="string">"Patty Dog"</span>); <span class="comment">// pass string literal</span></span><br></pre></td></tr></table></figure><br>在第一次调用中，name被绑定于一个左值，转入logAndAdd后,name最终被传入names.emplace。因为name是一个左值，因此最终它被copy至names，我们无法阻止这种拷贝，因为移动左值会导致局部变量（petname)的失效。</p>
<p>在第二次调用中，name被绑定于一个右值，但需要明确的是name自身是一个左值，因此它被copy至names，此处可用move代替copy以提升性能。</p>
<p>在第三次调用中，我们首先从const char *处构造了一个临时string对象，然后用name绑定了该右值，随后将name复制到names，可见这里做了大量的无用功，我们本应直接利用const char*在names中构建string。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>我们可以按照Item24、25中所提及的方法重写logAndAdd:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">"logAndAdd"</span>);</span><br><span class="line">    names.emplace(<span class="built_in">std</span>::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">petName</span><span class="params">(<span class="string">"Darla"</span>)</span></span>; <span class="comment">// as before</span></span><br><span class="line">logAndAdd(petName); <span class="comment">// as before, copy lvalue into multiset</span></span><br><span class="line">logAndAdd(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Persephone"</span>)); <span class="comment">// move rvalue instead of copying it</span></span><br><span class="line">logAndAdd(<span class="string">"Patty Dog"</span>); <span class="comment">// create std::string in multiset instead</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="更进一步的问题实例"><a href="#更进一步的问题实例" class="headerlink" title="更进一步的问题实例"></a>更进一步的问题实例</h1><p>&nbsp;<br>事实上客户端并非总是能够直接获取name，有些客户端只拥有一个获取对应name的索引，针对这种情况，我们将logAndAdd重载：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">nameFromIdx</span><span class="params">(<span class="keyword">int</span> idx)</span></span>; <span class="comment">// return name corresponding to idx</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">"logAndAdd"</span>);</span><br><span class="line">    names.emplace(nameFromIdx(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但这个重载版本的鲁棒性不太好：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">short nameIdx;</span><br><span class="line">… <span class="comment">// give nameIdx a value</span></span><br><span class="line">logAndAdd(nameIdx); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h1><p>&nbsp;<br>当前存在两个重载版本，带有universal reference的版本可以轻松地推衍出short，然后实现精准匹配，然后雪崩，参数为int的版本根本说不上话。</p>
<p>我们可以认为以universal reference为参数的函数几乎可以与任何参数完成精准匹配（因为它几乎可以绑定至一切类型，不能匹配的几种情况可见Item30），这也说明重载以universal reference的函数并不可取。</p>
<hr>
<h1 id="转发函数与默认函数"><a href="#转发函数与默认函数" class="headerlink" title="转发函数与默认函数"></a>转发函数与默认函数</h1><p>&nbsp;<br>我们设想一下当前存在一个class Person:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span>:<span class="title">name</span><span class="params">(<span class="built_in">std</span>::forward&lt;T&gt;(n))</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idx)</span>:<span class="title">name</span><span class="params">(nameFromIdx(idx))</span> </span>&#123;&#125;</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>类似于logAndAdd，当传入size_t或者short时直接可能会导致Person构造函数雪崩，不过当前问题比那个还要严重。原因在于重载函数的个数远比你肉眼所见的要多。Item17曾经提及在适当的条件下，C++将会自动生成copy constructor与move constructor，即使该class已经具备了能够实例化构造函数的模板。因此，我们可以认为Person实际上如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span>:<span class="title">name</span><span class="params">(<span class="built_in">std</span>::forward&lt;T&gt;(n))</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idx)</span></span>; <span class="comment">// int ctor</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person&amp; rhs); <span class="comment">// copy ctor(compiler-generated)</span></span><br><span class="line">    Person(Person&amp;&amp; rhs); <span class="comment">// move ctor(compiler-generated)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>考虑一下以下调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"Nancy"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>; <span class="comment">// create new Person from p;this won't compile!</span></span><br></pre></td></tr></table></figure><br>上述操作不会调用copy ctor，而是会调用转发构造函数，然后该函数将尝试使用Person对象p初始化Person的std::string数据成员。std::string没有接受Person类型的构造函数，因此触发雪崩。有人会疑惑编译器为什么不调用copy ctor，这是由C++重载函数调用准则决定的。</p>
<p>cloneOfP正在使用非const左值（p）进行初始化，这表明当前可以实例化出一个以non-const Person为参数的构造函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(Person&amp; n)</span>:<span class="title">name</span><span class="params">(<span class="built_in">std</span>::forward&lt;Person&amp;&gt;(n))</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在调用语句中，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure><br>p似乎既可以触发copy ctor也能触发实例化函数，但实际上调用copy ctor时需要为p添加const，而实例化函数则不需要这项要求，因此编译器选择最佳匹配方案：调用转发构造函数。</p>
<p>如果我们将p改为const，那么copy ctor则可被顺利调用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Person <span class="title">cp</span><span class="params">(<span class="string">"Nancy"</span>)</span></span>; <span class="comment">// object is now const</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(cp)</span></span>; <span class="comment">// calls copy constructor!</span></span><br></pre></td></tr></table></figure><br>此时同样会实例化一个以const Person&amp;为参数的转发构造函数，但在C++重载规则中，非模板函数优先级总是高于模板函数，因此本次将调用copy ctor。</p>
<p>一旦引入继承，转发函数与自动生成的函数之间会产生更多的交互，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialPerson</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpecialPerson(<span class="keyword">const</span> SpecialPerson&amp; rhs):Person(rhs)&#123; … &#125;</span><br><span class="line">    SpecialPerson(SpecialPerson&amp;&amp; rhs):Person(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs))&#123; … &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>需要注意的是，派生类的拷贝、移动构造函数不会调用它们的基类对应的此类函数，而是将调用基类的转发构造函数。原因在于传入的实参优先匹配于转发函数。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>本节并未描述问题解决方案，在下一节中我们将对此继续讨论。</p>
<ol>
<li><strong>universal refernce作为参数的函数不适合被重载。</strong></li>
<li><strong>转发函数经常会干涉别的函数的调用，并可能会因此产生极为恶劣的后果。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>32.降低文件间的编译依存关系</title>
    <url>/2018/04/16/%E9%99%8D%E4%BD%8E%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>某一天你对某个class中的部分实现文件做了些许更改，注意，改的不是接口，仅仅是实现，并且是private部分。当你按下build之后你估计大概要等几秒，但实际上。。。。你发现整个世界都被重新编译和连接了。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>上述问题出在C++对“将接口从实现中分离”完成得不好。<strong>class的定义式不仅仅描述了接口，还包括了实现细目</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//以下均为实现细目</span></span><br><span class="line">    <span class="built_in">string</span> theName;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果编译器没有取得上述程序所用到的string，Date等定义式，它就无法编译。​<br>当然，我们肯定会使用<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Address.h"</span></span></span><br></pre></td></tr></table></figure><br>不幸的是，这样一来便是在Person定义文件和其含入文件间形成了一种compilation dependency。<br>如果这些头文件中有任何一个被改变，或这些头文件所依赖的其他头文件有任何改变，那么每一个<code>#include &quot;Person.h&quot;</code>的文件都必须重新编译，任何使用了Person对象的文件也必须重新编译。</p>
<hr>
<h1 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h1><p>有人会好奇为何不使用前置声明分开实现细目：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">string</span>;</span><span class="comment">//前置声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span><span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果这样能够完成，那么仅有Person被改过之后客户才需要重新编译。</p>
<h2 id="前置声明的问题"><a href="#前置声明的问题" class="headerlink" title="前置声明的问题"></a>前置声明的问题</h2><ol>
<li>string并不是class<br>string并不是一个class，它是一个typedef。并且我们不应该尝试手工声明一部分STL，而是应该使用include完成目的，标准头文件不会成为编译瓶颈。</li>
<li>编译器必须在编译期间知道对象的大小<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(args)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当编译器看到Person p(args),它必须明确一个Person对象需要分配多少内存，该问题的答案只有通过询问class定义式才能得到。然而如果class可以合法地不列出实现细目，编译器如何知道该分配多少空间？</li>
</ol>
<hr>
<h1 id="接口与实现分离"><a href="#接口与实现分离" class="headerlink" title="接口与实现分离"></a>接口与实现分离</h1><p>&nbsp;<br>前置声明的第二个问题在Java中根本不是问题，因为它<strong>在定义对象时编译器只分配足够空间给一个指针</strong>。也就是说，其具体实现效果大概是这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pimpl设计模式"><a href="#pimpl设计模式" class="headerlink" title="pimpl设计模式"></a>pimpl设计模式</h2><p>当然，我们也能在c++中这么做，将对象实现细目隐藏于一个指针背后。</p>
<h3 id="pimpl实例"><a href="#pimpl实例" class="headerlink" title="pimpl实例"></a>pimpl实例</h3><p>举例而言，对于Person我们可以：<strong>把person分割为两个classes，一个只提供接口，另一个负责实现该接口</strong>。其具体实现类名为PersonImpl。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memroy&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="pimp分析"><a href="#pimp分析" class="headerlink" title="pimp分析"></a>pimp分析</h3><p>Person内部只含有一个指针成员指向实现类，这种设计被称为pimpl idiom(pointer to implementation）在这种设计下，Person的客户完全与Address以及Persons的实现细目分离。</p>
<p>该分离的关键在<strong>于以“声明的依存性”代替了“定义的依存性”</strong>，而这正是<strong>编译依存性最小化的本质：让头文件尽可能自我满足，否则就让它与其他文件内的声明式（而非定义式）相互依存。</strong>其设计策略大致有三：</p>
<ul>
<li>如果使用object references或者object pointers就可以完成任务，就不要使用objects。<br>当你使用后者时，必须使用该类型的定义式。</li>
<li>在条件允许的情况下，尽量用class声明式替换class定义式。</li>
<li>为声明式和定义式提供不同的头文件。<br>为了维持上述的两个准则，我们会定义两个一致的头文件，一个用于声明（<code>Person.h</code>)，一个用于定义(<code>PersonImpl.h</code>)。客户程序显然总是应该#include声明文件而非前置声明若干函数。</li>
</ul>
<hr>
<h1 id="Handle-class"><a href="#Handle-class" class="headerlink" title="Handle class"></a>Handle class</h1><h2 id="handle-class-工作原理"><a href="#handle-class-工作原理" class="headerlink" title="handle class 工作原理"></a>handle class 工作原理</h2><p>像person这样使用pimpl idiom的classes往往被称为handle classes.其工作方法之一是把<strong>所有函数都转交给相应的实现类并由后者完成实际工作</strong>，如下所示<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"Person.cpp"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PersonImpl.h"</span></span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp;name,<span class="keyword">const</span> Address&amp; addr)</span><br><span class="line">    :pImpl(<span class="keyword">new</span> PersonImpl(name,addr)) &#123;&#125;<span class="comment">//调用PersonImpl构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Address <span class="title">Person::getAddress</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;address();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里需要注意的是，Person以new调用PersonImpl的构造函数，任何操作都在调用PersonImpl对象的相关函数<strong>。让一个class变为handle class并不会改变它做的事，只会改变它做事的方法。</strong></p>
<h2 id="Interface-class"><a href="#Interface-class" class="headerlink" title="Interface class"></a>Interface class</h2><p>除了使用pimpl,另一种制作handle class的方法是<strong>令Person成为一种特殊的abstract base class，我们称其为Interface class.</strong><br>这种class的目的是详细描述derived classes的接口，因此它通常<strong>没有成员变量和构造函数</strong>，<strong>只有一个virtual析构函数以及一组pure virtual函数，用来叙述整个接口。</strong><br>C++ 中的Interface class类似于java的Interfaces，但是略有不同，比如c++不禁止在interface内部实现成员变量或non-virtual成员函数。</p>
<h3 id="Interface-class实例"><a href="#Interface-class实例" class="headerlink" title="Interface class实例"></a>Interface class实例</h3><p>仍以Person为例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> Address <span class="title">getAddress</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>该class的用户必须以指向Person的指针和或eference来编写应用程序，因为该类无法具现出实体。</strong>正如handle class的客户一样，除非interface class的接口发生改变，否则无需重新编译。</p>
<h3 id="Interface-class与对象构造"><a href="#Interface-class与对象构造" class="headerlink" title="Interface class与对象构造"></a>Interface class与对象构造</h3><p>如何为Interface class创建新对象？<br>一般而言，我们会选择调用一个特殊函数，此函数扮演“真正将被具现化”的那个derived classes的构造函数角色。<br>这种函数通常称为factory函数或者virtual构造函数（详见More Effective C++  25）其返回一个指针（或者智能指针）指向动态分配所得对象，而该对象又支持interface class的接口。此类函数一般被声明为static：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>：</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">shared_ptr</span>&lt;person&gt; <span class="title">create</span>(<span class="title">const</span> <span class="title">string</span> &amp;<span class="title">name</span>,<span class="title">const</span> <span class="title">Address</span> &amp;<span class="title">addr</span>);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>客户的使用操作如下所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> theName;</span><br><span class="line">Address theAddress;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;person&gt; <span class="title">pp</span><span class="params">(person::create(name,addr))</span></span>;<span class="comment">//构建对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pp-&gt;getName();</span><br><span class="line"><span class="comment">//当pp离开作用域，对象自动删除</span></span><br></pre></td></tr></table></figure><br>当然，<strong>支持Interface class接口的那个conrete class必须被定义出来，且真正的构造函数必须被调用</strong>。举例而言，我们现有一个具象类RealPerson继承自Person：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> Address&amp; addr)</span><br><span class="line">        :theName(name),theAddr(addr) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> theName;</span><br><span class="line">    Address theAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么create的定义式应当类似于如下形式（暂且忽略factory塑造不同类型对象的特性，仅仅把关注点置于构造）：:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;person&gt; <span class="title">person::create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name,<span class="keyword">const</span> Addresss &amp;addr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;person&gt;(<span class="keyword">new</span> realperson(name,addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="handle-class成本及风险"><a href="#handle-class成本及风险" class="headerlink" title="handle class成本及风险"></a>handle class成本及风险</h2><ul>
<li>在handle class中，成员函数必须通过一个implementation pointer取得对象数据，这无疑增加了访问的间接性。另外，implementation pointer必须初始化（在handle class内）指向一个动态分配的implementation object,所以我们还得承受动态分配和释放所带来的开销，以及遭遇bad_alloc的尴尬。</li>
<li>Interface class的每一个函数都是virtual，所以每一次函数使用都是一次间接函数指针访问，并且interface class派生的对象一定会含有一个vptr，这无疑增大了内存需求。（详见More Effective C++ 24)</li>
<li>handle class 与Interface class 都需要inline的支持。</li>
</ul>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>编译依存性最小化的一般构想：依赖于声明式而非定义式。基于此构想的两个实现分别是Handle class与Interface class.</li>
<li>程序库头文件应该有且仅有声明式,无论其是否涉及template。</li>
</ol>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>31.避免默认捕获模式</title>
    <url>/2018/07/16/%E9%81%BF%E5%85%8D%E9%BB%98%E8%AE%A4%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>C++11中有两种默认捕获模式：by-reference和by-value。默认的引用捕获可能导致空悬引用。默认的按值捕获让你觉得你的闭包是自包含（self-contained)的（它们可能不是）。</p>
<hr>
<h1 id="by-reference"><a href="#by-reference" class="headerlink" title="by-reference"></a>by-reference</h1><p>&nbsp;<br>引用捕获会导致闭包包含对局部变量或lambda的作用域中可用参数的引用,如果从该lambda创建的闭包的生命周期超过局部变量或参数的生命周期，则闭包引用空悬。举例而言，假设当前存在一个容器，其元素为过滤函数，每个函数都接受一个int并返回一个bool，指示传入的值是否满足过滤器：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters;</span><br></pre></td></tr></table></figure><br>我们向其中添加一个元素：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">filters.emplace_back([](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % <span class="number">5</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure><br>但实际上我们可能需要的是一个在运行期决定的除数，即5不可写死在lambda中，因此我们决定这么写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = computeSomeValue1();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = computeSomeValue2();</span><br><span class="line">    <span class="keyword">auto</span> divisor = computeDivisor(calc1, calc2);</span><br><span class="line">    filters.emplace_back([&amp;](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;); <span class="comment">// danger</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>lambda引用了局部变量divisor，但当addDivisorFilter返回时，该变量不再存在，因此我们向容器内部添加了一个错误的函数对象。<br>显式声明引用捕获divisor也会导致同样的问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">filters.emplace_back([&amp;divisor](<span class="keyword">int</span> value)&#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure><br>但这种写法更容易看出该lambda的可行性取决于divisor的寿命，它提醒我们要确保divisor至少与lambda的闭包具备一样长的生命周期。 </p>
<p>事实上，如果立即使用闭包（例如直接传入STL算法）且不copy它们，一般情况下不会触发引用空悬的情况，因此你可能会争辩说默认的by-reference不可能触发空悬引用。举例而言，我们的过滤lambda只能用作std::all_of的参数，它返回范围内的所有元素是否满足指定条件：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithContainer</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = computeSomeValue1(); <span class="comment">// as above</span></span><br><span class="line">    <span class="keyword">auto</span> calc2 = computeSomeValue2(); <span class="comment">// as above</span></span><br><span class="line">    <span class="keyword">auto</span> divisor = computeDivisor(calc1, calc2);</span><br><span class="line">    <span class="keyword">using</span> ContElemT = <span class="keyword">typename</span> C::value_type;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::all_of(<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container),</span><br><span class="line">                    [&amp;](<span class="keyword">const</span> ContElemT&amp; value)&#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">                    )</span><br><span class="line">    )&#123;</span><br><span class="line">        …</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++14的新特性可以简化上述程序为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::all_of(<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container),</span><br><span class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value)&#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;))</span><br></pre></td></tr></table></figure><br>确实，这是安全的，但它的安全性有些不稳定。如果该发现lambda在其他上下文中发挥作用（例如需要被添加到容器中）并且闭包存在复制行为（且当前局部对象已经析构），那么我们终将雪崩。</p>
<p>从软件工程的角度而言，在lambda中明确标识捕获对象具备更高的鲁棒性（它至少提示了该闭包捕获对象的生存期不应当小于闭包生存期）。</p>
<hr>
<h1 id="by-value"><a href="#by-value" class="headerlink" title="by-value"></a>by-value</h1><p>&nbsp;<br>一种解决方案是采用默认的按值传递形式:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">filters.emplace_back([=](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure><br>但按值捕获并不能完全解决空悬问题。举例而言，假设当前你copy了一个指针，你完全无力阻止在lambda之外的程序delete该指针从而导致触发空悬。</p>
<hr>
<h2 id="在成员函数中使用lambda"><a href="#在成员函数中使用lambda" class="headerlink" title="在成员函数中使用lambda"></a>在成员函数中使用lambda</h2><p>假设Widgets可以在过滤器容器中添加条目：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    … <span class="comment">// ctors, etc.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// add an entry to filters</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> divisor; <span class="comment">// used in Widget's filter</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>Widget::addFilter可能被定义为如下形式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    filters.emplace_back([=](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这看起来很安全，但实际上并非如此。</p>
<p>捕获仅适用于在创建lambda范围内可见的非静态局部变量（包括参数）。在Widget::addFilter的主体中，divisor不是局部变量，它是Widget类的数据成员，因此无法捕获。但如果不写默认捕获模式，则下述代码无法编译：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    filters.emplace_back([](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此外，如果尝试显式捕获divisor(无论是by-reference还是by-value），代码亦将无法编译，因为divisor既非局部变量亦非参数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    filters.emplace_back(</span><br><span class="line">        [divisor](<span class="keyword">int</span> value)&#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因此，默认的by-value capture子句并不捕获divisor，但没它又将无法编译，那该如何是好？答案在于this指针，当我们采用默认by-value捕获时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    filters.emplace_back([=](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>被捕获的是this指针，而非divisor，编译器会将其视为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> currentObjectPtr = <span class="keyword">this</span>;</span><br><span class="line">    filters.emplace_back(</span><br><span class="line">        [currentObjectPtr](<span class="keyword">int</span> value)&#123; <span class="keyword">return</span> value % currentObjectPtr-&gt;divisor == <span class="number">0</span>; &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这一点非常重要，换而言之，它等价于在描述lambda所生成的闭包与该Widget的生存期有关，因为闭包内含this指针的副本，下文代码将使用智能指针来说明这一点：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pw = <span class="built_in">std</span>::make_unique&lt;Widget&gt;();</span><br><span class="line">    pw-&gt;addFilter(); <span class="comment">// add filter that uses Widget::divisor</span></span><br><span class="line">    …</span><br><span class="line">&#125; <span class="comment">// destroy Widget; filters now holds dangling pointer!</span></span><br></pre></td></tr></table></figure><br>当dosomework完成后，widget对象析构，容器内加入了一个含有空悬引用的闭包，从而在后续引发雪崩。</p>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这一问题可通过制作data member副本，并在捕获时显式拷贝其副本得到解决：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> divisorCopy = divisor; <span class="comment">// copy data member</span></span><br><span class="line">    filters.emplace_back(</span><br><span class="line">        [divisorCopy](<span class="keyword">int</span> value) <span class="comment">// capture the copy</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>; &#125; <span class="comment">// use the copy</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++14提出了广义lambda捕获（generalized lambda capture，见Item32），它可以更好地捕获data member：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    filters.emplace_back(</span><br><span class="line">        [divisor = divisor](<span class="keyword">int</span> value) <span class="comment">// copy divisor to closure</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125; <span class="comment">// use the copy</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="self-contained"><a href="#self-contained" class="headerlink" title="self-contained"></a>self-contained</h2><p>&nbsp;<br>默认按值捕获的另一大缺点在于它使得闭包看起来具有自包含特性，并且与外界数据的更改产生了隔离。但事实并非如此。lambda不仅可以依赖于局部变量和参数（可以捕获），还可以依赖于具有静态存储持续时间的对象。 此类对象在全局作用域或命名空间内定义，又或者在函数、类、文件中被声明为static。它们可以在lambda中得到使用，但却无法被捕获。但默认按值捕获可能给我们造成了它们已被捕获的错觉，试看实例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> calc1 = computeSomeValue1(); <span class="comment">// now static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> calc2 = computeSomeValue2(); <span class="comment">// now static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> divisor = <span class="comment">// now static</span></span><br><span class="line">    computeDivisor(calc1, calc2);</span><br><span class="line">    filters.emplace_back(</span><br><span class="line">        [=](<span class="keyword">int</span> value) <span class="comment">// captures nothing!</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125; <span class="comment">// refers to above static</span></span><br><span class="line">    );</span><br><span class="line">    ++divisor; <span class="comment">// modify divisor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>某些开发者看到<code>[=]</code>后即认为当前lambda已经具备self-contained属性，不再与外部数据有所交互，实则不然。每一次addDivisorFilter的调用，都会造成容器内部lambda的变化，也就是说，它似乎具备了引用捕获的某些特性。如果不采用默认按值捕获，我们则可以清楚看出当前并未捕获任何对象。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>默认引用捕获可能会导致空悬引用。</strong></li>
<li><strong>默认按值捕获可能会导致空悬指针（尤其是this指针），并且给人以该lambda自包含的错觉。</strong></li>
</ol>
]]></content>
      <categories>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始学习velox源码（三）</title>
    <url>/2024/12/04/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0velox%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>orderBy是velox中的排序算子，其源码位置为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">velox&#x2F;exec&#x2F;OrderBy.h</span><br><span class="line">velox&#x2F;exec&#x2F;OrderBy.cpp</span><br></pre></td></tr></table></figure><br>其主要逻辑基本转交给了<code>sortbuffer</code>来处理，<code>sortbuffer</code>的源码位置为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">velox&#x2F;exec&#x2F;SortBuffer.h</span><br><span class="line">velox&#x2F;exec&#x2F;SortBuffer.cpp</span><br></pre></td></tr></table></figure><br>本节我们将重点关注<code>sortbuffer</code>的实现。<br>按照先易后难的顺序，我们先关注无需考虑<code>spill</code>的情况，再在后续章节讨论包含<code>spill</code>的情况。</p>
<a id="more"></a>
<h1 id="算子流程图"><a href="#算子流程图" class="headerlink" title="算子流程图"></a>算子流程图</h1><p><img src="/images/SortBufferProcess.png" alt="orderBy"></p>
<h1 id="Ctor"><a href="#Ctor" class="headerlink" title="Ctor"></a>Ctor</h1><p>调用方式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in velox/exec/OrderBy.cpp</span></span><br><span class="line">sortBuffer_ = <span class="built_in">std</span>::make_unique&lt;SortBuffer&gt;(</span><br><span class="line">      outputType_,</span><br><span class="line">      sortColumnIndices,</span><br><span class="line">      sortCompareFlags,</span><br><span class="line">      pool(),</span><br><span class="line">      &amp;nonReclaimableSection_,</span><br><span class="line">      driverCtx-&gt;prefixSortConfig(),</span><br><span class="line">      spillConfig_.has_value() ? &amp;(spillConfig_.value()) : <span class="literal">nullptr</span>,</span><br><span class="line">      &amp;spillStats_);</span><br></pre></td></tr></table></figure></p>
<p>实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SortBuffer::SortBuffer(</span><br><span class="line">    <span class="keyword">const</span> RowTypePtr&amp; input,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">column_index_t</span>&gt;&amp; sortColumnIndices,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CompareFlags&gt;&amp; sortCompareFlags,</span><br><span class="line">    velox::memory::MemoryPool* pool,</span><br><span class="line">    tsan_atomic&lt;<span class="keyword">bool</span>&gt;* nonReclaimableSection,</span><br><span class="line">    common::PrefixSortConfig prefixSortConfig,</span><br><span class="line">    <span class="keyword">const</span> common::SpillConfig* spillConfig,</span><br><span class="line">    folly::Synchronized&lt;velox::common::SpillStats&gt;* spillStats)</span><br><span class="line">    : input_(input),</span><br><span class="line">      sortCompareFlags_(sortCompareFlags), <span class="comment">// 各列排序规则</span></span><br><span class="line">      pool_(pool),</span><br><span class="line">      nonReclaimableSection_(nonReclaimableSection), <span class="comment">// 当前是否处于nonReclaimableSection</span></span><br><span class="line">      prefixSortConfig_(prefixSortConfig),</span><br><span class="line">      spillConfig_(spillConfig),</span><br><span class="line">      spillStats_(spillStats),</span><br><span class="line">      sortedRows_(<span class="number">0</span>, memory::StlAllocator&lt;<span class="keyword">char</span>*&gt;(*pool)) &#123; <span class="comment">// sortbuffer排序时使用行数据，这里存储有序的行数据地址</span></span><br><span class="line">  VELOX_CHECK_GE(input_-&gt;size(), sortCompareFlags_.size());</span><br><span class="line">  VELOX_CHECK_GT(sortCompareFlags_.size(), <span class="number">0</span>);</span><br><span class="line">  VELOX_CHECK_EQ(sortColumnIndices.size(), sortCompareFlags_.size());</span><br><span class="line">  VELOX_CHECK_NOT_NULL(nonReclaimableSection_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt; sortedColumnTypes;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt; nonSortedColumnTypes;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sortedSpillColumnNames;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TypePtr&gt; sortedSpillColumnTypes;</span><br><span class="line">  sortedColumnTypes.reserve(sortColumnIndices.size());</span><br><span class="line">  nonSortedColumnTypes.reserve(input-&gt;size() - sortColumnIndices.size());</span><br><span class="line">  sortedSpillColumnNames.reserve(input-&gt;size());</span><br><span class="line">  sortedSpillColumnTypes.reserve(input-&gt;size());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">column_index_t</span>&gt; sortedChannelSet;</span><br><span class="line">  <span class="comment">// Sorted key columns.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">column_index_t</span> i = <span class="number">0</span>; i &lt; sortColumnIndices.size(); ++i) &#123;</span><br><span class="line">    columnMap_.emplace_back(IdentityProjection(i, sortColumnIndices.at(i)));</span><br><span class="line">    sortedColumnTypes.emplace_back(input_-&gt;childAt(sortColumnIndices.at(i)));</span><br><span class="line">    sortedSpillColumnTypes.emplace_back(</span><br><span class="line">        input_-&gt;childAt(sortColumnIndices.at(i)));</span><br><span class="line">    sortedSpillColumnNames.emplace_back(input-&gt;nameOf(sortColumnIndices.at(i)));</span><br><span class="line">    sortedChannelSet.emplace(sortColumnIndices.at(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Non-sorted key columns.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">column_index_t</span> i = <span class="number">0</span>, nonSortedIndex = sortCompareFlags_.size();</span><br><span class="line">       i &lt; input_-&gt;size();</span><br><span class="line">       ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedChannelSet.count(i) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    columnMap_.emplace_back(nonSortedIndex++, i); <span class="comment">// columnMap_存储了行存储-&gt;列存储的索引映射，在行存储中，key列将靠前存储</span></span><br><span class="line">    nonSortedColumnTypes.emplace_back(input_-&gt;childAt(i));</span><br><span class="line">    sortedSpillColumnTypes.emplace_back(input_-&gt;childAt(i));</span><br><span class="line">    sortedSpillColumnNames.emplace_back(input-&gt;nameOf(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data_ = <span class="built_in">std</span>::make_unique&lt;RowContainer&gt;(</span><br><span class="line">      sortedColumnTypes, nonSortedColumnTypes, pool_); <span class="comment">// 构造RowContainer，后续用于存储行数据</span></span><br><span class="line">  spillerStoreType_ =</span><br><span class="line">      ROW(<span class="built_in">std</span>::move(sortedSpillColumnNames), <span class="built_in">std</span>::move(sortedSpillColumnTypes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="AddInput"><a href="#AddInput" class="headerlink" title="AddInput"></a>AddInput</h1><p>将输入的列数据转为行数据存储，在存储前会进行内存评估。<br>实现方式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortBuffer::addInput</span><span class="params">(<span class="keyword">const</span> VectorPtr&amp; input)</span> </span>&#123;</span><br><span class="line">  velox::common::testutil::TestValue::adjust(</span><br><span class="line">      <span class="string">"facebook::velox::exec::SortBuffer::addInput"</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  VELOX_CHECK(!noMoreInput_);</span><br><span class="line">  ensureInputFits(input);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开辟内存，存储行数据</span></span><br><span class="line">  <span class="function">SelectivityVector <span class="title">allRows</span><span class="params">(input-&gt;size())</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; <span class="title">rows</span><span class="params">(input-&gt;size())</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; input-&gt;size(); ++row) &#123;</span><br><span class="line">    rows[row] = data_-&gt;newRow();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span>* inputRow = input-&gt;as&lt;RowVector&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; columnProjection : columnMap_) &#123;</span><br><span class="line">    <span class="function">DecodedVector <span class="title">decoded</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        *inputRow-&gt;childAt(columnProjection.outputChannel), allRows)</span></span>;</span><br><span class="line">    data_-&gt;store(</span><br><span class="line">        decoded,</span><br><span class="line">        folly::Range(rows.data(), input-&gt;size()),</span><br><span class="line">        columnProjection.inputChannel);</span><br><span class="line">  &#125;</span><br><span class="line">  numInputRows_ += allRows.size(); <span class="comment">// 更新输入行数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中开辟内存，存储行数据的逻辑在<a href="https://xander.wiki/2024/12/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0velox%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/">RowContainer</a><br>中有详细描述。</p>
<p>我们把目光投向<code>ensureInputFits</code>函数，该函数用于评估内存是否足够存储输入数据。<br>若评估存在内存不足的风险，则会向pool申请更多内存。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortBuffer::ensureInputFits</span><span class="params">(<span class="keyword">const</span> VectorPtr&amp; input)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check if spilling is enabled or not.</span></span><br><span class="line">  <span class="keyword">if</span> (spillConfig_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> numRows = data_-&gt;numRows();</span><br><span class="line">  <span class="keyword">if</span> (numRows == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 'data_' is empty. Nothing to spill.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定长区还能存储多少行 + 变长区还能存储多少字节（在不扩容的前提下）</span></span><br><span class="line">  <span class="keyword">auto</span> [freeRows, outOfLineFreeBytes] = data_-&gt;freeSpace();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> outOfLineBytes =</span><br><span class="line">      data_-&gt;stringAllocator().retainedSize() - outOfLineFreeBytes; <span class="comment">// 当前变长区已使用的内存</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> flatInputBytes = input-&gt;estimateFlatSize(); <span class="comment">// LX <span class="doctag">TODO:</span>:看逻辑很像获取变长数据大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test-only spill path.</span></span><br><span class="line">  <span class="keyword">if</span> (numRows &gt; <span class="number">0</span> &amp;&amp; testingTriggerSpill(pool_-&gt;name())) &#123;</span><br><span class="line">    spill();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> currentMemoryUsage = pool_-&gt;usedBytes(); <span class="comment">// 当前内存池已使用大小</span></span><br><span class="line">  <span class="comment">// 若当前已使用大小为U, minSpillableReservationPct记作P, 当前内存池预留内存记作R</span></span><br><span class="line">  <span class="comment">// 经验认为，R &gt;= U * P 时才无需spill，否则很可能内存不足</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> minReservationBytes =</span><br><span class="line">      currentMemoryUsage * spillConfig_-&gt;minSpillableReservationPct / <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> availableReservationBytes = pool_-&gt;availableReservation();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> estimatedIncrementalBytes =</span><br><span class="line">      data_-&gt;sizeIncrement(input-&gt;size(), outOfLineBytes ? flatInputBytes : <span class="number">0</span>);  <span class="comment">// 评估所需要的内存大小</span></span><br><span class="line">  <span class="keyword">if</span> (availableReservationBytes &gt; minReservationBytes) &#123; <span class="comment">// 经过评估，总内存足够</span></span><br><span class="line">    <span class="comment">// If we have enough free rows for input rows and enough variable length</span></span><br><span class="line">    <span class="comment">// free space for the vector's flat size, no need for spilling.</span></span><br><span class="line">    <span class="keyword">if</span> (freeRows &gt; input-&gt;size() &amp;&amp;</span><br><span class="line">        (outOfLineBytes == <span class="number">0</span> || outOfLineFreeBytes &gt;= flatInputBytes)) &#123; <span class="comment">// 定长区和变长区都够用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the current available reservation in memory pool is 2X the</span></span><br><span class="line">    <span class="comment">// estimatedIncrementalBytes, no need to spill.</span></span><br><span class="line">    <span class="keyword">if</span> (availableReservationBytes &gt; <span class="number">2</span> * estimatedIncrementalBytes) &#123; <span class="comment">// 若当前预留内存大于缩小内存的两倍，也不spill</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try reserving targetIncrementBytes more in memory pool, if succeeded, no</span></span><br><span class="line">  <span class="comment">// need to spill.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> targetIncrementBytes = <span class="built_in">std</span>::max&lt;<span class="keyword">int64_t</span>&gt;(</span><br><span class="line">      estimatedIncrementalBytes * <span class="number">2</span>,</span><br><span class="line">      currentMemoryUsage * spillConfig_-&gt;spillableReservationGrowthPct / <span class="number">100</span>); <span class="comment">// 向内存池申请max(2 * 预估值， 当前使用量 * H)大小的内存</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">memory::ReclaimableSectionGuard <span class="title">guard</span><span class="params">(nonReclaimableSection_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (pool_-&gt;maybeReserve(targetIncrementBytes)) &#123; <span class="comment">// 能申请到，无需spill</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LOG(WARNING) &lt;&lt; <span class="string">"Failed to reserve "</span> &lt;&lt; succinctBytes(targetIncrementBytes)</span><br><span class="line">               &lt;&lt; <span class="string">" for memory pool "</span> &lt;&lt; pool()-&gt;name()</span><br><span class="line">               &lt;&lt; <span class="string">", usage: "</span> &lt;&lt; succinctBytes(pool()-&gt;usedBytes())</span><br><span class="line">               &lt;&lt; <span class="string">", reservation: "</span> &lt;&lt; succinctBytes(pool()-&gt;reservedBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="noMoreInput"><a href="#noMoreInput" class="headerlink" title="noMoreInput"></a>noMoreInput</h1><p>指示后续不再存在输入，此时将触发排序逻辑。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortBuffer::noMoreInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  velox::common::testutil::TestValue::adjust(</span><br><span class="line">      <span class="string">"facebook::velox::exec::SortBuffer::noMoreInput"</span>, <span class="keyword">this</span>);</span><br><span class="line">  VELOX_CHECK(!noMoreInput_); <span class="comment">// 此前不存在重复调用</span></span><br><span class="line">  <span class="comment">// It may trigger spill, make sure it's triggered before noMoreInput_ is set.</span></span><br><span class="line">  ensureSortFits(); <span class="comment">// 评估进行排序时的内存是否足够，sortedRows_所需占用的内存 + prefix-sort encoding所需占用的内存</span></span><br><span class="line"></span><br><span class="line">  noMoreInput_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No data.</span></span><br><span class="line">  <span class="keyword">if</span> (numInputRows_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (spiller_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    VELOX_CHECK_EQ(numInputRows_, data_-&gt;numRows());</span><br><span class="line">    updateEstimatedOutputRowSize(); <span class="comment">// 评估输出时内存是否足够</span></span><br><span class="line">    <span class="comment">// Sort the pointers to the rows in RowContainer (data_) instead of sorting</span></span><br><span class="line">    <span class="comment">// the rows.</span></span><br><span class="line">    sortedRows_.resize(numInputRows_); <span class="comment">// 存储有行数据的地址</span></span><br><span class="line">    RowContainerIterator iter;</span><br><span class="line">    data_-&gt;listRows(&amp;iter, numInputRows_, sortedRows_.data()); <span class="comment">// 提取当前输入的行地址至sortedRows_</span></span><br><span class="line">    PrefixSort::sort(</span><br><span class="line">        data_.get(), sortCompareFlags_, prefixSortConfig_, pool_, sortedRows_); <span class="comment">// 执行prefix-sort排序或者std-sort, sortedRows_将存储排序完成后的行地址</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Spill the remaining in-memory state to disk if spilling has been</span></span><br><span class="line">    <span class="comment">// triggered on this sort buffer. This is to simplify query OOM prevention</span></span><br><span class="line">    <span class="comment">// when producing output as we don't support to spill during that stage as</span></span><br><span class="line">    <span class="comment">// for now.</span></span><br><span class="line">    spill(); <span class="comment">// 如果此前触发过spill，把当前内存里的数据也执行spill（简化流程）</span></span><br><span class="line"></span><br><span class="line">    finishSpill();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Releases the unused memory reservation after procesing input.</span></span><br><span class="line">  pool_-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>velox</category>
      </categories>
      <tags>
        <tag>velox operator</tag>
        <tag>OrderBy</tag>
        <tag>SortBuffer</tag>
      </tags>
  </entry>
</search>
