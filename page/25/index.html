<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="zsmj" />





  <link rel="alternate" href="/atom.xml" title="Xander's Wiki" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="Xander&#39;s Wiki">
<meta property="og:url" content="https://xander.wiki/page/25/index.html">
<meta property="og:site_name" content="Xander&#39;s Wiki">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xander.wiki/page/25/"/>





  <title>Xander's Wiki</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xander's Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/s" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E8%B5%8B%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E8%B5%8B%E5%80%BC/" itemprop="url">12. 在operator=中处理自赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T11:23:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>我们在重载operator=时需要注意自我赋值的情况。可能有人会认为这种情况很少发生，因为很少有人会写诸如w=w的句子。但实际上,代码中出现a[i]=a[j]（i==j),或者<em>p=</em>q（指向同一对象）的例子屡见不鲜。<br>事实上，只要你使用了pointers或者references，而且它们被用来指向多个相同类型的对象，我们就需要考虑 是否会出现自赋值的情况。确切地说，<strong>只要有多个对象来自同一个继承体系</strong>，比如一个指针指向base class类型，而另一个指向derived class类型。<strong>它们完全可能指向的是同一个对象</strong>。</p>
<hr>
<h1 id="不处理自赋值情况的风险"><a href="#不处理自赋值情况的风险" class="headerlink" title="不处理自赋值情况的风险"></a>不处理自赋值情况的风险</h1><p>&nbsp;<br>如果我们在class中手动地进行了资源管理，那么自赋值的处理不当可能会带来一些问题。举例而言:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span>...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);<span class="comment">//如果是自赋值，pb指向的对象已经释放</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序<strong>既不具备异常安全性，也直接导致了“在停止使用资源前意外地释放了它”</strong>。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="证同测试"><a href="#证同测试" class="headerlink" title="证同测试"></a>证同测试</h2><p>其原理很简单：在函数最前端放上这样一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(this&#x3D;&#x3D;&amp;rhs) return *this;</span><br></pre></td></tr></table></figure><br>这个解决方案保证了自赋值安全性，但是不具备异常安全性。在这句话中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pb=<span class="keyword">new</span> Bitmap(*rhs.pb);<span class="comment">//已通过证同测试，此时已经执行delete</span></span><br></pre></td></tr></table></figure><br>如果new导致了一个异常（内存不足或者copy构造函数抛出异常），那么pb始终会指向一块被删除的Bitmap。我们无法安全地删除pb,甚至读取它。</p>
<h2 id="手动保证异常安全"><a href="#手动保证异常安全" class="headerlink" title="手动保证异常安全"></a>手动保证异常安全</h2><p>因为只要解决了异常安全性，那么自赋值安全性就会必然得到解决，所以我们倾向于使用足够完美的逻辑避免异常的发生，其原理也很简单：在赋值pb前别删pb<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitnap * porig = pb；</span><br><span class="line">pb =<span class="keyword">new</span> bitmap(rhs.pb);</span><br><span class="line"><span class="keyword">delete</span> porig;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><br>这样的好处不言自明，如果pb没能正确赋值，其对象也没有被析构。（异常发生时跳出了operator=函数，因此没有执行delete porig）。如果正确赋值，pb指向的对象被释放。</p>
<h2 id="copy-amp-amp-swap"><a href="#copy-amp-amp-swap" class="headerlink" title="copy&amp;&amp;swap"></a>copy&amp;&amp;swap</h2><p>还有一个十分灵巧的operator=撰写技巧：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widegt&amp; rhs)</span></span>;<span class="comment">//彻底交换数据</span></span><br><span class="line">&#125;</span><br><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果operator=接受的参数是by value而非by reference，那我们连temp都可以省略:</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>确保自赋值安全性。其技术包括比较lhs与rhs的地址，先做backup，以及copy-and-swap</li>
<li>确定任何操作一个以上的对象的函数，如果其操作对象是同一个对象时，还能保持正确性。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/STL%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/STL%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/" itemprop="url">12. STL容器的线程安全性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T09:59:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="STL提供的线程安全性"><a href="#STL提供的线程安全性" class="headerlink" title="STL提供的线程安全性"></a>STL提供的线程安全性</h1><p>&nbsp;<br>基本上STL容器提供的线程安全性只有以下两点：</p>
<ol>
<li><strong>多个线程读取是安全的</strong><br>多个线程可以读同一个容器内的数据，读时不允许写操作</li>
<li><strong>多个线程对不同的容器写入是安全的</strong></li>
</ol>
<hr>
<h1 id="如何实现线程安全性"><a href="#如何实现线程安全性" class="headerlink" title="如何实现线程安全性"></a>如何实现线程安全性</h1><p>&nbsp;<br>完全的线程安全很难实现，一个库可能试图以下列方式实现这样完全线程安全的容器：</p>
<ol>
<li>对于容器成员函数的每一次调用都锁住该容器直到调用完成。</li>
<li>在容器返回的迭代器生存期结束之前锁住容器</li>
<li>对于作用于容器的每个算法，在算法执行期间都锁住容器。（实际上这一点毫无必要，因为算法无法识别它们正在操作的容器)</li>
</ol>
<hr>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>&nbsp;<br>现在考虑一个例子：将vector内的第一个5改成0，如果它存在的话。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>())&#123;</span><br><span class="line">    *first5 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在多线程运行环境中，另一个线程可能在find操作完成后立刻修改v中的数据。那样第三行与v.end的检测将毫无意义，因为v的元素已经不再是原来的元素。并且如果执行了插入或者删除操作，first5也已经失效。<br>之前列举的3个方法都无法防止上述问题，迭代器调用返回得很快，生存期只有一行，find也是，无法帮助锁定。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>为了保证上述代码的线程安全，v必须从行1到行3都保持锁定，STL无法做到自动判断容器是否需要锁定，因此必须手动完成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">getMutexFor(v);<span class="comment">//需要自己实现的容器锁操作</span></span><br><span class="line"><span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    *first5 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">releaseMutexFor(v);</span><br></pre></td></tr></table></figure><br>从面向对象的角度而言，解决方法是构建一个lock类，其类模板大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Lock(<span class="keyword">const</span> Containers container)</span><br><span class="line">        : c(container)&#123;</span><br><span class="line">            getMutexFor(c);</span><br><span class="line">        &#125;</span><br><span class="line">    ~Lock()&#123;</span><br><span class="line">        releaseMutexFor(c); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> Container&amp; c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，这种方法是在用类来管理资源的生存期（RAII)，其使用案例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">lock</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *first5 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//lock对象析构，v解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>另外，这种解决方案是异常安全的，因<strong>为在异常发生的情况下，局部对象会被销毁，此时lock也会释放互斥量</strong>。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>STL允许在一个容器上的多线程读取和不同容器上的多线程写入，除此之外不能依赖任何库自带的线程安全性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/%E4%BB%A4operator=%E8%BF%94%E5%9B%9E%E8%87%AA%E8%BA%AB%E7%9A%84reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/%E4%BB%A4operator=%E8%BF%94%E5%9B%9E%E8%87%AA%E8%BA%AB%E7%9A%84reference/" itemprop="url">11. 令operator=返回reference to *this</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T09:43:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>operator= 的一大特点在于可以写成连锁形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">x=y=z=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><br>operator= 采用右结合律，所以上式被解析为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=(y=(z=<span class="number">15</span>));</span><br></pre></td></tr></table></figure><br>为了实现这种连锁赋值，operator=必须返回一个reference指向操作符的左侧实参，这是实现operator=的协议要求：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该协议不仅仅适用于operator=，也适用于所有赋值相关操作，例如operator+=之类。（关于操作符的复合形式，其实现亦有特点，具体可见More Effective C++ 22）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/%E8%87%AA%E5%AE%9A%E4%B9%89allocator%E7%9A%84%E5%90%88%E7%90%86%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/%E8%87%AA%E5%AE%9A%E4%B9%89allocator%E7%9A%84%E5%90%88%E7%90%86%E7%94%A8%E6%B3%95/" itemprop="url">11. 自定义allocator的合理用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T09:00:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（本节内容并未完全掌握，建议学习STL源码剖析相关章节后再次复习本章）</p>
<h1 id="何时需要自定义allocator？"><a href="#何时需要自定义allocator？" class="headerlink" title="何时需要自定义allocator？"></a>何时需要自定义allocator？</h1><p>&nbsp;<br>如果你对STL中默认的allocator感到不满，因为： </p>
<ol>
<li>你发现它太慢、浪费内存或造成过度的碎片</li>
<li>本次编写的程序无需考虑多线程，没必要支付同步开销</li>
<li>某些容器里的对象通常一同被使用，所以需要在一个特别的堆里把它们放得很近，使引用的区域性最大化</li>
<li>需要建立一个相当于共享内存的唯一的堆，然后把一个或多个容器放在那块内存里，使其他进程得以共享</li>
</ol>
<p>那你需要一种自定义allocator的方案（包括但不限定于上述几种情况）。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><h2 id="建立一个相当于共享内存的堆"><a href="#建立一个相当于共享内存的堆" class="headerlink" title="建立一个相当于共享内存的堆"></a>建立一个相当于共享内存的堆</h2><p>假定我们有一些特殊过程，采用malloc与free内存模型来管理一个位于共享内存的堆，并且需要把STL容器的内容放置于共享内存：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mallocShared</span><span class="params">(<span class="keyword">size_t</span> bytesNeeded)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeShared</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedMemoryAllocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type numObiects, <span class="keyword">const</span> <span class="keyword">void</span> *localityHint = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;pointer&gt;(mallocShared(numObiects * <span class="keyword">sizeof</span>(T)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer ptrToMemory, size_ type numObjects)</span></span>&#123;</span><br><span class="line">        freeShared(ptrToMiemory);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>SharedMemoryAllocator的使用方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>, SharedMemoryAllocator&lt;<span class="keyword">double</span>&gt; &gt; SharedDoubleVec;</span><br><span class="line">...</span><br><span class="line">&#123; <span class="comment">// 开始某一个块</span></span><br><span class="line">    SharedDoubleVec v; <span class="comment">//v在共享内存中</span></span><br><span class="line">... <span class="comment">// 结束这个块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但值得注意的是：v使用了自定义allocator作为分配器，因此所分配的容纳元素的内存必然来自共享内存<strong>。但是v自己，包括其所有数据成员，必然不会出现在共享内存中，它们存在于栈内。</strong><br>为了把v的内容与v自身一起放入共享内存，有操作如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *pVectorMemory =  mallocShared(<span class="keyword">sizeof</span>(SharedDoubleVec));<span class="comment">// 分配内存容纳SharedDoubleVec对象</span></span><br><span class="line">SharedDoubleVec *pv = <span class="keyword">new</span> (pVectorMemory) SharedDoubleVec;<span class="comment">//placement new 操作详见Effective C++ 52</span></span><br><span class="line">...<span class="comment">//使用pv</span></span><br><span class="line">pv-&gt;~SharedDoubleVec(); <span class="comment">//销毁共享内存中的容器</span></span><br><span class="line">freeShared(pVectorMemory); <span class="comment">// 销毁共享内存块</span></span><br></pre></td></tr></table></figure><br>总地来说，使用步骤依次为：<br>分配➡️构造➡️析构➡️释放</p>
<h2 id="聚合容器内的元素"><a href="#聚合容器内的元素" class="headerlink" title="聚合容器内的元素"></a>聚合容器内的元素</h2><p>假设我们有Heap1与Heap2两个堆，每个堆都有相应的静态成员函数来执行内存分配和释放操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">alloc</span><span class="params">(<span class="keyword">size_t</span> numBytes, <span class="keyword">const</span> <span class="keyword">void</span> *memoryBlockToBeNear)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealloc</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap2</span> &#123;</span> ... &#125;; <span class="comment">//接口与Heap1类似</span></span><br></pre></td></tr></table></figure><br>进一步地,我们想自定义容器元素容纳于哪一个堆。因此，我们必须设定一个分配器，使用像heap1，heap2那样真实管理内存的类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenameT, <span class="keyword">typename</span> Heap&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecificHeapAllocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type numObjects, <span class="keyword">const</span> <span class="keyword">void</span> *localityHint = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;pointer&gt;(Heap::alloc(numObjects * <span class="keyword">sizeof</span>(T),localityHint));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer ptrToMemory, size_type numObjects)</span></span>&#123;</span><br><span class="line">        Heap::dealloc(ptrToMemory);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>然后再使用allocator把容器的元素集合到一起：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, SpecificHeapAllocator&lt;<span class="keyword">int</span>,Heap1&gt; &gt; v;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, SpecificHeapAllocator&lt;<span class="keyword">int</span>,Heap1&gt; &gt; s;</span><br><span class="line"><span class="built_in">list</span>&lt;Widget,SpecificHeapAllocator&lt;Widget,Heap2&gt; &gt; L;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, less&lt;<span class="keyword">int</span>&gt;,SpecificHeapAllocator&lt;pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">string</span>&gt;,Heap2&gt; &gt; m;</span><br></pre></td></tr></table></figure><br>值得注意的是，<strong>Heap1和Heap2是类型而不是对象</strong>。如果Heap1和Heap2是对象而不是类型，那么它们将是不等价的分配器，那就违反了分配器的等价约束。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/08/%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/" itemprop="url">10.绝不在构造和析构过程中调用virtual函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T18:56:00+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++禁止在构造和析构期间调用virtual函数，这是它与Java或者C#的一大不同之处。</p>
<hr>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>假设我们现有一个class用来模拟股市交易，显然每一笔订单都需要经过审计，那么在审计日志中必然也需要创建一笔交易记录，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;<span class="comment">//因交易类型不同做出不同的记录</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction()&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction();<span class="comment">//构造的最后执行记录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span><span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span></span>;<span class="comment">//因交易类型不同做出不同的记录</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>试想一下，当这行语句执行时会发生什么？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="构造、析构次序与virtual函数"><a href="#构造、析构次序与virtual函数" class="headerlink" title="构造、析构次序与virtual函数"></a>构造、析构次序与virtual函数</h1><p>当我们创建derived class时，无疑bc的构造函数优先被调用，因为base class成分会在derived class自身成分被构造之前先构造完毕。这个时候问题来了，bc的构造函数最后使用了virtual function，但它调用的并不是derived class定义的版本，而是bc的pure virtual版。有一个不太恰当的解释：在构造base class构造期间，virtual函数并不是virtual函数。</p>
<p>因为base class的构造早于derived class构造函数，当base class构造函数执行时derived class的成员变量尚未初始化。如果在这期间调用derived class版本的virtual function，无疑该函数几乎必然使用local成员变量，而他们尚未初始化。</p>
<p>更根本的原因在于，<strong>在derived class的base成分构造期间，对象的类型是base class而非derived class。</strong>如果我们试图用dynmaic_cast或者typeid，这些函数也会把对象视为base class类型。这么对待对象是合理的：因为derived class的专属成分尚未被初始化，那么面对它们最安全的做法就是视而不见。<strong>对象在derived class构造函数开始执行前不会成为一个derived class对象。</strong></p>
<p>相同道理也适用于析构函数。当进入了base class的析构函数后，析构对象已经变成了一个base class对象。你不可能在一个bc对象上调用dc的成员函数。</p>
<hr>
<h1 id="潜在危险"><a href="#潜在危险" class="headerlink" title="潜在危险"></a>潜在危险</h1><p>并非每一种virtual函数都明明白白地写在构造或者析构函数中等你改正，考虑下面这种情况：由于构造函数往往有多个，我们通常倾向于把构造函数们共同使用的那一部分代码放进一个初始化函数，但是init函数可能会包含一个virtual函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction() &#123;init();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    init()&#123;</span><br><span class="line">        ...</span><br><span class="line">        logTransaction();<span class="comment">//此处调用了virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种方法十分毒瘤，因为不会有任何连接器和编译器报错我们只能认真地检查构造函数和析构函数，<strong>确保不管是它们自身还是它们所调用的那些函数都不含有任何virtual函数</strong>。</p>
<hr>
<h1 id="根治策略"><a href="#根治策略" class="headerlink" title="根治策略"></a>根治策略</h1><p>上述解决方法本质上仍然无法解决每当对象被创建就会自发记录的问题，我们已经了解无法在构造/析构函数中使用virtual函数,所以解决方法是将其改为non-virtual,要求dc构造函数必须传递必要信息给Transaction构造函数，而后那个构造函数就可以安全地调用non-virtual logTransaction。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; logInfo)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; logInfo)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">string</span>&amp; logInfo)&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span><span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BuyTransaction(parameters):</span><br><span class="line">        Transaction(createLogString(parameters))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>因为我们做不到virtual函数从base class向下调用，在构造期间，我们只能令derived class将必要的构造信息传递至base class的构造函数。<br><strong>比起在成员初值列给予base class所需要的数据，利用辅助函数创建一个值传给base class往往更加可读。令此函数为static，也就不可能指向derived class内尚未初始化的成员变量。</strong></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不要在构造和析构过程中调用virtual函数，因为此类调用从不会下降至dc层。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/08/%E4%BA%86%E8%A7%A3allocator%E7%9A%84%E7%BA%A6%E5%AE%9A%E4%B8%8E%E9%99%90%E5%88%B6md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/%E4%BA%86%E8%A7%A3allocator%E7%9A%84%E7%BA%A6%E5%AE%9A%E4%B8%8E%E9%99%90%E5%88%B6md/" itemprop="url">10.了解allocator的约定与限制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T12:49:00+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（本节内容并未完全掌握，建议学习STL源码剖析相关章节后再次复习本章）<br>allocator最初作为内存模型的抽象而产生，但最终失败了。后来又被设计成促进全功能内存管理器，但又发现可能会造成效率低下，最终，allocator被弱化成为了对象。</p>
<hr>
<h1 id="allocator的特点"><a href="#allocator的特点" class="headerlink" title="allocator的特点"></a>allocator的特点</h1><p>类似于operator new 和operator new[]，allocator也负责分配和回收内存，但其接口和new，new[],或者malloc毫无相似之处。并且，大部分容器从未向它们相关的allocator索取内存。这是相当奇怪的一点。</p>
<p>正如前文提到的，allocator最初作为内存模型的抽象而产生，那么它必须为其所定义的内存模型中的指针和引用提供类型定义，一般而言，一个类型为T的对象，它的默认allocator<T>提供了allocator<T>::pointer与allocator<T>::reference;</p>
<p>如果你对C++十分了解，你会发现其实我们无法模拟一个引用。这需要重载operator. （该操作符禁止重载）而且模拟引用最好的方式是使用代理对象（proxy object详见More Effective C++ 30),代理对象会带来许多问题。</p>
<p><strong>c++标准明确指出，允许库实现者假定每个分配子的指针等价于T*，而其引用等价于T&amp;.</strong>也就是说，库实现可以忽视typedef并直接使用原始指针和引用。</p>
<p>allocator是对象这一性质意味着它可以拥有成员函数、嵌套类型和类型定义（如reference与pointer）。同时c++标准再一次规定，<strong>STL的实现可以假定所有属于同一种类型的allocator对象等价，且比较结果相等</strong>，这非常很奇怪，但是是可以理解并接受的，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 一个用户定义的分配器模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialAllocator</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">typedef</span> SpecialAllocator&lt;Widget&gt; SAW;</span><br><span class="line"><span class="built_in">list</span>&lt;Widget, SAW&gt; L1;</span><br><span class="line"><span class="built_in">list</span>&lt;Widget, SAW&gt; L2;</span><br><span class="line">...</span><br><span class="line">L1.splice(L1.<span class="built_in">begin</span>(), L2); <span class="comment">// 把L2的节点移到L1前端</span></span><br></pre></td></tr></table></figure><br>众所周知，当list的元素从一个list链接到另一个时，并没有复制任何东西，而是仅仅调整了一些指针。当L1被析构时，L1的allocator必须析构自己的所有节点并释放内存，但其现在包含了L2的节点，所以它必须释放最初由L2的allocator分配的节点，这也就是allocator同类型等价的原因，<strong>允许一个allocator对象分配的内存可以由另一个allocator对象安全删除</strong>。<br>这一点也禁止了allocator不允许存在自己的state，更直白的说，allocator不允许有任何non-static成员，如果存在则无法等价。</p>
<hr>
<h1 id="allocator与内存分配"><a href="#allocator与内存分配" class="headerlink" title="allocator与内存分配"></a>allocator与内存分配</h1><p>allocator与new在分配内存上有一点相似之处：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line">pointer allocator&lt;T&gt;::allocate(size_type numObjects);<span class="comment">//pointer 等价于T*</span></span><br></pre></td></tr></table></figure><br>对于new而言，它的参数是所需字节的大小，而<strong>allocator的参数是分配多少个对象</strong>。它们的返回值也不同，operator new返回void*，而allocator<T>::allocate则是返回T*，而且这个<strong>返回值并没有指向某个T对象</strong>，因为根本还没有构造。</p>
<hr>
<h1 id="容器与它们对应的allocator"><a href="#容器与它们对应的allocator" class="headerlink" title="容器与它们对应的allocator"></a>容器与它们对应的allocator</h1><p>大多数标准容器从未单独调用过对应的allocator，这种情况普遍发生于基于节点的容器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>,allocator&lt;<span class="keyword">int</span>&gt; &gt; L; <span class="comment">//allocator&lt;int&gt;从未分配内存</span></span><br><span class="line"><span class="built_in">set</span>&lt;Widget, SAW&gt; s; <span class="comment">//SAW从未分配内存</span></span><br></pre></td></tr></table></figure><br>list&lt;T&gt;的一个可能实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Allocator = allocator&lt;T&gt; &gt;</span><br><span class="line">class <span class="built_in">list</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Allocator alloc; <span class="comment">// 用于T类型对象的分配器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span> <span class="comment">// 链表里的节点</span></span><br><span class="line">        T data:</span><br><span class="line">        ListNode *prev;</span><br><span class="line">        ListNode *next;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当添加一个node到list时，我们需要从分配器为其获取内存，我们要的并非是T的内存，而是包含了一个T的ListNode的内存。那allocator&lt;T&gt;基本上就是废了。<br>list需要的是从他的分配器类型那里获取用于Listnode的对应分配器的方法。按照协定，分配器需要提供完成那部分工作的typedef，实际上这个东西叫other.是嵌入一个叫做rebind的结构体的typedef，rebind自己是一个嵌入分配器的模板—分配器自己也是一个模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span> &#123;</span><span class="comment">// 分配器模板</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在list<T>的实现代码里，需要确定我们持有的T的分配器所对应的ListNode的分配器类型，所以，list的allocator类型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allocator::rebind&lt;ListNode&gt;::other</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>如果你需要自己实现一个allocator，你需要明确：</p>
<ol>
<li>allocator是一个模板</li>
<li>提供pointer与reference的typedef</li>
<li>不要给allorator分配state，通常不含有non-static成员</li>
<li>传给allocate的是对象个数而非字节数，同时记得其返回T*指针。</li>
<li>一定要提供标准容器依赖的内嵌rebind模板</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/08/%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%E7%A6%BB%E5%BC%80%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%E7%A6%BB%E5%BC%80%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" itemprop="url">9.禁止异常离开析构函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T12:00:00+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++并不禁止析构函数抛出异常，但需要明确：<strong>析构函数抛出异常存在风险</strong>。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>考虑如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~Widget() &#123;...&#125;<span class="comment">//可能抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Widget&gt; v;</span><br><span class="line">    ...<span class="comment">//v在此处被自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当vector被销毁时，所有的Widget对象都会被销毁。于是我们一一调用析构函数.假设在析构第一个元素时，有一个异常被抛出，但剩下的还是应该被销毁（否则就会资源泄漏），因此会接着销毁第二个，但如果第二个Widget被析构时又抛出了异常，于是现在有了两个同时作用的异常，<strong>C++不允许处理多个异常同时存在的情况</strong>。<strong>在两个异常同时存在的情况下，c++不是立刻结束运行就是导致不明确行为</strong>。在本例中就是会导致不明确行为。<br>我们需要记住的是：<strong>只要析构抛出异常，程序就可能过早结束或者行为不明确</strong>。</p>
<hr>
<h1 id="问题实例及解决方案"><a href="#问题实例及解决方案" class="headerlink" title="问题实例及解决方案"></a>问题实例及解决方案</h1><h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设我们建立了一个数据库连接类，其行为如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;<span class="comment">//返回对象 static成员函数不属于对象而是属于类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭连接，关闭失败则抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了确保DBConnection对象必然会关闭，很自然地，我们会建立一个类来管理DBConnection对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DBConn()&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();<span class="comment">//析构函数中可能抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果析构时抛出异常，DBConn会传播该异常（允许其离开析构函数），那么结果相当麻烦。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="修改析构函数"><a href="#修改析构函数" class="headerlink" title="修改析构函数"></a>修改析构函数</h3><h4 id="抛出异常就终结程序（调用abort）"><a href="#抛出异常就终结程序（调用abort）" class="headerlink" title="抛出异常就终结程序（调用abort）"></a>抛出异常就终结程序（调用abort）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123; db.<span class="built_in">close</span>():&#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        ...<span class="comment">//记录失败至日志</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这直接导致了程序突然结束，但至少它阻止了异常的传播。</p>
<h4 id="直接吞下异常，不对它进行处理"><a href="#直接吞下异常，不对它进行处理" class="headerlink" title="直接吞下异常，不对它进行处理"></a>直接吞下异常，不对它进行处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123; db.<span class="built_in">close</span>():&#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        ...<span class="comment">//记录失败至日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这基本上会导致雪崩，但有时我们不能立刻终结程序，毕竟能跑总比不能用要好。</p>
<h3 id="重新设计DBConn类接口（较优策略）"><a href="#重新设计DBConn类接口（较优策略）" class="headerlink" title="重新设计DBConn类接口（较优策略）"></a>重新设计DBConn类接口（较优策略）</h3><p>我们可以重新设计DBConn，使用户可以对发生异常做出反应。或者说追踪connection是否被关闭，如果未被关闭则由析构函数关闭。但如果析构函数调用close失败，我们还是又将退回“强迫结束程序”或者“吞下异常”的老路：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;<span class="comment">//供客户使用的关闭函数</span></span><br><span class="line">        db.<span class="built_in">close</span>();<span class="comment">//调用时不会在析构函数中抛出异常</span></span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBConn()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)&#123;<span class="comment">//如果用户没有手动关闭连接</span></span><br><span class="line">            <span class="keyword">try</span>&#123;db.<span class="built_in">close</span>();&#125;</span><br><span class="line">            <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">                <span class="comment">//使用上述两种处理方式之一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种写法把调用close的责任从析构函数转移到了客户手中。可能有人会认为这令接口变得不方便使用，但实际<strong>上如果某个操作可能在失败时抛出异常，又存在某种必要必须处理该异常，那么这个异常必须来自析构函数之外的某个函数</strong>。因为析构函数抛出异常必然会导致过早结束程序或者发生不明确行为的风险。<br>如果用户没用close来关闭连接,那至少析构函数中也适当的调用了它，这时候再发生错误用户也没资格抱怨，因为毕竟我们提供了接口，而他们选择了放弃使用。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>析构函数绝对不能吐出异常，如果一个被析构函数调用的函数可能会抛出异常，那我们的析构函数应该捕捉任何异常，然后吞下它们（不传播）或者结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/08/%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/" itemprop="url">9.慎重选择删除元素的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T10:15:00+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="删除某个值-10"><a href="#删除某个值-10" class="headerlink" title="删除某个值&#10;"></a>删除某个值&#10;</h1><p>假设我们有一个容器，其内部元素类型为int.现在需要删除容器c内所有值为1963的元素，值得注意的是，完成这项任务的方法因不同的容器类型而不同，<strong>无通用解</strong>。</p>
<h2 id="连续内存容器（vector-deque-string"><a href="#连续内存容器（vector-deque-string" class="headerlink" title="连续内存容器（vector,deque,string)"></a>连续内存容器（vector,deque,string)</h2><p>最好的删除操作是erase—remove惯用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.erase(<span class="built_in">remove</span>(c.<span class="built_in">begin</span>()，c.<span class="built_in">end</span>()，<span class="number">1963</span>)，c.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>list也可以用erase_remove，但是最好直接使用remove：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">remove</span>(<span class="number">1963</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="标准关联容器"><a href="#标准关联容器" class="headerlink" title="标准关联容器"></a>标准关联容器</h2><p>标准关联容器没有remove成员函数，其删除操作的正确做法是使用erase<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.erase(<span class="number">1963</span>);</span><br></pre></td></tr></table></figure><br>这种做法兼具高效性与正确性，对数时间开销，同时<strong>关联容器的erase基于等价而非相等</strong>。(详见Effective STL 19）</p>
<hr>
<h1 id="删除所有符合条件的值"><a href="#删除所有符合条件的值" class="headerlink" title="删除所有符合条件的值"></a>删除所有符合条件的值</h1><h2 id="序列容器（连续内存容器与list）"><a href="#序列容器（连续内存容器与list）" class="headerlink" title="序列容器（连续内存容器与list）"></a>序列容器（连续内存容器与list）</h2><p>我们只需要把remove改为remove_if<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">badValue</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">c.erase(remove_if(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),badValue),c.<span class="built_in">end</span>());<span class="comment">//连续内存容器</span></span><br><span class="line">c.remove_if(badValue); <span class="comment">//list</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p>对于关联容器，一般有两种方法来处理这一情况，一个容易编码，一个高效。</p>
<h3 id="容易编码的方法"><a href="#容易编码的方法" class="headerlink" title="容易编码的方法"></a>容易编码的方法</h3><p>其原理为：remove_copy_if把我们需要的值拷贝到新容器中，然后把原容器内容与新容器的交换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c; </span><br><span class="line">... </span><br><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; goodValues; <span class="comment">//临时容器</span></span><br><span class="line">remove_copy_if(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), inserter(goodValues, goodValues.<span class="built_in">end</span>()), badValue);</span><br><span class="line">c.swap(goodValues); <span class="comment">// 交换c和goodValues</span></span><br></pre></td></tr></table></figure><br>这种方法的缺点是它拷贝了所有不删除的元素,直接造成了效率极低。</p>
<h3 id="高效的方法"><a href="#高效的方法" class="headerlink" title="高效的方法"></a>高效的方法</h3><p>其直接从容器中删除元素，不过关联容器没有remove_if之类的成员函数，所以必须通过循环来完成，首先给出一个错误案例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>(); i!= c.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (badValue(*i)) c.erase(i);<span class="comment">//未考虑迭代器失效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了避免迭代器失效，我们必须保证<strong>在调用erase之前就得到了c中下一个元素的迭代器</strong>，所以有正确写法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();<span class="comment">/*nothing*/</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span> (badValue(*i)) c.erase(i++); <span class="comment">//如果需要删除，删除当前位置并自增迭代器</span></span><br><span class="line"><span class="keyword">else</span> ++i;<span class="comment">//不需要删除则直接递增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="删除元素后记录日志"><a href="#删除元素后记录日志" class="headerlink" title="删除元素后记录日志"></a>删除元素后记录日志</h1><h2 id="关联容器-1"><a href="#关联容器-1" class="headerlink" title="关联容器"></a>关联容器</h2><p>对于关联容器，只要在循环内部增加一条语句即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ofstream logFile; <span class="comment">//日志文件</span></span><br><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>();i !=c.<span class="built_in">end</span>();)&#123;</span><br><span class="line">    <span class="keyword">if</span> (badValue(*i))&#123;</span><br><span class="line">        logFile &lt;&lt; <span class="string">"Erasing "</span> &lt;&lt; *i &lt;&lt;<span class="string">'\n'</span>; <span class="comment">//写日志文件</span></span><br><span class="line">        c.erase(i++); <span class="comment">// 删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="连续内存容器"><a href="#连续内存容器" class="headerlink" title="连续内存容器"></a>连续内存容器</h2><p>与关联容器不同，连续容器的erase不仅令当前迭代器失效，也同时令后面的迭代器失效。所以我们必须利用<strong>erase返回被删除元素之后的元素的迭代器</strong>的特性，完成操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.<span class="built_in">begin</span>();i != c.<span class="built_in">end</span>();)&#123;</span><br><span class="line">    <span class="keyword">if</span> (badValue(*i))&#123;</span><br><span class="line">        logFile &lt;&lt; <span class="string">"Erasing "</span> &lt;&lt; *i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        i = c.erase(i);<span class="comment">//利用返回值，也是C++ primer描述容器删除时使用的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h2><p>对于list，上述两种方法都行。</p>
<hr>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>去除容器内有特定值的对象，连续容器使用erase-remove，list使用remove，关联容器使用erase</li>
<li>去除满足某个判定式的所有对象，连续容器使用erase-remove_if，list使用remove_if，关联容器则使用remove_cooy_if与swap，或者使用循环（记得后置递增）</li>
<li>需要在循环中做操作时，连续内存容器记得要利用erase返回值更新迭代器，关联容器同2。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/08/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E7%94%9F%E6%88%90virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E7%94%9F%E6%88%90virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" itemprop="url">8.为多态基类生成virtual析构函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T09:33:00+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>假设我们定义了一个base class，并随之延伸出一些derived class。用户只需要在程序中使用某个功能，并不关心其实现。因此，我们可以设计一个factory函数。(工厂模式详见More Effective C++ 25）<br>factory函数返回一个base clsss指针，指向新生成的derived class对象。 返回的对象必须位于heap，因此为了避免泄漏内存和其他资源，factory返回的每一个对象都应该被适当的delete。举例而言：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span>&#123;</span><span class="comment">//计时器基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    ~TimeKeeper();<span class="comment">//此处不应该使用non-virtual析构函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicClock</span>:</span><span class="keyword">public</span> TimeKeeper&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterClock</span>:</span><span class="keyword">public</span> TimeKeeper&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">TimeKeeper* ptk=getTimeKeeper();<span class="comment">//factory函数</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;释放以避免资源泄露</span><br></pre></td></tr></table></figure><br>问题在于factory返回的指针指向一个derived class对象，而那个对象却经由一个base class指针被删除。如果base class的析构函数是non-virtual，则我们再次雪崩。</p>
<hr>
<h1 id="多态基类不使用virtual析构的后果"><a href="#多态基类不使用virtual析构的后果" class="headerlink" title="多态基类不使用virtual析构的后果"></a>多态基类不使用virtual析构的后果</h1><p>c++明确指出，当derived class对象由一个base class指针被删除，而base class带着一个non-virtual析构函数，<strong>其结果未定义</strong> — 一般来说，实际执行时对象的derived成分没被销毁，derived class的析构函数也没执行。也就是说我们得到了一个诡异的<strong>局部销毁对象</strong>。</p>
<hr>
<h1 id="何时需要virtual析构函数？"><a href="#何时需要virtual析构函数？" class="headerlink" title="何时需要virtual析构函数？"></a>何时需要virtual析构函数？</h1><p>一般来说，base class都会有那么一个virtual function。我们在这里指出，<strong>只要一个class有virtual function，我们都应该把它的析构函数定义为virtual。</strong></p>
<p><strong>如果一个class不被用作base class，那给他定义一个virtual 析构函数非常愚蠢</strong>。原因是这样的：<br>欲实现出virtual函数，对象必须携带某些信息，要来指出在运行期哪个virtual函数被调用。这份信息一般由一个virtual table pointer指出。vtp指向一个vbtl(virtual table)每一个带virtual函数的class都会有一个vtbl，当函数调用某个virtual函数，实际被调用的函数取决于对象的vptr所指向的vtbl—编译器在其中寻找函数指针。（关于虚函数的使用成本，详见More Effective C++ 24）<br>总之，虚函数的引入增加了class的大小，并且破坏了原有的内存结构。</p>
<p>另外，<strong>STL所有的类都不能作为base class，它们也没有virtual析构函数</strong>。</p>
<hr>
<h1 id="virtual析构函数在abstract-class中的用法"><a href="#virtual析构函数在abstract-class中的用法" class="headerlink" title="virtual析构函数在abstract class中的用法"></a>virtual析构函数在abstract class中的用法</h1><p>有时我们希望定义一个abstract class，但是手头上并没有pure virtual function，那解决方法很简单：<strong>声明一个pure virtual 析构函数</strong>。<br>但事情还没完，我们<strong>不仅仅需要声明，还需要定义</strong>这个析构函数。可能你会诧异于pure function居然还需要实现，但实际上pure function和有没有实现并没有任何联系。（该论述详见More Effective C++ 33）,具体声明和定义如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span>｛</span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line">    <span class="keyword">virtual</span> ～c() = <span class="number">0</span>;<span class="comment">//声明式</span></span><br><span class="line">&#125;;</span><br><span class="line">c::~c() &#123;&#125;<span class="comment">//定义式</span></span><br></pre></td></tr></table></figure><br>因为析构函数的运作规则是是从最深层派生的class开始调用其析构，然后是每一个base class。在derived class的析构动作中编译器会创建一个对其基类析构函数的调用动作，如果没有定义，连接器会报错。</p>
<hr>
<h1 id="是否只要是base-class就需要析构函数？"><a href="#是否只要是base-class就需要析构函数？" class="headerlink" title="是否只要是base class就需要析构函数？"></a>是否只要是base class就需要析构函数？</h1><p>正如标题所说，<strong>只有使用了多态性的base class（具备虚函数）才需要virtual析构</strong>。<br>诸如上节提到的uncopyable类，其根本不需要使用virtual 析构函数。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>polymorphic base class应该声明一个virtual析构。如果一个类至少有一个virtual function，把它也应该拥有一个virtual析构函数</li>
<li>class 不具有多态性或者根本不作为base class，那就不要搞virtual析构。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/08/%E5%88%87%E5%8B%BF%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%ABauto_ptr%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/%E5%88%87%E5%8B%BF%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%ABauto_ptr%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1/" itemprop="url">8.切勿创建包含auto_ptr的容器对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T09:00:00+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Contain of auto_ptr (COAP)被禁止使用，其代码无法编译。原因很简单，COAP无法移植，再究其根本，在于auto_ptr被复制后，它所指向的对象的所有权被移交给lhs，而自身被置为nullptr,其特性可以用代码表述如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; <span class="comment">// pw1指向一个Widget</span></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">pw2</span><span class="params">(pw1)</span></span>; <span class="comment">// pw2指向pw1的Widget,pw1被设为nullptr</span></span><br><span class="line">pw1 = pw2; <span class="comment">// pw1现在再次指向Widget，pw2被设为nullptr</span></span><br></pre></td></tr></table></figure><br>举一个COAP的例子，它建立一个包含auto_ptr&lt;Widget&gt;的vector,然后对这个vector内部元素排序，其排序指标是一个谓词：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">widgetAPCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;Widget&gt;&amp; lhs,<span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;Widget&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *lhs &lt; *rhs; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">auto_ptr</span>&lt;Widget&gt; &gt; widgets; </span><br><span class="line">sort(widgets.<span class="built_in">begin</span>(), widgets.<span class="built_in">end</span>(),widgetAPCompare);<span class="comment">//无法编译</span></span><br></pre></td></tr></table></figure><br>这段代码看起来很合理，但实际上不行，原因在于在排序过程中widget中的一个或多个auto_ptr被置为null.之所以会这样，是快排的锅。快排的基本思想在于把容器内的某个元素作为pivot elements，然后对大于和小于等于该元素的其他元素递归调用排序。其方法看起来像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>，<span class="title">class</span> <span class="title">Compare</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,<span class="title">RandomAccessIterator</span> <span class="title">last</span>,<span class="title">Compare</span> <span class="title">comp</span>)&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;RandomAccessIterator&gt;::value_type ElementType;</span><br><span class="line">    RandomAccessIterator i;</span><br><span class="line">    ... <span class="comment">// 让i指向主元</span></span><br><span class="line">    <span class="function">ElementType <span class="title">pivotValue</span><span class="params">(*i)</span></span>;<span class="comment">//将主元拷贝到一个局部变量中</span></span><br><span class="line">    ...<span class="comment">//接着排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个typename挺有讲究，强调了后面是一个类型，但我们不管，重点在于那个拷贝，它把auto_ptr的值放到了一个局部临时中，随着临时对象生命周期结束，对象也被析构了，真是倒了血霉。</p>
<p>所以说，不要搞包含auto_ptr的容器，其他智能指针配合容器倒是可以用用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/26/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xander.liu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/s">
              
                  <span class="site-state-item-count">264</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsmj2017" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lxiang2018@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xander.liu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
