<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="zsmj" />





  <link rel="alternate" href="/atom.xml" title="Xander's Wiki" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="Xander&#39;s Wiki">
<meta property="og:url" content="https://xander.wiki/page/24/index.html">
<meta property="og:site_name" content="Xander&#39;s Wiki">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xander.wiki/page/24/"/>





  <title>Xander's Wiki</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xander's Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/s" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/11/%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8vector%20bool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8vector%20bool/" itemprop="url">18.避免使用vector&lt;bool></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-11T09:26:00+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>vector&lt;bool&gt;只有两个问题：</p>
<ol>
<li>它不是一个STL容器</li>
<li>它没有容纳bool</li>
</ol>
<hr>
<h1 id="vector-lt-bool-gt-的特点"><a href="#vector-lt-bool-gt-的特点" class="headerlink" title="vector&lt;bool&gt;的特点"></a>vector&lt;bool&gt;的特点</h1><h2 id="STL的一个必要条件"><a href="#STL的一个必要条件" class="headerlink" title="STL的一个必要条件"></a>STL的一个必要条件</h2><p>STL容器的一个要求是：如果c是stl容器，且支持operator[],则以下代码可编译：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T *p = &amp;c[<span class="number">0</span>]; <span class="comment">// 无论operator[]返回什么，都可以用这个地址初始化一个T*</span></span><br></pre></td></tr></table></figure><br>具体来说就是，<strong>如果你可以使用operator[]来得到Container&lt;T&gt;中的一个T对象，那你必然可以通过取它的地址而获得指向那个对象的指针</strong>。<br>看起来很正常的要求，但vector&lt;bool&gt;做不到。</p>
<h2 id="vector-lt-bool-gt-的内存分布"><a href="#vector-lt-bool-gt-的内存分布" class="headerlink" title="vector&lt;bool&gt;的内存分布"></a>vector&lt;bool&gt;的内存分布</h2><p>vector<bool>是一个伪容器，并不保存真正的bool，而是打包bool以节约空间。确切的说，bool在vector内仅仅只占用了一个bit，我们无法创建指向单个bit的指针。</p>
<p>同样的，也不可能存在单个bit引用.为了解决这个问题，vector&lt;bool&gt;使用了proxy class（详见More Effective C++ 30),从本质上来说，vector<bool>看起来像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Allocator&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">reference</span> &#123;</span>...&#125;; <span class="comment">//proxy class</span></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n); <span class="comment">//return a proxy object</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这也说明了为什么上面的代码无法编译，因为返回的并不是bool类型，而是一个代理对象。</p>
<hr>
<h1 id="使用deque-lt-bool-gt-与bitset来替换vector"><a href="#使用deque-lt-bool-gt-与bitset来替换vector" class="headerlink" title="使用deque&lt;bool&gt;与bitset来替换vector"></a>使用deque&lt;bool&gt;与bitset来替换vector<bool></h1><ol>
<li>deque&lt;bool&gt;<br>deque提供了几乎所有vector所提供的成员函数（缺是reserve和capacity）。并且，deque&lt;bool&gt;是一个STL容器，它保存真正的bool值。</li>
<li>bitset<br>bitset不是一个STL容器，但它是C++标准库的一部分。其内存分布和vector&lt;bool&gt;差不多，其具体实现与应用可参照数据结构·Bitamap篇。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/11/new%E4%B8%8Edelete%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8%E6%97%B6%E5%BF%85%E9%A1%BB%E5%BD%A2%E5%BC%8F%E7%9B%B8%E5%90%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/new%E4%B8%8Edelete%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8%E6%97%B6%E5%BF%85%E9%A1%BB%E5%BD%A2%E5%BC%8F%E7%9B%B8%E5%90%8C/" itemprop="url">17.new与delete成对使用时必须形式相同</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-11T08:45:00+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> * stringarray = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> stringarray;</span><br></pre></td></tr></table></figure>
<p>在上述代码中我们成对地使用了<code>new</code>与<code>delete</code>，似乎避开了资源泄露，但其实并非如此。<br>上文动态分配了100个string对象，却只删除了第一个，其它string对象的析构函数根本没有被调用。</p>
<hr>
<h1 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a>new与delete</h1><h2 id="调用new与delete时发生了什么？"><a href="#调用new与delete时发生了什么？" class="headerlink" title="调用new与delete时发生了什么？"></a>调用new与delete时发生了什么？</h2><p>当你使用new的时候，有两件事会发生：</p>
<ol>
<li>内存通过<code>operator new</code>被分配出来（new操作符详见Effective C++ 50 52）</li>
<li>针对此内存有一个或多个构造函数被调用</li>
</ol>
<p>对应的，使用delete的时候也会发生两件事：</p>
<ol>
<li>一个或多个析构函数被调用</li>
<li>通过<code>operator delete</code>释放内存</li>
</ol>
<h2 id="delete如何判定对象个数？"><a href="#delete如何判定对象个数？" class="headerlink" title="delete如何判定对象个数？"></a>delete如何判定对象个数？</h2><p>delete的最大问题在于：即将被删除的内存之内究竟存有多少对象？这决定了会调用多少次析构函数。换句话说<strong>，delete需要明确：被删除的指针究竟指向单一对象还是对象数组</strong>？<br>在编译器的具体实现中，单一对象的内存布局不同于数组的内存布局，数组的内存布局中记录了数组大小，这得以让delete函数知道需要调用多少次析构函数。它们的内存布局大概是这样：<br><img src="http://static.zybuluo.com/zsmj2017/q7o6hnu7bl6ol60j9te6o2yk/image_1cap38n6l1a205v11tnn1t9017gu9.png" alt="image_1cap38n6l1a205v11tnn1t9017gu9.png-11.9kB"></p>
<h2 id="delete的正确使用"><a href="#delete的正确使用" class="headerlink" title="delete的正确使用"></a>delete的正确使用</h2><p>我们通过人为指定的方式让delete明确其操作：<strong>使用delete或delete[]</strong>;<br>前者认定当前指向的是单一对象，后者则认定当前指向数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>* pstr1 = <span class="keyword">new</span> <span class="built_in">string</span>；</span><br><span class="line"><span class="built_in">string</span>* pstr2 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> pstr1;</span><br><span class="line"><span class="keyword">delete</span>[] pstr2;</span><br></pre></td></tr></table></figure></p>
<h2 id="误用delete形式的后果"><a href="#误用delete形式的后果" class="headerlink" title="误用delete形式的后果"></a>误用delete形式的后果</h2><p>如果我们对<code>pstr1</code>使用<code>delete[]</code>,结果未定义,可想而知它会误认为当前指向某一个对象数组，然后读取某块内存将其解释为数组大小，然后反复调用析构函数。</p>
<p>如果我们对<code>pstr2</code>没有使用<code>delete[]</code>,结果亦未有定义，但肯定调用的析构函数不足。事实上，<strong>即使针对没有析构函数的内置类型，这种写法也是有害的。</strong></p>
<h2 id="new、delete与typedef"><a href="#new、delete与typedef" class="headerlink" title="new、delete与typedef"></a>new、delete与typedef</h2><p>本节的规则十分简单，无非是<strong>成对使用new与delete时必须保证形式一致</strong>，读者想必会认为稍加注意不难做到。但对于某些重度typedef爱好者而言，还是要多加留心为是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> AddressLines[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">string</span>* pal = <span class="keyword">new</span> AddressLines;<span class="comment">//pal指向的是数组对象</span></span><br><span class="line"><span class="keyword">delete</span> pal;<span class="comment">//error!</span></span><br><span class="line"><span class="keyword">delete</span>[] pal;</span><br></pre></td></tr></table></figure><br>我认为C++语言应当尽量减少对数组使用typedef定义，在降低了可读性的同时还容易引发错误。在能够使用STL容器的地方坚决不使用动态数组。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/11/swap%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E5%AE%B9%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/swap%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E5%AE%B9%E9%87%8F/" itemprop="url">17.swap去除多余容量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-11T08:10:00+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>当我们的容器内存储了海量的元素之后，可能在某个阶段会进行大量的删除，此时容器已经没有必要再持有过多的内存，为了避免浪费，应该使用某种shrink_to_fit的手法将其cap缩减到合适的大小（<strong>resize与reserve都无法减小cap</strong>）。</p>
<h1 id="Swap技巧"><a href="#Swap技巧" class="headerlink" title="Swap技巧"></a>Swap技巧</h1><h2 id="Swap与shrink-to-fit"><a href="#Swap与shrink-to-fit" class="headerlink" title="Swap与shrink_to_fit"></a>Swap与shrink_to_fit</h2><p>收缩容器的技巧在操作上十分简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sth</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Sth&gt; v;</span><br><span class="line">...<span class="comment">//Now v need to be shrinked to the fit capacity</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Sth&gt;(v).swap(v);</span><br></pre></td></tr></table></figure><br>该技巧的执行流程：</p>
<ol>
<li>建立了一个临时变量，并调用拷贝构造函数复制了v中元素<br><strong>拷贝构造只使用了需要的内存，并没有分配所有内存</strong></li>
<li>将临时对象与v交换。</li>
<li>完成此表达式后临时对象被析构。</li>
</ol>
<p>同理，收缩string也是如此：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">string</span>(s).swap(s);</span><br></pre></td></tr></table></figure></p>
<h2 id="Swap与容器清除"><a href="#Swap与容器清除" class="headerlink" title="Swap与容器清除"></a>Swap与容器清除</h2><p>Swap技巧同样也能够直接<strong>清除容器内部所有元素，并减小其容量至最小值</strong>，其原理是使用刚初始化过的临时变量与需要清除的vector或string交换，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Sth&gt; v;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">vector</span>&lt;Sth&gt;().swap(v);</span><br><span class="line"><span class="built_in">string</span>().swap(s);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/" itemprop="url">16.在资源管理类中提供对原始资源的访问</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T18:28:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>资源管理类是排除资源泄漏的壁垒，是良好设计系统的根本性质。但有许多api直接指涉资源，有时不得不绕过资源管理对象直接访问原始资源。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>举例而言，假设有一个shared_ptr保存了factory函数生成的资源，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">spInv</span><span class="params">(createInvestment())</span></span>;</span><br></pre></td></tr></table></figure><br>但现在API如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Investment* pi)</span></span>;</span><br></pre></td></tr></table></figure><br>我们肯定没法把spInv传入进去，因为该函数需要的是Investment*指针，而不是shared_ptr&lt;Investment&gt;类型的对象。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&lt;/br&gt;<br>有两个做法可以把RAII对象转换为原始资源：<strong>显式转换和隐式转换</strong>。</p>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><p>shared_ptr与auto_ptr都提供一个get成员函数，用来执行显式转换。<strong>该函数返回智能指针内部的原始指针（的副本）</strong>。我们可以写作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daysHeld(spInv.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><br>另外，智能指针并非仅有显式转换，它们重载了解引用操作符（operator*，operator-&gt;),这两种操作符执行了隐式转换。（我以为是调用了get().opertaor*，inline之后调用成本也不是很高，不过生成的文件可能变大了)</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>对于需要频繁转换的RAII classes来说，不断调用get()未免繁琐，因此我们可以提供一个隐式转换操作符。举例而言：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">explict <span class="title">Widget</span><span class="params">(WidegtHandle wh)</span>:<span class="title">w</span><span class="params">(wh)</span> </span>&#123;&#125;</span><br><span class="line">    ~Widget() &#123;<span class="built_in">release</span>(w);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">WidegtHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> w;&#125;<span class="comment">//隐式转换</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetHandle w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如此一来，在API中直接可以将RAII对象作为参数传入。<br>这样有时候会发生崩盘，比如原意是拷贝一个RAII对象，但实际上却（发生隐式转换）拷贝了资源。</p>
<hr>
<h1 id="转换接口的合理性"><a href="#转换接口的合理性" class="headerlink" title="转换接口的合理性"></a>转换接口的合理性</h1><p>&lt;/br&gt;<br>是否应该提供转换，以及哪一种转换取决于你是否需要转换或者转换的频率。要记住一切操作都是为了令接口更加灵活且不易被误用。<br>你可能会认为转换接口与封装发生了矛盾。但事实并非如此，RAII对象负责资源管理，而非起封装数据的作用。作为类的设计者，我们有责任隐藏用户不需要了解的内容，同时提供给用户一切他们需要的东西。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>APIs往往要求访问原始资源，所以每一个RAII class应该提供一个获取原始资源的函数。</li>
<li>显式转换比较安全，但隐式转换对客户比较方便，当然也更容易出错。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/STL%E5%AE%B9%E5%99%A8%E4%B8%8EC%20API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/STL%E5%AE%B9%E5%99%A8%E4%B8%8EC%20API/" itemprop="url">16.STL容器与C API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T14:39:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="获取指针"><a href="#获取指针" class="headerlink" title="获取指针"></a>获取指针</h1><p>&lt;/br&gt;<br>假设有一个vector对象v，而你需要得到一个指向v中数据的指针，这让v可以被当作一个数组在C中使用。<br>我们只需要使用<code>&amp;v[0]</code>即可获得指向首元素的指针。如果是string，请使用<code>s.c_str()</code>.<br>实际上这样做可能会有一些问题，具体而言就是v可能是空的，所以需要<strong>先对v进行empty判定</strong>。</p>
<p>有人说可以用begin这种迭代器来代替&amp;v[0],实际上这完全是胡说八道，因为并不总是能做到迭代器和指针之间的互相转换。<br><code>&amp;*v.begin()</code>倒是真的可以等价于<code>&amp;v[0]</code>,但这种写法除了让别人一目了然你的智力水平外并没有其他好处。</p>
<p>有人会疑惑为什么vctor就可以直接取址，而string不行，原因有以下两点：</p>
<ol>
<li>string的数据并没有保证被存储于连续内存（详见 Effective STL 15）</li>
<li>string并不保证以null结尾</li>
</ol>
<p>因此，string必须使用c_str:</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pString)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(s.c_str())</span></span>;</span><br></pre></td></tr></table></figure></h2><h1 id="C-API初始化STL容器"><a href="#C-API初始化STL容器" class="headerlink" title="C API初始化STL容器"></a>C API初始化STL容器</h1><h2 id="用C-API返回的元素初始化vector"><a href="#用C-API返回的元素初始化vector" class="headerlink" title="用C API返回的元素初始化vector"></a>用C API返回的元素初始化vector</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C API数需要一个指向数组的指针，数组最多有arraySize个double</span></span><br><span class="line"><span class="comment">// 功能为向数组内部写入数据，返回写入数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vd</span><span class="params">(maxNumDoubles)</span></span>;，</span><br><span class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.<span class="built_in">size</span>()));<span class="comment">//数据写入后调整大小</span></span><br></pre></td></tr></table></figure>
<h2 id="用C-API返回的元素初始化string"><a href="#用C-API返回的元素初始化string" class="headerlink" title="用C API返回的元素初始化string"></a>用C API返回的元素初始化string</h2><p>上述写法并不能应用于string类型，因为只有vector保证了与数组具有相同内存分布。（顺序表）<br>但用用C API初始化string也不难，具体来说就是先初始化一个vector&lt;char&gt;，然后再用vector初始化string：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillString</span><span class="params">(<span class="keyword">char</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">vc</span><span class="params">(maxNumChars)</span></span>; </span><br><span class="line"><span class="keyword">size_t</span> charsWritten = fillString(&amp;vc[<span class="number">0</span>], vc.<span class="built_in">size</span>());</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(vc.<span class="built_in">begin</span>(), vc.<span class="built_in">begin</span>()+charsWritten)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="用C-API返回的元素初始化STL中的任何容器"><a href="#用C-API返回的元素初始化STL中的任何容器" class="headerlink" title="用C API返回的元素初始化STL中的任何容器"></a>用C API返回的元素初始化STL中的任何容器</h2><p>因为和数组内存分布一致的只有vector，所以我们的策略十分简单：<strong>把数组内的元素传入vector，然后再用vector初始化STL容器：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vd</span><span class="params">(maxNumDoubles)</span></span>;</span><br><span class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.<span class="built_in">size</span>()));</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; <span class="title">d</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到deque</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; <span class="title">l</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到list</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; <span class="title">s</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到set</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="STL容器传递数据至C-API"><a href="#STL容器传递数据至C-API" class="headerlink" title="STL容器传递数据至C API"></a>STL容器传递数据至C API</h1><p>&lt;/br&gt;<br>从上文中自然能领会到反向传递的方法：用STL容器内的元素初始化vector，然后再用vector传入C API：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pints, <span class="keyword">size_t</span> numInts)</span></span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet; <span class="comment">//要传递给API数据的set</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(intSet.<span class="built_in">begin</span>(), intSet.<span class="built_in">end</span>())</span></span>; </span><br><span class="line"><span class="keyword">if</span> (!v.empty()) doSomething(&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E7%9A%84copying%E8%A1%8C%E4%B8%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E7%9A%84copying%E8%A1%8C%E4%B8%BA/" itemprop="url">15.资源管理类中的copying行为</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T13:55:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>在上一节的末尾，我已经提到RAII和智能指针并无直接关联，并且给出了例证。事实上，smart_ptr适用于管理heap-based资源。如果你所需要的资源不是heap-based，往往需要建立自己的资源管理类。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假定我们有类型为murtex的互斥器对象，共有lock与unlock两个函数作用其上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;<span class="comment">//锁定互斥器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;<span class="comment">//解除锁定</span></span><br></pre></td></tr></table></figure><br>基于RAII思想，我们建立一个资源管理类Lock:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line"><span class="function">        :<span class="title">mutexPtr</span><span class="params">(pm)</span> </span>&#123;lock(mutexPtr);&#125;</span><br><span class="line">    ~Lock() &#123;unlock(mutexPtr);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果资源管理类发生了复制行为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line"><span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br></pre></td></tr></table></figure><br>将会产生何种后果？</p>
<hr>
<h1 id="资源管理类的复制行为"><a href="#资源管理类的复制行为" class="headerlink" title="资源管理类的复制行为"></a>资源管理类的复制行为</h1><p>&lt;/br&gt;<br>常见做法有以下两种：</p>
<ol>
<li><strong>禁止复制</strong><br>有时允许RAII对象被复制并不合理，所以我们应该禁止它们的copy行为。如何禁止，详见Effective C++ 6</li>
<li><strong>对底层资源使用引用计数</strong><br>这种方法的最佳实现就是使用shared_ptr。通常我们只要内含一个shared_ptr成员变量，RAII classes便可以实现出reference-counting copying行为</li>
</ol>
<h2 id="引用计数在RAII中的应用"><a href="#引用计数在RAII中的应用" class="headerlink" title="引用计数在RAII中的应用"></a>引用计数在RAII中的应用</h2><p>针对Lock class，可以把接受的指针从mutex*，转为shared_ptr&lt;Mutex&gt;。<br>但shared_ptr的default析构行为是“引用次数为0时删除所指物”，也就是析构时delete指针。（我们仅仅需要解除互锁）为了改变默认行为，我们必须<strong>手动地将删除器unlock作为shared_ptr的第二参数</strong>。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line"><span class="function">        :<span class="title">mutexSP</span><span class="params">(pm,unlock)</span> </span>&#123;lock(mutexSP.<span class="built_in">get</span>());&#125;</span><br><span class="line">    <span class="comment">//无需析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexSP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Lock类此时无需再声明析构函数，因为当shared_ptr析构时，unlock就会被调用。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>复制RAII对象必须一并复制它所管理的资源，资源的copying行为决定了RAII对象的copying行为。</li>
<li>对于RAII class copying，其常见做法无非是禁止拷贝和引用计数。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/string%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/string%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7/" itemprop="url">15.string实现的多样性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T13:23:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（本章并未完全理解 建议结合More Effective C++ 29 写一个带有引用计数的string类以加深认识）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>sizeof(string)返回多少？不同的实现得到的答案不同。有的string大小等价于char*，而有的则是它的7倍大小。</p>
<hr>
<h1 id="string的内部组成"><a href="#string的内部组成" class="headerlink" title="string的内部组成"></a>string的内部组成</h1><p>每一个string的实现都容纳了以下信息：</p>
<ul>
<li>字符串大小（size)</li>
<li>该字符串所需的内存容量(capacity)</li>
<li>字符串的值</li>
</ul>
<p>另外，它们可能含有</p>
<ul>
<li>allocator的拷贝</li>
<li>值的引用计数</li>
</ul>
<p>不同的string实现以不同的方式把这些信息放在一起，为了证明此言非虚，下文给出了string的四种实现</p>
<hr>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="Implement-A"><a href="#Implement-A" class="headerlink" title="Implement A"></a>Implement A</h2><p><img src="http://static.zybuluo.com/zsmj2017/xdsavm0c3xiklk7lxit9ibr0/image_1can0lrfspfg12ulrsh1f66nu59.png" alt="image_1can0lrfspfg12ulrsh1f66nu59.png-28.3kB"><br>在实现A中，每个string有4个部分，配置器拷贝，大小，容量，以及一个指针。该指针指向引用计数以及字符串值的缓冲区。如果使用默认allocator，该实现的size是指针的四倍，而自定义allocator的话则会变得更大一些。</p>
<h2 id="Implement-B"><a href="#Implement-B" class="headerlink" title="Implement B"></a>Implement B</h2><p><img src="http://static.zybuluo.com/zsmj2017/lsl7f3d7bhd1k2om11cso1dh/image_1can0qdv7lmfirra5r1vcbhasm.png" alt="image_1can0qdv7lmfirra5r1vcbhasm.png-32.4kB"><br>实现B的string对象和内置指针一样大（这里假定使用的是默认allocator），因为其内存结构中确实只包含一个指针。该指针指向的对象包含字符串的大小、容量和引用计数，以及容纳字符串值的动态分配缓冲区的指针。对象也包含在多线程系统中与并发控制有关的一些附加数据。我们把这些数据标注为“other”.</p>
<h2 id="Implement-C"><a href="#Implement-C" class="headerlink" title="Implement C"></a>Implement C</h2><p><img src="http://static.zybuluo.com/zsmj2017/pff2i4ggex61wis8iea9xjl7/image_1can120f91jpa1sh91goa1j7a115113.png" alt="image_1can120f91jpa1sh91goa1j7a115113.png-22.7kB"><br>因为与allocator无关，实现C的大小总是等价于指针，X的部分是一些关于值可共享性的数据。（详见More Effective C++ 29）</p>
<h2 id="Implement-D"><a href="#Implement-D" class="headerlink" title="Implement D"></a>Implement D</h2><p><img src="http://static.zybuluo.com/zsmj2017/grp2afnkdd88xwak04lfnqoi/image_1can16lj2647uae1g5gkrc1muo1g.png" alt="image_1can16lj2647uae1g5gkrc1muo1g.png-43.1kB"><br>实现D的大小是指针的7倍。该实现没有使用引用计数，但每个srtring包含了一个最多可以表现15个字符的内部缓冲区。所以小字符串可以直接保留在对象中，如果大于15，则缓冲器的第一部分变成一个指向动态分配位置的指针，字符串的值存放于该内存中。（不可避免地浪费了一部分内存）</p>
<hr>
<h2 id="不同实现下的动态分配"><a href="#不同实现下的动态分配" class="headerlink" title="不同实现下的动态分配"></a>不同实现下的动态分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>当写下上述的表达式，我们可以清楚判断出D没有作动态分配，AC则做了一次，B则作了两次（分配对象，分配对象所指的字符缓冲）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/" itemprop="url">14.以对象管理资源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T12:01:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假设我们有一个关于投资的继承体系，其基类为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span>...&#125;;</span><br></pre></td></tr></table></figure><br>我们惯用factory function来产生特定的对象，并且有责任释放该对象，现有某个f函数执行了该操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Inverstment* pInv = createInvestment();<span class="comment">//调用factory function</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序看起来没毛病，但是实际使用中可能会发生内存泄漏。原因可能但不仅仅如下：</p>
<ol>
<li>…处有了一个过早的return</li>
<li>delete位于某个循环或者判断内并未能执行到</li>
<li>…处抛出了一个异常</li>
</ol>
<p>我们泄漏的不仅仅只是内含投资对象的那一块内存，还包括任何它所保存的资源。</p>
<p>当然，完美的逻辑可以避免上述问题，但关键在于代码总是处于不断修改和升级的过程中，<strong>单纯依赖delete语句总被执行是不可能的</strong>。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&lt;/br&gt;<br><strong>为了确保资源总是被释放，我们需要将资源放进对象内。当控制流离开程序块时，该对象的析构函数则会自动释放那些资源。</strong></p>
<h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>许多资源被动态地分配于heap内,然后被用于单一区块或函数内。这些资源应该在控制流离开那个区块或者函数时被释放。标准库提供的auto_ptr正是针对这种形式而设计的。<br>auto_ptr是一个智能指针，其析构函数自动对其所指对象调用delete。（auto_ptr的具体描述及特性，详见C++ Primer）<br>其具体使用大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以对象管理资源的关键思路在于：</p>
<ol>
<li><strong>获得资源后立刻放入管理对象</strong>。<br>这也被称为“资源获取之日即是初始化之时”（resource acquisition initialization；RAII）<br>有时候我们也把拿到的资源用来赋值而不是初始化。但不管怎么说，每一笔资源总在获得之时就被立刻放入管理对象中。</li>
<li><strong>管理对象（managing object)运用析构函数确保资源释放</strong>。<br>除非管理对象析构函数里会抛出异常，否则资源总能被正确释放。针对唯一的这一种例外，Effective C++ 8 对此有详细的描述</li>
</ol>
<h3 id="auto-ptr的缺陷"><a href="#auto-ptr的缺陷" class="headerlink" title="auto_ptr的缺陷"></a>auto_ptr的缺陷</h3><p>如果通过copy构造函数或者copy assignment操作符来复制auto_ptr，那它们会变成null，新复制的智能指针将获得资源的唯一使用权。<br>这种诡异的复制行为直接导致STL容器不能使用auto_ptr(具体论述见Effective STL 8）</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>auto_ptr的替代方案是用引用计数型智能指针。也就是reference-counting smart pointer(RCSP)。它持续地追踪有多少对象指向某个资源，没人指向就释放资源。</p>
<h3 id="shared-ptr的缺陷"><a href="#shared-ptr的缺陷" class="headerlink" title="shared_ptr的缺陷"></a>shared_ptr的缺陷</h3><p>无法打破环状引用（例如两个没人用的对象彼此互指，编译器判断对象仍然处于使用状态）。</p>
<h2 id="智能指针的缺陷"><a href="#智能指针的缺陷" class="headerlink" title="智能指针的缺陷"></a>智能指针的缺陷</h2><p>智能指针的析构函数中做的是delete而非delete[]，这意味着在动态分配而得到的array身上用它们效果感人。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>])</span></span>;<span class="comment">//析构时只释放了一个</span></span><br></pre></td></tr></table></figure><br>但这个问题不大，Effective STL 13提及，应当尽可能使用vector与string替换动态数组。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&lt;/br&gt;<br>本节虽然大量提及了智能指针，但实际<strong>上RAII和智能指针并无关联</strong>，考虑Effective STL 12中提到的多线程实例，其中Lock对象也负责了资源的管理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/%E4%BD%BF%E7%94%A8reverse%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/%E4%BD%BF%E7%94%A8reverse%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D/" itemprop="url">14.使用reverse避免重新分配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T10:12:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>(本章内容笔者认为可通过合理的初始化完成）</p>
<p>vector与string可以动态增长，其增长操作大概等价于realloc，分为4个部分（关于具体实现，C++ Primer 以及 数据结构·向量篇 均有涉及）</p>
<ol>
<li>分配当前cap*2的内存</li>
<li>把元素拷贝到新内存起始处</li>
<li>销毁旧有对象</li>
<li>收回原内存</li>
</ol>
<p>这些步骤的开销极大，并且执行了这些后同时还需要更新现在正在使用的迭代器或者指针之类。reserve可以最大幅度避免这些开销。</p>
<p>在说reverse之前，首先复习4个vector或string的成员函数</p>
<blockquote>
<ul>
<li>size：当前容器内的元素个数</li>
<li>capacity：最大容纳个数</li>
<li>resize：强制将元素个数变为n个，调用构造或者析构，不影响cap.如果n&gt;cap,则realloc.</li>
<li>reserve：将cap改为至少n，如果n&lt;cap,无动作，否则realloc.同时不改变size.</li>
</ul>
</blockquote>
<p>为了避免大量的realloc操作，我们可以一旦建立容器就立刻reserve到一个合适的大小（为啥不好好初始化）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) v.push_back(i);</span><br></pre></td></tr></table></figure><br>上述操作大约会导致2到10次重新分配。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reserve(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) v.push_back(i);</span><br></pre></td></tr></table></figure><br>这则不会导致重新分配。</p>
<p>通常有两种情况可以使用reverse来避免重新分配：</p>
<ol>
<li>你了解容器最终大致的元素个数（不如好好初始化 然后赋值 不过一旦估算少了会越界）</li>
<li>保留你可能需要的最大空间，添加完成后修整掉多余的容量。（修整操作见Effective STL 17）</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%8A%A1%E5%BF%85%E5%B0%BD%E5%96%84%E5%B0%BD%E7%BE%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%8A%A1%E5%BF%85%E5%B0%BD%E5%96%84%E5%B0%BD%E7%BE%8E/" itemprop="url">13. 复制对象务必尽善尽美</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T12:01:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>设计良好的OO System一般只留有两个函数负责对象拷贝，那就是copy构造函数和copy assignment操作符，暂称它们为copying函数。正如前文所说，编译器会在必要的时候为我们的classes创建copying函数，其行为是：将被copy对象的所有成员变量都做一份拷贝。</p>
<hr>
<h1 id="手动处理拷贝可能存在的风险"><a href="#手动处理拷贝可能存在的风险" class="headerlink" title="手动处理拷贝可能存在的风险"></a>手动处理拷贝可能存在的风险</h1><p>&lt;/br&gt;<br>如果我们自己声明和实现了copying函数，但却并没有完全拷贝成员变量，造成<strong>了partial copy，此时编译器根本不会报错</strong>，所以需要仔细地排查：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">        :name(rhs.name) &#123;&#125;;<span class="comment">//忘记了copy age 不会报错</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于这种特性，<strong>每一次新的成员变量的加入，copying函数，构造函数，以及任何重载的operator=都必须要做出修改。</strong>你就不用指望编译器会提醒你了。</p>
<hr>
<h1 id="继承体系下的partial-copy"><a href="#继承体系下的partial-copy" class="headerlink" title="继承体系下的partial copy"></a>继承体系下的partial copy</h1><h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设我们的继承体系中存在着Customer与PCustomer两个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCustomer</span>:</span><span class="keyword">public</span> Customer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs);</span><br><span class="line">    PCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PCustomer &amp;rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line">PCustomer::PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs)</span><br><span class="line">    :priority(rhs.priority) &#123;&#125;</span><br></pre></td></tr></table></figure><br>看起来确实执行了copy，但实际上dc内部的bc成分并未被copy。在这种情况下，<strong>bc成分将会被默认初始化。</strong><br>如果是operator=，则仅仅复制了dc成分，bc成分保持不变。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在任何时候我们一旦承担起为derived class编写copying函数的责任，必须要注意一定要记得复制base class的成员变量 ，一般情况下它们是private，所以我们<strong>调用base class的copying函数</strong>来完成它们。针对上面的实例，两个copying函数的正确写法如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PCustomer::PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs)</span><br><span class="line">    :Customer(rhs),priority(rhs.priority) &#123;&#125;</span><br><span class="line">PCustomer&amp;</span><br><span class="line">PCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PCustomer &amp;rhs)&#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority=rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="copy构造函数与copy-assignment运算符之间的关系"><a href="#copy构造函数与copy-assignment运算符之间的关系" class="headerlink" title="copy构造函数与copy assignment运算符之间的关系"></a>copy构造函数与copy assignment运算符之间的关系</h1><p>&lt;/br&gt;<br>一般来说，copying 函数往往有近似的实现本体，这可能会让我们想到在一个中调用另一个。但这并不可取。</p>
<p>令copy assignment调用copy construct函数并不科学，原因很简单，你在试图构造一个已经存在的对象。<br>令copy construct函数调用copy assignment同样毫无意义。构造函数用来初始化新对象，而assignment操作符只施行于已经被初始化的对象。对还没构造好的对象赋值完全毫无意义。</p>
<p>如果它们两个之间真的存在相近的代码，那应该编写一个private的init函数，给他们两个调用，这样就完美消除了代码重复的问题。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>copying函数应该确保复制对象内所有成员，以及所有base class成分（调用bc对应的copying函数）</li>
<li>不要尝试以某个copying函数实现另一个copying 函数。应该新建一个private init函数给二者调用。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/25/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xander.liu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/s">
              
                  <span class="site-state-item-count">265</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsmj2017" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lxiang2018@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xander.liu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
