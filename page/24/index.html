<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="zsmj" />





  <link rel="alternate" href="/atom.xml" title="Xander's Wiki" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="Xander&#39;s Wiki">
<meta property="og:url" content="https://xander.wiki/page/24/index.html">
<meta property="og:site_name" content="Xander&#39;s Wiki">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xander.wiki/page/24/"/>





  <title>Xander's Wiki</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xander's Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/s" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/STL%E5%AE%B9%E5%99%A8%E4%B8%8EC%20API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/STL%E5%AE%B9%E5%99%A8%E4%B8%8EC%20API/" itemprop="url">16.STL容器与C API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T14:39:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="获取指针"><a href="#获取指针" class="headerlink" title="获取指针"></a>获取指针</h1><p>&lt;/br&gt;<br>假设有一个vector对象v，而你需要得到一个指向v中数据的指针，这让v可以被当作一个数组在C中使用。<br>我们只需要使用<code>&amp;v[0]</code>即可获得指向首元素的指针。如果是string，请使用<code>s.c_str()</code>.<br>实际上这样做可能会有一些问题，具体而言就是v可能是空的，所以需要<strong>先对v进行empty判定</strong>。</p>
<p>有人说可以用begin这种迭代器来代替&amp;v[0],实际上这完全是胡说八道，因为并不总是能做到迭代器和指针之间的互相转换。<br><code>&amp;*v.begin()</code>倒是真的可以等价于<code>&amp;v[0]</code>,但这种写法除了让别人一目了然你的智力水平外并没有其他好处。</p>
<p>有人会疑惑为什么vctor就可以直接取址，而string不行，原因有以下两点：</p>
<ol>
<li>string的数据并没有保证被存储于连续内存（详见 Effective STL 15）</li>
<li>string并不保证以null结尾</li>
</ol>
<p>因此，string必须使用c_str:</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pString)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(s.c_str())</span></span>;</span><br></pre></td></tr></table></figure></h2><h1 id="C-API初始化STL容器"><a href="#C-API初始化STL容器" class="headerlink" title="C API初始化STL容器"></a>C API初始化STL容器</h1><h2 id="用C-API返回的元素初始化vector"><a href="#用C-API返回的元素初始化vector" class="headerlink" title="用C API返回的元素初始化vector"></a>用C API返回的元素初始化vector</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C API数需要一个指向数组的指针，数组最多有arraySize个double</span></span><br><span class="line"><span class="comment">// 功能为向数组内部写入数据，返回写入数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vd</span><span class="params">(maxNumDoubles)</span></span>;，</span><br><span class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.<span class="built_in">size</span>()));<span class="comment">//数据写入后调整大小</span></span><br></pre></td></tr></table></figure>
<h2 id="用C-API返回的元素初始化string"><a href="#用C-API返回的元素初始化string" class="headerlink" title="用C API返回的元素初始化string"></a>用C API返回的元素初始化string</h2><p>上述写法并不能应用于string类型，因为只有vector保证了与数组具有相同内存分布。（顺序表）<br>但用用C API初始化string也不难，具体来说就是先初始化一个vector&lt;char&gt;，然后再用vector初始化string：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillString</span><span class="params">(<span class="keyword">char</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">vc</span><span class="params">(maxNumChars)</span></span>; </span><br><span class="line"><span class="keyword">size_t</span> charsWritten = fillString(&amp;vc[<span class="number">0</span>], vc.<span class="built_in">size</span>());</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(vc.<span class="built_in">begin</span>(), vc.<span class="built_in">begin</span>()+charsWritten)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="用C-API返回的元素初始化STL中的任何容器"><a href="#用C-API返回的元素初始化STL中的任何容器" class="headerlink" title="用C API返回的元素初始化STL中的任何容器"></a>用C API返回的元素初始化STL中的任何容器</h2><p>因为和数组内存分布一致的只有vector，所以我们的策略十分简单：<strong>把数组内的元素传入vector，然后再用vector初始化STL容器：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="keyword">double</span> *pArray, <span class="keyword">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vd</span><span class="params">(maxNumDoubles)</span></span>;</span><br><span class="line">vd.resize(fillArray(&amp;vd[<span class="number">0</span>], vd.<span class="built_in">size</span>()));</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; <span class="title">d</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到deque</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; <span class="title">l</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到list</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; <span class="title">s</span><span class="params">(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝数据到set</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="STL容器传递数据至C-API"><a href="#STL容器传递数据至C-API" class="headerlink" title="STL容器传递数据至C API"></a>STL容器传递数据至C API</h1><p>&lt;/br&gt;<br>从上文中自然能领会到反向传递的方法：用STL容器内的元素初始化vector，然后再用vector传入C API：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pints, <span class="keyword">size_t</span> numInts)</span></span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet; <span class="comment">//要传递给API数据的set</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(intSet.<span class="built_in">begin</span>(), intSet.<span class="built_in">end</span>())</span></span>; </span><br><span class="line"><span class="keyword">if</span> (!v.empty()) doSomething(&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E7%9A%84copying%E8%A1%8C%E4%B8%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E7%9A%84copying%E8%A1%8C%E4%B8%BA/" itemprop="url">15.资源管理类中的copying行为</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T13:55:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>在上一节的末尾，我已经提到RAII和智能指针并无直接关联，并且给出了例证。事实上，smart_ptr适用于管理heap-based资源。如果你所需要的资源不是heap-based，往往需要建立自己的资源管理类。</p>
<hr>
<h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假定我们有类型为murtex的互斥器对象，共有lock与unlock两个函数作用其上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;<span class="comment">//锁定互斥器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;<span class="comment">//解除锁定</span></span><br></pre></td></tr></table></figure><br>基于RAII思想，我们建立一个资源管理类Lock:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line"><span class="function">        :<span class="title">mutexPtr</span><span class="params">(pm)</span> </span>&#123;lock(mutexPtr);&#125;</span><br><span class="line">    ~Lock() &#123;unlock(mutexPtr);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果资源管理类发生了复制行为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line"><span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br></pre></td></tr></table></figure><br>将会产生何种后果？</p>
<hr>
<h1 id="资源管理类的复制行为"><a href="#资源管理类的复制行为" class="headerlink" title="资源管理类的复制行为"></a>资源管理类的复制行为</h1><p>&lt;/br&gt;<br>常见做法有以下两种：</p>
<ol>
<li><strong>禁止复制</strong><br>有时允许RAII对象被复制并不合理，所以我们应该禁止它们的copy行为。如何禁止，详见Effective C++ 6</li>
<li><strong>对底层资源使用引用计数</strong><br>这种方法的最佳实现就是使用shared_ptr。通常我们只要内含一个shared_ptr成员变量，RAII classes便可以实现出reference-counting copying行为</li>
</ol>
<h2 id="引用计数在RAII中的应用"><a href="#引用计数在RAII中的应用" class="headerlink" title="引用计数在RAII中的应用"></a>引用计数在RAII中的应用</h2><p>针对Lock class，可以把接受的指针从mutex*，转为shared_ptr&lt;Mutex&gt;。<br>但shared_ptr的default析构行为是“引用次数为0时删除所指物”，也就是析构时delete指针。（我们仅仅需要解除互锁）为了改变默认行为，我们必须<strong>手动地将删除器unlock作为shared_ptr的第二参数</strong>。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line"><span class="function">        :<span class="title">mutexSP</span><span class="params">(pm,unlock)</span> </span>&#123;lock(mutexSP.<span class="built_in">get</span>());&#125;</span><br><span class="line">    <span class="comment">//无需析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexSP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Lock类此时无需再声明析构函数，因为当shared_ptr析构时，unlock就会被调用。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>复制RAII对象必须一并复制它所管理的资源，资源的copying行为决定了RAII对象的copying行为。</li>
<li>对于RAII class copying，其常见做法无非是禁止拷贝和引用计数。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/string%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/string%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7/" itemprop="url">15.string实现的多样性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T13:23:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（本章并未完全理解 建议结合More Effective C++ 29 写一个带有引用计数的string类以加深认识）</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>sizeof(string)返回多少？不同的实现得到的答案不同。有的string大小等价于char*，而有的则是它的7倍大小。</p>
<hr>
<h1 id="string的内部组成"><a href="#string的内部组成" class="headerlink" title="string的内部组成"></a>string的内部组成</h1><p>每一个string的实现都容纳了以下信息：</p>
<ul>
<li>字符串大小（size)</li>
<li>该字符串所需的内存容量(capacity)</li>
<li>字符串的值</li>
</ul>
<p>另外，它们可能含有</p>
<ul>
<li>allocator的拷贝</li>
<li>值的引用计数</li>
</ul>
<p>不同的string实现以不同的方式把这些信息放在一起，为了证明此言非虚，下文给出了string的四种实现</p>
<hr>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="Implement-A"><a href="#Implement-A" class="headerlink" title="Implement A"></a>Implement A</h2><p><img src="http://static.zybuluo.com/zsmj2017/xdsavm0c3xiklk7lxit9ibr0/image_1can0lrfspfg12ulrsh1f66nu59.png" alt="image_1can0lrfspfg12ulrsh1f66nu59.png-28.3kB"><br>在实现A中，每个string有4个部分，配置器拷贝，大小，容量，以及一个指针。该指针指向引用计数以及字符串值的缓冲区。如果使用默认allocator，该实现的size是指针的四倍，而自定义allocator的话则会变得更大一些。</p>
<h2 id="Implement-B"><a href="#Implement-B" class="headerlink" title="Implement B"></a>Implement B</h2><p><img src="http://static.zybuluo.com/zsmj2017/lsl7f3d7bhd1k2om11cso1dh/image_1can0qdv7lmfirra5r1vcbhasm.png" alt="image_1can0qdv7lmfirra5r1vcbhasm.png-32.4kB"><br>实现B的string对象和内置指针一样大（这里假定使用的是默认allocator），因为其内存结构中确实只包含一个指针。该指针指向的对象包含字符串的大小、容量和引用计数，以及容纳字符串值的动态分配缓冲区的指针。对象也包含在多线程系统中与并发控制有关的一些附加数据。我们把这些数据标注为“other”.</p>
<h2 id="Implement-C"><a href="#Implement-C" class="headerlink" title="Implement C"></a>Implement C</h2><p><img src="http://static.zybuluo.com/zsmj2017/pff2i4ggex61wis8iea9xjl7/image_1can120f91jpa1sh91goa1j7a115113.png" alt="image_1can120f91jpa1sh91goa1j7a115113.png-22.7kB"><br>因为与allocator无关，实现C的大小总是等价于指针，X的部分是一些关于值可共享性的数据。（详见More Effective C++ 29）</p>
<h2 id="Implement-D"><a href="#Implement-D" class="headerlink" title="Implement D"></a>Implement D</h2><p><img src="http://static.zybuluo.com/zsmj2017/grp2afnkdd88xwak04lfnqoi/image_1can16lj2647uae1g5gkrc1muo1g.png" alt="image_1can16lj2647uae1g5gkrc1muo1g.png-43.1kB"><br>实现D的大小是指针的7倍。该实现没有使用引用计数，但每个srtring包含了一个最多可以表现15个字符的内部缓冲区。所以小字符串可以直接保留在对象中，如果大于15，则缓冲器的第一部分变成一个指向动态分配位置的指针，字符串的值存放于该内存中。（不可避免地浪费了一部分内存）</p>
<hr>
<h2 id="不同实现下的动态分配"><a href="#不同实现下的动态分配" class="headerlink" title="不同实现下的动态分配"></a>不同实现下的动态分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>当写下上述的表达式，我们可以清楚判断出D没有作动态分配，AC则做了一次，B则作了两次（分配对象，分配对象所指的字符缓冲）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/" itemprop="url">14.以对象管理资源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T12:01:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&lt;/br&gt;<br>假设我们有一个关于投资的继承体系，其基类为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span>...&#125;;</span><br></pre></td></tr></table></figure><br>我们惯用factory function来产生特定的对象，并且有责任释放该对象，现有某个f函数执行了该操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Inverstment* pInv = createInvestment();<span class="comment">//调用factory function</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序看起来没毛病，但是实际使用中可能会发生内存泄漏。原因可能但不仅仅如下：</p>
<ol>
<li>…处有了一个过早的return</li>
<li>delete位于某个循环或者判断内并未能执行到</li>
<li>…处抛出了一个异常</li>
</ol>
<p>我们泄漏的不仅仅只是内含投资对象的那一块内存，还包括任何它所保存的资源。</p>
<p>当然，完美的逻辑可以避免上述问题，但关键在于代码总是处于不断修改和升级的过程中，<strong>单纯依赖delete语句总被执行是不可能的</strong>。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&lt;/br&gt;<br><strong>为了确保资源总是被释放，我们需要将资源放进对象内。当控制流离开程序块时，该对象的析构函数则会自动释放那些资源。</strong></p>
<h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>许多资源被动态地分配于heap内,然后被用于单一区块或函数内。这些资源应该在控制流离开那个区块或者函数时被释放。标准库提供的auto_ptr正是针对这种形式而设计的。<br>auto_ptr是一个智能指针，其析构函数自动对其所指对象调用delete。（auto_ptr的具体描述及特性，详见C++ Primer）<br>其具体使用大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以对象管理资源的关键思路在于：</p>
<ol>
<li><strong>获得资源后立刻放入管理对象</strong>。<br>这也被称为“资源获取之日即是初始化之时”（resource acquisition initialization；RAII）<br>有时候我们也把拿到的资源用来赋值而不是初始化。但不管怎么说，每一笔资源总在获得之时就被立刻放入管理对象中。</li>
<li><strong>管理对象（managing object)运用析构函数确保资源释放</strong>。<br>除非管理对象析构函数里会抛出异常，否则资源总能被正确释放。针对唯一的这一种例外，Effective C++ 8 对此有详细的描述</li>
</ol>
<h3 id="auto-ptr的缺陷"><a href="#auto-ptr的缺陷" class="headerlink" title="auto_ptr的缺陷"></a>auto_ptr的缺陷</h3><p>如果通过copy构造函数或者copy assignment操作符来复制auto_ptr，那它们会变成null，新复制的智能指针将获得资源的唯一使用权。<br>这种诡异的复制行为直接导致STL容器不能使用auto_ptr(具体论述见Effective STL 8）</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>auto_ptr的替代方案是用引用计数型智能指针。也就是reference-counting smart pointer(RCSP)。它持续地追踪有多少对象指向某个资源，没人指向就释放资源。</p>
<h3 id="shared-ptr的缺陷"><a href="#shared-ptr的缺陷" class="headerlink" title="shared_ptr的缺陷"></a>shared_ptr的缺陷</h3><p>无法打破环状引用（例如两个没人用的对象彼此互指，编译器判断对象仍然处于使用状态）。</p>
<h2 id="智能指针的缺陷"><a href="#智能指针的缺陷" class="headerlink" title="智能指针的缺陷"></a>智能指针的缺陷</h2><p>智能指针的析构函数中做的是delete而非delete[]，这意味着在动态分配而得到的array身上用它们效果感人。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>])</span></span>;<span class="comment">//析构时只释放了一个</span></span><br></pre></td></tr></table></figure><br>但这个问题不大，Effective STL 13提及，应当尽可能使用vector与string替换动态数组。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&lt;/br&gt;<br>本节虽然大量提及了智能指针，但实际<strong>上RAII和智能指针并无关联</strong>，考虑Effective STL 12中提到的多线程实例，其中Lock对象也负责了资源的管理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/10/%E4%BD%BF%E7%94%A8reverse%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/%E4%BD%BF%E7%94%A8reverse%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D/" itemprop="url">14.使用reverse避免重新分配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T10:12:00+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>(本章内容笔者认为可通过合理的初始化完成）</p>
<p>vector与string可以动态增长，其增长操作大概等价于realloc，分为4个部分（关于具体实现，C++ Primer 以及 数据结构·向量篇 均有涉及）</p>
<ol>
<li>分配当前cap*2的内存</li>
<li>把元素拷贝到新内存起始处</li>
<li>销毁旧有对象</li>
<li>收回原内存</li>
</ol>
<p>这些步骤的开销极大，并且执行了这些后同时还需要更新现在正在使用的迭代器或者指针之类。reserve可以最大幅度避免这些开销。</p>
<p>在说reverse之前，首先复习4个vector或string的成员函数</p>
<blockquote>
<ul>
<li>size：当前容器内的元素个数</li>
<li>capacity：最大容纳个数</li>
<li>resize：强制将元素个数变为n个，调用构造或者析构，不影响cap.如果n&gt;cap,则realloc.</li>
<li>reserve：将cap改为至少n，如果n&lt;cap,无动作，否则realloc.同时不改变size.</li>
</ul>
</blockquote>
<p>为了避免大量的realloc操作，我们可以一旦建立容器就立刻reserve到一个合适的大小（为啥不好好初始化）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) v.push_back(i);</span><br></pre></td></tr></table></figure><br>上述操作大约会导致2到10次重新分配。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reserve(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) v.push_back(i);</span><br></pre></td></tr></table></figure><br>这则不会导致重新分配。</p>
<p>通常有两种情况可以使用reverse来避免重新分配：</p>
<ol>
<li>你了解容器最终大致的元素个数（不如好好初始化 然后赋值 不过一旦估算少了会越界）</li>
<li>保留你可能需要的最大空间，添加完成后修整掉多余的容量。（修整操作见Effective STL 17）</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%8A%A1%E5%BF%85%E5%B0%BD%E5%96%84%E5%B0%BD%E7%BE%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%8A%A1%E5%BF%85%E5%B0%BD%E5%96%84%E5%B0%BD%E7%BE%8E/" itemprop="url">13. 复制对象务必尽善尽美</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T12:01:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;/br&gt;<br>设计良好的OO System一般只留有两个函数负责对象拷贝，那就是copy构造函数和copy assignment操作符，暂称它们为copying函数。正如前文所说，编译器会在必要的时候为我们的classes创建copying函数，其行为是：将被copy对象的所有成员变量都做一份拷贝。</p>
<hr>
<h1 id="手动处理拷贝可能存在的风险"><a href="#手动处理拷贝可能存在的风险" class="headerlink" title="手动处理拷贝可能存在的风险"></a>手动处理拷贝可能存在的风险</h1><p>&lt;/br&gt;<br>如果我们自己声明和实现了copying函数，但却并没有完全拷贝成员变量，造成<strong>了partial copy，此时编译器根本不会报错</strong>，所以需要仔细地排查：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">        :name(rhs.name) &#123;&#125;;<span class="comment">//忘记了copy age 不会报错</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于这种特性，<strong>每一次新的成员变量的加入，copying函数，构造函数，以及任何重载的operator=都必须要做出修改。</strong>你就不用指望编译器会提醒你了。</p>
<hr>
<h1 id="继承体系下的partial-copy"><a href="#继承体系下的partial-copy" class="headerlink" title="继承体系下的partial copy"></a>继承体系下的partial copy</h1><h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>假设我们的继承体系中存在着Customer与PCustomer两个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCustomer</span>:</span><span class="keyword">public</span> Customer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs);</span><br><span class="line">    PCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PCustomer &amp;rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line">PCustomer::PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs)</span><br><span class="line">    :priority(rhs.priority) &#123;&#125;</span><br></pre></td></tr></table></figure><br>看起来确实执行了copy，但实际上dc内部的bc成分并未被copy。在这种情况下，<strong>bc成分将会被默认初始化。</strong><br>如果是operator=，则仅仅复制了dc成分，bc成分保持不变。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在任何时候我们一旦承担起为derived class编写copying函数的责任，必须要注意一定要记得复制base class的成员变量 ，一般情况下它们是private，所以我们<strong>调用base class的copying函数</strong>来完成它们。针对上面的实例，两个copying函数的正确写法如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PCustomer::PCustomer(<span class="keyword">const</span> PCustomer &amp;rhs)</span><br><span class="line">    :Customer(rhs),priority(rhs.priority) &#123;&#125;</span><br><span class="line">PCustomer&amp;</span><br><span class="line">PCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PCustomer &amp;rhs)&#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority=rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="copy构造函数与copy-assignment运算符之间的关系"><a href="#copy构造函数与copy-assignment运算符之间的关系" class="headerlink" title="copy构造函数与copy assignment运算符之间的关系"></a>copy构造函数与copy assignment运算符之间的关系</h1><p>&lt;/br&gt;<br>一般来说，copying 函数往往有近似的实现本体，这可能会让我们想到在一个中调用另一个。但这并不可取。</p>
<p>令copy assignment调用copy construct函数并不科学，原因很简单，你在试图构造一个已经存在的对象。<br>令copy construct函数调用copy assignment同样毫无意义。构造函数用来初始化新对象，而assignment操作符只施行于已经被初始化的对象。对还没构造好的对象赋值完全毫无意义。</p>
<p>如果它们两个之间真的存在相近的代码，那应该编写一个private的init函数，给他们两个调用，这样就完美消除了代码重复的问题。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>copying函数应该确保复制对象内所有成员，以及所有base class成分（调用bc对应的copying函数）</li>
<li>不要尝试以某个copying函数实现另一个copying 函数。应该新建一个private init函数给二者调用。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/vector%E4%B8%8Estring%E7%9B%B8%E8%BE%83%E4%BA%8E%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E8%B6%8A%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/vector%E4%B8%8Estring%E7%9B%B8%E8%BE%83%E4%BA%8E%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E8%B6%8A%E6%80%A7/" itemprop="url">13. vector与string相较于动态数组的优越性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T11:48:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果我们决定使用new进行动态分配，那么我们必须肩负以下责任：</p>
<ol>
<li>有new必然要delete</li>
<li>new[]必然要对应着delete[]</li>
<li>避免重复delete</li>
</ol>
<p>实际上上述操作总是很麻烦，所以我们应该尽可能使用vector或者string来代替动态数组。另外，这两大容器可以配合STL算法，效果绝佳。</p>
<p>事实上除了在多线程中使用引用计数字符串会导致性能下降外，其他情况下vector与string都具有绝对优势。就算这样，我们也可以试图关闭引用计数，或者使用<code>vector&lt;char&gt;</code>,尽管那失去了一些string的专有成员函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E8%B5%8B%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E8%B5%8B%E5%80%BC/" itemprop="url">12. 在operator=中处理自赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T11:23:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>我们在重载operator=时需要注意自我赋值的情况。可能有人会认为这种情况很少发生，因为很少有人会写诸如w=w的句子。但实际上,代码中出现a[i]=a[j]（i==j),或者<em>p=</em>q（指向同一对象）的例子屡见不鲜。<br>事实上，只要你使用了pointers或者references，而且它们被用来指向多个相同类型的对象，我们就需要考虑 是否会出现自赋值的情况。确切地说，<strong>只要有多个对象来自同一个继承体系</strong>，比如一个指针指向base class类型，而另一个指向derived class类型。<strong>它们完全可能指向的是同一个对象</strong>。</p>
<hr>
<h1 id="不处理自赋值情况的风险"><a href="#不处理自赋值情况的风险" class="headerlink" title="不处理自赋值情况的风险"></a>不处理自赋值情况的风险</h1><p>&nbsp;<br>如果我们在class中手动地进行了资源管理，那么自赋值的处理不当可能会带来一些问题。举例而言:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span>...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);<span class="comment">//如果是自赋值，pb指向的对象已经释放</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序<strong>既不具备异常安全性，也直接导致了“在停止使用资源前意外地释放了它”</strong>。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="证同测试"><a href="#证同测试" class="headerlink" title="证同测试"></a>证同测试</h2><p>其原理很简单：在函数最前端放上这样一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(this&#x3D;&#x3D;&amp;rhs) return *this;</span><br></pre></td></tr></table></figure><br>这个解决方案保证了自赋值安全性，但是不具备异常安全性。在这句话中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pb=<span class="keyword">new</span> Bitmap(*rhs.pb);<span class="comment">//已通过证同测试，此时已经执行delete</span></span><br></pre></td></tr></table></figure><br>如果new导致了一个异常（内存不足或者copy构造函数抛出异常），那么pb始终会指向一块被删除的Bitmap。我们无法安全地删除pb,甚至读取它。</p>
<h2 id="手动保证异常安全"><a href="#手动保证异常安全" class="headerlink" title="手动保证异常安全"></a>手动保证异常安全</h2><p>因为只要解决了异常安全性，那么自赋值安全性就会必然得到解决，所以我们倾向于使用足够完美的逻辑避免异常的发生，其原理也很简单：在赋值pb前别删pb<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitnap * porig = pb；</span><br><span class="line">pb =<span class="keyword">new</span> bitmap(rhs.pb);</span><br><span class="line"><span class="keyword">delete</span> porig;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><br>这样的好处不言自明，如果pb没能正确赋值，其对象也没有被析构。（异常发生时跳出了operator=函数，因此没有执行delete porig）。如果正确赋值，pb指向的对象被释放。</p>
<h2 id="copy-amp-amp-swap"><a href="#copy-amp-amp-swap" class="headerlink" title="copy&amp;&amp;swap"></a>copy&amp;&amp;swap</h2><p>还有一个十分灵巧的operator=撰写技巧：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widegt&amp; rhs)</span></span>;<span class="comment">//彻底交换数据</span></span><br><span class="line">&#125;</span><br><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果operator=接受的参数是by value而非by reference，那我们连temp都可以省略:</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>确保自赋值安全性。其技术包括比较lhs与rhs的地址，先做backup，以及copy-and-swap</li>
<li>确定任何操作一个以上的对象的函数，如果其操作对象是同一个对象时，还能保持正确性。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/STL%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/STL%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/" itemprop="url">12. STL容器的线程安全性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T09:59:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-STL/" itemprop="url" rel="index">
                    <span itemprop="name">Effective STL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="STL提供的线程安全性"><a href="#STL提供的线程安全性" class="headerlink" title="STL提供的线程安全性"></a>STL提供的线程安全性</h1><p>&nbsp;<br>基本上STL容器提供的线程安全性只有以下两点：</p>
<ol>
<li><strong>多个线程读取是安全的</strong><br>多个线程可以读同一个容器内的数据，读时不允许写操作</li>
<li><strong>多个线程对不同的容器写入是安全的</strong></li>
</ol>
<hr>
<h1 id="如何实现线程安全性"><a href="#如何实现线程安全性" class="headerlink" title="如何实现线程安全性"></a>如何实现线程安全性</h1><p>&nbsp;<br>完全的线程安全很难实现，一个库可能试图以下列方式实现这样完全线程安全的容器：</p>
<ol>
<li>对于容器成员函数的每一次调用都锁住该容器直到调用完成。</li>
<li>在容器返回的迭代器生存期结束之前锁住容器</li>
<li>对于作用于容器的每个算法，在算法执行期间都锁住容器。（实际上这一点毫无必要，因为算法无法识别它们正在操作的容器)</li>
</ol>
<hr>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>&nbsp;<br>现在考虑一个例子：将vector内的第一个5改成0，如果它存在的话。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>())&#123;</span><br><span class="line">    *first5 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在多线程运行环境中，另一个线程可能在find操作完成后立刻修改v中的数据。那样第三行与v.end的检测将毫无意义，因为v的元素已经不再是原来的元素。并且如果执行了插入或者删除操作，first5也已经失效。<br>之前列举的3个方法都无法防止上述问题，迭代器调用返回得很快，生存期只有一行，find也是，无法帮助锁定。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&nbsp;<br>为了保证上述代码的线程安全，v必须从行1到行3都保持锁定，STL无法做到自动判断容器是否需要锁定，因此必须手动完成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">getMutexFor(v);<span class="comment">//需要自己实现的容器锁操作</span></span><br><span class="line"><span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    *first5 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">releaseMutexFor(v);</span><br></pre></td></tr></table></figure><br>从面向对象的角度而言，解决方法是构建一个lock类，其类模板大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Lock(<span class="keyword">const</span> Containers container)</span><br><span class="line">        : c(container)&#123;</span><br><span class="line">            getMutexFor(c);</span><br><span class="line">        &#125;</span><br><span class="line">    ~Lock()&#123;</span><br><span class="line">        releaseMutexFor(c); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> Container&amp; c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>显然，这种方法是在用类来管理资源的生存期（RAII)，其使用案例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">lock</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> first5 = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *first5 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//lock对象析构，v解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>另外，这种解决方案是异常安全的，因<strong>为在异常发生的情况下，局部对象会被销毁，此时lock也会释放互斥量</strong>。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>STL允许在一个容器上的多线程读取和不同容器上的多线程写入，除此之外不能依赖任何库自带的线程安全性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/09/%E4%BB%A4operator=%E8%BF%94%E5%9B%9E%E8%87%AA%E8%BA%AB%E7%9A%84reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/%E4%BB%A4operator=%E8%BF%94%E5%9B%9E%E8%87%AA%E8%BA%AB%E7%9A%84reference/" itemprop="url">11. 令operator=返回reference to *this</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T09:43:00+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>operator= 的一大特点在于可以写成连锁形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">x=y=z=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><br>operator= 采用右结合律，所以上式被解析为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=(y=(z=<span class="number">15</span>));</span><br></pre></td></tr></table></figure><br>为了实现这种连锁赋值，operator=必须返回一个reference指向操作符的左侧实参，这是实现operator=的协议要求：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该协议不仅仅适用于operator=，也适用于所有赋值相关操作，例如operator+=之类。（关于操作符的复合形式，其实现亦有特点，具体可见More Effective C++ 22）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/25/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xander.liu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/s">
              
                  <span class="site-state-item-count">261</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsmj2017" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lxiang2018@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xander.liu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
