<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="zsmj" />





  <link rel="alternate" href="/atom.xml" title="Xander's Wiki" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="Xander&#39;s Wiki">
<meta property="og:url" content="https://xander.wiki/page/14/index.html">
<meta property="og:site_name" content="Xander&#39;s Wiki">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="https://xander.wiki/page/14/"/>





  <title>Xander's Wiki</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xander's Wiki</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/s" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/30/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%89%8D%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%89%8D%E8%A8%80/" itemprop="url">关于对象——前言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-30T11:12:00+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Inside-the-C-object-model/" itemprop="url" rel="index">
                    <span itemprop="name">Inside the C++ object model</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><p>&nbsp;<br>在C语言中，“数据”及“处理数据的操作”是分开声明的，这种处理方式被称为procedural：一组“分布在各个以功能为导向的函数中”的算法驱动和处理外部数据。</p>
<h2 id="C-struct实例"><a href="#C-struct实例" class="headerlink" title="C struct实例"></a>C struct实例</h2><p>假设我们当前存在一个struct Point3d：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point3d</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line">&#125; Point3d;</span><br></pre></td></tr></table></figure><br>如果我们需要打印该Point3d，则必须定义这样一个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point3d_print</span><span class="params">(<span class="keyword">const</span> Point3d *pd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%f,%f,%f)"</span>,pd-&gt;x,pd-&gt;y,pd-&gt;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>又或者为了追求效率，直接使用函数宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Point3d_print(pd)   printf(<span class="meta-string">"(%f,%f,%f)"</span>,pd-&gt;x,pd-&gt;y,pd-&gt;z);</span></span><br></pre></td></tr></table></figure><br>同样地，某个点的特定坐标可以直接存取：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point3d pt;</span><br><span class="line">pt.x = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">//宏操作</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SetX(p,xval) (p.x)=(xval);</span></span><br><span class="line">SetX(pt,<span class="number">0.0</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>C++中实现Point3d可能会使用独立的“抽象数据类型”（abstract data type,ADT)来实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="keyword">const</span> Point3d &amp;pt)&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p>又或者以一个两层到三层的继承体系完成：<img src="http://static.zybuluo.com/zsmj2017/wqlsxrhsul1mirhq8dtrp1xk/image_1ccad3v788kbnc78s3bg4bfb9.png" alt="image_1ccad3v788kbnc78s3bg4bfb9.png-9.4kB"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>:</span><span class="keyword">public</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h2><p>我们甚至可以更进一步地抽象，将坐标值类型甚至坐标数量参数化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...<span class="comment">//内含数组或容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>&nbsp;<br>仅从Point来看，C与C++处理问题的方式截然不同，这并非是语言间的区别，而是过程式与面向对象的差别。<br>从软件工程的角度而言，封装性比全局数据要好，但也付出了编写和使用上的代价。</p>
<hr>
<h1 id="封装的成本"><a href="#封装的成本" class="headerlink" title="封装的成本"></a>封装的成本</h1><p>&nbsp;<br>从Point的角度而言，封装并未带来任何成本：</p>
<ol>
<li>data<br>所有的数据均存储于Object内，就如同struct中的情况一样。</li>
<li>member function<br>成员函数虽然包含于class的声明之内，但却不会出现在object中。每一个non-inline成员函数都只会生成一个函数实体。</li>
</ol>
<p>C++在内存布局以及存储时间上的额外负担主要由virtual引起：</p>
<ul>
<li>virtual function<br>实现函数执行期绑定。</li>
<li>virtual base class<br>实现“多次出现在继承体系中的base class在派生类中只存在一个可共享的实体”。</li>
</ul>
<p>一般而言，我们没有理由认为C++就一定会比C庞大且迟缓。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/30/%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8C%E4%B8%8EC++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8C%E4%B8%8EC++/" itemprop="url">34.混合使用C与C++</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-30T07:12:00+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>在混合编程前，首先确保你的C++编译器和C编译器兼容。确认兼容后，还有四个需要考虑的问题：名变换、静态初始化、内存动态分配、数据结构兼容。</p>
<hr>
<h1 id="名变换"><a href="#名变换" class="headerlink" title="名变换"></a>名变换</h1><p>&nbsp;<br>名变换，就是C++编译器给程序的每个函数换一个独一无二的名字。C没有函数重载，因此不需要该过程。重载不兼容于绝大部分链接程序，因为链接程序通常无法分辨同名的函数，它坚持函数名必须独一无二。名变换是C++对编译器的妥协。<br>在C++使用范围内用户无需考虑名变换，但在C运行库中，那么情况截然不同。</p>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>举例而言，在Cpp包含的头文件中，drawline被声明为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>;</span><br></pre></td></tr></table></figure><br>代码体中通常也是调用drawLine，每一个这样的调用都被编译器转换为调用名变换后的函数，所以写下的是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawLine(a, b, c, d);</span><br></pre></td></tr></table></figure><br>在obj中被调用的是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xyzzy(a, b, c, d);<span class="comment">//编译器变换了名称</span></span><br></pre></td></tr></table></figure><br>但如果drawline是一个C函数，obj文件（或者是动态链接库之类的文件）中包含的编译后的drawline函数仍然叫drawline，不会发生名变换动作。这意味着链接时将发生错误，因为链接程序找不到xyzzy函数的存在。</p>
<hr>
<h2 id="解决方案（extern-“C”"><a href="#解决方案（extern-“C”" class="headerlink" title="解决方案（extern “C”)"></a>解决方案（extern “C”)</h2><p>我们需要某种方法告诉C++编译器不要在这个函数上进行名变换，就是使用C++的<code>extern &quot;C&quot;</code>关键词：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>;</span><br></pre></td></tr></table></figure><br>不要以为有一个extern “C”，那么就应该同样有一个extern “Pascal”和extern “FORTRAN”之类。该关键词的意思是下述函数应该被当作C语言写的一样。所以汇编也是用extern “C”声明，甚至可以在C++函数上申明 extern “C”。（用C++写库给其他语言的客户使用），这样编译器就不会对你的函数执行名变换。<br>如果你需要批量地声明函数无需名变换，extern “C”可以对一组函数生效，只要将它们放入一对大括号中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">twiddleBits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> bits)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(<span class="keyword">int</span> iterations)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种技巧普遍适用于头文件中。假设当前头文件可能被C++编译器编译也可能会被C语言编译器编译。当用C++编译时，你应该加 extern “C”，但用C编译时则不必。通过只在C++编译器下定义的宏__cplusplus，头文件的写法很简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">twiddleBits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> bits)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(<span class="keyword">int</span> iterations)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>顺便提及一下，名变换没有标准规则，不同的编译器名变换不同。</p>
<hr>
<h1 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h1><p>&nbsp;<br>在C++中，main函数执行前和执行后都有大量代码被执行。具体来说，静态的类对象和定义在全局的、命名空间中的或文件体中的类对象的构造函数通常在main执行前就被调用。这个过程称为静态初始化。同样，通过静态初始化产生的对象也要在静态析构过程中调用其析构函数，这个过程通常发生在main结束<br>运行之后。<br>为了解决main应该首先被调用，而对象又需要在main执行前被构造的两难问题，许多编译器在main的最开始处插入了一个特别的函数，由它来负责静态初始化。同样地，编译器在main结束处插入了一个函数来析构静态对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    performStaticInitialization();</span><br><span class="line">    ...<span class="comment">//the statements you put in main go here;</span></span><br><span class="line">    performStaticDestruction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>示例中函数的名称不需要在意，关注要点是：如果一个C++编译器采用这种方法来初始化和析构静态对象，那么除非你用C++写了main函数，否则这些对象既不会构造也不会析构。因此只要代码中有C++部分，就应该使用C++的main函数。<br>但有时似乎用C写main更有意义————比如当前程序的大部分都是用C写的，C++部分只是一个支持库。然而，这个C++库很可能含有静态对象（即使现在没有，以后也可能会有），所以仍然需要用C++写main函数。但我们并不需要改写C语言代码，只要将C写的main改名为realmain，然后用C++版本的main调用realMain：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">realMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;<span class="comment">//in C++</span></span><br><span class="line">    <span class="keyword">return</span> realMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不这么写，就无法确保确保静态对象是否已经构造和析构。 </p>
<hr>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>&nbsp;<br>动态内存分配的规则很简单：C++部分使用new和delete，C部分使用malloc和free。用free释放new 分配的内存或用delete释放malloc分配的内存，其行为没有定义。<br>说起来容易，做起来未必简单。比如strdup函数，它并不存在于C和C++标准库中，却很常见：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ps)</span></span>; <span class="comment">// return a copy of the string pointed to by ps</span></span><br></pre></td></tr></table></figure><br>为了避免内存泄漏，strdup的调用者必须释放分配的内存。那是使用delete还是free呢？如果你调用的 strdup来自于C函数库中，使用free，否则使用delete.<br>在调用strdup后所需要做的操作，在不同的操作系统下不同，在不同的编译器下也不同。为了减少这种可移植性问题，应当尽可能避免调用那些既不在标准运行库中也没有固定形式的函数 。</p>
<hr>
<h1 id="数据结构兼容性"><a href="#数据结构兼容性" class="headerlink" title="数据结构兼容性"></a>数据结构兼容性</h1><p>&nbsp;<br>最后一个问题是在C++和C之间传递数据。<br>C与C++的交互必须限定在C可表示的概念上。因此，不可能传递给C语言对象或者成员函数指针。但C中存在着普通指针的概念，所以C和C++的函数可以安全地交换”指向对象的指针”和”指向非成员的函数或静态成员函数的指针”。同样，struct和内置类型的变量也可自由交换。<br>因为C++中struct兼容C中的规则，因此C编译器和C++编译器处理struct得到的结果一样。在C++ struct中增加非虚函数不会导致内存结构发生改变，因此，只有非虚函数的strcut的对象兼容于它们在C 中的孪生版本（C++成员函数并不在对象的内存布局中体现）。增加虚函数和加入继承体系会改变内存布局，此时无法完成C与C++的安全交换。<br>就数据结构而言，我们可以认为在C++和C之间相互传递数据结构是安全的（前提是结构式的定义在C和C++中都可编译）。在 C++版本中增加非虚成员函数或许不影响兼容性，但几乎其它的改变都将影响兼容。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/29/%E5%B0%86%E9%9D%9E%E5%B0%BE%E7%AB%AF%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/%E5%B0%86%E9%9D%9E%E5%B0%BE%E7%AB%AF%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB/" itemprop="url">33.将非尾端类设计为抽象类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-29T20:18:00+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设我们正在抽象动物，其中晰蜴和小鸡需要特别处理,当前继承体系如下：<img src="http://static.zybuluo.com/zsmj2017/ts93pmj4ugcn49y1x0pvi84z/image_1cc8lhmb189u17ud1g9qlaf1fc89.png" alt="image_1cc8lhmb189u17ud1g9qlaf1fc89.png-40.4kB"><br>动物类处理所有动物共有的特性，晰蜴类和小鸡类特别化动物类以适用这两种动物的特有行为。它们的简化版定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Chicken&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>考虑如下表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lizard liz1;</span><br><span class="line">Lizard liz2;</span><br><span class="line">Animal *pAnimal1 = &amp;liz1;</span><br><span class="line">Animal *pAnimal2 = &amp;liz2;</span><br><span class="line">...</span><br><span class="line">*pAnimal1 = *pAnimal2;</span><br></pre></td></tr></table></figure><br>显然，最后的赋值操作符调用的是Animal的，所以直接导致了liz1只有animal部分被修改，也就是部分赋值。</p>
<hr>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>一个解决方法是将赋值运算符声明为虚函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这种写法直接导致了operator=可以接受任意类型的Animal对象，也就是说，下面的代码是合法的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lizard liz;</span><br><span class="line">Chicken chick;</span><br><span class="line">Animal *pAnimal1 = &amp;liz;</span><br><span class="line">Animal *pAnimal2 = &amp;chick;</span><br><span class="line">*pAnimal1 = *pAnimal2;</span><br></pre></td></tr></table></figure><br>显然这是一个混合类型赋值。在未引入虚函数之前，混合类型赋值会被C++的强类型原则判定非法，但引入虚函数之后它们变为了合法。</p>
<hr>
<h3 id="动态转换与同类型赋值"><a href="#动态转换与同类型赋值" class="headerlink" title="动态转换与同类型赋值"></a>动态转换与同类型赋值</h3><p>我们真正想要通过指针来完成同类型赋值，而非通过指针完成混合类型赋值，于是我们可以使用动态转换完成这一操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lizard&amp; Lizard::<span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs)&#123;</span><br><span class="line">    <span class="comment">//make sure rhs is really a lizard</span></span><br><span class="line">    <span class="keyword">const</span> Lizard&amp; rhs_liz = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Lizard&amp;&gt;(rhs);</span><br><span class="line">    proceed with a normal assignment of rhs_liz to *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述代码中，如果可以转换则顺利执行operator=，否则抛出bad_cast的异常。</p>
<hr>
<h3 id="重载赋值"><a href="#重载赋值" class="headerlink" title="重载赋值"></a>重载赋值</h3><p>其实我们并不需要非得在运行期使用虚函数与dynamic_cast，下面的代码规避了在常规情况下它们的成本，而仅仅只需要增加了一个普通形式的赋值操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>事实上，有了第二个operator=后，第一个虚函数版operator=亦得到了简化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lizard&amp; Lizard::<span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span>=(dynamic&lt;<span class="keyword">const</span> Lizard&amp;&gt;(rhs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在这个函数试图将rhs转换为一个Lizard。如果转换成功，通常的赋值操作被调用；否则，一个bad_cast异常被抛出。  </p>
<hr>
<h2 id="私有化operator"><a href="#私有化operator" class="headerlink" title="私有化operator="></a>私有化operator=</h2><p>在看到了将operator=设置为虚函数之后的弊端后，我们应该想到重新整理代码以确保用户无法写出有问题的赋值语句，最好能够在编译期就会被拒绝。比较容易的方法是在Animal类中把operator=设为private：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Chicken&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>但需要注意的是Animal本身是一个具象类，也就是说这样一来Animal对象就无法执行opertaor=操作，另外，Lizard与Chicken的赋值也不可能正确完成，因为派生类的赋值操作函数需要调用基类的赋值操作函数。第二个问题可以通过将Animal中的operator=设为protected实现，但“不允许混合类型赋值”的任务并未完成，因为Lizard与Chicken仍然可以通过Animal的指针来互相赋值。</p>
<hr>
<h2 id="修改继承体系"><a href="#修改继承体系" class="headerlink" title="修改继承体系"></a>修改继承体系</h2><p>最简单的方法就是修改继承体系。由于我们之前认定Animal必须作为一个实体类存在且有其意义，因此我们创建一个新类 AbstractAnimal，来包含 Animal、 Lizard、Chikcen的共有属性，并把它设为抽象类， 各具象类均由该抽象类派生而出，修改后的继承体系如下所示：<img src="http://static.zybuluo.com/zsmj2017/ftaqwnn4yqyivbvangkycc69/image_1cc8mt77im8l89b6ns12b710grm.png" alt="image_1cc8mt77im8l89b6ns12b710grm.png-32kB"><br>类的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractAnimal</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractAnimal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> AbstractAnimal&amp; rhs);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractAnimal() = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span> <span class="keyword">public</span> AbstractAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lizard</span>:</span> <span class="keyword">public</span> AbstractAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span>:</span> <span class="keyword">public</span> AbstractAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Chicken&amp; rhs);...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>至此，一切工作均已完成。同类型间的赋值被允许，部分赋值或不同类型间的赋值被禁止；派生类的赋值操作函数可以调用基类的赋值操作函数。 </p>
<hr>
<h1 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h1><p>&nbsp;<br>当我们找不到一个函数可以作为纯虚函数时，我们定义可以析构函数为纯虚函数，<strong>把析构函数设置为纯虚函数时需要记住必须在类的定义之外实现它。</strong><br>声明一个函数为纯虚函数并不意味着它没有实现，它意味着：</p>
<ol>
<li>当前类是抽象类</li>
<li>任何从此类派生的实体类必须将此函数申明为一个“普通”的虚函数（不能带“= 0”）</li>
</ol>
<p>尽管大部分纯虚函数都没有实现，但纯虚函数是一个特例，他必须被实现。因为它们在派生类析构函数被调用时也将被调用。而且，它们经常执行有用的任务，诸如释放资源或记录消息。  </p>
<hr>
<h1 id="非尾端类与抽象类"><a href="#非尾端类与抽象类" class="headerlink" title="非尾端类与抽象类"></a>非尾端类与抽象类</h1><p>&nbsp;<br>用如AbstractAnimal这样的抽象基类替换如Animal这样的实体基类，其好处并不只有保证operator=的行为正常，它同时减少了你试图对数组使用多态的可能（More Effective C++ 3）。但该技巧最大的好处发生在设计层，因为我们强迫认定所有实体都具备明确行为准则，仅有抽象类承担了抽象的义务。<br>我们并没有方法明确判断未来情况是否需要抽象类，但我们可以肯定，如果存在两个具象类需要以公有继承的方式相互联系，那么通常表示当前情况需要一个抽象类：<br><img src="http://static.zybuluo.com/zsmj2017/d10a84bsw0sea0bsbc07hhtv/image_1cc8ne4hf1aflqd51cd7oq0liv13.png" alt="image_1cc8ne4hf1aflqd51cd7oq0liv13.png-35.7kB"><br>显然，C1和C2具有共性，我们通过建立抽象类将它们的共性抽取出来，使其具备明确的语义。但实际使用中我们可能会发现自己没有权限取更改类库。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>非尾端类应该是抽象类。我们对类库中的程序可能没有办法，但对于能控制的代码，遵守这一约定可以提高程序的可靠性、健壮性、可读性、可扩展性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/29/%E9%9D%A2%E5%90%91%E6%9C%AA%E6%9D%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/%E9%9D%A2%E5%90%91%E6%9C%AA%E6%9D%A5%E7%BC%96%E7%A8%8B/" itemprop="url">32.面向未来编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-29T19:12:00+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>唯一不变的就是变化本身。</p>
<hr>
<h1 id="软件的变化性"><a href="#软件的变化性" class="headerlink" title="软件的变化性"></a>软件的变化性</h1><p>&nbsp;<br>好的软件能够适应变化。软件的灵活性、健壮性、可靠性是程序员们在满足当前需求并关注将来的可能后设计和实现出来的。优秀的软件是那些时刻关注未来的人们编写的。<br>什么会发生变化呢？继承体系会变，现在的派生类将会是以后的基类；运行平台会变；程序的维护人员会更替，因此程序应该被设计得易于被别人理解、维护和扩充 。</p>
<hr>
<h1 id="如何表达设计条件的约束"><a href="#如何表达设计条件的约束" class="headerlink" title="如何表达设计条件的约束"></a>如何表达设计条件的约束</h1><p>&nbsp;<br>我们应该<strong>习惯于使用C++语言自身来约束程序的性质，而不是依赖注释或文档</strong>。<br>如果一个类不可继承，那么应该按照More Effective C++ 26中的方法阻止。<br>如果一个类的实例必须创建于heap中，应该用More Effective C++ 27中的方法来强迫完成。<br>如果一个类的拷贝构造或赋值无意义，则应该将它们设置为private。<br>当我们定义成员函数时，应该判明其意义，以及派生类中的它是否有意义。如果它在派生类中依然存在意义，则令它为虚函数，即使当前并不需要override。如果不存在任何意义，声明为非虚函数。确保更改是为了整个类的运行环境和类所表示的抽象，而非仅仅满足某个需求。（Effetive C++ 35）<br>处理每个类的赋值和拷贝构造函数，以防止有人误调编译器提供的默认版本而产生意料之外的结果。（Effective C++ 07）<br>当我们建立一个类时，努力保证其操作和语法自然且直观，自定义数据类型的行为尽量与内置类型保持一致。（Effective C++ 19）<br>要确信用户必然会犯错，因此你的类必须设计得可以预防、检测、及修正这些错误。（Effective C++ 18）<br>努力去写可移植的代码。只有在性能极其重要时采用不可移植的结构才是可取的。<br>尽可能地封装,将实现细节申明为私有。（Effective C++ 23、29）<br>尽可能使用无名命名空间和文件内的静态对象或函数。(More Effective C++ 31）<br>避免导致虚基类的设计，因为这种类需要每个派生类都直接初始化它－－即使是间接派生类。（Effective C++ 41)<br>避免需要RTTI的设计，因为它需要多重的if-else逻辑判断，每当继承层次改变，都需要更新原有的逻辑。(More Effective C++ 31）<br><strong>面向未来编程认为：在设计一个类时，不要去关注现在该如何使用该类，而是关注该类被设计为如何使用。</strong>如果一个类被设计为作一个基类使用（即使现在还没有被这么使用），它就应该有一个虚析构函数。这样的类在现在和将来都行为正确，并且当新类从它们派生时并不影响其它库用户。</p>
<hr>
<h1 id="活在当下与面向未来"><a href="#活在当下与面向未来" class="headerlink" title="活在当下与面向未来"></a>活在当下与面向未来</h1><p>&nbsp;<br>当然，我们依旧活在当下，首先要做的应该是确保完成当下的任务，但未来时态仅仅只是增加了一些额外的约束：</p>
<ol>
<li>尽可能提供完备的类， 确保当产生新需求时不用去更改它们。</li>
<li>将你的接口设计得直观且高效，使class不易被错误使用。</li>
<li>尽量通用化代码。例如，如果在写树的遍历算法，考虑将其通用化至可以处理任何有向无环图。</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>面向未来编程增加了代码的可重用性、可维护性、健壮性，并且保证了在运行环境发生改变时易于修改。但面向未来编程的前提是完成当前问题已经得到有效解决。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/29/%E8%AE%A9%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%86%B3%E5%AE%9A%E5%A6%82%E4%BD%95%E8%99%9A%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/%E8%AE%A9%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%86%B3%E5%AE%9A%E5%A6%82%E4%BD%95%E8%99%9A%E5%8C%96/" itemprop="url">31.让函数根据一个以上的对象类型来决定如何虚化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-29T17:12:00+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h1><p>&nbsp;<br>假设我们在设计一个游戏，游戏的背景发生在太空，有宇宙飞船、太空站和小行星等对象。这些对象可能会发生碰撞，有规则如下：</p>
<ul>
<li>如果飞船和空间站以低速接触，飞船将泊入空间站。否则，它们将有正比于相对速度的损坏。</li>
<li>如果飞船与飞船，或空间站与空间站相互碰撞，参与者均有正比于相对速度的损坏。</li>
<li>如果小行星与飞船或空间站碰撞，小行星毁灭。如果是小行星体积较大，飞船或空间站也毁坏。</li>
<li>如果两个小行星碰撞，将碎裂为更小的小行星，并向各个方向溅射。</li>
</ul>
<hr>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&nbsp;<br>首先开始分析对象共性。显然，它们都在运动，都有一个速度描述运动，因此应该存在一个抽象基类，让各对象从抽象基类中派生出来。继承体系如下：<img src="http://static.zybuluo.com/zsmj2017/gd97vru83myvlbpioi22nfph/image_1cc8b0o0hd4smo21uu2166j18fc9.png" alt="image_1cc8b0o0hd4smo21uu2166j18fc9.png-53.9kB"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceStation</span>:</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asteroid</span>:</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br></pre></td></tr></table></figure><br>接着我们准备撰写最关键的碰撞函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkForCollision</span><span class="params">(GameObject&amp; object1,GameObject&amp; object2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (theyJustCollided(object1, object2)) &#123;</span><br><span class="line">        processCollision(object1, object2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>processCollision函数必然是一个虚函数，但关键问题在于，该函数的虚化并非由一个对象类型决定，而是由两个对象类型共同决定。<br>这种二重调度问题被称为double dispatch，相应地当然也有multiple dispatch。C++并没有提供相应的功能，因此我们必须手动模拟编译器来进行实现。</p>
<hr>
<h1 id="虚函数-RTTI"><a href="#虚函数-RTTI" class="headerlink" title="虚函数+RTTI"></a>虚函数+RTTI</h1><p>&nbsp;<br>我们在GameObject中申明一个虚函数collide。这个函数被派生类以通常的形式重载：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>为了节约篇幅，下文只针对派生类SpaceShip做出详细描述，其他派生类的情况类似于SpaceShip。<br>实现double-dispatch最常见的写法就是if-else逻辑链。在这种方法中，我们首先判断rhs的真实类型，然后测试所有可能：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollisionWithUnknownObject</span> &#123;</span><span class="comment">//异常类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CollisionWithUnknownObject(GameObject&amp; whatWeHit);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject&amp; otherObject)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type_info&amp; objectType = <span class="keyword">typeid</span>(otherObject);</span><br><span class="line">    <span class="keyword">if</span> (objectType == <span class="keyword">typeid</span>(SpaceShip)) &#123;</span><br><span class="line">        SpaceShip&amp; ss = <span class="keyword">static_cast</span>&lt;SpaceShip&amp;&gt;(otherObject);</span><br><span class="line">        ...<span class="comment">//process a SpaceShip-SpaceShip collision;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objectType == <span class="keyword">typeid</span>(SpaceStation)) &#123;</span><br><span class="line">        SpaceStation&amp; ss = <span class="keyword">static_cast</span>&lt;SpaceStation&amp;&gt;(otherObject);</span><br><span class="line">        ...<span class="comment">//process a SpaceShip-SpaceStation collision;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objectType == <span class="keyword">typeid</span>(Asteroid)) &#123;</span><br><span class="line">        Asteroid&amp; a = <span class="keyword">static_cast</span>&lt;Asteroid&amp;&gt;(otherObject);</span><br><span class="line">        <span class="built_in">process</span> a SpaceShip-Asteroid collision;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> CollisionWithUnknownObject(otherObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们完全放弃了封装:每一个object都必须了解其同胞类的版本，一旦增了新类，我们必须更新每一个RTTI体系。<br>在没有虚函数的概念时，这种写法就是虚函数的粗陋实现，显然这种程序毫无维护性。</p>
<hr>
<h1 id="只使用虚函数"><a href="#只使用虚函数" class="headerlink" title="只使用虚函数"></a>只使用虚函数</h1><p>&nbsp;<br>这个方法架构与RTTI版本其实无二，只不过其collide函数增加了各种重载版本，每一个重载处理一个类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceStation</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asteroid</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceShip&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceStation&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(Asteroid&amp; otherobject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceShip&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceStation&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(Asteroid&amp; otherobject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其基本原理就是用两个单一调度实现二重调度，也就是说有两个单独的虚函数调用：以rhs作为函数调用的对象再次调用虚函数，*this的静态类型已知，可以直接匹配。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject&amp; otherObject)</span></span>&#123;</span><br><span class="line">    otherObject.collide(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法的缺陷和RTTI一样：每一个类都必须知道其同胞类，当增加新类时，所有代码必须更新，而且必须为每一个新类增加一个新的虚函数。如果当前依赖于某个运行库，这样的改动会导致整个运行库都必须重新编译。</p>
<hr>
<h1 id="模拟虚函数表"><a href="#模拟虚函数表" class="headerlink" title="模拟虚函数表"></a>模拟虚函数表</h1><p>&nbsp;<br>在More Effective C++ 24中我们提及了vtbl，虚函数实现的基础。使用vtbl，编译器避免了使用if…then…else链，并能在所有调用虚函数的地方生成同样的代码。我们没有理由无法在之前的RTTI体系中模拟vtbl。<br>首先，我们对GameObjcet继承体系中的函数作一些修改,为每个子类添加对应的碰撞函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceShip</span><span class="params">(SpaceShip&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceStation</span><span class="params">(SpaceStation&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitAsteroid</span><span class="params">(Asteroid&amp; otherobject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceShip</span><span class="params">(SpaceShip&amp; otherObject)</span></span>&#123;</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-SpaceShip collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceStation</span><span class="params">(SpaceStation&amp; otherObject)</span></span>&#123;</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-SpaceStation collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitAsteroid</span><span class="params">(Asteroid&amp; otherObject)</span></span>&#123;</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-Asteroid collision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Spaceship::collide中，我们需要一个方法来映射参数otherObject的动态类型到一个成员函数指针，我们使用一个中间函数lookup来完成此工作:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(SpaceShip::*HitFunctionPtr)</span><span class="params">(GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> GameObject&amp; whatWeHit)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>既然有了lookup，那么collide的实现就很简单了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject&amp; otherObject)</span></span>&#123;</span><br><span class="line">    HitFunctionPtr hfp = lookup(otherObject);</span><br><span class="line">    <span class="keyword">if</span>(hfp) &#123;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;*hfp)(otherObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> CollisionWithUnknownObject(otherObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来要做的就是保证动态类型与成员函数之间的映射了。</p>
<hr>
<h2 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h2><p>首先要做的是一个映射表。该映射表应该在它被使用前构造与初始化，并在不被需要时析构。以上操作应该由编译器自动完成，所以我们将映射表设为lookup函数中的static对象，在第一次调用lookup时构造，在main退出后自行析构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(SpaceShip::*HitFunctionPtr)</span><span class="params">(GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, HitFunctionPtr&gt; HitMap;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SpaceShip::HitFunctionPtr</span><br><span class="line">SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whatWeHit)&#123;</span><br><span class="line">    <span class="keyword">static</span> HitMap collisionMap;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过使用map的find函数，lookup实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SpaceShip::HitFunctionPtr</span><br><span class="line">SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whatWeHit)&#123;</span><br><span class="line">    <span class="keyword">static</span> HitMap collisionMap;</span><br><span class="line">    <span class="keyword">auto</span> mapEntry = collisionMap.<span class="built_in">find</span>(<span class="keyword">typeid</span>(whatWeHit).name());</span><br><span class="line">    <span class="keyword">if</span> (mapEntry == collisionMap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> mapEntry-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="初始化映射表"><a href="#初始化映射表" class="headerlink" title="初始化映射表"></a>初始化映射表</h3><p>我们需要写一个私有的静态成员函数initializeCollisionMap来构造和初始化映射表，然后用其返回值来初始化collisionMap：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> HitMap <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SpaceShip::HitFunctionPtr</span><br><span class="line">SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whatWeHit)&#123;</span><br><span class="line">    <span class="keyword">static</span> HitMap collisionMap = initializeCollisionMap();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种写法意味着我们需要拷贝赋值，如果初始化函数返回指针则可以避免该问题，但堆中对象又可能会发生资源泄露。考虑到RAII，我们可以将 collisionMap改为一个智能指针，它将在自己被析构时delete 所指向的对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line">    <span class="keyword">private</span>:<span class="function"><span class="keyword">static</span> HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SpaceShip::HitFunctionPtr</span><br><span class="line">SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whatWeHit)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">auto_ptr</span>&lt;HitMap&gt; <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SpaceShip::HitMap * <span class="title">SpaceShip::initializeCollisionMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">    (*phm)[<span class="string">"SpaceShip"</span>] = &amp;hitSpaceShip;</span><br><span class="line">    (*phm)[<span class="string">"SpaceStation"</span>] = &amp;hitSpaceStation;</span><br><span class="line">    (*phm)[<span class="string">"Asteroid"</span>] = &amp;hitAsteroid;</span><br><span class="line">    <span class="keyword">return</span> phm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但这无法通过编译，因为HitMap内包容的是一堆指向成员函数的指针，他们的参数类型都是GameObject，而hitSpaceShip等函数带的不一样。虽然对象类型可以隐式转换，但函数指针并没有这种转换关系。<br>使用reinterpret_cast并不是好主意，而且存在极大风险，当spaceship位于多继承体系下时，编译器可能会传输错误的地址。为了不采取类型转换，我们不得不把hit函数的形参改为统一的gameobject，然后在每一个函数中使用dynamic_cast：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>:</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceShip</span><span class="params">(GameObject&amp; spaceShip)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceStation</span><span class="params">(GameObject&amp; spaceStation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitAsteroid</span><span class="params">(GameObject&amp; asteroid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceShip</span><span class="params">(GameObject&amp; spaceShip)</span></span>&#123;</span><br><span class="line">    SpaceShip&amp; otherShip = <span class="keyword">dynamic_cast</span>&lt;SpaceShip&amp;&gt;(spaceShip);</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-SpaceShip collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceStation</span><span class="params">(GameObject&amp; spaceStation)</span></span>&#123;</span><br><span class="line">    SpaceStation&amp; station = <span class="keyword">dynamic_cast</span>&lt;SpaceStation&amp;&gt;(spaceStation);</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-SpaceStation collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitAsteroid</span><span class="params">(GameObject&amp; asteroid)</span></span>&#123;</span><br><span class="line">    Asteroid&amp; theAsteroid = <span class="keyword">dynamic_cast</span>&lt;Asteroid&amp;&gt;(asteroid);</span><br><span class="line">    <span class="built_in">process</span> a SpaceShip-Asteroid collision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="使用非成员碰撞函数"><a href="#使用非成员碰撞函数" class="headerlink" title="使用非成员碰撞函数"></a>使用非成员碰撞函数</h1><p>&nbsp;<br>之前我们一直以成员函数指针存放于map中，这直接导致如果添加新类的话，依然存在更新成员函数的问题，这也导致了重新编译。<br>另外，当发生A撞B时，应该调用谁的成员函数呢?我们总以左侧参数决定调用对象，实际上我们应该认定，A与B的碰撞应该既不在A中处理也不在B中处理。<br>当我们把碰撞函数从类中移除，其文件组织形式大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SpaceShip.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SpaceStation.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Asteroid.h"</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">//无名命名空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shipAsteroid</span><span class="params">(GameObject&amp; spaceShip,GameObject&amp; asteroid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shipStation</span><span class="params">(GameObject&amp; spaceShip,GameObject&amp; spaceStation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asteroidStation</span><span class="params">(GameObject&amp; asteroid,GameObject&amp; spaceStation)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asteroidShip</span><span class="params">(GameObject&amp; asteroid,GameObject&amp; spaceShip)</span></span>&#123; </span><br><span class="line">        shipAsteroid(spaceShip, asteroid); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stationShip</span><span class="params">(GameObject&amp; spaceStation,GameObject&amp; spaceShip)</span></span>&#123; </span><br><span class="line">        shipStation(spaceShip, spaceStation); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stationAsteroid</span><span class="params">(GameObject&amp; spaceStation,GameObject&amp; asteroid)</span></span>&#123;                            asteroidStation(asteroid, spaceStation); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;, GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">map</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;, HitFunctionPtr &gt; HitMap;</span><br><span class="line">    pair&lt;string,string&gt; makeStringPair(const char *s1,const char *s2);</span><br><span class="line">    <span class="function">HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; class1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; class2)</span></span>;</span><br><span class="line">&#125;<span class="comment">//end namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processCollision</span><span class="params">(GameObject&amp; object1,GameObject&amp; object2)</span></span>&#123;</span><br><span class="line">    HitFunctionPtr phf = lookup(<span class="keyword">typeid</span>(object1).name(),<span class="keyword">typeid</span>(object2).name());</span><br><span class="line">    <span class="keyword">if</span>(phf) </span><br><span class="line">        phf(object1, object2);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> UnknownCollision(object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意这里使用了无名命名空间，其特点在于命名空间内所有东西均被本文件所私有（类似于声明在文件范围内的static函数)<br>非成员映射需要两个类型名与一个HitFunctionPtr，但只要用pair把那两个string绑一起就好了。于是映射表初始化函数实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    pair&lt;string,string&gt; makeStringPair(const char *s1,const char *s2)&#123; </span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;(s1, s2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end namespace</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function">HitMap * <span class="title">initializeCollisionMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">        (*phm)[makeStringPair(<span class="string">"SpaceShip"</span>,<span class="string">"Asteroid"</span>)] =&amp;shipAsteroid;</span><br><span class="line">        (*phm)[makeStringPair(<span class="string">"SpaceShip"</span>, <span class="string">"SpaceStation"</span>)] =&amp;shipStation;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> phm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end namespace</span></span><br></pre></td></tr></table></figure><br>lookup 函数也必须被修改以处理pair&lt;string,string&gt;对象，并将它作为映射表的第一部分:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; class1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; class2)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">auto_ptr</span>&lt;HitMap&gt; <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> mapEntry = collisionMap-&gt;<span class="built_in">find</span>(make_pair(class1, class2));</span><br><span class="line">        <span class="keyword">if</span> (mapEntry == collisionMap-&gt;<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> (*mapEntry).second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end namespace</span></span><br></pre></td></tr></table></figure><br>因为上述函数的声明都在无名命名空间中，因此实现也必须在无名命名空间中。</p>
<hr>
<h1 id="继承与模拟虚函数表"><a href="#继承与模拟虚函数表" class="headerlink" title="继承与模拟虚函数表"></a>继承与模拟虚函数表</h1><p>&nbsp;<br>假设我们当前需要区分贸易飞船与军事飞船的区别，无疑，继承体系需要更改：<br><img src="http://static.zybuluo.com/zsmj2017/oyk370ogwudt9e1nin8tyzcu/image_1cc8g09pf18qt12ag5u1hmh1r0am.png" alt="image_1cc8g09pf18qt12ag5u1hmh1r0am.png-76.5kB"><br>我们会发现lookup根本找不到这两个子类，除非我们再次更新表，这样再次造成了重编译。</p>
<hr>
<h1 id="再次讨论初始化vtbl"><a href="#再次讨论初始化vtbl" class="headerlink" title="再次讨论初始化vtbl"></a>再次讨论初始化vtbl</h1><p>&nbsp;<br>之所以会出现上一个问题完全是由于我们的map是完全静态的，每当我们注册一个碰撞函数，其行为便被完全固定。从面向对象的角度而言，我们应该建立一个class存放映射表，并且为它提供动态修改映射关系的成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollisionMap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;, GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; type2,</span></span></span><br><span class="line"><span class="function"><span class="params">                  HitFunctionPtr collisionFunction,<span class="keyword">bool</span> symmetric = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeEntry</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; type2)</span></span>;</span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; type2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> CollisionMap&amp; <span class="title">theCollisionMap</span><span class="params">()</span></span>;<span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CollisionMap();</span><br><span class="line">    CollisionMap(<span class="keyword">const</span> CollisionMap&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该类使用了单例模式，保证只存在一张表。同时允许增加对称性碰撞，自动添加对称关系。<br>为了确保发生碰撞前映射关系已存在，我们可以创建一个register类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterCollisionFunction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RegisterCollisionFunction(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; type2,</span><br><span class="line">                              CollisionMap::HitFunctionPtr collisionFunction,</span><br><span class="line">                              <span class="keyword">bool</span> symmetric = <span class="literal">true</span>)&#123;</span><br><span class="line">        CollisionMap::theCollisionMap().addEntry(type1, type2,collisionFunction,symmetric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>用户于是可以使用此类型的一个全局对象来自动地注册他们所需要的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RegisterCollisionFunction <span class="title">cf1</span><span class="params">(<span class="string">"SpaceShip"</span>, <span class="string">"Asteroid"</span>,&amp;shipAsteroid)</span></span>;</span><br><span class="line"><span class="function">RegisterCollisionFunction <span class="title">cf2</span><span class="params">(<span class="string">"SpaceShip"</span>, <span class="string">"SpaceStation"</span>,&amp;shipStation)</span></span>;</span><br><span class="line"><span class="function">RegisterCollisionFunction <span class="title">cf3</span><span class="params">(<span class="string">"Asteroid"</span>, <span class="string">"SpaceStation"</span>,&amp;asteroidStation)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为这些全局对象在main被调用前就构造了，它们在构造函数中注册的函数也在main被调用前就加入了映射表。如果以后增加了一个派生类或新的碰撞对象，也只需要在主函数执行前加入即可，不需要修改库文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/29/Proxy%20Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/Proxy%20Class/" itemprop="url">30.Proxy Class</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-29T15:04:00+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>C++无法自由地创建多维数组，你可能会作出反驳：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[<span class="number">10</span>][<span class="number">20</span>];</span><br></pre></td></tr></table></figure><br>但我指的是以变量作为构建数组的形参：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(<span class="keyword">int</span> dim1, <span class="keyword">int</span> dim2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[dim1][dim2];<span class="comment">//error</span></span><br><span class="line">    <span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[dim1][dim2];<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="实现二维数组"><a href="#实现二维数组" class="headerlink" title="实现二维数组"></a>实现二维数组</h1><p>&nbsp;<br>为了实现二维数组，我们不得不自己新建一个class，以期待完成功能：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array2D(<span class="keyword">int</span> dim1, <span class="keyword">int</span> dim2);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>遗憾的是Array2D生成的对象并不具备索引功能。也就是说：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array2D&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[<span class="number">3</span>][<span class="number">6</span>];<span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>我们只能最多重载一个operator[]，不可能重载operator[][]（详见More Effective C++ 7）。<br>事实上，我们完全有理由相信，一个二维数组在调用operator[]后应当返回一个Array1D对象，然后我们通过重载Array1D的operator[]即可顺利完成索引操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">Array2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Array1D</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">        <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line">    Array1D <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    <span class="keyword">const</span> Array1D <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Array2D&lt;<span class="keyword">float</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[<span class="number">3</span>][<span class="number">6</span>];<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><br>Array2D的用户并不需要知道Array1D类的存在。这个背后的“一维数组”对象从概念上来说，并不是为 Array2D 类的用户而存在的。其用户编程时就象他们在使用真正的二维数组一样<br>每个Array1D对象扮演的是一个一维数组，而这个一维数组并不存在于使用Array2D的程序中<strong>。“用来代表其他对象”的对象通常被称为代理类。</strong>Array1D就是一个代理类，它的对象扮演的是一个在概念上不存在的一维数组。</p>
<hr>
<h1 id="区分opeator-的读写操作"><a href="#区分opeator-的读写操作" class="headerlink" title="区分opeator[]的读写操作"></a>区分opeator[]的读写操作</h1><p>&nbsp;<br>​我们已经了解operator[]会在两种不同的情况下调用：读和写。读是一个右值操作而写是一个左值操作。<br>在实现引用计数时我们假设所有operator[]操作均为写，这直接导致了一系列麻烦的操作，以及shareable标志位的诞生。<br>事实上我们可以通过Proxy class区分operato[]的操作，其原理为：<strong>将判断读和写的行为推迟到我们明确operator[]的结果会被如何使用</strong>。显然，这是Lzay evaluation的一大体现。</p>
<h2 id="String中的proxy对象"><a href="#String中的proxy对象" class="headerlink" title="String中的proxy对象"></a>String中的proxy对象</h2><p>结合String实例,我们可以修改operator[],令其返回一个proxy对象而非字符本身，然后观察proxy会被如何使用。<br>String中的proxy对象只能做3件事：</p>
<ol>
<li>创建，指定扮演哪个字符</li>
<li>将其作为赋值的目标，此时扮演左值</li>
<li>以其他方式使用，扮演右值</li>
</ol>
<p>以带有引用计数的String class为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CharProxy</span> &#123;</span> <span class="comment">// proxies for string chars</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CharProxy(<span class="keyword">String</span>&amp; str, <span class="keyword">int</span> index);</span><br><span class="line">        CharProxy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CharProxy&amp; rhs);</span><br><span class="line">        CharProxy&amp; <span class="keyword">operator</span>=(<span class="keyword">char</span> c);</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">String</span>&amp; theString;</span><br><span class="line">        <span class="keyword">int</span> charIndex;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> CharProxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    CharProxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CharProxy</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当前String的operator[]函数将返回的是CharProxy对象。然而，String类的用户并不需要了解这一点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s1, s2;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1[<span class="number">5</span>];</span><br><span class="line">s2[<span class="number">5</span>] = <span class="string">'x'</span>;</span><br><span class="line">s1[<span class="number">3</span>] = s2[<span class="number">8</span>];</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="右值操作"><a href="#右值操作" class="headerlink" title="右值操作"></a>右值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; s1[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>表达式s1[5]返回的是一个CharProxy对象。由于Proxy对象并没有定义IO流操作，于是编译器开始试图寻找令该语句编译成功的方法，最终找到了隐式转换。以上是代理类被作为右值操作时的常规行为。</p>
<h3 id="左值操作"><a href="#左值操作" class="headerlink" title="左值操作"></a>左值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2[<span class="number">5</span>] = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure>
<p>表达式s2[5]返回的是一个CharProxy对象，但这次它是赋值操作的目标。由于赋值的目标是CharProxy 类，因此调用的是harProxy类中的赋值操作。这至关重要，因为<strong>当进入Proxy对象的赋值函数时，我们明确当前String的operator[]执行了左值操作</strong>，因此有必要执行某些操作保证程序正常运行。</p>
<hr>
<h2 id="String的operator-实现"><a href="#String的operator-实现" class="headerlink" title="String的operator[]实现"></a>String的operator[]实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">String</span>::CharProxy <span class="keyword">String</span>::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CharProxy(<span class="keyword">const_cast</span>&lt;<span class="keyword">String</span>&amp;&gt;(*<span class="keyword">this</span>), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>::CharProxy <span class="keyword">String</span>::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">return</span> CharProxy(*<span class="keyword">this</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个函数都创建和返回一个proxy对象来代替字符。根本没有对那个字符作任何操作:我们将它推迟到直到我们知道是读操作还是写操作。<br>需要注意的是const版本返回一个const Proxy对象，因此它不能被赋值，这正是我们想要的。并且在该函数中为了与构造函数匹配，我们使用了类型转换，此处类型转换构造的对象也是const，不用担心数据被篡改的问题。</p>
<hr>
<h2 id="Proxy对象的实现"><a href="#Proxy对象的实现" class="headerlink" title="Proxy对象的实现"></a>Proxy对象的实现</h2><h3 id="构造与转换"><a href="#构造与转换" class="headerlink" title="构造与转换"></a>构造与转换</h3><p>通过operator[]返回的proxy对象记录了它属于哪个string，以及下标。当proxy对象作为右值被使用时，其返回值是一个不可修改的proxy对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>::CharProxy::CharProxy(<span class="keyword">String</span>&amp; str, <span class="keyword">int</span> index)</span><br><span class="line">: theString(str), charIndex(index) &#123;&#125;</span><br><span class="line"><span class="keyword">String</span>::<span class="function">CharProxy::<span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> theString.value-&gt;data[charIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><p>赋值操作的实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>::CharProxy&amp;</span><br><span class="line"><span class="keyword">String</span>::CharProxy::<span class="keyword">operator</span>=(<span class="keyword">const</span> CharProxy&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;isShared()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> StringValue(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    theString.value-&gt;data[charIndex] = rhs.theString.value-&gt;data[rhs.charIndex];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以char作为形参执行的赋值操作也大同小异：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>::CharProxy&amp; <span class="keyword">String</span>::CharProxy::<span class="keyword">operator</span>=(<span class="keyword">char</span> c)&#123;</span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;isShared()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> StringValue(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    theString.value-&gt;data[charIndex] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然，我们应当编写一个private member function消除它们之间的代码重复。</p>
<hr>
<h1 id="Porxy-class的局限性"><a href="#Porxy-class的局限性" class="headerlink" title="Porxy class的局限性"></a>Porxy class的局限性</h1><p>Proxy并非完美，在某些场合下它离无缝替代差的很远。</p>
<h2 id="取址"><a href="#取址" class="headerlink" title="取址"></a>取址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;s1[<span class="number">1</span>]; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>我们没法把一个charProxy*赋值给char*，要解决的话只能重载取址运算符。<br>const版本很容易实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">String</span>::CharProxy::<span class="keyword">operator</span>&amp;() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(theString.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>non-const版本则颇类似于前一节中的operator[]:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">String</span>::CharProxy::<span class="keyword">operator</span>&amp;()&#123;</span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;isShared()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> StringValue(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    theString.value-&gt;markUnshareable();<span class="comment">//无法保证其被用于何种操作，因此锁定不可共享</span></span><br><span class="line">    <span class="keyword">return</span> &amp;(theString.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="带引用计数的数组模板"><a href="#带引用计数的数组模板" class="headerlink" title="带引用计数的数组模板"></a>带引用计数的数组模板</h2><p>如果我们想用proxy类来区分其operator[]作左值还是右值时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Proxy(Array&lt;T&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> index);</span><br><span class="line">        Proxy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; rhs);</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> Proxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    Proxy <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该带有引用计数的数组可能被这样使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;<span class="keyword">int</span>&gt; intArray;</span><br><span class="line">...</span><br><span class="line">intArray[<span class="number">5</span>] = <span class="number">22</span>;</span><br><span class="line">intArray[<span class="number">5</span>] += <span class="number">5</span>;<span class="comment">//error!</span></span><br><span class="line">++intArray[<span class="number">5</span>];<span class="comment">//error!</span></span><br></pre></td></tr></table></figure><br>无法编译的原因在于我们没有为代理类重载这些操作符。相似的，我们也无法通过代理类来调用实际对象的member function，也没法作为非const的引用传给函数。</p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>我们之所以能用代理类是因为它和真实对象间存在隐式转换，但当我们期待原对象发生隐式转换时，表达式将无法通过编译，原因在于隐式转换无法在同一时间触发多次。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>Proxy Class可以完成一些其它方法很难甚至不可能实现的行为,例如：</p>
<ol>
<li>多维数组</li>
<li>区分左右值操作</li>
<li>限制隐式类型转换</li>
</ol>
<p>Proxy Class亦有缺点，代理对象始终是一个临时对象，不可避免地存在着构造与析构的成本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/29/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/" itemprop="url">29.引用计数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-29T11:56:00+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>引用计数允许多个具有相同值的对象共享这个值的实现，其作用大致有二：</p>
<ol>
<li>简化跟踪堆中对象。<br>在使用引用计数后，对象明确自己拥有自己的资源，当没人使用时自动销毁，可以算是一个简单的垃圾回收。</li>
<li>Lazy evaluation<br>如果很多对象拥有相同的值，我们不应该存储这个值，而是让所有对象共享其实现。</li>
</ol>
<hr>
<h1 id="引用计数实例"><a href="#引用计数实例" class="headerlink" title="引用计数实例"></a>引用计数实例</h1><p>&nbsp;<br>我们首先复习一下Lazy evaluation。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span><span class="comment">//自定义string类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span> a, b, c, d, e;</span><br><span class="line">a = b = c = d = e = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><br>a到e的具体值形态其实取决于string类的实现。如果不作特殊化处理，每一个string对象均应具有一个值的拷贝，此时有赋值操作符实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, rhs.data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然，在这种实现下，abcde如下所示：<br><img src="http://static.zybuluo.com/zsmj2017/qts3knjxll0lza2h7vmqh5lp/image_1cc7oo06d1n3v1sjt1omc1h6b15gc9.png" alt="image_1cc7oo06d1n3v1sjt1omc1h6b15gc9.png-48.3kB"><br>​这无疑是冗余的，我们希望的理想情况是这样：<br><img src="http://static.zybuluo.com/zsmj2017/pl4h5tdvws1z0tz8zc03d9ax/image_1cc7opfrj1avv1hha5ub1sdu84tm.png" alt="image_1cc7opfrj1avv1hha5ub1sdu84tm.png-30.9kB"><br>但这种情况是不现实的，我们<strong>至少应该记录当前有多少对象在使用该资源</strong>，增设计数器之后的效果如下：<img src="http://static.zybuluo.com/zsmj2017/4mds08expzujjkkyd5janclh/image_1cc7oqndik0j1i0h1ue21mmkgue13.png" alt="image_1cc7oqndik0j1i0h1ue21mmkgue13.png-35.5kB"></p>
<hr>
<h1 id="实现引用计数"><a href="#实现引用计数" class="headerlink" title="实现引用计数"></a>实现引用计数</h1><p>&nbsp;<br>仍以String为例。首先我们应当明确需要空间来存储计数值。该空间不可能存在于string内部，因为引用计数的本质是每一个资源一个计数，而非一个对象一个计数，这也表明了资源和引用计数之间存在一种耦合关系。<br>我们使用一个名为StringValue的struct帮助我们实现上述功能。它不仅仅保存计数器，同时也保存资源。我们将其置于String的private部分(<strong>将一个struct内嵌在类的私有区内，能便于这个类的所有成员访问这个结构，但阻止了其它任何人对它的访问</strong>)其设计与实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> refCount;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line">    StringValue* value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">:refCount(<span class="number">1</span>)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>::StringValue::~StringValue()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这便是引用计数的全部，你所认为缺少的功能将由String类提供。StringValue的功能主要就是：将一个特殊的值与共享此值的对象的数目联系起来。</p>
<hr>
<h2 id="String的构造"><a href="#String的构造" class="headerlink" title="String的构造"></a>String的构造</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue = <span class="string">""</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">: value(<span class="keyword">new</span> StringValue(initValue))&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，String对象是独立构造的，有同样初始化值的对象并不共享数据：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"More Effective C++"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">s2</span><span class="params">(<span class="string">"More Effective C++"</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>产生的数据结构如下所示：<img src="http://static.zybuluo.com/zsmj2017/a8xpqnsww9an00wvqr4fn6r4/image_1cc7qinp41b8b1pd851p11dd1gv61t.png" alt="image_1cc7qinp41b8b1pd851p11dd1gv61t.png-42kB"><br>消除这样的副本是可能的：通过让String或StringValue对象跟踪已存在的StringValue对象，并只在不同串时才创建新的对象。</p>
<hr>
<h2 id="String的拷贝"><a href="#String的拷贝" class="headerlink" title="String的拷贝"></a>String的拷贝</h2><p>String 的拷贝构造函数效率很高，新生成的String对象与被拷贝的对象共享相同的StringValue对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs)</span><br><span class="line">: value(rhs.value)&#123;</span><br><span class="line">    ++value-&gt;refCount;<span class="comment">//需要注意value在heap中，为对象所共有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如下代码产生的数据结构如图所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"More Effective C++"</span>)</span></span>;</span><br><span class="line"><span class="keyword">String</span> s2 = s1;</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/zsmj2017/a5r77zx2z4bb6n94dyjdlz7m/image_1cc7qpffq11lo13nkif8m84r0d2a.png" alt="image_1cc7qpffq11lo13nkif8m84r0d2a.png-25.3kB"><br>这必然比值拷贝系列效率要高，在本次拷贝中，我们只不过是拷贝了一个指针并增加了一次引用计数。</p>
<hr>
<h2 id="String的析构"><a href="#String的析构" class="headerlink" title="String的析构"></a>String的析构</h2><p>析构函数实现较为容易：只要引用计数值不为0，也就是当前至少存在一个String对象使用这个值，这个值就不可以被销毁：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="keyword">String</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) <span class="keyword">delete</span> value;<span class="comment">//先执行自减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="String的赋值"><a href="#String的赋值" class="headerlink" title="String的赋值"></a>String的赋值</h2><p>当用户写下这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = s2;</span><br></pre></td></tr></table></figure><br>其结果应该是s1和s2指向相同的StringValue对象,对象的引用计数在赋值时被增加。并且，s1原来指向的 StringValue对象的引用计数应该减少，如果s1是拥有原来的值的唯一对象，这个值销毁。上述功能实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == rhs.value) &#123;<span class="comment">//类似于自赋值，这里指的是已经指向相同对象</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = rhs.value;</span><br><span class="line">    ++value-&gt;refCount;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h1><p>&nbsp;<br>数组下标操作符[]允许字符串中的单个字符被读或写:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>; <span class="comment">// for const Strings</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index); <span class="comment">// for non-const Strings</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>const成员函数很容易实现，因为它仅仅提供读操作。但non-const则较为繁琐，因为它需要分别处理读和写的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[<span class="number">3</span>];<span class="comment">//read</span></span><br><span class="line">s[<span class="number">5</span>] = <span class="string">'x'</span>;<span class="comment">//write</span></span><br></pre></td></tr></table></figure><br>当我们试图修改一个String对象的值时，必须确保没有修改和它共享StringValue的对象。但我们无法确定operator[]执行的是何种操作（proxy class可以帮助区分读写，详见More Effective C++ 30），所以我们必须假设所有operator[]都在执行写操作。<br>为了安全地实现non-const operator[]，我们必须确保资源被当前String对象独占。简而言之，当我们返回StringValue对象中的一个字符的引用时，必须确保这个StringValue的引用计数是1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;refCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        --value-&gt;refCount;<span class="comment">//脱离当前资源共享阶段</span></span><br><span class="line">        value = <span class="keyword">new</span> StringValue(value-&gt;data);<span class="comment">//生成一个新资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>写时拷贝是这么一种情况：一个对象永远与其他等值对象共享资源，直到它需要修改自身时才迅速拷贝一份资源，你可以把它视为lazy-evacuation的一个应用特例。</p>
<hr>
<h1 id="指针、引用与写时拷贝"><a href="#指针、引用与写时拷贝" class="headerlink" title="指针、引用与写时拷贝"></a>指针、引用与写时拷贝</h1><p>&nbsp;<br>多数情况下上文所实现的写时拷贝兼具正确性与高效性，但加入了指针后正确性可能会因此失效：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;s1[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><br>其数据结构如下所示：<img src="http://static.zybuluo.com/zsmj2017/q5z8n5l245jbml5g9c7xaoq9/image_1cc7skm1scn5emb6i1d1tsno2n.png" alt="image_1cc7skm1scn5emb6i1d1tsno2n.png-15.3kB"><br>现增加一条语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s2 = s1;</span><br></pre></td></tr></table></figure><br>由于资源共享的原因，当前数据结构如下所示：<img src="http://static.zybuluo.com/zsmj2017/e5xeg3q7myaib4p73vr1dqy0/image_1cc7smvc4e04147p1dml1tb757s34.png" alt="image_1cc7smvc4e04147p1dml1tb757s34.png-21.5kB"><br>如果我们试图通过p去更改s1，就会发现s2也遭到了更改。并非只有指针会造成这种情况，non-conts-reference也是如此。<br>解决方案不难实现，但我们付出了代价：降低一个值共享于对象间的次数。解决方案原理是：在每个StringValue对象中增加一个标志以指出它是否具备共享性，一开始标志位设置为可共享，一旦有operator[]被调用，标志位翻转为不可共享状态，并且永久保持为不可共享：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> refCount;</span><br><span class="line">        <span class="keyword">bool</span> shareable; <span class="comment">// add this</span></span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">: refCount(<span class="number">1</span>),shareable(<span class="literal">true</span>)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>::StringValue::~StringValue()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在标志位增加后，String的成员函数也需要修改保持配合：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; rhs)&#123;<span class="comment">//以拷贝构造举例</span></span><br><span class="line">    <span class="keyword">if</span> (rhs.value-&gt;shareable) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        ++value-&gt;refCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="keyword">new</span> StringValue(rhs.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>non-const operator[]是唯一一个可以更改标志位的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;refCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        --value-&gt;refCount;</span><br><span class="line">        value = <span class="keyword">new</span> StringValue(value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    value-&gt;shareable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="引用计数与mixin-class"><a href="#引用计数与mixin-class" class="headerlink" title="引用计数与mixin class"></a>引用计数与mixin class</h1><p>&nbsp;<br>不仅仅只有String需要引用计数，但我们不可能为所有需要引用计数的类都添加对应的struct，为了把引用计数功能抽象到与运行环境无关，我们想到了mixin class。</p>
<h2 id="RCObject"><a href="#RCObject" class="headerlink" title="RCObject"></a>RCObject</h2><p>首先构建一个基类RCObject，任何需要引用计数的类都必须继承自它，其具体定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCObject();</span><br><span class="line">    RCObject(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~RCObject() = <span class="number">0</span>;<span class="comment">//纯虚析构函数，表明该类仅能作为基类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RCObject的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RCObject::RCObject():refCount(<span class="number">0</span>), shareable(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject::RCObject(<span class="keyword">const</span> RCObject&amp;):refCount(<span class="number">0</span>), shareable(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject&amp; RCObject::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp;)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">RCObject::~RCObject() &#123;&#125;<span class="comment">//虚析构函数必须被定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::addReference</span><span class="params">()</span> </span>&#123; ++refCount; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::removeReference</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (--refCount == <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::markUnshareable</span><span class="params">()</span></span>&#123; </span><br><span class="line">    shareable = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shareable; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShared</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> refCount &gt; <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所有的构造函数都把refCount设为了0，因为我们会在构造完毕后把构造它的这个对象的count设为1。赋值操作也很奇怪，它什么都没做，因为我们不可能把计数对象从一个赋予另外一个。就算真的被赋值，它也什么都没变。removeReference函数不仅仅负责减少count值，还负责析构对象，因此这里我们必须要保证对象只被构建于堆中。（More Effective C++ 27）</p>
<hr>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String</span>::StringValue::~StringValue()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的StringValue什么都不用管，其基类接管了所有行为。</p>
<hr>
<h1 id="引用计数自动化处理"><a href="#引用计数自动化处理" class="headerlink" title="引用计数自动化处理"></a>引用计数自动化处理</h1><p>&nbsp;<br>RCObject并没有提供自动化操作，一切关于refcount的行为都必须手动完成，比如在String的拷贝构造函数和赋值运算函数中，我们需要调用StringValue的addReference和removeReference函数。我们寄希望于某种操作，能够将大部分与引用计数相关的工作从所有具象类中移出。确实存在这种东西：智能指针。</p>
<h2 id="计数对象所使用的智能指针"><a href="#计数对象所使用的智能指针" class="headerlink" title="计数对象所使用的智能指针"></a>计数对象所使用的智能指针</h2><p>以下是计数对象所使用的智能指针模版：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RCPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    RCPtr(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    ~RCPtr();</span><br><span class="line">    RCPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>; <span class="comment">// see Item 28</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>; <span class="comment">// see Item 28</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该模板允许了我们自定义构造、赋值、析构时执行的操作。当这些事件发生时，智能指针对象可以自动执行正确的操作来处理它们指向的对象（引用计数对象）的refCount字段。其具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCPtr</span>&lt;T&gt;:</span>:RCPtr(T* realPtr): pointee(realPtr)&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCPtr</span>&lt;T&gt;:</span>:RCPtr(<span class="keyword">const</span> RCPtr&amp; rhs): pointee(rhs.pointee)&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RCPtr</span>&lt;T&gt;:</span>:init()&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pointee-&gt;isShareable() == <span class="literal">false</span>) &#123;<span class="comment">//如果计数对象所指向的资源不可共享</span></span><br><span class="line">        pointee = <span class="keyword">new</span> T(*pointee);</span><br><span class="line">    &#125;</span><br><span class="line">    pointee-&gt;addReference();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="init存在的问题"><a href="#init存在的问题" class="headerlink" title="init存在的问题"></a>init存在的问题</h2><p>当init()函数中发现拷贝构造的rhs处于不可共享状态，它会构建一个新的T型的对象，并且使用T对象的拷贝构造完成了初始化。对于一个String来说，T型对象是StringValue，我们没有对它声明拷贝构造函数，因此编译器选择调用默认版本，只拷贝了StringValue的数据pointer，而没有拷贝所指向的char*字符串。<br>正确的做法是令T含有正确的值拷贝行为(如深拷贝），以StringValue举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        StringValue(<span class="keyword">const</span> StringValue&amp; rhs);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span>::StringValue::StringValue(<span class="keyword">const</span> StringValue&amp; rhs)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, rhs.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>深copy并非唯一选择，我们应该将具体拷贝实现类型写于文档，告知用户。</p>
<h2 id="智能指针的指向对象"><a href="#智能指针的指向对象" class="headerlink" title="智能指针的指向对象"></a>智能指针的指向对象</h2><p>RCPtr<T>假设智能指针永远指向T型对象，但实际上我们知道可以指向T的派生类，为了防止一些奇怪的问题，建议使用虚拷贝构造等手段（More Effective C++ 25）。</p>
<h2 id="智能指针的赋值与析构"><a href="#智能指针的赋值与析构" class="headerlink" title="智能指针的赋值与析构"></a>智能指针的赋值与析构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCPtr</span>&lt;T&gt;&amp; <span class="title">RCPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee != rhs.pointee) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointee) &#123;</span><br><span class="line">            pointee-&gt;removeReference();</span><br><span class="line">        &#125;</span><br><span class="line">        pointee = rhs.pointee;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCPtr</span>&lt;T&gt;:</span>:~RCPtr()&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee)</span><br><span class="line">        pointee-&gt;removeReference();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符"></a>解引用操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">RCPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> pointee; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">RCPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *pointee; &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h1><p>&nbsp;<br>将之前提到的所有东西合在一起，真正的带有引用计数的String对象数据结构如下：<br><img src="http://static.zybuluo.com/zsmj2017/xfk39ev9qbd2xhu4q4slsrpg/image_1cc813plr5sq19f6cqi19mviu3h.png" alt="image_1cc813plr5sq19f6cqi19mviu3h.png-120.6kB"><br>String类有定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RCPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    RCPtr(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    ~RCPtr();</span><br><span class="line">    RCPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;<span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    RCObject();</span><br><span class="line">    RCObject(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~RCObject() = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        StringValue(<span class="keyword">const</span> StringValue&amp; rhs);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span></span>;</span><br><span class="line">        ~StringValue();</span><br><span class="line">    &#125;;</span><br><span class="line">    RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>String class没有声明拷贝构造、赋值运算、析构函数，但这并不是因为操作失误，而是这些函数均可以使用编译器自动生成的版本，真正本质上的上述操作均已在智能指针类及引用计数类中实现。<br>通过完美的封装，我们在没有更改String接口的同时增加了功能。</p>
<hr>
<h1 id="在现存类上增加引用计数"><a href="#在现存类上增加引用计数" class="headerlink" title="在现存类上增加引用计数"></a>在现存类上增加引用计数</h1><p>&nbsp;<br>假设我们有一个不可更改的class Widget（不该更改的原因可能是其位于支持库中），如何给它添加引用计数功能？<br>首先从刚才已实现的思路入手，我们应该会建立一个RCWidget class，内部嵌套有一个struct public继承自RCObject，RCWidget内持有一个智能指针RCPtr指向Count对象：<br><img src="http://static.zybuluo.com/zsmj2017/za7vr0i7hw24a9ie3eba1ppd/image_1cc81soqn1pls1vmttmu3c2ukg4b.png" alt="image_1cc81soqn1pls1vmttmu3c2ukg4b.png-107.6kB"><br>我们当前自然无法修改Widget内部，但我们可以试图构造一个中间层，然后完成这份任务：<img src="http://static.zybuluo.com/zsmj2017/ebw6lpwidbhlsn78bd4c78la/image_1cc81h7851qt1182q2fdffkmci3u.png" alt="image_1cc81h7851qt1182q2fdffkmci3u.png-122.9kB"><br>其中，CountHolder是人为构造的class，其内部有一个指针指向了Widget资源，我们用一个智能指针指向CountHolder。</p>
<h2 id="PCIPtr与CountHolder"><a href="#PCIPtr与CountHolder" class="headerlink" title="PCIPtr与CountHolder"></a>PCIPtr与CountHolder</h2><p>我们可以认为CountHolder是RCIPtr的实现细节，所以将其嵌套在该类中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">RCIPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCIPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    RCIPtr(<span class="keyword">const</span> RCIPtr&amp; rhs);</span><br><span class="line">    ~RCIPtr();</span><br><span class="line">    RCIPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCIPtr&amp; rhs);</span><br><span class="line">    <span class="keyword">const</span> T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;();</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CountHolder</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        ~CountHolder() &#123; <span class="keyword">delete</span> pointee; &#125;</span><br><span class="line">        T *pointee;</span><br><span class="line">    &#125;;</span><br><span class="line">    CountHolder *counter;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeCopy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RCIPtr</span>&lt;T&gt;:</span>:init()&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter-&gt;isShareable() == <span class="literal">false</span>) &#123;</span><br><span class="line">        T *oldValue = counter-&gt;pointee;</span><br><span class="line">        counter = <span class="keyword">new</span> CountHolder;</span><br><span class="line">        counter-&gt;pointee = <span class="keyword">new</span> T(*oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    counter-&gt;addReference();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCIPtr</span>&lt;T&gt;:</span>:RCIPtr(T* realPtr)</span><br><span class="line">:counter(<span class="keyword">new</span> CountHolder)&#123;</span><br><span class="line">    counter-&gt;pointee = realPtr;init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCIPtr</span>&lt;T&gt;:</span>:RCIPtr(<span class="keyword">const</span> RCIPtr&amp; rhs)</span><br><span class="line">:counter(rhs.counter)&#123;</span><br><span class="line">    init(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCIPtr</span>&lt;T&gt;:</span>:~RCIPtr()&#123; </span><br><span class="line">    counter-&gt;removeReference(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RCIPtr</span>&lt;T&gt;&amp; <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> RCIPtr&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter != rhs.counter) &#123;</span><br><span class="line">        counter-&gt;removeReference();</span><br><span class="line">        counter = rhs.counter;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RCIPtr</span>&lt;T&gt;:</span>:makeCopy()&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter-&gt;isShared()) &#123;</span><br><span class="line">        T *oldValue = counter-&gt;pointee;</span><br><span class="line">        counter-&gt;removeReference();</span><br><span class="line">        counter = <span class="keyword">new</span> CountHolder;</span><br><span class="line">        counter-&gt;pointee = <span class="keyword">new</span> T(*oldValue);</span><br><span class="line">        counter-&gt;addReference();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>* <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> counter-&gt;pointee; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">non</span>-<span class="title">constT</span>* <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">    makeCopy(); </span><br><span class="line">    <span class="keyword">return</span> counter-&gt;pointee; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>&amp; <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(counter-&gt;pointee); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">RCIPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>*()&#123; </span><br><span class="line">    makeCopy(); </span><br><span class="line">    <span class="keyword">return</span> *(counter-&gt;pointee); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="RCwidget"><a href="#RCwidget" class="headerlink" title="RCwidget"></a>RCwidget</h2><p>有了RCIPtr，RCWidget很容易实现，因为RCWidget的每个函数都是将操作RCIPtr以完成对Widget对象的操作。若有Widget class有实例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    ~Widget();</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doThis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">showThat</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>那么RCWidget将被定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCWidget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RCWidget(<span class="keyword">int</span> <span class="built_in">size</span>): value(<span class="keyword">new</span> Widget(<span class="built_in">size</span>)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doThis</span><span class="params">()</span> </span>&#123; value-&gt;doThis(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">showThat</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value-&gt;showThat(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RCIPtr&lt;Widget&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>需要注意的是，RcWidget没有拷贝，析构，赋值函数，因为RCIPtr将自动地执行这些行为。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/28/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" itemprop="url">28.智能指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T19:56:00+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>智能指针在多个领域都具备使用价值，例如资源管理与重复代码任务的自动化。</p>
<hr>
<h1 id="智能指针相对于raw-pointer的优点"><a href="#智能指针相对于raw-pointer的优点" class="headerlink" title="智能指针相对于raw pointer的优点"></a>智能指针相对于raw pointer的优点</h1><p>&nbsp;</p>
<ol>
<li>构造、析构<br>智能指针将完美初始化，并且智能指针的析构会负责对象的释放。</li>
<li>拷贝与赋值操作<br>可以自由地深拷贝，或者指针拷贝，又或者禁止这些行为。</li>
<li>解引用<br>自行决定解引用功能，比如用它来实现lazy-fetching.</li>
</ol>
<hr>
<h1 id="智能指针的实现雏形"><a href="#智能指针的实现雏形" class="headerlink" title="智能指针的实现雏形"></a>智能指针的实现雏形</h1><p>&nbsp;<br>智能指针从模版中生成，因为要与内置指针一致，所以它们是strong-typed:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SmartPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&amp; rhs);</span><br><span class="line">    ~SmartPtr();</span><br><span class="line">    SmartPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&amp; rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;<span class="comment">//解引用</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>; <span class="comment">//解引用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不允许copy与赋值，那就应该把拷贝构造与operator=设为private。解引用对象的两个操作符设为const，因为解引用并不能改变对象本身。</p>
<hr>
<h1 id="用户如何使用智能指针"><a href="#用户如何使用智能指针" class="headerlink" title="用户如何使用智能指针"></a>用户如何使用智能指针</h1><p>&nbsp;<br>假设存在一个分布式系统（对象一些在本地一些在远程），采用不同的方法分别处理本地对象和远程对象相当麻烦，我们试图让所有东西看起来在一个地方：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DBPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DBPtr(T *realPtr = <span class="literal">nullptr</span>);</span><br><span class="line">    DBPtr(DataBaseID id);<span class="comment">//指向DB id对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&#123;</span><span class="comment">// 数据库元组类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayEditDialog</span><span class="params">()</span></span>;<span class="comment">//显示一个图形对话框，允许用户编辑</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//返回合法性检验</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LogEntry</span> &#123;</span><span class="comment">//修改T对象时完成日志登记</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LogEntry(<span class="keyword">const</span> T&amp; objectToBeModified);</span><br><span class="line">    ~LogEntry();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">editTuple</span><span class="params">(DBPtr&lt;Tuple&gt;&amp; pt)</span></span>&#123;</span><br><span class="line">    <span class="function">LogEntry&lt;Tuple&gt; <span class="title">entry</span><span class="params">(*pt)</span></span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;<span class="comment">//重复显示对话框，直到数值合法</span></span><br><span class="line">        pt-&gt;displayEditDialog();</span><br><span class="line">    &#125; <span class="keyword">while</span> (pt-&gt;<span class="built_in">isValid</span>() == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>被编辑的元祖既可以位于本地也可以位于远程，在编写程序时我们感受不到他们的区别。Logentry的构造函数负责了启动日志记录，析构函数负责关闭记录。这在含有异常时能让程序更加robust，并且建立对象本身也比调用记录函数要直观。</p>
<p>如我们所见，使用智能指针与使用raw pointer区别不大，在了解了这一特性之后，我们开始编写智能指针。</p>
<hr>
<h1 id="构造、赋值、析构"><a href="#构造、赋值、析构" class="headerlink" title="构造、赋值、析构"></a>构造、赋值、析构</h1><p>&nbsp;<br>一般来说构造较为简单：找到需要指向的对象，令raw pointer指向它，如果没有则将raw pointer指向nullptr或者抛出一个异常。<br>拷贝、赋值、析构由于对象所有权的问题，所以导致略微复杂。我们默认智能指针被释放时需要析构指向的对象，当然，这里的对象说的是动态分配得到的对象。<br>以STL中的auto_ptr为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">auto_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(T *ptr = <span class="number">0</span>): pointee(ptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> pointee; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当auto_ptr被拷贝或被赋值时，会发生什么情况？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;TreeNode&gt; <span class="title">ptn1</span><span class="params">(<span class="keyword">new</span> TreeNode)</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;TreeNode&gt; ptn2 = ptn1;<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;TreeNode&gt; ptn3;</span><br><span class="line">ptn3 = ptn2;<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><br>如果我们只拷贝内部的raw pointer，则会有两个智能指针指向一个对象，如果两个智能指针依次释放，我们会试图析构一个已经被析构的东西，结果未定义。<br>另一种方法是new一个新的对象，但这本身带有性能损耗，更何况我们也不知道建立什么对象，万一是派生类而非基类呢。<br>STL定义：“当auto_ptr被拷贝和赋值时，对象所有权随之传递”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">auto_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs);</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto_ptr</span>&lt;T&gt;:</span>:<span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">    pointee = rhs.pointee;</span><br><span class="line">    rhs.pointee = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto_ptr</span>&lt;T&gt;&amp; <span class="title">auto_ptr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)<span class="comment">//处理自赋值,此处内容建议翻阅Effective C++ 12</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pointee;</span><br><span class="line">    pointee = rhs.pointee;</span><br><span class="line">    rhs.pointee = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般来说，拷贝构造和赋值运算符的形参都是const，但是auto_ptr的就不是，原因在于rhs被改变了。</p>
<p>最后，其析构函数如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">SmartPtr</span>&lt;T&gt;:</span>:~SmartPtr()&#123;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">this</span> owns *pointee) &#123;</span><br><span class="line">        <span class="keyword">delete</span> pointee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不同的智能指针析构函数各有不同，比如说shared_ptr就需要检查引用计数。</p>
<hr>
<h1 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符"></a>解引用操作符</h1><h2 id="operator"><a href="#operator" class="headerlink" title="operator*"></a>operator*</h2><p>operator*返回所指向的对象，理论上来说这好像很简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">SmartPtr</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">    perform <span class="string">"smart pointer"</span> processing;</span><br><span class="line">    <span class="keyword">return</span> *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先，我们必须初始化指针或者让raw pointer合法(例如Lazy evaluation中构建对象）。<br>其次，我们必须返回引用而非对象，因为在引入继承体系后，如果返回对象会导致slicing，而且智能指针也因此丧失了虚函数的功能，此外返回引用效率也高。</p>
<h2 id="operator-gt"><a href="#operator-gt" class="headerlink" title="operator-&gt;"></a>operator-&gt;</h2><p>operator-&gt;与operator*差不多，我们先回头看用户使用实例中调用-&gt;的语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-&gt;displayEditDialog();</span><br></pre></td></tr></table></figure><br>该语句被编译器解释为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pt.<span class="keyword">operator</span>-&gt;())-&gt;displayEditDialog();</span><br></pre></td></tr></table></figure><br>这意味着不论operator-&gt;返回什么，它必须在返回结果上使用-&gt;，那也就是说operator-&gt;仅能返回一个指针或类指针对象，一般来说，我们把一个raw pointer作为其返回值。</p>
<hr>
<h1 id="测试智能指针是否为nullptr"><a href="#测试智能指针是否为nullptr" class="headerlink" title="测试智能指针是否为nullptr"></a>测试智能指针是否为nullptr</h1><p>&nbsp;<br>为了保证智能指针的行为与raw pointer完全一致，比如保证下述表达式能够编译：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">if</span> (ptn)</span><br><span class="line"><span class="keyword">if</span> (!ptn)</span><br></pre></td></tr></table></figure><br>为了谨慎和保险，我们在智能指针类中重载operator！，当且仅当其为空指针时返回true:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:...</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!() <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="把智能指针转为raw-pointer"><a href="#把智能指针转为raw-pointer" class="headerlink" title="把智能指针转为raw pointer"></a>把智能指针转为raw pointer</h1><p>&nbsp;<br>有时我们需要作出类似的转换，因为有些接口只接受raw pointer，可能你会写出&amp;*sp之类的东西，但这无疑太丑了。所以某些人更倾向于隐式类型转换符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> T*() &#123; <span class="keyword">return</span> pointee; &#125;</span><br></pre></td></tr></table></figure><br>这种设计看起来很好，但实际上完全不行，如果直接可以让用户操纵raw pointer，那我们设计智能指针的意义何在？并且引用计数等功能也遭到了破坏。<br>此外，这种隐式转换编译器同一时间只能使用一次，比如说智能指针和raw pointer之间存在隐式转换，raw pointer又和A之间存在转换，智能指针无法隐式转为A，也就是说其行为与raw pointer不符。<br>这种写法还会诱导用户写下delete sp这种天理难容的东西，要知道智能指针是一个对象…<br>编译器不会报错，但你的对象会被删除两次（一次是delete，一次是sp被析构）<br>总之，智能指针应该拒绝提供隐式转换操作符，最好的操作就是提供显示接口，例如get。</p>
<hr>
<h1 id="智能指针与基于继承的类型转换（Effective-C-46）"><a href="#智能指针与基于继承的类型转换（Effective-C-46）" class="headerlink" title="智能指针与基于继承的类型转换（Effective C++ 46）"></a>智能指针与基于继承的类型转换（Effective C++ 46）</h1><p>&nbsp;<br>下图是模型化音乐商店商品的一个继承体系，其大致实现如下：<img src="http://static.zybuluo.com/zsmj2017/wuswa468p8neq5lz5881824f/image_1cc655eos1cq45b81l021alv1kj49.png" alt="image_1cc655eos1cq45b81l021alv1kj49.png-39.2kB"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicProduct</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MusicProduct(<span class="keyword">const</span> <span class="built_in">string</span>&amp; title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cassette</span>:</span> <span class="keyword">public</span> MusicProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cassette(<span class="keyword">const</span> <span class="built_in">string</span>&amp; title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CD</span>:</span> <span class="keyword">public</span> MusicProduct &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CD(<span class="keyword">const</span> <span class="built_in">string</span>&amp; title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>更进一步地假设存在一个函数，它对于任何一个Musicproduct对象都会显示标题并播放指定次数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> MusicProduct* pmp, <span class="keyword">int</span> numTimes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numTimes; ++i) &#123;</span><br><span class="line">        pmp-&gt;displayTitle();</span><br><span class="line">        pmp-&gt;play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然该函数本身具备多态性，但如果我们使用智能指针，则无法具备多态性，原因在于sp派生出的这几个class根本不具备任何相关性。</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>我们想到的第一个解决方案是令每一个sp class具备隐式类型转换符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&lt;Cassette&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;()&#123;<span class="keyword">return</span> SmartPtr&lt;MusicProduct&gt;(pointee);&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cassette *pointee;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&lt;CD&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;()&#123;<span class="keyword">return</span> SmartPtr&lt;MusicProduct&gt;(pointee);&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CD *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此方法缺点十分明显：</p>
<ol>
<li>对于每一个sp class都需要加入大量的隐式类型转换符，这对template是一大讽刺。</li>
<li>如果当前对象位于继承体系的底层，那你必须为每一个直接或者间接继承的基类提供隐式类型转换，因为编译器无法执行多次转换。</li>
</ol>
<h2 id="非虚成员函数模板"><a href="#非虚成员函数模板" class="headerlink" title="非虚成员函数模板"></a>非虚成员函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SmartPtr(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">newType</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">operator</span> <span class="title">SmartPtr</span>&lt;newType&gt;()&#123;</span></span><br><span class="line">        <span class="keyword">return</span> SmartPtr&lt;newType&gt;(pointee);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其具体工作原理如下：<br>假设编译器持有一个指向T对象的智能指针，它需要把该指针转换成指向T的基类的智能指针.<br>编译器检查了一番SmartPtr&lt;T&gt;,但并没有找到明确的类型转换符，然后检查有没有一个成员函数模板，通过该模板实例化一个对象完成类型转换。最终它构建了这么一个对象，完成了隐式转换。<br>结合具体实例而言，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;MusicProduct&gt;&amp; pmp,<span class="keyword">int</span> howMany)</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;Cassette&gt; <span class="title">funMusic</span><span class="params">(<span class="keyword">new</span> Cassette(<span class="string">"Alapalooza"</span>))</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;CD&gt; <span class="title">nightmareMusic</span><span class="params">(<span class="keyword">new</span> CD(<span class="string">"Disco Hits of the 70s"</span>))</span></span>;</span><br><span class="line">displayAndPlay(funMusic, <span class="number">10</span>);</span><br><span class="line">displayAndPlay(nightmareMusic, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>函数在调用时本质上使用了Smart&lt;music&gt;的构造函数，将新的对象作为参数传递给了函数，最终完成多态。</p>
<p>不要觉得这种方法只能用于继承体系中的相互转换，事实上，这是一种通用的、安全的智能指针转换操作，只要你能够把T*隐式地转为NT*，那我们就一定能安全直接地转换它们的智能指针。假设我们修改了继承体系：<br><img src="http://static.zybuluo.com/zsmj2017/n7npu89nb9veidxhtnv1wnkn/image_1cc661nbnnb27o7m5i5rj17egm.png" alt="image_1cc661nbnnb27o7m5i5rj17egm.png-53.5kB"><br>并有如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtr</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;MusicProduct&gt;&amp; pmp,<span class="keyword">int</span> howMany)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;Cassette&gt;&amp; pc,<span class="keyword">int</span> howMany)</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;CasSingle&gt; <span class="title">dumbMusic</span><span class="params">(<span class="keyword">new</span> CasSingle(<span class="string">"Achy Breaky Heart"</span>))</span></span>;</span><br><span class="line">displayAndPlay(dumbMusic, <span class="number">1</span>);<span class="comment">//error!</span></span><br></pre></td></tr></table></figure><br>这里错误的原因很简单，二义性，所有类型的转换符具有同等地位，编译器无法知道该使用哪一个（这种行为与内置指针不符，内置指针会直接匹配继承体系最接近的重载）。</p>
<hr>
<h1 id="智能指针与const"><a href="#智能指针与const" class="headerlink" title="智能指针与const"></a>智能指针与const</h1><p>&nbsp;<br>对于raw pointer，我们的const属性分为顶层和底层，详见C++ Primer。<br>我们希望智能指针也拥有const属性，但实际上好像不太行，我们可以令智能指针自身const，无法让指向的对象也const.有一个简单的补救方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;<span class="keyword">const</span> Sth&gt;;</span><br></pre></td></tr></table></figure><br>但该类型的对象与SmartPtr&lt;Sth&gt;不具备任何相关性，所以需要再次使用上文所提到的成员模板。需要注意的是，const的类型转换是单向的，就像public继承一样，non-const可以做const的事，反之则不行.既然如此，我们不如把它设为继承关系：<img src="http://static.zybuluo.com/zsmj2017/8v5j11i9bdlqapt9gfgptqmk/image_1cc66ffmd52a1u2f15vkhp81b7u1j.png" alt="image_1cc66ffmd52a1u2f15vkhp81b7u1j.png-66.2kB"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtrToConst</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> T* constPointee;</span><br><span class="line">        T* pointee;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SmartPtr</span>:</span><span class="keyword">public</span> SmartPtrToConst&lt;T&gt; &#123;</span><br><span class="line">    ...<span class="comment">//没有数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>使用这种设计方法，指向non-const-T对象的智能指针包含一个指向const-T的raw pointer。union的特点是节约空间，但我们需要手动约束两个类各自使用专属指针。其使用大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; pCD = <span class="keyword">new</span> CD(<span class="string">"Famous Movie Themes"</span>);</span><br><span class="line">SmartPtrToConst&lt;CD&gt; pConstCD = pCD;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/28/%E8%A6%81%E6%B1%82%E6%88%96%E7%A6%81%E6%AD%A2%E5%9C%A8%E5%A0%86%E4%B8%AD%E4%BA%A7%E7%94%9F%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/%E8%A6%81%E6%B1%82%E6%88%96%E7%A6%81%E6%AD%A2%E5%9C%A8%E5%A0%86%E4%B8%AD%E4%BA%A7%E7%94%9F%E5%AF%B9%E8%B1%A1/" itemprop="url">27.要求或禁止在堆中产生对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T16:56:00+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>有时候我们希望可以自由的构造与析构对象，这要求它们存在于heap中。又有时我们希望对象不会产生资源泄漏的问题，那我们必须保证某个类不会在heap中构造对象。</p>
<hr>
<h1 id="仅允许在heap中建立对象"><a href="#仅允许在heap中建立对象" class="headerlink" title="仅允许在heap中建立对象"></a>仅允许在heap中建立对象</h1><p>&nbsp;<br>显然，为了达成这一目的，我们必须找到一种方法，禁止所有new之外的能够构造对象的手段。<br>non-heap object在定义它的地方被自动构造，生存时间结束后自动释放，所以只需要禁止隐式的构造和析构函数就可以实现这种限制。<br>最直接的手法就是把构造函数和析构函数声明为private，但这样的副作用太大，我们只需要令其中一个声明为private即可。</p>
<ol>
<li>构造函数为public，析构函数为private<br>这会导致对象依旧可以构造在stack中，只是在析构时会报错。</li>
<li>构造函数为private，析构函数为public<br>一般来说，一个class会存在多个构造函数，因此必须将所有构造函数都声明为private。</li>
</ol>
<p>通过限制访问一个类的析构或构造函数来阻止建立非堆对象固然很好，但这种方法也同时禁止了继承与containment.但我们有两种技术来克服这些缺陷：</p>
<ol>
<li>对于继承而言，可以把构造或析构函数声明为protected。</li>
<li>对于包含来说，可以把包含对象改为包含指向对象的指针。（pimpl）</li>
</ol>
<p>以下给出具体实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//derived</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span> ... &#125;;<span class="comment">//protected:~UPNumber</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonNegativeUPNumber</span>:</span><span class="keyword">public</span> UPNumber &#123; ... &#125;;</span><br><span class="line"><span class="comment">//containment</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Asset(<span class="keyword">int</span> initValue);</span><br><span class="line">    ~Asset();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber *value;<span class="comment">// RAII is better</span></span><br><span class="line">&#125;;</span><br><span class="line">Asset::Asset(<span class="keyword">int</span> initValue):value(<span class="keyword">new</span> UPNumber(initValue))&#123; ... &#125;</span><br><span class="line">Asset::~Asset()&#123;value-&gt;destroy();&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="判断一个对象是否在堆中"><a href="#判断一个对象是否在堆中" class="headerlink" title="判断一个对象是否在堆中"></a>判断一个对象是否在堆中</h1><p>&nbsp;<br>如果采用上述方法，当我们写下如下表达式时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NonNegativeUPNumber n;<span class="comment">//n处于stack中</span></span><br></pre></td></tr></table></figure><br>n的base部分是否处于stack中却是根据具体实现来确定的，如果现在我们需要作出强制性的保证：一个对象，哪怕是作为派生类的基类部分，也必须出现在堆中。该如何执行这种约束？</p>
<p>没有特别简单的办法来完成这个功能，因为构造函数在调用不可能检测当前环境。简而言之，UPNumber的构造函数无法区分如下两种构造环境：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NonNegativeUPNumber *n1 = <span class="keyword">new</span> NonNegativeUPNumber;<span class="comment">//in heap</span></span><br><span class="line">NonNegativeUPNumber n2;<span class="comment">//in stack</span></span><br></pre></td></tr></table></figure></p>
<h2 id="操作符修改"><a href="#操作符修改" class="headerlink" title="操作符修改"></a>操作符修改</h2><p>也许你可能会试图在new操作符上玩儿一些小花样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HeapConstraintViolation</span> &#123;</span>&#125;;<span class="comment">//如果建立一个非堆对象，抛出一个异常</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    UPNumber();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> onTheHeap; <span class="comment">//指示当前是否在堆中</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> UPNumber::onTheHeap = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *UPNumber::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    onTheHeap = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line">UPNumber::UPNumber()&#123;</span><br><span class="line">    <span class="keyword">if</span> (!onTheHeap) &#123;</span><br><span class="line">        <span class="keyword">throw</span> HeapConstraintViolation();</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//构造</span></span><br><span class="line">    onTheHeap = <span class="literal">false</span>; <span class="comment">// 为下一个对象清除标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们在heap中调用时势必会使用new，因此建立判断位，确保每一次构建时都完美运行。<br>这个方法很好，但不能应用于实际中。举例而言：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPNumber *numberArray = <span class="keyword">new</span> UPNumber[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><br>new[]只申请了一次内存，然后调用了100次构造函数，z这和我们预期的根本不一致。<br>就算不考虑operator[]，我们也未必能够取得成功:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPNumber *pn = <span class="keyword">new</span> UPNumber(*<span class="keyword">new</span> UPNumber);</span><br></pre></td></tr></table></figure><br>我们在堆中建立两个UPNumber，让pn先指向一个对象，这个对象利用另一个对象的值进行初始化。就算不用顾忌内存泄漏，编译器的行为也未必会按照预期执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">预期行为：</span><br><span class="line">调用第一个对象的 operator new</span><br><span class="line">调用第一个对象的构造函数</span><br><span class="line">调用第二个对象的 operator new</span><br><span class="line">调用第二个对象的构造函数</span><br><span class="line"></span><br><span class="line">可能发生的实际行为：</span><br><span class="line">调用第一个对象的 operator new</span><br><span class="line">调用第二个对象的 operator new</span><br><span class="line">调用第一个对象的构造函数</span><br><span class="line">调用第二个对象的构造函数</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="通过地址判断对象处于何处"><a href="#通过地址判断对象处于何处" class="headerlink" title="通过地址判断对象处于何处"></a>通过地址判断对象处于何处</h2><p>在很多系统中，程序的地址空间被作为线性地址管理，程序的栈自顶而下，堆则自底而上，如下图所示：<br><img src="http://static.zybuluo.com/zsmj2017/rqgn1ejuqze9xekgoav3u8wj/image_1cc5qj8cd7eqsckjee1oe2q9g9.png" alt="image_1cc5qj8cd7eqsckjee1oe2q9g9.png-66kB"><br>因此我们试图使用这么一个函数来判断某个特定的地址是否在堆中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onHeap</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *address)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> onTheStack;</span><br><span class="line">    <span class="keyword">return</span> address &lt; &amp;onTheStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该函数的原理很简单：新建的局部变量必然是栈的最底层，如果某个地址比他还低，那必然是存在于heap中。但是，谁告诉你内存空间只有栈和堆了？static变量也会有特定的位置，一般情况下它们会出现在heap的下面，如下所示：<img src="http://static.zybuluo.com/zsmj2017/vbqdc97zjsdzxsd7p53ww4uv/image_1cc5qp2o01jht12ih1jcbue71tge16.png" alt="image_1cc5qp2o01jht12ih1jcbue71tge16.png-88.7kB"><br>那么该函数不能工作的原因就很清楚了：无法判断堆对象与静态对象。</p>
<hr>
<h2 id="安全delete"><a href="#安全delete" class="headerlink" title="安全delete"></a>安全delete</h2><p>令人悲伤的是我们无法找到一个通用方法来判断对象到底在不在堆上，但我们迫切地需要了解某个对象在不在heap中的初衷很简单：我们需要判断该对象能不能被安全delete。<br>“能否安全删除一个指针”与“一个指针是否指向堆中的事物”并不相同，因为不是所有heap中的事物都能被安全delete：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Asset *pa = <span class="keyword">new</span> Asset;</span><br><span class="line"><span class="keyword">delete</span> pa-&gt;value;<span class="comment">//error</span></span><br></pre></td></tr></table></figure><br>报错的原因在于value并非是一个由new返回的指针，而是一个由new返回的指针初始化的指针。<br>但判断“能否删除一个指针”比判断“一个指针指向的对象是否在堆上”容易，因为对于前者我们只需要每一次new的时候记录一下返回的地址（以一个vector或list保存之），每一次delete之前判断一下地址在不在记录，在的话就把地址从记录中移除。这一系列操作只需要重载一下operator new与delete就好了。<br>但是，在实际使用中，这种方法也不是特别受欢迎，因为：</p>
<ol>
<li>重载后的operator new与operator delete必须在全局作用域，这会引发一些不兼容</li>
<li>不是所有客户都需要这项功能，记录地址未必需要</li>
<li>记录地址未必不出错，比如说多继承或者继承自虚基类的类往往有多个地址。</li>
</ol>
<hr>
<h3 id="mixin-class"><a href="#mixin-class" class="headerlink" title="mixin class"></a>mixin class</h3><p>我们希望存在某些函数提供以上功能，但不污染全局命名空间，没有额外开销，这时mixin class出场了(“mix in” Effective C++ 7中的uncopyable也是一个mixin class）。具体来说，mixin是一个抽象类，其功能可以与其派生类的功能相融合，以上述要求为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapTracked</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MissingAddress</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~HeapTracked() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOnHeap</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">void</span>* RawAddress;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">list</span>&lt;RawAddress&gt; addresses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;RawAddress&gt; HeapTracked::addresses;</span><br><span class="line">HeapTracked::~HeapTracked() &#123;&#125;<span class="comment">//析构函数必须被定义 即使是纯虚函数 详见Effective C++ 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* HeapTracked::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *memPtr = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">    addresses.push_front(memPtr);<span class="comment">//把地址放到list前端</span></span><br><span class="line">    <span class="keyword">return</span> memPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> HeapTracked::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), ptr);</span><br><span class="line">    <span class="keyword">if</span> (it != addresses.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        addresses.erase(it);</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> MissingAddress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HeapTracked::isOnHeap</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *rawAddress = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(<span class="keyword">this</span>);<span class="comment">//动态转换</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), rawAddress);</span><br><span class="line">    <span class="keyword">return</span> it != addresses.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在判定函数中使用了动态转换，这是为了解决我们之前提出的第三个问题，将指针永远指向当前对象起始地址。<br>mixin class使用范式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span>:</span> <span class="keyword">public</span> HeapTracked &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inventoryAsset</span><span class="params">(<span class="keyword">const</span> Asset *ap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ap-&gt;isOnHeap()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>遗憾的是这种mixin不能用于内置类型，因为内置类型无法继承自某类。但我们的本意就是为了安全地delete某对象，内置类型无法delete。</p>
<hr>
<h1 id="禁止建立堆对象"><a href="#禁止建立堆对象" class="headerlink" title="禁止建立堆对象"></a>禁止建立堆对象</h1><p>&nbsp;<br>对象的建立无非三种情况：</p>
<ol>
<li>直接实例化</li>
<li>对象作为派生类的基类被实例化</li>
<li>对象被嵌入到其他对象内</li>
</ol>
<h2 id="直接实例化"><a href="#直接实例化" class="headerlink" title="直接实例化"></a>直接实例化</h2><p>禁止直接实例化很简单，把operator new和delete设为private，如果你需要同时禁止堆对象数组，也可以把operator new[]与operator delete[]设为private:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">UPNumber *p = <span class="keyword">new</span> UPNumber;<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<h2 id="派生类基类"><a href="#派生类基类" class="headerlink" title="派生类基类"></a>派生类基类</h2><p>把operator new声明为private会导致派生类对象的基类无法被实例化。因为operator new与operator delete是自动继承的，除非你手动声明派生类中的它们为public，否则它们默认为基类中的private版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonNegativeUPNumber</span>:</span><span class="keyword">public</span> UPNumber &#123;...&#125;;<span class="comment">//默认operator new为private</span></span><br><span class="line">NonNegativeUPNumber *p = <span class="keyword">new</span> NonNegativeUPNumber;<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<h2 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h2><p>operator new是private这一特性，不会对包含产生任何影响：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Asset(<span class="keyword">int</span> initValue);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber value;</span><br><span class="line">&#125;;</span><br><span class="line">Asset *pa = <span class="keyword">new</span> Asset(<span class="number">100</span>);<span class="comment">//调用Asset::operator new或::operator new</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xander.wiki/2018/04/28/%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AA%E7%B1%BB%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xander.liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xander's Wiki">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AA%E7%B1%BB%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F/" itemprop="url">26.限制某个类所能产生的对象数量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T10:03:00+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/More-Effective-C/" itemprop="url" rel="index">
                    <span itemprop="name">More Effective C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;<br>本节内容的极端情况即为禁止建立对象与单例模式。</p>
<hr>
<h1 id="禁止对象实例化"><a href="#禁止对象实例化" class="headerlink" title="禁止对象实例化"></a>禁止对象实例化</h1><p>&nbsp;<br>如果我们需要阻止建立某个类的对象，应该把它的构造函数设为private:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CantBeInstantiated</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CantBeInstantiated();</span><br><span class="line">    CantBeInstantiated(<span class="keyword">const</span> CantBeInstantiated&amp;);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>&nbsp;<br>假设我们现在只允许生成一个打印机对象，我们应当把这个对象封装置入某个函数，允许所有人访问，但只有一个对象存在：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintJob</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Printer p; <span class="comment">// 单个打印机对象</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个设计有三部分：</p>
<ol>
<li>printer无法构造</li>
<li>全局函数thePrinter被设为friend，因此可以调用private构造函数。</li>
<li>thePrinter包含一个静态Printer对象，这意味着只有一个对象被建立。我们只能通过thePrinter函数来使用这个对象。</li>
</ol>
<hr>
<h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>有人会认为thePrinter没必要污染全局命名空间，为此解决方法是把thePrinter声明为printer内部的静态函数，那顺便去除了friend属性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Printer&amp; <span class="title">Printer::thePrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Printer p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>就是调用函数的时候麻烦了一些：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Printer::thePrinter().reset();</span><br><span class="line">Printer::thePrinter().submitJob(<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="新建命名空间"><a href="#新建命名空间" class="headerlink" title="新建命名空间"></a>新建命名空间</h2><p>另一种做法是将class与thePrinter移出全局域，放入专属namespace，防止命名冲突：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> PrintingStuff&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob&amp; job)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Printer p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只不过这样一来调用每一次调用都必须提及命名空间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintingStuff::thePrinter().reset();</span><br><span class="line">PrintingStuff::thePrinter().submitJob(<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure><br>又或者使用using：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> PrintingStuff::thePrinter; </span><br><span class="line">thePrinter().reset();</span><br><span class="line">thePrinter().submitJob(<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="单例模式实现细节"><a href="#单例模式实现细节" class="headerlink" title="单例模式实现细节"></a>单例模式实现细节</h2><p>thePrinter的实现有两个微妙之处：</p>
<ol>
<li>p是函数中的静态对象而非类中的静态对象<br>如果是类中的静态对象，则该对象总是会被构造和析构。（即使你根本没有试图去使用）函数中的则不同，只有第一次调用函数时才会被构造。当然，我们也为此付出了代价：每一次都必须检查是否需要建立对象。<br>如果对象是类中的静态成员，它的初始化时间难以确定，我们清楚的了解函数的静态对象初始化于函数的第一次调用，而类则说不准。</li>
<li>关注内联与函数内静态对象的关系<br>我们看得出thePrinter的函数体非常简短，很适合内联，但我们不能内联它。因为对于非成员函数，内联会导致复制obj中的代码，简单来说，就连静态对象也被复制了。所以不要<strong>内联包含局部静态数据的非成员对象。</strong></li>
</ol>
<hr>
<h1 id="多例模式-限制数目）"><a href="#多例模式-限制数目）" class="headerlink" title="多例模式(限制数目）"></a>多例模式(限制数目）</h1><p>&nbsp;<br>一般来说，限制对象数目的核心思想在于：实时跟踪当前已生成的对象数目，如果超出则抛出异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span>&#123;</span>&#125;;<span class="comment">//异常类</span></span><br><span class="line">    Printer();</span><br><span class="line">    ~Printer();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);<span class="comment">//禁止拷贝</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line">Printer::Printer()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> TooManyObjects();</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//执行构造</span></span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line">Printer::~Printer()&#123;</span><br><span class="line">    ...<span class="comment">//执行析构;</span></span><br><span class="line">    --numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种方法相当直观，就是设计起来存在些许小小的问题。</p>
<hr>
<h2 id="建立对象的环境"><a href="#建立对象的环境" class="headerlink" title="建立对象的环境"></a>建立对象的环境</h2><p>假设我们有一个彩色打印机，继承自printer：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPrinter</span>:</span> <span class="keyword">public</span> Printer &#123;...&#125;;</span><br><span class="line">Printer p;</span><br><span class="line">ColorPrinter cp;</span><br></pre></td></tr></table></figure><br>上述定义产生了两个Printer对象,于是，在构造cp的基类部分时抛出了异常（More Effective C++ 33提出设计时避免非尾端类为具象类）。<br>如果有其他对象包含Printer对象，也会有同样的问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPFMachine</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer p;<span class="comment">//有打印能力</span></span><br><span class="line">    FaxMachine f;<span class="comment">//有传真能力</span></span><br><span class="line">    CopyMachine c;<span class="comment">//有复印能力</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">CPFMachine m1;<span class="comment">//运行正常</span></span><br><span class="line">CPFMachine m2;<span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure><br>这些问题的根源在于Pointer对象可以在3种不同状态下生存：</p>
<ol>
<li>仅有自身</li>
<li>作为派生对象的base成分</li>
<li>内嵌于较大对象</li>
</ol>
<p>这直接导致了我们心目中的“目标个数”与编译器看到的目标个数不一致。</p>
<h3 id="private构造函数"><a href="#private构造函数" class="headerlink" title="private构造函数"></a>private构造函数</h3><p>通常情况下我们只对状态1感兴趣，那把构造函数设为private可以很有效地满足我们。<strong>带有private构造函数的类无法作为基类，也无法内嵌到其他对象中。</strong><br>private构造函数是一种阻止产生派生类的好手段，具体来说，假如你有一个类FSA（finite state automata），我们允许它产生多个对象，但禁止从它派生出新类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FSA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FSA * <span class="title">makeFSA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FSA * <span class="title">makeFSA</span><span class="params">(<span class="keyword">const</span> FSA&amp; rhs)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FSA();</span><br><span class="line">    FSA(<span class="keyword">const</span> FSA&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FSA* <span class="title">FSA::makeFSA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FSA(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FSA* <span class="title">FSA::makeFSA</span><span class="params">(<span class="keyword">const</span> FSA&amp; rhs)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FSA(rhs); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不同于thePrinter函数总是返回一个对象的引用（引用的对象是固定的），每个 makeFSA的伪构造函数则是返回一个指向对象的指针，也就是说允许建立的 FSA 对象数量没有限制。<br>为了防止资源泄漏，最佳方案自然是RAII：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;FSA&gt; <span class="title">pfsa1</span><span class="params">(FSA::makeFSA())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;FSA&gt; <span class="title">pfsa2</span><span class="params">(FSA::makeFSA(*pfsa1))</span></span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="允许对象自由生灭"><a href="#允许对象自由生灭" class="headerlink" title="允许对象自由生灭"></a>允许对象自由生灭</h2><p>在之前的设计手法中，首次我们调用thePrinter时，对象被构造，但我们无法控制对象的销毁，也就是说无法达成这样的功能：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">建立Printer对象 p1;</span><br><span class="line">使用p1;</span><br><span class="line">释放p1;</span><br><span class="line">建立Printer对象 p2;</span><br><span class="line">使用p2;</span><br><span class="line">释放p2;</span><br></pre></td></tr></table></figure></p>
<p>解决方法就是把对象计数和伪构造函数合并：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    ~Printer();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line">Printer::Printer()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> TooManyObjects();</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//执行构造</span></span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line">Printer::~Printer()&#123;</span><br><span class="line">    ...<span class="comment">//执行析构;</span></span><br><span class="line">    --numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了用户必须调用伪构造函数之外，这一切使用起来就如同其他类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Printer p1;<span class="comment">//error 构造函数为private</span></span><br><span class="line">Printer *p2 =Printer::makePrinter();</span><br><span class="line">Printer p3 = *p2; <span class="comment">//error 禁止拷贝</span></span><br><span class="line">p2-&gt;performSelfTest();</span><br><span class="line">p2-&gt;reset();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p2;<span class="comment">//避免资源泄漏</span></span><br></pre></td></tr></table></figure><br>如果我们需要制定最多生成N个，那只要在class中定义一个static const maxsize=N就ok：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer&amp; rhs)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;<span class="comment">//声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxObjects = <span class="number">10</span>;<span class="comment">//内置static类型可以直接在class中声明时定义</span></span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;<span class="comment">//在类外定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Printer::maxObjects;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="建立具有计数功能的基类"><a href="#建立具有计数功能的基类" class="headerlink" title="建立具有计数功能的基类"></a>建立具有计数功能的基类</h2><p>如果我们需要大量这种限制产出对象数量的class，难道我们要一遍一遍地重复编写？当然不是。<br>理想做法是编写一个具有实例计数功能的基类，然后让产出受限的类继承该类。我们使用一种方法封装计数功能，这种做法不但封装维护实例计数器的函数，也封装实例计数器本身。<br>下面给出该类的具体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Counted</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span>&#123;</span>&#125;;<span class="comment">//异常类</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">objectCount</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> numObjects;&#125;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//仅作为基类使用</span></span><br><span class="line">    Counted();</span><br><span class="line">    Counted(<span class="keyword">const</span> Counted&amp; rhs);</span><br><span class="line">    ~Counted() &#123;--numObjects;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> numObjects;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxObjects;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;<span class="comment">//避免代码重复</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Counted</span>&lt;BeingCounted&gt;:</span>:Counted()&#123;</span><br><span class="line">    init(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Counted</span>&lt;BeingCounted&gt;:</span>:Counted(<span class="keyword">const</span> Counted&lt;BeingCounted&gt;&amp;)&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Counted</span>&lt;BeingCounted&gt;:</span>:init()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= maxObjects) <span class="keyword">throw</span> TooManyObjects();</span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>于是最终的Printer类如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span><span class="keyword">private</span> Counted&lt;Printer&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer * <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer&amp; rhs)</span></span>;</span><br><span class="line">    ~Printer();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::objectCount;</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::TooManyObjects;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Printer();</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>用户有权得知当前的对象数目以及最大数目，private继承使得它们被隐藏，因此需要在public中使用using来获取他们。<br>最后需要注意的就是定义counted内部的静态成员，对于numobject，我们只需要在counted的实现中定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Counted</span>&lt;BeingCounted&gt;:</span>:numObjects;<span class="comment">//自动初始化为0</span></span><br></pre></td></tr></table></figure><br>max的定义则略微麻烦，我们不初始化它，而是留待客户进行初始化。以Printer举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Counted&lt;Printer&gt;::maxObjects = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>如果客户没写，那么在连接时会报错。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/15/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xander.liu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/s">
              
                  <span class="site-state-item-count">265</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsmj2017" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lxiang2018@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xander.liu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
